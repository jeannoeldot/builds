diff -aur nanovdb-20200925/nanovdb/ci/build_core.sh nanovdb-20201022/nanovdb/ci/build_core.sh
--- nanovdb-20200925/nanovdb/ci/build_core.sh	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/ci/build_core.sh	2020-10-22 03:52:50.000000000 +0200
@@ -33,31 +33,58 @@
     RELEASE=Release
 fi
 
-cmake \
-	-DCMAKE_CUDA_COMPILER=/usr/local/cuda/bin/nvcc \
-    -DCMAKE_INSTALL_PREFIX="../../__release_core/${NAME}" \
-    -DCMAKE_CXX_COMPILER=${COMPILER} \
-    -DCMAKE_BUILD_TYPE=${RELEASE} \
-	-DCMAKE_VERBOSE_MAKEFILE=ON \
-    \
-    -DNANOVDB_BUILD_TOOLS=ON \
-    -DNANOVDB_BUILD_EXAMPLES=ON \
-    -DNANOVDB_BUILD_UNITTESTS=ON \
-    -DNANOVDB_USE_CUDA=ON \
-    -DNANOVDB_USE_OPENGL=ON \
-    -DNANOVDB_USE_OPENCL=ON \
-    -DNANOVDB_USE_OPTIX=ON \
-    -DNANOVDB_USE_OPENVDB=ON \
-    -DNANOVDB_USE_TBB=ON \
-    -DNANOVDB_USE_ZLIB=ON \
-    -DNANOVDB_USE_BLOSC=ON \
-    -DNANOVDB_BUILD_TOOLS=ON \
-    -DNANOVDB_BUILD_INTERACTIVE_RENDERER=OFF \
-	-DNANOVDB_BUILD_DOCS=OFF \
-	\
-    ${CMAKE_EXTRA} \
-    ../..
-
+if [[ $COMPILER = msvc* ]]; then
+    cmake \
+        -DCMAKE_TOOLCHAIN_FILE=../../ci/wine-toolchain.cmake \
+        -DCMAKE_INSTALL_PREFIX="../../__release_core/${NAME}" \
+        -DCMAKE_CXX_FLAGS_DebugNoInfo="" \
+        -DCMAKE_BUILD_TYPE=${RELEASE} \
+        -DCMAKE_VERBOSE_MAKEFILE=ON \
+        \
+        -DNANOVDB_USE_CUDA=OFF \
+        -DNANOVDB_USE_TBB=OFF \
+        -DNANOVDB_USE_OPENCL=OFF \
+        -DNANOVDB_USE_BLOSC=OFF \
+        -DNANOVDB_USE_ZLIB=OFF \
+        -DNANOVDB_USE_OPTIX=OFF \
+        \
+        -DNANOVDB_BUILD_EXAMPLES=OFF \
+        -DNANOVDB_BUILD_BENCHMARK=OFF \
+        -DNANOVDB_BUILD_UNITTESTS=OFF \
+        -DNANOVDB_BUILD_TOOLS=ON \
+        -DNANOVDB_BUILD_INTERACTIVE_RENDERER=ON \
+        -DNANOVDB_BUILD_DOCS=OFF \
+        \
+        -DNANOVDB_USE_OPENVDB=OFF \
+        \
+        ${CMAKE_EXTRA} \
+        ../..
+else
+    cmake \
+        -DCMAKE_CUDA_COMPILER=/usr/local/cuda/bin/nvcc \
+        -DCMAKE_INSTALL_PREFIX="../../__release_core/${NAME}" \
+        -DCMAKE_CXX_COMPILER=${COMPILER} \
+        -DCMAKE_BUILD_TYPE=${RELEASE} \
+        -DCMAKE_VERBOSE_MAKEFILE=ON \
+        \
+        -DNANOVDB_BUILD_TOOLS=ON \
+        -DNANOVDB_BUILD_EXAMPLES=ON \
+        -DNANOVDB_BUILD_UNITTESTS=ON \
+        -DNANOVDB_USE_CUDA=ON \
+        -DNANOVDB_USE_OPENGL=ON \
+        -DNANOVDB_USE_OPENCL=ON \
+        -DNANOVDB_USE_OPTIX=ON \
+        -DNANOVDB_USE_OPENVDB=ON \
+        -DNANOVDB_USE_TBB=ON \
+        -DNANOVDB_USE_ZLIB=ON \
+        -DNANOVDB_USE_BLOSC=ON \
+        -DNANOVDB_BUILD_TOOLS=ON \
+        -DNANOVDB_BUILD_INTERACTIVE_RENDERER=OFF \
+        -DNANOVDB_BUILD_DOCS=OFF \
+        \
+        ${CMAKE_EXTRA} \
+        ../..
+fi
 make -j2
 make install
 chmod +x ../../__release_core/${NAME}/bin/*
diff -aur nanovdb-20200925/nanovdb/ci/build_core_toolchain.sh nanovdb-20201022/nanovdb/ci/build_core_toolchain.sh
--- nanovdb-20200925/nanovdb/ci/build_core_toolchain.sh	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/ci/build_core_toolchain.sh	2020-10-22 03:52:50.000000000 +0200
@@ -11,7 +11,7 @@
 pushd __build_core/${NAME}
 
 # print version
-cmake --version
+#cmake --version
 
 cmake \
     -DCMAKE_TOOLCHAIN_FILE=${TOOLCHAIN_FILE} \
Seulement dans nanovdb-20201022/nanovdb/ci: mk_turntable.cmd
Seulement dans nanovdb-20201022/nanovdb/ci: mk_turntable.sh
diff -aur nanovdb-20200925/nanovdb/ci/run.sh nanovdb-20201022/nanovdb/ci/run.sh
--- nanovdb-20200925/nanovdb/ci/run.sh	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/ci/run.sh	2020-10-22 03:52:50.000000000 +0200
@@ -1,12 +1,12 @@
 #!/usr/bin/env bash
 
-./ci/build_core_toolchain.sh ./ci/wine-toolchain.cmake msvc16 Release -DCMAKE_VERBOSE_MAKEFILE=OFF -DNANOVDB_USE_OPENVDB=OFF -DNANOVDB_USE_TBB=OFF -DNANOVDB_USE_ZLIB=OFF -DNANOVDB_USE_BLOSC=OFF -DNANOVDB_BUILD_TOOLS=ON -DNANOVDB_BUILD_UNITTESTS=OFF -DNANOVDB_USE_OPTIX=OFF -DNANOVDB_USE_CUDA=OFF
+./ci/build_core.sh msvc16 msvc 10.2 Release -DCMAKE_VERBOSE_MAKEFILE=OFF -DNANOVDB_USE_OPENVDB=OFF -DNANOVDB_USE_TBB=OFF -DNANOVDB_USE_ZLIB=OFF -DNANOVDB_USE_BLOSC=OFF -DNANOVDB_BUILD_TOOLS=ON -DNANOVDB_BUILD_UNITTESTS=OFF -DNANOVDB_USE_OPTIX=OFF -DNANOVDB_USE_CUDA=OFF
 
-./ci/build_core.sh clang++ clang Release -DCMAKE_VERBOSE_MAKEFILE=OFF -DNANOVDB_USE_OPTIX=OFF -DNANOVDB_USE_CUDA=OFF
+./ci/build_core.sh clang clang++ 10.2 Release -DCMAKE_VERBOSE_MAKEFILE=OFF -DNANOVDB_USE_OPTIX=OFF -DNANOVDB_USE_CUDA=OFF
 ./ci/test_core.sh clang
 ./ci/test_render.sh clang
 
-./ci/build_core.sh g++ gcc8 Release -DCMAKE_VERBOSE_MAKEFILE=OFF -DNANOVDB_USE_OPTIX=OFF -DNANOVDB_USE_CUDA=OFF
+./ci/build_core.sh gcc8 g++-8 10.2 Release -DCMAKE_VERBOSE_MAKEFILE=OFF -DNANOVDB_USE_OPTIX=OFF -DNANOVDB_USE_CUDA=OFF
 ./ci/test_core.sh gcc8
 ./ci/test_render.sh gcc8
 
diff -aur nanovdb-20200925/nanovdb/ci/test_render.sh nanovdb-20201022/nanovdb/ci/test_render.sh
--- nanovdb-20200925/nanovdb/ci/test_render.sh	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/ci/test_render.sh	2020-10-22 03:52:50.000000000 +0200
@@ -10,17 +10,15 @@
 	mkdir -p ${OUT_PATH}
 
 	# make gold image.
-	./bin/nanovdb_viewer -b -o ${OUT_PATH}/gold -p host-mt --count 1 --turntable
-	mogrify -format png ${OUT_PATH}/gold.0000.pfm
+	./bin/nanovdb_viewer -b --render-start 0 --render-end 0 --render-output ${OUT_PATH}/gold.%04d.png -p host-mt --render-camera-turntable 1 internal://#ls_box_100
 
 	# test against other platforms...
-
-	./bin/nanovdb_viewer -b --gold ${OUT_PATH}/gold -o ${OUT_PATH}/test-cuda -p cuda -n 1 --turntable
-	./bin/nanovdb_viewer -b --gold ${OUT_PATH}/gold -o ${OUT_PATH}/test-c99 -p host-c99 -n 1 --turntable
-	./bin/nanovdb_viewer -b --gold ${OUT_PATH}/gold -o ${OUT_PATH}/test-glsl -p glsl -n 1 --turntable
-	./bin/nanovdb_viewer -b --gold ${OUT_PATH}/gold -o ${OUT_PATH}/test-opencl -p opencl -n 1 --turntable
-	./bin/nanovdb_viewer -b --gold ${OUT_PATH}/gold -o ${OUT_PATH}/test-optix -p optix -n 1 --turntable
-
-	#compare -verbose -metric MAE ../../__output/gold.0000.pfm ../../__output/test-glsl.0000.pfm null: 2>&1
-	#compare -verbose -metric MAE ../../__output/gold.0000.pfm ../../__output/test-opencl.0000.pfm null: 2>&1
+if false; then
+	./bin/nanovdb_viewer -b --render-end 0 --render-gold ${OUT_PATH}/gold.%04d.png --render-output ${OUT_PATH}/test-cuda.%04d.png -p cuda --render-camera-turntable 1 internal://#ls_box_100
+	./bin/nanovdb_viewer -b --render-end 0 --render-gold ${OUT_PATH}/gold.%04d.png --render-output ${OUT_PATH}/test-c99.%04d.png -p host-c99 --render-camera-turntable 1 internal://#ls_box_100
+	./bin/nanovdb_viewer -b --render-end 0 --render-gold ${OUT_PATH}/gold.%04d.png --render-output ${OUT_PATH}/test-glsl.%04d.png -p glsl --render-camera-turntable 1 internal://#ls_box_100
+	./bin/nanovdb_viewer -b --render-end 0 --render-gold ${OUT_PATH}/gold.%04d.png --render-output ${OUT_PATH}/test-opencl.%04d.png -p opencl --render-camera-turntable 1 internal://#ls_box_100
+	./bin/nanovdb_viewer -b --render-end 0 --render-gold ${OUT_PATH}/gold.%04d.png --render-output ${OUT_PATH}/test-optix.%04d.png -p optix --render-camera-turntable 1 internal://#ls_box_100
+	
+fi
 fi
diff -aur nanovdb-20200925/nanovdb/.circleci/config.yml nanovdb-20201022/nanovdb/.circleci/config.yml
--- nanovdb-20200925/nanovdb/.circleci/config.yml	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/.circleci/config.yml	2020-10-22 03:52:50.000000000 +0200
@@ -45,7 +45,7 @@
             - run:
                 name: build-msvc
                 command: |
-                    ./ci/build_core_toolchain.sh msvc16 ~/repo/ci/wine-toolchain.cmake Release -DNANOVDB_USE_OPENVDB=OFF -DNANOVDB_USE_TBB=OFF -DNANOVDB_USE_ZLIB=OFF -DNANOVDB_USE_BLOSC=OFF -DNANOVDB_BUILD_TOOLS=ON -DNANOVDB_BUILD_UNITTESTS=OFF -DNANOVDB_USE_OPTIX=OFF -DNANOVDB_USE_CUDA=OFF
+                    ./ci/build_core.sh msvc16 msvc 10.2 Release -DNANOVDB_USE_OPENVDB=OFF -DNANOVDB_USE_TBB=OFF -DNANOVDB_USE_ZLIB=OFF -DNANOVDB_USE_BLOSC=OFF -DNANOVDB_BUILD_TOOLS=ON -DNANOVDB_BUILD_UNITTESTS=OFF -DNANOVDB_USE_OPTIX=OFF -DNANOVDB_USE_CUDA=OFF
             - store_test_results:
                 path: test-results
 workflows:
diff -aur nanovdb-20200925/nanovdb/CMakeLists.txt nanovdb-20201022/nanovdb/CMakeLists.txt
--- nanovdb-20200925/nanovdb/CMakeLists.txt	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/CMakeLists.txt	2020-10-22 03:52:50.000000000 +0200
@@ -54,6 +54,7 @@
 option(NANOVDB_BUILD_TOOLS "Build command-line tools" ON)
 option(NANOVDB_CUDA_KEEP_PTX "Keep CUDA PTX" OFF)
 
+option(NANOVDB_USE_INTRINSICS "Build with hardware intrinsics support" ON)
 option(NANOVDB_USE_OPENVDB "Build with OpenVDB support" ON)
 option(NANOVDB_USE_OPENGL "Build with OpenGL support" ON)
 option(NANOVDB_USE_OPENCL "Build with OpenCL support" ON)
@@ -71,7 +72,8 @@
 if(CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /bigobj")
 elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pthread -lpthread")
+  set(CMAKE_CXX_FLAGS
+      "${CMAKE_CXX_FLAGS} -Wno-invalid-offsetof -pthread -lpthread")
   set(CMAKE_CXX_FLAGS_RELEASE "-O3 -march=native")
 endif()
 
@@ -147,6 +149,11 @@
 endif()
 
 # -----------------------------------------------------------------------
+if(NANOVDB_USE_INTRINSICS)
+  set(NANOVDB_USE_INTRINSICS_FLAG "NANOVDB_USE_INTRINSICS")
+endif()
+
+# -----------------------------------------------------------------------
 if(NANOVDB_USE_OPENCL AND NOT USE_EMSCRIPTEN_TOOLCHAIN)
   find_package(OpenCL)
   if(OpenCL_FOUND)
@@ -266,7 +273,7 @@
 target_include_directories(libnanovdb INTERFACE ${NANOVDB_INCLUDE_DIR}
                                                 ${NANOVDB_INCLUDE_DIR}/nanovdb)
 
-target_compile_definitions(libnanovdb INTERFACE "-DNOMINMAX")
+target_compile_definitions(libnanovdb INTERFACE "-DNOMINMAX" "-D${NANOVDB_USE_INTRINSICS_FLAG}")
 
 add_custom_target(nanovdb SOURCES ${NANOVDB_HEADERS})
 
diff -aur nanovdb-20200925/nanovdb/cmd/CMakeLists.txt nanovdb-20201022/nanovdb/cmd/CMakeLists.txt
--- nanovdb-20200925/nanovdb/cmd/CMakeLists.txt	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/CMakeLists.txt	2020-10-22 03:52:50.000000000 +0200
@@ -119,7 +119,7 @@
       FetchContent_Declare(
         imgui
         GIT_REPOSITORY https://github.com/ocornut/imgui.git
-        GIT_TAG master)
+        GIT_TAG docking)
 
       FetchContent_GetProperties(imgui)
       if(NOT imgui_POPULATED)
@@ -130,13 +130,12 @@
         list(
           APPEND
           IMGUI_SOURCE_FILES
-          # ${imgui_SOURCE_DIR}/imgui_demo.cpp
           ${imgui_SOURCE_DIR}/imgui.cpp
           ${imgui_SOURCE_DIR}/imgui_draw.cpp
           ${imgui_SOURCE_DIR}/imgui_widgets.cpp
-          ${imgui_SOURCE_DIR}/examples/imgui_impl_glfw.cpp
-          ${imgui_SOURCE_DIR}/examples/imgui_impl_opengl3.h
-          ${imgui_SOURCE_DIR}/examples/imgui_impl_opengl3.cpp)
+          ${imgui_SOURCE_DIR}/backends/imgui_impl_glfw.cpp
+          ${imgui_SOURCE_DIR}/backends/imgui_impl_opengl3.h
+          ${imgui_SOURCE_DIR}/backends/imgui_impl_opengl3.cpp)
 
         add_library(imgui ${IMGUI_SOURCE_FILES})
 
@@ -173,6 +172,10 @@
     viewer/nanovdb_viewer
     viewer/RenderLauncherC99impl.c
     viewer/nanovdb_viewer.cpp
+    viewer/StringUtils.h
+    viewer/StringUtils.cpp
+    viewer/GridAssetUrl.h
+    viewer/GridAssetUrl.cpp
     viewer/FrameBuffer.h
     viewer/FrameBuffer.cpp
     viewer/FrameBufferHost.cpp
@@ -192,7 +195,13 @@
     viewer/RenderLauncher.cpp
     viewer/RenderLauncherCpuMT.cpp
     viewer/AgnosticNanoVDB.h
-    viewer/RenderLauncherC99.cpp)
+    viewer/RenderLauncherC99.cpp
+    viewer/GridManager.h
+    viewer/GridManager.cpp
+    viewer/AssetLoader.h
+    viewer/AssetLoader.cpp
+    viewer/CallbackPool.h
+    viewer/CallbackPool.cpp)
 
   if(NOT (NANOVDB_GLFW_LINK_LIBRARY AND NANOVDB_GLAD_LINK_LIBRARY)
      AND NOT USE_EMSCRIPTEN_TOOLCHAIN)
@@ -237,6 +246,7 @@
   target_include_directories(
     nanovdb_viewer
     PRIVATE ${NANOVDB_INCLUDE_DIR}
+            ${NanoVDB_TOP_LEVEL_DIR}/external
             ${TBB_INCLUDE_DIRECTORY} # optional
             ${CUDA_INCLUDE_DIRECTORY} # optional
             ${OPENCL_INCLUDE_DIRECTORY} # optional
@@ -263,6 +273,7 @@
             "-D${NANOVDB_USE_ZLIB_FLAG}"
             "-D${NANOVDB_USE_OPENVDB_FLAG}"
             "-D${NANOVDB_USE_IMGUI_FLAG}"
+            "-DNANOVDB_USE_IMGUI_DOCKING"
             "-D${NANOVDB_USE_OPENGL_FLAG}"
             "-D${NANOVDB_USE_EGL_FLAG}"
             "-D${NANOVDB_VIEWER_USE_GLES_FLAG}"
@@ -314,15 +325,16 @@
   else()
     add_executable(nanovdb_convert convert/nanovdb_convert.cpp)
 
-    target_include_directories(nanovdb_convert PUBLIC ${NANOVDB_INCLUDE_DIR})
+    target_include_directories(nanovdb_convert PRIVATE ${NANOVDB_INCLUDE_DIR})
 
     target_compile_definitions(
       nanovdb_convert
       PRIVATE "-D${NANOVDB_USE_BLOSC_FLAG}" "-D${NANOVDB_USE_ZLIB_FLAG}"
               "-D${NANOVDB_USE_OPENVDB_FLAG}" "-D${NANOVDB_USE_TBB_FLAG}")
 
-    target_link_libraries(nanovdb_convert libnanovdb OpenVDB::openvdb TBB::tbb
-                          ${NANOVDB_BLOSC} ${NANOVDB_ZLIB})
+    target_link_libraries(
+      nanovdb_convert PRIVATE libnanovdb ${NANOVDB_OPENVDB} ${NANOVDB_TBB}
+                              ${NANOVDB_BLOSC} ${NANOVDB_ZLIB})
 
     install(TARGETS nanovdb_convert DESTINATION bin)
 
@@ -334,13 +346,33 @@
 
   add_executable(nanovdb_print print/nanovdb_print.cpp)
 
-  target_include_directories(nanovdb_print PUBLIC ${NANOVDB_INCLUDE_DIR})
+  target_include_directories(nanovdb_print PRIVATE ${NANOVDB_INCLUDE_DIR})
 
-  target_compile_definitions(nanovdb_print PRIVATE)
+  target_compile_definitions(nanovdb_print PRIVATE "-D${NANOVDB_USE_BLOSC_FLAG}"
+                                                   "-D${NANOVDB_USE_ZLIB_FLAG}")
 
-  target_link_libraries(nanovdb_print libnanovdb ${NANOVDB_BLOSC}
-                        ${NANOVDB_ZLIB})
+  target_link_libraries(nanovdb_print PRIVATE libnanovdb ${NANOVDB_BLOSC}
+                                              ${NANOVDB_ZLIB})
 
   install(TARGETS nanovdb_print DESTINATION bin)
 
 endif()
+
+# -----------------------------------------------------------------------
+if(TRUE)
+
+  add_executable(nanovdb_validate validate/nanovdb_validate.cpp)
+
+  target_include_directories(nanovdb_validate PRIVATE ${NANOVDB_INCLUDE_DIR})
+
+  target_compile_definitions(
+    nanovdb_validate PRIVATE "-D${NANOVDB_USE_BLOSC_FLAG}"
+                             "-D${NANOVDB_USE_ZLIB_FLAG}"
+                             "-D${NANOVDB_USE_TBB_FLAG}")
+
+  target_link_libraries(nanovdb_validate PRIVATE libnanovdb ${NANOVDB_BLOSC}
+                                                 ${NANOVDB_ZLIB} ${NANOVDB_TBB})
+
+  install(TARGETS nanovdb_validate DESTINATION bin)
+
+endif()
diff -aur nanovdb-20200925/nanovdb/cmd/convert/nanovdb_convert.cpp nanovdb-20201022/nanovdb/cmd/convert/nanovdb_convert.cpp
--- nanovdb-20200925/nanovdb/cmd/convert/nanovdb_convert.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/convert/nanovdb_convert.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -31,6 +31,7 @@
               << "-f,--force\tOverwrite output file if it already exists\n"
               << "-g,--grid name\tConvert all grids matching the specified string name\n"
               << "-h,--help\tPrints this message\n"
+              << "-s,--stats mode\t where mode={none, bbox, extrema, all}\n"
               << "-v,--verbose\tPrint verbose information to the terminal\n"
               << "-z,--zip\tUse ZIP compression on the output file\n";
     exit(exitStatus);
@@ -41,7 +42,8 @@
     int exitStatus = EXIT_SUCCESS;
 
     nanovdb::io::Codec       codec = nanovdb::io::Codec::NONE;
-    nanovdb::ChecksumMode    mode = nanovdb::ChecksumMode::Default;
+    nanovdb::StatsMode       sMode = nanovdb::StatsMode::Default;
+    nanovdb::ChecksumMode    cMode = nanovdb::ChecksumMode::Default;
     bool                     verbose = false, overwrite = false;
     std::string              gridName;
     std::vector<std::string> fileNames;
@@ -66,16 +68,36 @@
                     std::string str(argv[++i]);
                     std::transform(str.begin(), str.end(), str.begin(),[](unsigned char c){ return std::tolower(c); });
                     if (str == "none") {
-                       mode = nanovdb::ChecksumMode::Disable;
+                       cMode = nanovdb::ChecksumMode::Disable;
                     } else if (str == "partial") {
-                       mode = nanovdb::ChecksumMode::Partial;
+                       cMode = nanovdb::ChecksumMode::Partial;
                     } else if (str == "full") {
-                       mode = nanovdb::ChecksumMode::Full;
+                       cMode = nanovdb::ChecksumMode::Full;
                     } else {
                       std::cerr << "Expected one of the following checksum modes: {none, partial, full}\n" << std::endl;
                       usage(argv[0]);
                     }
                 }
+            } else if (arg == "-s" || arg == "--stats") {
+                if (i + 1 == argc) {
+                    std::cerr << "Expected a mode to follow the -s,--stats option\n" << std::endl;
+                    usage(argv[0]);
+                } else {
+                    std::string str(argv[++i]);
+                    std::transform(str.begin(), str.end(), str.begin(),[](unsigned char c){ return std::tolower(c); });
+                    if (str == "none") {
+                       sMode = nanovdb::StatsMode::Disable;
+                    } else if (str == "bbox") {
+                       sMode = nanovdb::StatsMode::BBox;
+                    } else if (str == "extrema") {
+                       sMode = nanovdb::StatsMode::MinMax;
+                    } else if (str == "all") {
+                       sMode = nanovdb::StatsMode::All;
+                    } else {
+                      std::cerr << "Expected one of the following stats modes: {none, bbox, extrema, all}\n" << std::endl;
+                      usage(argv[0]);
+                    }
+                }    
             } else if (arg == "-g" || arg == "--grid") {
                 if (i + 1 == argc) {
                     std::cerr << "Expected a grid name to follow the -g,--grid option\n" << std::endl;
@@ -141,15 +163,19 @@
                 if (gridName.empty()) {
                     auto grids = file.getGrids();
                     for (auto& grid : *grids) {
-                        if (verbose)
+                        if (verbose) {
                             std::cout << "Converting OpenVDB grid named \"" << grid->getName() << "\" to NanoVDB" << std::endl;
-                        nanovdb::io::writeGrid(os, nanovdb::openToNanoVDB(grid, false, 0, mode), codec);
+                        }
+                        auto handle = nanovdb::openToNanoVDB(grid, sMode, cMode, false, verbose ? 1 : 0);
+                        nanovdb::io::writeGrid(os, handle, codec);
                     } // loop over OpenVDB grids in file
                 } else {
                     auto grid = file.readGrid(gridName);
-                    if (verbose)
+                    if (verbose) {
                         std::cout << "Converting OpenVDB grid named \"" << grid->getName() << "\" to NanoVDB" << std::endl;
-                    nanovdb::io::writeGrid(os, nanovdb::openToNanoVDB(grid, false, 0, mode), codec);
+                    }
+                    auto handle = nanovdb::openToNanoVDB(grid, sMode, cMode, false, verbose ? 1 : 0);
+                    nanovdb::io::writeGrid(os, handle, codec);
                 }
             } // loop over input files
         } else { // NanoVDB -> OpenVDB
@@ -182,6 +208,11 @@
             } // loop over input files
             file.write(*grids);
         }
+        if (verbose) {
+            std::cout << "\nThis binary was build against NanoVDB version " << NANOVDB_MAJOR_VERSION_NUMBER << "."
+                                                                            << NANOVDB_MINOR_VERSION_NUMBER << "."
+                                                                            << NANOVDB_PATCH_VERSION_NUMBER << std::endl;
+        }
     }
     catch (const std::exception& e) {
         std::cerr << "An exception occurred: \"" << e.what() << "\"" << std::endl;
diff -aur nanovdb-20200925/nanovdb/cmd/print/nanovdb_print.cpp nanovdb-20201022/nanovdb/cmd/print/nanovdb_print.cpp
--- nanovdb-20200925/nanovdb/cmd/print/nanovdb_print.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/print/nanovdb_print.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -102,10 +102,14 @@
     };
     auto wbboxToStr = [](const nanovdb::BBox<nanovdb::Vec3d>& bbox) {
         std::stringstream ss;
-        ss << std::setprecision(3);
-        ss << "(" << bbox[0][0] << "," << bbox[0][1] << "," << bbox[0][2] << ")";
-        ss << " -> ";
-        ss << "(" << bbox[1][0] << "," << bbox[1][1] << "," << bbox[1][2] << ")";
+        if (bbox.empty()) {
+            ss << "empty grid";
+        } else {
+            ss << std::setprecision(3);
+            ss << "(" << bbox[0][0] << "," << bbox[0][1] << "," << bbox[0][2] << ")";
+            ss << " -> ";
+            ss << "(" << bbox[1][0] << "," << bbox[1][1] << "," << bbox[1][2] << ")";
+        }
         return ss.str();
     };
     auto ibboxToStr = [](const nanovdb::CoordBBox& bbox) {
@@ -148,23 +152,27 @@
             auto       nameWidth = std::string("Name").length() + padding;
             auto       typeWidth = std::string("Type").length() + padding;
             auto       classWidth = std::string("Class").length() + padding;
+            auto       codecWidth = std::string("Codec").length() + padding;
             auto       ibboxWidth = std::string("Index Bounding Box").length() + padding;
             auto       wbboxWidth = std::string("World BBox").length() + padding;
             auto       sizeWidth = std::string("Size").length() + padding;
             auto       fileWidth = std::string("File").length() + padding;
             auto       voxelsWidth = std::string("# Voxels").length() + padding;
             auto       voxelSizeWidth = std::string("Scale").length() + padding;
+            auto       majorWidth = std::string("Version").length() + padding;
             auto       configWidth = std::string("32^3->16^3->8^3").length() + padding;
             auto       resWidth = std::string("Resolution").length() + padding;
             for (auto& m : list) {
                 width(nameWidth, m.gridName);
                 width(typeWidth, nanovdb::io::getStringForGridType(m.gridType));
                 width(classWidth, nanovdb::io::getStringForGridClass(m.gridClass));
+                width(codecWidth, nanovdb::io::getStringForCodec(m.codec));
                 width(wbboxWidth, wbboxToStr(m.worldBBox));
                 width(ibboxWidth, ibboxToStr(m.indexBBox));
                 width(resWidth, resToStr(m.indexBBox));
                 width(sizeWidth, format(m.gridSize));
                 width(fileWidth, format(m.fileSize));
+                width(majorWidth, std::to_string(m.major) + ".X");
                 width(configWidth, nodesToStr(m.nodeCount));
                 width(voxelsWidth, std::to_string(m.voxelCount));
                 width(voxelSizeWidth, vec3RToStr(m.voxelSize));
@@ -175,6 +183,8 @@
                       << std::left << std::setw(typeWidth) << "Type";
             if (mode != Short) {
                 std::cout << std::left << std::setw(classWidth) << "Class"
+                          << std::left << std::setw(majorWidth) << "Version"
+                          << std::left << std::setw(codecWidth) << "Codec"
                           << std::left << std::setw(sizeWidth) << "Size"
                           << std::left << std::setw(fileWidth) << "File"
                           << std::left << std::setw(voxelSizeWidth) << "Scale";
@@ -196,6 +206,8 @@
                           << std::left << std::setw(typeWidth) << nanovdb::io::getStringForGridType(m.gridType);
                 if (mode != Short) {
                     std::cout << std::left << std::setw(classWidth) << nanovdb::io::getStringForGridClass(m.gridClass)
+                              << std::left << std::setw(majorWidth) << (std::to_string(m.major) + ".X")
+                              << std::left << std::setw(codecWidth) << nanovdb::io::getStringForCodec(m.codec)
                               << std::left << std::setw(sizeWidth) << format(m.gridSize)
                               << std::left << std::setw(fileWidth) << format(m.fileSize)
                               << std::left << std::setw(voxelSizeWidth) << vec3RToStr(m.voxelSize);
@@ -227,6 +239,8 @@
                 width(w, "\"Name\":");
                 width(w, "\"Type\":");
                 width(w, "\"Class\":");
+                width(w, "\"Version\":");
+                width(w, "\"Codec\":");
                 width(w, "\"Size\":");
                 width(w, "\"File\":");
                 width(w, "\"Scale\":");
@@ -235,8 +249,11 @@
                 std::cout << std::left << std::setw(w) << "\n\"Name\":"  << "name of a grid. Note that it is optional and hence might be empty."
                           << std::left << std::setw(w) << "\n\"Type\":"  << "static type of the values in a grid, e.g. float, vec3f etc."
                           << std::left << std::setw(w) << "\n\"Class\":"  << "class of the grid, e.g. FOG for Fog volume, LS for level set, etc."
+                          << std::left << std::setw(w) << "\n\"Version\":"  << "major version number of the grid."
+                          << std::left << std::setw(w) << "\n\"Codec\":"  << "codec of the optional compression applied to the out-of-core grid, i.e. on disk."
                           << std::left << std::setw(w) << "\n\"Size\":"  << "In-core memory footprint of the grid, i.e. in ram."
                           << std::left << std::setw(w) << "\n\"File\":"  << "Out-of-core memory footprint of the grid, i.e. on disk."
+                          << std::left << std::setw(w) << "\n\"Scale\":"  << "Scale of the grid, i.e. the size of a voxel in world units."
                           << std::left << std::setw(w) << "\n\"# Voxels\":" << "total number of active values in a grid."
                           << std::left << std::setw(w) << "\n\"Resolution\":" << "Efficient resolution of all the active values in a grid!\n";
                 break;
@@ -244,6 +261,8 @@
             width(w, "\"Name\":");
                 width(w, "\"Type\":");
                 width(w, "\"Class\":");
+                width(w, "\"Version\":");
+                width(w, "\"Codec\":");
                 width(w, "\"Size\":");
                 width(w, "\"File\":");
                 width(w, "\"Scale\":");
@@ -255,19 +274,24 @@
                 std::cout << std::left << std::setw(w) << "\n\"Name\":"  << "name of a grid. Note that it is optional and hence might be empty."
                           << std::left << std::setw(w) << "\n\"Type\":"  << "static type of the values in a grid, e.g. float, vec3f etc."
                           << std::left << std::setw(w) << "\n\"Class\":"  << "class of the grid, e.g. FOG for Fog volume, LS for level set, etc."
+                          << std::left << std::setw(w) << "\n\"Version\":" << "major version number of the grid."
+                          << std::left << std::setw(w) << "\n\"Codec\":"  << "codec of the optional compression applied to the out-of-core grid, i.e. on disk."
                           << std::left << std::setw(w) << "\n\"Size\":"  << "In-core memory footprint of the grid, e.g. in RAM on the CPU."
                           << std::left << std::setw(w) << "\n\"File\":"  << "Out-of-core memory footprint of the grid, i.e. compressed on disk."
-                          << std::left << std::setw(w) << "\n\"Scale\":"  << "Uniform scale of the grid, i.e. the size of a voxel in world units."
+                          << std::left << std::setw(w) << "\n\"Scale\":"  << "Scale of the grid, i.e. the size of a voxel in world units."
                           << std::left << std::setw(w) << "\n\"# Voxels\":" << "total number of active values in a grid. Note this includes both active tiles and voxels."
                           << std::left << std::setw(w) << "\n\"Resolution\":" << "Efficient resolution of all the active values in a grid!"
                           << std::left << std::setw(w) << "\n\"32^3->16^3->8^3\":" << "Number of nodes at each level of the tree structure from the root to leaf level."
                           << std::left << std::setw(w) << "\n\"Index Bounding Box\":" << "coordinate bounding box of all the active values in a grid. Note that both min and max coordinates are inclusive!"
-                          << std::left << std::setw(w) << "\n\"World Bounding Box\":" << "world-space bounding box of all the active values in a grid.\n";  
+                          << std::left << std::setw(w) << "\n\"World Bounding Box\":" << "world-space bounding box of all the active values in a grid. Note that min is inclusive and max is exclusive!\n";  
                 break;
             default:
                 throw std::runtime_error("Internal error in switch!");
                 break;
             }
+            std::cout << "\nThis binary was build against NanoVDB version " << NANOVDB_MAJOR_VERSION_NUMBER << "."
+                                                                            << NANOVDB_MINOR_VERSION_NUMBER << "."
+                                                                            << NANOVDB_PATCH_VERSION_NUMBER << std::endl;
         }
     }
     catch (const std::exception& e) {
Seulement dans nanovdb-20201022/nanovdb/cmd: validate
Seulement dans nanovdb-20201022/nanovdb/cmd/viewer: AssetLoader.cpp
Seulement dans nanovdb-20201022/nanovdb/cmd/viewer: AssetLoader.h
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/BatchRenderer.cpp nanovdb-20201022/nanovdb/cmd/viewer/BatchRenderer.cpp
--- nanovdb-20200925/nanovdb/cmd/viewer/BatchRenderer.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/BatchRenderer.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -29,7 +29,8 @@
 BatchRenderer::BatchRenderer(const RendererParams& params)
     : RendererBase(params)
 {
-    mParams.mUseAccumulation = false;
+    mParams.mUseAccumulation = true;
+    mPendingSceneFrame = params.mFrameStart;
 }
 
 bool initializeEGL(const RendererParams& params, void** glContext, void** glDisplay)
@@ -146,13 +147,17 @@
     mFrameBuffer.reset(new FrameBufferHost());
 #endif
 
-    resize(mParams.mWidth, mParams.mHeight);
-
-    printHelp();
+    resizeFrameBuffer(mParams.mWidth, mParams.mHeight);
+    resetCamera();
 }
 
 void BatchRenderer::run()
 {
+    if (mSelectedSceneNodeIndex < 0) {
+        logError("Nothing to render");
+        return;
+    }
+
     int breakWidth = 80;
 
     auto printBreak = [breakWidth] {
@@ -162,46 +167,75 @@
         std::cout.fill(' ');
     };
 
-    mFrame = 0;
-
-    bool isSingleFrame = (mParams.mFrameCount <= 0);
+    bool isSingleFrame = (mParams.mFrameEnd <= mParams.mFrameStart);
     bool isComputingPSNR = (!mParams.mGoldPrefix.empty());
 
     FrameBufferHost goldImageBuffer;
 
     auto loadGoldImage = [&](int frame) -> bool {
-        std::stringstream ss;
-        if (!isSingleFrame) {
-            ss << mParams.mGoldPrefix << '.' << std::setfill('0') << std::setw(4) << frame << std::setfill('\0') << ".pfm";
-        } else {
-            ss << mParams.mGoldPrefix << ".pfm";
-        }
-        return goldImageBuffer.load(ss.str().c_str());
+        return goldImageBuffer.load(updateFilePathWithFrame(mParams.mGoldPrefix, frame).c_str(), "pfm");
     };
 
-    int   count = (isSingleFrame) ? 1 : mParams.mFrameCount;
+    std::stringstream ss;
+    if (isSingleFrame) {
+        ss << "Rendering frame " << mParams.mFrameStart;
+    } else {
+        ss << "Rendering frames " << mParams.mFrameStart << " - " << mParams.mFrameEnd;
+    }
+    if (mParams.mOutputFilePath.length()) {
+        ss << " to " << mParams.mOutputFilePath;
+        if (mParams.mOutputExtension.length()) {
+            ss << " as " << mParams.mOutputExtension;
+        }
+    }
+    logInfo(ss.str());
+
+    int   count = (isSingleFrame) ? 1 : (mParams.mFrameEnd - mParams.mFrameStart + 1);
     float totalDuration = 0;
     float totalPSNR = 0;
+    int   frame = mParams.mFrameStart;
+
+    // go to the first frame and ensure it is loaded to get the bounds.
+    // we use this for the bounds for resetCamera.
+    setSceneFrame(mParams.mFrameStart);
 
-    for (int i = 0; i < count; ++i) {
-        if (mRenderGroupIndex < mGridGroups.size()) {
-            auto group = mGridGroups[mRenderGroupIndex];
-            setGridIndex(mRenderGroupIndex, ++group->mCurrentGridIndex);
+    bool hasError = !updateNodeAttachmentRequests(mSceneNodes[mSelectedSceneNodeIndex], true, mIsDumpingLog);
+    if (hasError) {
+        logError("Some assets have errors. Unable to render frame " + std::to_string(frame) + "; bad asset");
+        return;
+    }
+
+    // reset the camera to home.
+    // TODO: we should allow setting the camera in the command-line arguments.
+    resetCamera();
+
+    for (; frame <= mParams.mFrameEnd; ++frame) {
+        setSceneFrame(frame);
+
+        hasError = !updateNodeAttachmentRequests(mSceneNodes[mSelectedSceneNodeIndex], true, mIsDumpingLog);
+        if (hasError) {
+            logError("Unable to render frame " + std::to_string(frame) + "; bad asset");
+            break;
+        }
+
+        updateScene();
+
+        for (int i=(mParams.mUseAccumulation)?mParams.mMaxProgressiveSamples:1;i>0;--i) {
+            render(frame);
         }
 
-        render(mFrame);
         float renderDuration = mRenderStats.mDuration;
 
         float renderPSNR = -1;
         if (isComputingPSNR) {
-            if (loadGoldImage(mFrame)) {
+            if (loadGoldImage(frame)) {
                 renderPSNR = computePSNR(goldImageBuffer);
             }
         }
 
         printBreak();
         if (!isSingleFrame) {
-            std::cout << "Frame    : " << mFrame << "/" << count << std::endl;
+            std::cout << "Frame    : " << frame << std::endl;
         }
         std::cout << "Duration : " << renderDuration << " ms" << std::endl;
         if (isComputingPSNR) {
@@ -210,13 +244,23 @@
 
         renderViewOverlay();
 
-        saveFrameBuffer(!isSingleFrame, mFrame);
+        if (mParams.mOutputFilePath.empty() == false) {
+            hasError = (saveFrameBuffer(frame) == false);
+            if (hasError) {
+                break;
+            }
+        }
 
-        ++mFrame;
         totalDuration += renderDuration;
         totalPSNR += renderPSNR;
     }
 
+    if (hasError == false) {
+        logInfo("Rendering complete.");
+    } else {
+        logError("Rendering failed.");
+    }
+
     if (!isSingleFrame) {
         printBreak();
         std::cout << "Average duration : ";
Seulement dans nanovdb-20201022/nanovdb/cmd/viewer: CallbackPool.cpp
Seulement dans nanovdb-20201022/nanovdb/cmd/viewer: CallbackPool.h
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/code/CPlatform.c nanovdb-20201022/nanovdb/cmd/viewer/code/CPlatform.c
--- nanovdb-20200925/nanovdb/cmd/viewer/code/CPlatform.c	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/code/CPlatform.c	2020-10-22 03:52:50.000000000 +0200
@@ -37,6 +37,8 @@
 }
 kGridData;
 
+layout(rgba32f, binding = 0) uniform image2D kOutImage;
+
 #else
 struct nanovdb_Node0_Block
 {
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/code/CPlatform.h nanovdb-20201022/nanovdb/cmd/viewer/code/CPlatform.h
--- nanovdb-20200925/nanovdb/cmd/viewer/code/CPlatform.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/code/CPlatform.h	2020-10-22 03:52:50.000000000 +0200
@@ -75,11 +75,14 @@
 {
     return (ivec2)(get_global_id(0), get_global_id(1));
 }
-CNANOVDB_INLINE vec4 imageLoadPixel(__global const vec4* image, int w, ivec2 p)
+
+#define CNANOVDB_IMAGE_TYPE __global vec4*
+
+CNANOVDB_INLINE vec4 imageLoadPixel(const CNANOVDB_IMAGE_TYPE image, int w, ivec2 p)
 {
     return image[p.x + w * p.y];
 }
-CNANOVDB_INLINE void imageStorePixel(__global vec4* image, int w, ivec2 p, vec4 color)
+CNANOVDB_INLINE void imageStorePixel(CNANOVDB_IMAGE_TYPE image, int w, ivec2 p, vec4 color)
 {
     image[p.x + w * p.y] = color;
 }
@@ -88,6 +91,7 @@
 #define logf(x) log(x)
 #define cosf(x) cos(x)
 #define sinf(x) sin(x)
+#define tanf(x) tan(x)
 #define sqrtf(x) sqrt(x)
 #define fmin(a, b) min(a, b)
 #define fmax(a, b) max(a, b)
@@ -164,6 +168,7 @@
 #define logf(x) log(x)
 #define cosf(x) cos(x)
 #define sinf(x) sin(x)
+#define tanf(x) tan(x)
 #define sqrtf(x) sqrt(x)
 #define fabs(x) abs(x)
 #define fmod(a, b) mod(a, b)
@@ -186,8 +191,9 @@
 #define vec4_add(a, b) ((a) + (b))
 #define vec4_fmul(a, b) ((a) * (b))
 
-#define imageLoadPixel(img, w, p) imageLoad(img, p);
-#define imageStorePixel(img, w, p, color) imageStore(img, p, color)
+#define CNANOVDB_IMAGE_TYPE int
+#define imageLoadPixel(img, w, p) imageLoad(kOutImage, p);
+#define imageStorePixel(img, w, p, color) imageStore(kOutImage, p, color)
 
 #elif defined(__cplusplus)
 
@@ -345,11 +351,14 @@
 {
     return ivec2{0, 0};
 }
-CNANOVDB_INLINE vec4 imageLoadPixel(const vec4* image, int w, ivec2 p)
+
+#define CNANOVDB_IMAGE_TYPE vec4*
+
+CNANOVDB_INLINE vec4 imageLoadPixel(const CNANOVDB_IMAGE_TYPE image, int w, ivec2 p)
 {
     return image[p.x + w * p.y];
 }
-CNANOVDB_INLINE void imageStorePixel(vec4* image, int w, ivec2 p, vec4 color)
+CNANOVDB_INLINE void imageStorePixel(CNANOVDB_IMAGE_TYPE image, int w, ivec2 p, vec4 color)
 {
     image[p.x + w * p.y] = color;
 }
@@ -509,11 +518,14 @@
 {
     return (ivec2){0, 0};
 }
-CNANOVDB_INLINE vec4 imageLoadPixel(const vec4* image, int w, ivec2 p)
+
+#define CNANOVDB_IMAGE_TYPE vec4*
+
+CNANOVDB_INLINE vec4 imageLoadPixel(const CNANOVDB_IMAGE_TYPE image, int w, ivec2 p)
 {
     return image[p.x + w * p.y];
 }
-CNANOVDB_INLINE void imageStorePixel(vec4* image, int w, ivec2 p, vec4 color)
+CNANOVDB_INLINE void imageStorePixel(CNANOVDB_IMAGE_TYPE image, int w, ivec2 p, vec4 color)
 {
     image[p.x + w * p.y] = color;
 }
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/code/renderCommon.h nanovdb-20201022/nanovdb/cmd/viewer/code/renderCommon.h
--- nanovdb-20200925/nanovdb/cmd/viewer/code/renderCommon.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/code/renderCommon.h	2020-10-22 03:52:50.000000000 +0200
@@ -7,12 +7,15 @@
 int   width;
 int   height;
 int   numAccumulations;
-float useGround;
-float useShadows;
-float useGroundReflections;
-float useLighting;
+int   useBackground;
+int   useGround;
+int   useShadows;
+int   useGroundReflections;
+int   useLighting;
 float useOcclusion;
-float volumeDensity;
+float volumeDensityScale;
+float volumeAlbedo;
+int   useTonemapping;
 float tonemapWhitePoint;
 int   samplesPerPixel;
 float groundHeight;
@@ -21,16 +24,16 @@
 float cameraUx, cameraUy, cameraUz;
 float cameraVx, cameraVy, cameraVz;
 float cameraWx, cameraWy, cameraWz;
+float cameraAspect;
+float cameraFovY;
 CNANOVDB_DECLARE_UNIFORMS_END
 
 ////////////////////////////////////////////////////////
 
-#define CNANOVDB_RENDERMETHOD_AUTO 0
-#define CNANOVDB_RENDERMETHOD_LEVELSET 1
-#define CNANOVDB_RENDERMETHOD_FOG_VOLUME 2
-#define CNANOVDB_RENDERMETHOD_GRID 3
-#define CNANOVDB_RENDERMETHOD_POINTS 4
-#define CNANOVDB_RENDERMETHOD_COUNT 5
+#define CNANOVDB_RENDERMETHOD_LEVELSET 0
+#define CNANOVDB_RENDERMETHOD_FOG_VOLUME 1
+#define CNANOVDB_RENDERMETHOD_GRID 2
+#define CNANOVDB_RENDERMETHOD_POINTS 3
 
 ////////////////////////////////////////////////////////
 
@@ -86,13 +89,19 @@
     return CNANOVDB_MAKE_VEC3(x, x, x);
 }
 
-CNANOVDB_INLINE void rayTraceGround(float groundT, float falloffDistance, const vec3 pos, float rayDirY, CNANOVDB_REF(float) outIntensity, CNANOVDB_REF(float) outMix)
+CNANOVDB_INLINE float evalSkyMaterial(const vec3 dir)
+{
+    return 0.75f + 0.25f * dir.y;
+}
+
+CNANOVDB_INLINE float evalGroundMaterial(float groundT, float falloffDistance, const vec3 pos, float rayDirY, CNANOVDB_REF(float) outMix)
 {
     const float checkerScale = 1.0f / 1024.0f;
     float       iu = floor(pos.x * checkerScale);
     float       iv = floor(pos.z * checkerScale);
-    CNANOVDB_DEREF(outIntensity) = 0.25f + fabs(fmod(iu + iv, 2.f)) * 0.5f;
+    float       outIntensity = 0.25f + fabs(fmod(iu + iv, 2.f)) * 0.5f;
     CNANOVDB_DEREF(outMix) = fmax(0.f, (1.0f - groundT / falloffDistance) * -rayDirY);
+    return outIntensity;
 }
 
 // algorithm taken from: http://amietia.com/lambertnotangent.html
@@ -105,4 +114,50 @@
     return vec3_normalize(vec3_add(normal, spherePoint));
 }
 
+CNANOVDB_INLINE Vec3T getRayDirFromPixelCoord(uint32_t ix, uint32_t iy, int width, int height, int numAccumulations, int samplesPerPixel, uint32_t pixelSeed, const Vec3T cameraU, const Vec3T cameraV, const Vec3T cameraW, float fovY, float aspect)
+{
+    float u = CNANOVDB_MAKE(float)(ix) + 0.5f;
+    float v = CNANOVDB_MAKE(float)(iy) + 0.5f;
+
+    float randVar1 = randomf(pixelSeed + 0);
+    float randVar2 = randomf(pixelSeed + 1);
+
+    if (numAccumulations > 0) {
+        u += randVar1 - 0.5f;
+        v += randVar2 - 0.5f;
+    }
+
+    u /= CNANOVDB_MAKE(float)(width);
+    v /= CNANOVDB_MAKE(float)(height);
+
+    // get camera ray...
+    float halfHeight = tanf(fovY * 3.14159265358979323846f / 360.f);
+    float halfWidth = aspect * halfHeight;
+    vec3  W = vec3_add(vec3_add(vec3_fmul(halfWidth, cameraU), vec3_fmul(halfHeight, cameraV)), cameraW);
+    vec3  U = vec3_fmul(2.f * halfWidth, cameraU);
+    vec3  V = vec3_fmul(2.f * halfHeight, cameraV);
+    vec3  rd = vec3_sub(vec3_add(vec3_fmul(u, U), vec3_fmul(v, V)), W);
+    return vec3_normalize(rd);
+}
+
+CNANOVDB_INLINE void compositeFn(CNANOVDB_IMAGE_TYPE image, int width, ivec2 tid, vec3 color, int numAccumulations, int useTonemapping, float tonemapWhitePoint)
+{
+    if (numAccumulations > 1) {
+        vec4 prevOutput = imageLoadPixel(image, width, tid);
+        vec3 oldLinearPixel;
+        vec3 prevColor = CNANOVDB_MAKE_VEC3(prevOutput.x, prevOutput.y, prevOutput.z);
+        if (useTonemapping != 0) {
+            invTonemapReinhard(CNANOVDB_ADDRESS(oldLinearPixel), prevColor, tonemapWhitePoint);
+        } else {
+            oldLinearPixel = prevColor;
+        }
+        color = vec3_add(oldLinearPixel, vec3_fmul((1.0f / CNANOVDB_MAKE(float)(numAccumulations)), vec3_sub(color, oldLinearPixel)));
+    }
+
+    if (useTonemapping != 0) {
+        tonemapReinhard(CNANOVDB_ADDRESS(color), color, tonemapWhitePoint);
+    }
+    imageStorePixel(image, width, tid, CNANOVDB_MAKE_VEC4(color.x, color.y, color.z, 1.0f));
+}
+
 ////////////////////////////////////////////////////////
\ Pas de fin de ligne Ã  la fin du fichier
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/code/renderFogVolume.c nanovdb-20201022/nanovdb/cmd/viewer/code/renderFogVolume.c
--- nanovdb-20200925/nanovdb/cmd/viewer/code/renderFogVolume.c	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/code/renderFogVolume.c	2020-10-22 03:52:50.000000000 +0200
@@ -12,13 +12,14 @@
 #line 12
 #endif
 
-#define CNANOVDB_VIEWER_USE_RATIO_TRACKED_TRANSMISSION 1
+//#define CNANOVDB_VIEWER_USE_RATIO_TRACKED_TRANSMISSION 1
 
 CNANOVDB_DECLARE_STRUCT_BEGIN(HeterogenousMedium)
-    float densityFactor;
+    float densityScale;
     float densityMin;
     float densityMax;
     float hgMeanCosine;
+    float albedo;
 CNANOVDB_DECLARE_STRUCT_END(HeterogenousMedium)
 
 /////////////////////////
@@ -26,17 +27,11 @@
 CNANOVDB_INLINE float
 deltaTracking(CNANOVDB_CONTEXT cxt, CNANOVDB_REF(nanovdb_Ray) ray, CNANOVDB_REF(nanovdb_ReadAccessor) acc, HeterogenousMedium medium, CNANOVDB_REF(uint32_t) seed)
 {
-    boolean hit = nanovdb_Ray_clip(ray,
-                                   nanovdb_CoordToVec3f(CNANOVDB_ROOTDATA(cxt).mBBox_min),
-                                   nanovdb_CoordToVec3f(CNANOVDB_ROOTDATA(cxt).mBBox_max));
-    if (!hit)
-        return -1.f;
-
     float densityMaxInv = 1.0f / medium.densityMax;
     float t = CNANOVDB_DEREF(ray).mT0;
     do {
         t += -logf(randomf(CNANOVDB_DEREF(seed)++)) * densityMaxInv;
-    } while (t < CNANOVDB_DEREF(ray).mT1 && nanovdb_ReadAccessor_getValue(cxt, acc, nanovdb_Vec3fToCoord(nanovdb_Ray_eval(ray, t))) * medium.densityFactor * densityMaxInv < randomf(CNANOVDB_DEREF(seed)++));
+    } while (t < CNANOVDB_DEREF(ray).mT1 && nanovdb_ReadAccessor_getValue(cxt, acc, nanovdb_Vec3fToCoord(nanovdb_Ray_eval(ray, t))) * medium.densityScale * densityMaxInv < randomf(CNANOVDB_DEREF(seed)++));
     return t;
 }
 
@@ -49,48 +44,7 @@
     if (!hit)
         return 1.0f;
 
-#if !defined(CNANOVDB_VIEWER_USE_RATIO_TRACKED_TRANSMISSION)
-    // delta tracking.
-    // faster due to earlier termination, but we need multiple samples
-    // to reduce variance.
-    float     densityMaxInv = 1.0f / medium.densityMax;
-    const int nSamples = 2;
-    float     transmittance = 0.f;
-    for (int n = 0; n < nSamples; n++) {
-        float t = CNANOVDB_DEREF(ray).mT0;
-        while (CNANOVDB_TRUE) {
-            t -= logf(randomf(CNANOVDB_DEREF(seed)++)) * densityMaxInv;
-
-            if (t >= CNANOVDB_DEREF(ray).mT1) {
-                transmittance += 1.0f;
-                break;
-            }
-
-            float density = nanovdb_ReadAccessor_getValue(cxt, acc, nanovdb_Vec3fToCoord(nanovdb_Ray_eval(ray, t))) * medium.densityFactor;
-            density = fmin(fmax(density, medium.densityMin), medium.densityMax); // just in case these are soft extrema
-
-            if (density * densityMaxInv >= randomf(CNANOVDB_DEREF(seed)++))
-                break;
-        }
-    }
-    return transmittance / nSamples;
-#elif 0
-    // ratio tracking.
-    // slower due to no early termination, but better estimation.
-    float densityMaxInv = 1.0f / medium.densityMax;
-    float transmittance = 1.f;
-    float t = CNANOVDB_DEREF(ray).mT0;
-    while (CNANOVDB_TRUE) {
-        t -= logf(randomf(CNANOVDB_DEREF(seed)++)) * densityMaxInv;
-        if (t >= CNANOVDB_DEREF(ray).mT1)
-            break;
-        float density = nanovdb_ReadAccessor_getValue(cxt, acc, nanovdb_Vec3fToCoord(nanovdb_Ray_eval(ray, t))) * medium.densityFactor;
-        density = fmin(fmax(density, medium.densityMin), medium.densityMax); // just in case these are soft extrema
-
-        transmittance *= 1.0f - density * densityMaxInv;
-    }
-    return transmittance;
-#elif 1
+#if defined(CNANOVDB_VIEWER_USE_RATIO_TRACKED_TRANSMISSION)
         // residual ratio tracking.
 #if 1
     // control is minimum.
@@ -109,52 +63,93 @@
     const float residualDensityMax = fmaxf(0.001f, fabsf(residualDensityMax1));
 #endif
     const float residualDensityMaxInv = 1.0f / residualDensityMax;
-    float controlTransmittance = expf(-controlDensity * (CNANOVDB_DEREF(ray).mT1 - CNANOVDB_DEREF(ray).mT0));
-    float residualTransmittance = 1.f;
-    float t = CNANOVDB_DEREF(ray).mT0;
+    float       controlTransmittance = expf(-controlDensity * (CNANOVDB_DEREF(ray).mT1 - CNANOVDB_DEREF(ray).mT0));
+    float       residualTransmittance = 1.f;
+    float       t = CNANOVDB_DEREF(ray).mT0;
     while (CNANOVDB_TRUE) {
         t -= logf(randomf(CNANOVDB_DEREF(seed)++)) * residualDensityMaxInv;
         if (t >= CNANOVDB_DEREF(ray).mT1)
             break;
-        float density = nanovdb_ReadAccessor_getValue(cxt, acc, nanovdb_Vec3fToCoord(nanovdb_Ray_eval(ray, t))) * medium.densityFactor;
-        density = fmin(fmax(density, medium.densityMin), medium.densityMax); // just in case these are soft extrema
+        float density = nanovdb_ReadAccessor_getValue(cxt, acc, nanovdb_Vec3fToCoord(nanovdb_Ray_eval(ray, t))) * medium.densityScale;
+        //density = fmin(fmax(density, medium.densityMin), medium.densityMax); // just in case these are soft extrema
 
         float residualDensity = density - controlDensity;
         residualTransmittance *= 1.0f - residualDensity / residualDensityMax1;
     }
     return residualTransmittance * controlTransmittance;
+#elif 1
+    // ratio tracking.
+    // slower due to no early termination, but better estimation.
+    float densityMaxInv = 1.0f / medium.densityMax;
+    float transmittance = 1.f;
+    float t = CNANOVDB_DEREF(ray).mT0;
+    while (CNANOVDB_TRUE) {
+        t -= logf(randomf(CNANOVDB_DEREF(seed)++)) * densityMaxInv;
+        if (t >= CNANOVDB_DEREF(ray).mT1)
+            break;
+        float density = nanovdb_ReadAccessor_getValue(cxt, acc, nanovdb_Vec3fToCoord(nanovdb_Ray_eval(ray, t))) * medium.densityScale;
+
+        transmittance *= 1.0f - density * densityMaxInv;
+        if (transmittance < 0.01f)
+            return 0.f;
+    }
+    return transmittance;
+#elif 1
+
+    // delta tracking.
+    // faster due to earlier termination, but we need multiple samples
+    // to reduce variance.
+    float     densityMaxInv = 1.0f / medium.densityMax;
+    const int nSamples = 2;
+    float     transmittance = 0.f;
+    for (int n = 0; n < nSamples; n++) {
+        float t = CNANOVDB_DEREF(ray).mT0;
+        while (CNANOVDB_TRUE) {
+            t -= logf(randomf(CNANOVDB_DEREF(seed)++)) * densityMaxInv;
+
+            if (t >= CNANOVDB_DEREF(ray).mT1) {
+                transmittance += 1.0f;
+                break;
+            }
+
+            float density = nanovdb_ReadAccessor_getValue(cxt, acc, nanovdb_Vec3fToCoord(nanovdb_Ray_eval(ray, t))) * medium.densityScale;
+
+            if (density * densityMaxInv >= randomf(CNANOVDB_DEREF(seed)++))
+                break;
+        }
+    }
+    return transmittance / nSamples;
 #endif // CNANOVDB_VIEWER_USE_RATIO_TRACKED_TRANSMISSION
 }
 
 CNANOVDB_INLINE float henyeyGreenstein(float g, float cosTheta)
 {
-    // phase function pdf.
-#if 1
-    // isotropic.
-    return 1.0f / (3.14159265359f * 4.f);
-#else
-    float denom = 1.f + g * g - 2.f * g * cosTheta;
-    return (1.0f / (3.14159265359f * 4.f)) * (1.f - g * g) / (denom * sqrtf(denom));
-#endif
+    if (g == 0) {
+        return 1.0f / (3.14159265359f * 4.f);
+    } else {
+        float denom = fmax(0.001f, 1.f + g * g - 2.f * g * cosTheta);
+        return (1.0f / (3.14159265359f * 4.f)) * (1.f - g * g) / (denom * sqrtf(denom));
+    }
 }
 
 CNANOVDB_INLINE vec3 sampleHG(float g, float e1, float e2)
 {
     // phase function.
-#if 1
-    // isotropic
-    const float phi = CNANOVDB_MAKE(float)(2.0f * 3.14159265359f) * e1;
-    const float cosTheta = 1.0f - 2.0f * e2;
-    const float sinTheta = sqrtf(1.0f - cosTheta * cosTheta);
-#else
-    const float phi = CNANOVDB_MAKE(float)(2.0f * 3.14159265359f) * e2;
-    const float s = 2.0f * e1 - 1.0f;
-    const float denom = nanovdb::Max(0.001f, (1.0f + g * s));
-    const float f = (1.0f - g * g) / denom;
-    const float cosTheta = 0.5f * (1.0f / g) * (1.0f + g * g - f * f);
-    const float sinTheta = sqrtf(1.0f - cosTheta * cosTheta);
-#endif
-    return CNANOVDB_MAKE_VEC3(cosf(phi) * sinTheta, sinf(phi) * sinTheta, cosTheta);
+    if (g == 0) {
+        // isotropic
+        const float phi = CNANOVDB_MAKE(float)(2.0f * 3.14159265359f) * e1;
+        const float cosTheta = 1.0f - 2.0f * e2;
+        const float sinTheta = sqrtf(1.0f - cosTheta * cosTheta);
+        return CNANOVDB_MAKE_VEC3(cosf(phi) * sinTheta, sinf(phi) * sinTheta, cosTheta);
+    } else {
+        const float phi = CNANOVDB_MAKE(float)(2.0f * 3.14159265359f) * e2;
+        const float s = 2.0f * e1 - 1.0f;
+        const float denom = fmax(0.001f, (1.0f + g * s));
+        const float f = (1.0f - g * g) / denom;
+        const float cosTheta = 0.5f * (1.0f / g) * (1.0f + g * g - f * f);
+        const float sinTheta = sqrtf(1.0f - cosTheta * cosTheta);
+        return CNANOVDB_MAKE_VEC3(cosf(phi) * sinTheta, sinf(phi) * sinTheta, cosTheta);
+    }
 }
 
 CNANOVDB_INLINE Vec3T estimateLight(CNANOVDB_CONTEXT cxt, Vec3T pos, Vec3T dir, CNANOVDB_REF(nanovdb_ReadAccessor) acc, HeterogenousMedium medium, CNANOVDB_REF(uint32_t) seed, Vec3T lightDir)
@@ -167,18 +162,16 @@
     shadowRay.mT1 = MaxFloat;
 
     float transmittance = getTransmittance(cxt, CNANOVDB_ADDRESS(shadowRay), acc, medium, seed);
-    float pdf = 1.0f;//henyeyGreenstein(medium.hgMeanCosine, vec3_dot(dir, lightDir));
+    float pdf = 1.0f; //henyeyGreenstein(medium.hgMeanCosine, vec3_dot(dir, lightDir));
     return vec3_fmul(pdf * transmittance, lightRadiance);
 }
 
-CNANOVDB_INLINE nanovdb_Vec3f traceVolume(CNANOVDB_CONTEXT cxt, CNANOVDB_REF(nanovdb_Ray) ray, CNANOVDB_REF(nanovdb_ReadAccessor) acc, HeterogenousMedium medium, CNANOVDB_REF(uint32_t) seed, nanovdb_Vec3f lightDir)
+CNANOVDB_INLINE nanovdb_Vec3f traceFogVolume(CNANOVDB_CONTEXT cxt, CNANOVDB_REF(float) outThroughput, int useLighting, CNANOVDB_REF(nanovdb_Ray) ray, CNANOVDB_REF(nanovdb_ReadAccessor) acc, HeterogenousMedium medium, CNANOVDB_REF(uint32_t) seed, nanovdb_Vec3f lightDir)
 {
     float throughput = 1.0f;
 
-    float albedo = 0.8f;
-
-    int max_interactions = 40;
-    int num_interactions = 0;
+    int kMaxPathDepth = 4;
+    int numInteractions = 0;
 
     if (!nanovdb_Ray_clip(ray, nanovdb_CoordToVec3f(CNANOVDB_ROOTDATA(cxt).mBBox_min), nanovdb_CoordToVec3f(CNANOVDB_ROOTDATA(cxt).mBBox_max))) {
         return CNANOVDB_MAKE_VEC3(0, 0, 0);
@@ -188,29 +181,32 @@
 
     nanovdb_Vec3f radiance = CNANOVDB_MAKE_VEC3(0, 0, 0);
 
-    while (CNANOVDB_TRUE) {
+    while (numInteractions++ < kMaxPathDepth) {
         float s = deltaTracking(cxt, CNANOVDB_ADDRESS(pathRay), acc, medium, seed);
         if (s >= pathRay.mT1)
             break;
 
-        if (s < 0)
-            return CNANOVDB_MAKE_VEC3(0, 0, 0);
-
-        if (num_interactions++ >= max_interactions)
-            return CNANOVDB_MAKE_VEC3(0, 0, 0);
+        if (s < 0) {
+            radiance = CNANOVDB_MAKE_VEC3(0, 0, 0);
+            break;
+        }
 
         nanovdb_Vec3f pos = nanovdb_Ray_eval(CNANOVDB_ADDRESS(pathRay), s);
 
         // sample key light.
-        radiance = vec3_add(radiance, vec3_fmul(throughput, estimateLight(cxt, pos, pathRay.mDir, acc, medium, seed, lightDir)));
-
-        throughput *= albedo;
+        if (useLighting > 0) {
+            radiance = vec3_add(radiance, vec3_fmul(throughput, estimateLight(cxt, pos, pathRay.mDir, acc, medium, seed, lightDir)));
+        }
+        
+        throughput *= medium.albedo;
 
         // Russian roulette absorption.
         if (throughput < 0.2f) {
             float r1 = randomf(CNANOVDB_DEREF(seed)++);
-            if (r1 > throughput * 5.0f)
-                return CNANOVDB_MAKE_VEC3(0, 0, 0); // full absorbtion.
+            if (r1 > throughput * 5.0f) {
+                radiance = CNANOVDB_MAKE_VEC3(0, 0, 0);
+                break;
+            }
             throughput = 0.2f; // unbias.
         }
 
@@ -222,13 +218,13 @@
         pathRay.mT0 = DeltaFloat;
         pathRay.mT1 = MaxFloat;
 
-        if (!nanovdb_Ray_clip(CNANOVDB_ADDRESS(pathRay), nanovdb_CoordToVec3f(CNANOVDB_ROOTDATA(cxt).mBBox_min), nanovdb_CoordToVec3f(CNANOVDB_ROOTDATA(cxt).mBBox_max)))
-            return CNANOVDB_MAKE_VEC3(0, 0, 0);
+        if (!nanovdb_Ray_clip(CNANOVDB_ADDRESS(pathRay), nanovdb_CoordToVec3f(CNANOVDB_ROOTDATA(cxt).mBBox_min), nanovdb_CoordToVec3f(CNANOVDB_ROOTDATA(cxt).mBBox_max))) {
+            radiance = CNANOVDB_MAKE_VEC3(0, 0, 0);
+            break;
+        }
     }
-    /*
-	const float f = (0.5f + 0.5f * ray.dir()[1]) * throughput;
-	radiance = radiance + Vec3f(f);*/
 
+    CNANOVDB_DEREF(outThroughput) = throughput;
     return radiance;
 }
 
@@ -236,13 +232,11 @@
 
 #if defined(CNANOVDB_COMPILER_GLSL)
 
-layout(rgba32f, binding = 0) uniform image2D outImage;
-
 layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
 void main()
 {
-    int cxt;
-
+    int   cxt;
+    int   outImage;
     ivec2 threadId = getThreadId();
 
 #elif defined(__OPENCL_VERSION__)
@@ -316,32 +310,18 @@
     vec3                 color = CNANOVDB_MAKE_VEC3(0, 0, 0);
 
     HeterogenousMedium medium;
-    medium.densityFactor = kArgs.volumeDensity;
-    medium.densityMin = CNANOVDB_ROOTDATA(cxt).mValueMin * medium.densityFactor;
-    medium.densityMax = medium.densityFactor; //grid->tree().root().valueMax() * medium.densityFactor;
+    medium.densityScale = kArgs.volumeDensityScale;
+    medium.densityMin = CNANOVDB_ROOTDATA(cxt).mValueMin * medium.densityScale;
+    medium.densityMax = medium.densityScale; //grid->tree().root().valueMax() * medium.densityScale;
     medium.densityMax = fmax(medium.densityMin, fmax(medium.densityMax, 0.001f));
     medium.hgMeanCosine = 0.f;
+    medium.albedo = kArgs.volumeAlbedo;
 
-    
     for (int sampleIndex = 0; sampleIndex < kArgs.samplesPerPixel; ++sampleIndex) {
         uint32_t pixelSeed = hash1(sampleIndex + kArgs.numAccumulations * kArgs.samplesPerPixel ^ hash2(ix, iy));
 
-        float u = CNANOVDB_MAKE(float)(ix) + 0.5f;
-        float v = CNANOVDB_MAKE(float)(iy) + 0.5f;
-
-        float randVar1 = randomf(pixelSeed + 0);
-        float randVar2 = randomf(pixelSeed + 1);
+        vec3 wRayDir = getRayDirFromPixelCoord(ix, iy, kArgs.width, kArgs.height, kArgs.numAccumulations, kArgs.samplesPerPixel, pixelSeed, cameraU, cameraV, cameraW, kArgs.cameraFovY, kArgs.cameraAspect);
 
-        if (kArgs.numAccumulations > 0) {
-            u += randVar1 - 0.5f;
-            v += randVar2 - 0.5f;
-        }
-
-        u /= CNANOVDB_MAKE(float)(kArgs.width);
-        v /= CNANOVDB_MAKE(float)(kArgs.height);
-
-        // get camera ray...
-        vec3        wRayDir = vec3_sub(vec3_add(vec3_fmul(u, cameraU), vec3_fmul(v, cameraV)), cameraW);
         vec3        wRayEye = cameraP;
         nanovdb_Ray wRay;
         wRay.mEye = wRayEye;
@@ -353,26 +333,26 @@
         vec3        iRayDir = iRay.mDir;
 
         Vec3T radiance = CNANOVDB_MAKE_VEC3(0, 0, 0);
+        float pathThroughput = 1.0f;
 
-        if (kArgs.useLighting > 0) {
-            radiance = traceVolume(cxt, CNANOVDB_ADDRESS(iRay), CNANOVDB_ADDRESS(acc), medium, CNANOVDB_ADDRESS(pixelSeed), iLightDir);
-        }
+        radiance = traceFogVolume(cxt, CNANOVDB_ADDRESS(pathThroughput), kArgs.useLighting, CNANOVDB_ADDRESS(iRay), CNANOVDB_ADDRESS(acc), medium, CNANOVDB_ADDRESS(pixelSeed), iLightDir);
 
-        float transmittance = getTransmittance(cxt, CNANOVDB_ADDRESS(iRay), CNANOVDB_ADDRESS(acc), medium, CNANOVDB_ADDRESS(pixelSeed));
+        //float pathThroughput = getTransmittance(cxt, CNANOVDB_ADDRESS(iRay), CNANOVDB_ADDRESS(acc), medium, CNANOVDB_ADDRESS(pixelSeed));
 
-        if (transmittance > 0.01f) {
+        if (kArgs.useBackground > 0 && pathThroughput > 0.0f) {
+            float bgIntensity = 0.0f;
             float groundIntensity = 0.0f;
             float groundMix = 0.0f;
 
             if (kArgs.useGround > 0) {
                 float wGroundT = (kArgs.groundHeight - wRayEye.y) / wRayDir.y;
-                if (wGroundT > 0.f) {
+                if (wRayDir.y != 0 && wGroundT > 0.f) {
                     vec3 wGroundPos = vec3_add(wRayEye, vec3_fmul(wGroundT, wRayDir));
                     vec3 iGroundPos = nanovdb_Grid_worldToIndexF(CNANOVDB_GRIDDATA(cxt), wGroundPos);
 
-                    rayTraceGround(wGroundT, kArgs.groundFalloff, wGroundPos, wRayDir.y, CNANOVDB_ADDRESS(groundIntensity), CNANOVDB_ADDRESS(groundMix));
+                    groundIntensity = evalGroundMaterial(wGroundT, kArgs.groundFalloff, wGroundPos, wRayDir.y, CNANOVDB_ADDRESS(groundMix));
 
-                    if (kArgs.useShadows > 0) {
+                    if (kArgs.useLighting > 0 && kArgs.useShadows > 0) {
                         nanovdb_Ray iShadowRay;
                         iShadowRay.mEye = iGroundPos;
                         iShadowRay.mDir = iLightDir;
@@ -385,10 +365,11 @@
                 }
             }
 
-            float skyIntensity = 0.75f + 0.25f * wRayDir.y;
-
-            float radianceIntensity = transmittance * ((1.f - groundMix) * skyIntensity + groundMix * groundIntensity);
-            radiance = vec3_add(radiance, CNANOVDB_MAKE_VEC3(radianceIntensity, radianceIntensity, radianceIntensity));
+            float skyIntensity = evalSkyMaterial(wRayDir);
+            bgIntensity = (1.f - groundMix) * skyIntensity + groundMix * groundIntensity;
+            bgIntensity *= pathThroughput;
+            
+            radiance = vec3_add(radiance, CNANOVDB_MAKE_VEC3(bgIntensity, bgIntensity, bgIntensity));
         }
 
         color = vec3_add(color, radiance);
@@ -398,15 +379,6 @@
     color.y /= kArgs.samplesPerPixel;
     color.z /= kArgs.samplesPerPixel;
 
-    if (kArgs.numAccumulations > 1) {
-        vec4 prevOutput = imageLoadPixel(outImage, kArgs.width, threadId);
-        vec3 prevColor = CNANOVDB_MAKE_VEC3(prevOutput.x, prevOutput.y, prevOutput.z);
-        vec3 oldLinearPixel;
-        invTonemapReinhard(CNANOVDB_ADDRESS(oldLinearPixel), prevColor, kArgs.tonemapWhitePoint);
-        color = vec3_add(oldLinearPixel, vec3_fmul((1.0f / CNANOVDB_MAKE(float)(kArgs.numAccumulations)), vec3_sub(color, oldLinearPixel)));
-    }
-
-    tonemapReinhard(CNANOVDB_ADDRESS(color), color, kArgs.tonemapWhitePoint);
-    imageStorePixel(outImage, kArgs.width, threadId, CNANOVDB_MAKE_VEC4(color.x, color.y, color.z, 1.0f));
+    compositeFn(outImage, kArgs.width, threadId, color, kArgs.numAccumulations, kArgs.useTonemapping, kArgs.tonemapWhitePoint);
 }
 ////////////////////////////////////////////////////////
\ Pas de fin de ligne Ã  la fin du fichier
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/code/renderLevelSet.c nanovdb-20201022/nanovdb/cmd/viewer/code/renderLevelSet.c
--- nanovdb-20200925/nanovdb/cmd/viewer/code/renderLevelSet.c	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/code/renderLevelSet.c	2020-10-22 03:52:50.000000000 +0200
@@ -11,13 +11,12 @@
 #if defined(CNANOVDB_COMPILER_GLSL)
 #line 12
 
-layout(rgba32f, binding = 0) uniform image2D outImage;
-
 layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
 void main()
 {
     int   cxt;
-    ivec2 threadId = ivec2(gl_GlobalInvocationID.xy);
+    int   outImage;
+    ivec2 threadId = getThreadId();
 
 #elif defined(__OPENCL_VERSION__)
 
@@ -84,26 +83,15 @@
     vec3                 color = CNANOVDB_MAKE_VEC3(0, 0, 0);
 
     int sampleIndex = 0;
-    //for (; sampleIndex < kArgs.samplesPerPixel; sampleIndex++) 
+    //for (; sampleIndex < kArgs.samplesPerPixel; sampleIndex++)
     {
         uint32_t pixelSeed = hash1(sampleIndex + kArgs.numAccumulations * kArgs.samplesPerPixel ^ hash2(ix, iy));
 
-        float u = CNANOVDB_MAKE(float)(ix) + 0.5f;
-        float v = CNANOVDB_MAKE(float)(iy) + 0.5f;
-
         float randVar1 = randomf(pixelSeed + 0);
         float randVar2 = randomf(pixelSeed + 1);
 
-        if (kArgs.numAccumulations > 0) {
-            u += randVar1 - 0.5f;
-            v += randVar2 - 0.5f;
-        }
-
-        u /= CNANOVDB_MAKE(float)(kArgs.width);
-        v /= CNANOVDB_MAKE(float)(kArgs.height);
+        vec3 wRayDir = getRayDirFromPixelCoord(ix, iy, kArgs.width, kArgs.height, kArgs.numAccumulations, kArgs.samplesPerPixel, pixelSeed, cameraU, cameraV, cameraW, kArgs.cameraFovY, kArgs.cameraAspect);
 
-        // get camera ray...
-        vec3        wRayDir = vec3_sub(vec3_add(vec3_fmul(u, cameraU), vec3_fmul(v, cameraV)), cameraW);
         vec3        wRayEye = cameraP;
         nanovdb_Ray wRay;
         wRay.mEye = wRayEye;
@@ -117,7 +105,6 @@
         nanovdb_Coord ijk;
         float         v0 = 0.0f;
         if (nanovdb_ZeroCrossing(cxt, iRay, acc, CNANOVDB_ADDRESS(ijk), CNANOVDB_ADDRESS(v0))) {
-
             Vec3T iPrimaryPos = nanovdb_CoordToVec3f(ijk);
             //Vec3T wPrimaryPos = nanovdb_Grid_indexToWorldF(grid, iPrimaryPos);
 
@@ -179,54 +166,55 @@
             color.y += intensity.y;
             color.z += intensity.z;
         } else {
-            float groundIntensity = 0.0f;
-            float groundMix = 0.0f;
-
-            if (kArgs.useGround > 0) {
-                float wGroundT = (kArgs.groundHeight - wRayEye.y) / wRayDir.y;
-                if (wGroundT > 0.f) {
-                    vec3 wGroundPos = vec3_add(wRayEye, vec3_fmul(wGroundT, wRayDir));
-                    vec3 iGroundPos = nanovdb_Grid_worldToIndexF(CNANOVDB_GRIDDATA(cxt), wGroundPos);
-                    vec3 iGroundNormal = CNANOVDB_MAKE_VEC3(0, 1, 0);
-
-                    rayTraceGround(wGroundT, kArgs.groundFalloff, wGroundPos, wRayDir.y, CNANOVDB_ADDRESS(groundIntensity), CNANOVDB_ADDRESS(groundMix));
-
-                    groundMix *= kArgs.useGround;
-
-                    if (kArgs.useOcclusion > 0) {
-                        nanovdb_Ray iOccRay;
-                        iOccRay.mEye = vec3_add(iGroundPos, vec3_fmul(2.0f, iGroundNormal));
-                        iOccRay.mDir = lambertNoTangent(iGroundNormal, randVar1, randVar2);
-                        iOccRay.mT0 = DeltaFloat;
-                        iOccRay.mT1 = MaxFloat;
-                        if (nanovdb_ZeroCrossing(cxt, iOccRay, acc, CNANOVDB_ADDRESS(ijk), CNANOVDB_ADDRESS(v0)))
-                            groundIntensity = groundIntensity * (1.0f - kArgs.useOcclusion);
-                    }
-
-                    if (kArgs.useShadows > 0) {
-                        nanovdb_Ray iShadowRay;
-                        iShadowRay.mEye = iGroundPos;
-                        iShadowRay.mDir = iLightDir;
-                        iShadowRay.mT0 = DeltaFloat;
-                        iShadowRay.mT1 = MaxFloat;
-                        if (nanovdb_ZeroCrossing(cxt, iShadowRay, acc, CNANOVDB_ADDRESS(ijk), CNANOVDB_ADDRESS(v0)))
-                            groundIntensity = groundIntensity - kArgs.useShadows * groundIntensity;
-                    }
-
-                    if (kArgs.useGroundReflections > 0) {
-                        nanovdb_Ray iReflRay;
-                        iReflRay.mEye = iGroundPos;
-                        iReflRay.mDir = vec3_sub(iRayDir, CNANOVDB_MAKE_VEC3(0.f, 2.0f * iRayDir.y, 0.f));
-                        iReflRay.mT0 = DeltaFloat;
-                        iReflRay.mT1 = MaxFloat;
-                        if (nanovdb_ZeroCrossing(cxt, iReflRay, acc, CNANOVDB_ADDRESS(ijk), CNANOVDB_ADDRESS(v0)))
-                            groundIntensity = groundIntensity - kArgs.useGroundReflections * groundIntensity;
+            float bgIntensity = 0.0f;
+            if (kArgs.useBackground > 0) {
+                float groundIntensity = 0.0f;
+                float groundMix = 0.0f;
+
+                if (kArgs.useGround > 0) {
+                    float wGroundT = (kArgs.groundHeight - wRayEye.y) / wRayDir.y;
+                    if (wRayDir.y != 0 && wGroundT > 0.f) {
+                        vec3 wGroundPos = vec3_add(wRayEye, vec3_fmul(wGroundT, wRayDir));
+                        vec3 iGroundPos = nanovdb_Grid_worldToIndexF(CNANOVDB_GRIDDATA(cxt), wGroundPos);
+                        vec3 iGroundNormal = CNANOVDB_MAKE_VEC3(0, 1, 0);
+
+                        groundIntensity = evalGroundMaterial(wGroundT, kArgs.groundFalloff, wGroundPos, wRayDir.y, CNANOVDB_ADDRESS(groundMix));
+
+                        if (kArgs.useOcclusion > 0) {
+                            nanovdb_Ray iOccRay;
+                            iOccRay.mEye = vec3_add(iGroundPos, vec3_fmul(2.0f, iGroundNormal));
+                            iOccRay.mDir = lambertNoTangent(iGroundNormal, randVar1, randVar2);
+                            iOccRay.mT0 = DeltaFloat;
+                            iOccRay.mT1 = MaxFloat;
+                            if (nanovdb_ZeroCrossing(cxt, iOccRay, acc, CNANOVDB_ADDRESS(ijk), CNANOVDB_ADDRESS(v0)))
+                                groundIntensity = groundIntensity * (1.0f - kArgs.useOcclusion);
+                        }
+
+                        if (kArgs.useShadows > 0) {
+                            nanovdb_Ray iShadowRay;
+                            iShadowRay.mEye = iGroundPos;
+                            iShadowRay.mDir = iLightDir;
+                            iShadowRay.mT0 = DeltaFloat;
+                            iShadowRay.mT1 = MaxFloat;
+                            if (nanovdb_ZeroCrossing(cxt, iShadowRay, acc, CNANOVDB_ADDRESS(ijk), CNANOVDB_ADDRESS(v0)))
+                                groundIntensity = 0;
+                        }
+
+                        if (kArgs.useGroundReflections > 0) {
+                            nanovdb_Ray iReflRay;
+                            iReflRay.mEye = iGroundPos;
+                            iReflRay.mDir = vec3_sub(iRayDir, CNANOVDB_MAKE_VEC3(0.f, 2.0f * iRayDir.y, 0.f));
+                            iReflRay.mT0 = DeltaFloat;
+                            iReflRay.mT1 = MaxFloat;
+                            if (nanovdb_ZeroCrossing(cxt, iReflRay, acc, CNANOVDB_ADDRESS(ijk), CNANOVDB_ADDRESS(v0)))
+                                groundIntensity = 0;
+                        }
                     }
                 }
-            }
 
-            float skyIntensity = 0.75f + 0.25f * wRayDir.y;
-            float bgIntensity = (1.0f - groundMix) * skyIntensity + groundMix * groundIntensity;
+                float skyIntensity = evalSkyMaterial(wRayDir);
+                bgIntensity = (1.f - groundMix) * skyIntensity + groundMix * groundIntensity;
+            }
 
             color.x += bgIntensity;
             color.y += bgIntensity;
@@ -238,15 +226,6 @@
     color.y /= kArgs.samplesPerPixel;
     color.z /= kArgs.samplesPerPixel;
 
-    if (kArgs.numAccumulations > 1) {
-        vec4 prevOutput = imageLoadPixel(outImage, kArgs.width, threadId);
-        vec3 prevColor = CNANOVDB_MAKE_VEC3(prevOutput.x, prevOutput.y, prevOutput.z);
-        vec3 oldLinearPixel;
-        invTonemapReinhard(CNANOVDB_ADDRESS(oldLinearPixel), prevColor, kArgs.tonemapWhitePoint);
-        color = vec3_add(oldLinearPixel, vec3_fmul((1.0f / CNANOVDB_MAKE(float)(kArgs.numAccumulations)), vec3_sub(color, oldLinearPixel)));
-    }
-
-    tonemapReinhard(CNANOVDB_ADDRESS(color), color, kArgs.tonemapWhitePoint);
-    imageStorePixel(outImage, kArgs.width, threadId, CNANOVDB_MAKE_VEC4(color.x, color.y, color.z, 1.0f));
+    compositeFn(outImage, kArgs.width, threadId, color, kArgs.numAccumulations, kArgs.useTonemapping, kArgs.tonemapWhitePoint);
 }
 ////////////////////////////////////////////////////////
\ Pas de fin de ligne Ã  la fin du fichier
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/FrameBuffer.cpp nanovdb-20201022/nanovdb/cmd/viewer/FrameBuffer.cpp
--- nanovdb-20200925/nanovdb/cmd/viewer/FrameBuffer.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/FrameBuffer.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -17,10 +17,16 @@
 #include <string>
 #include <iomanip>
 #include <cmath>
+#include <vector>
+#include <cstring>
+#include <algorithm>
+
+#define STB_IMAGE_WRITE_IMPLEMENTATION
+#include <stb/stb_image_write.h>
 
 // Save a PFM file.
 // http://netpbm.sourceforge.net/doc/pfm.html
-static bool savePFM(const float* buffer, int width, int height, FrameBufferBase::InternalFormat format, const char* filePath)
+static bool savePFM(const float* buffer, int numComponents, int width, int height, const char* filePath)
 {
     std::fstream file(filePath, std::ios::out | std::ios::binary);
     if (!file.is_open()) {
@@ -34,28 +40,8 @@
         return result;
     };
 
-    int numComponents = 0;
-
-    switch (format) {
-    case FrameBufferBase::InternalFormat::DEPTH_COMPONENT32F:
-    case FrameBufferBase::InternalFormat::DEPTH_COMPONENT32:
-    case FrameBufferBase::InternalFormat::R32F:
-        numComponents = 1;
-        break;
-    case FrameBufferBase::InternalFormat::RGBA32F:
-        numComponents = 4;
-        break;
-    case FrameBufferBase::InternalFormat::RGB32F:
-        numComponents = 3;
-    case FrameBufferBase::InternalFormat::RGBA8UI:
-        numComponents = 4;
-        break;
-    default:
-        numComponents = 0;
-    }
-
     if (numComponents == 0) {
-        std::cerr << "Unable to save PFM file due to unrecognized type: " << (int)format << std::endl;
+        std::cerr << "Unable to save PFM file due to invalid number of components: " << (int)numComponents << std::endl;
         return false;
     }
 
@@ -66,13 +52,6 @@
     float scale = 1.0f;
     if (isLittleEndian())
         scale = -scale;
-    /*
-    auto applyColorProfile = [](float x) -> float {
-        return (x <= 0.04045f)
-                   ? (x / 12.92f)
-                   : (powf((x + 0.055f) / 1.055f, 2.4f));
-    };
-    */
     file << method << "\n"
          << width << "\n"
          << height << "\n"
@@ -90,12 +69,7 @@
             for (int x = 0; x < width; ++x) {
                 float v0 = buffer[(x + y * width) * numComponents + 0];
                 float v1 = buffer[(x + y * width) * numComponents + 1];
-                float v2 = buffer[(x + y * width) * numComponents + 2];
-#if 0
-                v0 = applyColorProfile(v0);
-                v1 = applyColorProfile(v1);
-                v2 = applyColorProfile(v2);
-#endif
+                float v2 = (numComponents <= 2) ? 0.f : buffer[(x + y * width) * numComponents + 2];
                 file.write((char*)&v0, sizeof(float));
                 file.write((char*)&v1, sizeof(float));
                 file.write((char*)&v2, sizeof(float));
@@ -108,7 +82,7 @@
 
 // Load a PFM file.
 // http://netpbm.sourceforge.net/doc/pfm.html
-static bool loadPFM(const char* filePath, FrameBufferBase::InternalFormat format, int& outWidth, int& outHeight, float* buffer)
+static bool loadPFM(const char* filePath, int numComponents, int& outWidth, int& outHeight, float* buffer)
 {
     std::fstream file(filePath, std::ios::in | std::ios::binary);
     if (!file.is_open()) {
@@ -121,35 +95,10 @@
         static bool result = reinterpret_cast<uint8_t*>(&x)[0] == 1;
         return result;
     };
-    
-    auto applyColorProfile = [](float x) -> float {
-        return (x <= 0.0031308f)
-                   ? (12.92f * x)
-                   : (1.055f * powf(x, 1.0f / 2.4f) - 0.055f);
-    };
     */
-    int numComponents = 0;
-
-    switch (format) {
-    case FrameBufferBase::InternalFormat::DEPTH_COMPONENT32F:
-    case FrameBufferBase::InternalFormat::DEPTH_COMPONENT32:
-    case FrameBufferBase::InternalFormat::R32F:
-        numComponents = 1;
-        break;
-    case FrameBufferBase::InternalFormat::RGBA32F:
-        numComponents = 4;
-        break;
-    case FrameBufferBase::InternalFormat::RGB32F:
-        numComponents = 3;
-    case FrameBufferBase::InternalFormat::RGBA8UI:
-        numComponents = 4;
-        break;
-    default:
-        numComponents = 0;
-    }
 
     if (numComponents == 0) {
-        std::cerr << "Unable to load PFM file due to unrecognized type: " << (int)format << std::endl;
+        std::cerr << "Unable to load PFM file due to invalid number of components: " << (int)numComponents << std::endl;
         return false;
     }
 
@@ -185,14 +134,10 @@
                     file.read((char*)&v0, sizeof(float));
                     file.read((char*)&v1, sizeof(float));
                     file.read((char*)&v2, sizeof(float));
-#if 0
-                    v0 = applyColorProfile(v0);
-                    v1 = applyColorProfile(v1);
-                    v2 = applyColorProfile(v2);
-#endif
                     buffer[(x + y * srcWidth) * numComponents + 0] = v0;
                     buffer[(x + y * srcWidth) * numComponents + 1] = v1;
-                    buffer[(x + y * srcWidth) * numComponents + 2] = v2;
+                    if (numComponents > 2)
+                        buffer[(x + y * srcWidth) * numComponents + 2] = v2;
                 }
             }
         }
@@ -204,32 +149,107 @@
     return true;
 }
 
-bool FrameBufferBase::save(const char* filename)
+bool FrameBufferBase::save(const char* filename, const char* fileformat, int quality)
 {
     auto buffer = map(AccessType::READ_ONLY);
     if (!buffer)
         return false;
-    std::cout << "Saving framebuffer(" << mWidth << "x" << mHeight << ") to file: " << filename << " ..." << std::endl;
-    savePFM((const float*)buffer, mWidth, mHeight, mInternalFormat, filename);
-    unmap();
-    return true;
+    //std::cout << "Saving framebuffer(" << mWidth << "x" << mHeight << ") to file: " << filename << " ..." << std::endl;
+
+    std::string fn(filename);
+    std::string ext(fileformat);
+
+    bool targetIsFloat = false;
+    if (ext == "pfm" || ext == "hdr") {
+        targetIsFloat = true;
+    }
+
+    int                  numComponents = formatGetNumComponents(mInternalFormat);
+    int                  typeSize = formatGetElementSize(mInternalFormat) / numComponents;
+    std::vector<uint8_t> tmpBuffer;
+
+    void* srcBuffer = buffer;
+
+    auto byteToFloatFn = [](uint8_t in) -> float { return in / 255.f; };
+    auto floatToByteFn = [](float in) -> uint8_t { return std::min(255, int(in * 255)); };
+
+    if (targetIsFloat == false && formatIsFloat(mInternalFormat)) {
+        tmpBuffer.resize(sizeof(uint8_t) * mWidth * mHeight * numComponents);
+        for (int y = 0; y < mHeight; ++y) {
+            auto* src = ((const float*)buffer) + ((mHeight - 1) - y) * mWidth * numComponents;
+            auto* dst = ((uint8_t*)tmpBuffer.data()) + y * mWidth * numComponents;
+            for (int i = 0; i < mWidth * numComponents; ++i) {
+                dst[i] = floatToByteFn(src[i]);
+            }
+        }
+        srcBuffer = tmpBuffer.data();
+    } else if (targetIsFloat == true && formatIsFloat(mInternalFormat) == false) {
+        tmpBuffer.resize(sizeof(float) * mWidth * mHeight * numComponents);
+        for (int y = 0; y < mHeight; ++y) {
+            auto* src = ((const uint8_t*)buffer) + ((mHeight - 1) - y) * mWidth * numComponents;
+            auto* dst = ((float*)tmpBuffer.data()) + y * mWidth * numComponents;
+            for (int i = 0; i < mWidth * numComponents; ++i) {
+                dst[i] = byteToFloatFn(src[i]);
+            }
+        }
+        srcBuffer = tmpBuffer.data();
+    } else {
+        // no type conversion.
+        tmpBuffer.resize(typeSize * mWidth * mHeight * numComponents);
+        for (int y = 0; y < mHeight; ++y) {
+            auto* src = ((const uint8_t*)buffer) + ((mHeight - 1) - y) * mWidth * numComponents * typeSize;
+            auto* dst = ((uint8_t*)tmpBuffer.data()) + y * mWidth * numComponents * typeSize;
+            std::memcpy(dst, src, typeSize * numComponents * mWidth);
+        }
+        srcBuffer = tmpBuffer.data();
+    }
+
+    if (srcBuffer != buffer)
+        unmap();
+
+    bool hasError = false;
+
+    if (ext == "pfm") {
+        savePFM((const float*)srcBuffer, numComponents, mWidth, mHeight, filename);
+    } else if (ext == "hdr") {
+        stbi_write_hdr(fn.c_str(), mWidth, mHeight, numComponents, (const float*)srcBuffer);
+    } else if (ext == "png") {
+        stbi_write_png(fn.c_str(), mWidth, mHeight, numComponents, srcBuffer, mWidth * numComponents);
+    } else if (ext == "bmp") {
+        stbi_write_bmp(fn.c_str(), mWidth, mHeight, numComponents, srcBuffer);
+    } else if (ext == "tga") {
+        stbi_write_tga(fn.c_str(), mWidth, mHeight, numComponents, srcBuffer);
+    } else if (ext == "jpg") {
+        stbi_write_jpg(fn.c_str(), mWidth, mHeight, numComponents, srcBuffer, quality);
+    } else {
+        hasError = true;
+    }
+
+    if (srcBuffer == buffer)
+        unmap();
+    return hasError == false;
 }
 
-bool FrameBufferBase::load(const char* filename)
+bool FrameBufferBase::load(const char* filename, const char* fileformat)
 {
-    std::cout << "Loading framebuffer from file: " << filename << " ..." << std::endl;
+    std::string ext(fileformat);
 
-    int w, h;
-    if (loadPFM(filename, InternalFormat::RGBA32F, w, h, nullptr)) {
-        bool rc = setup(w, h, InternalFormat::RGBA32F);
-        if (rc) {
-            auto buffer = map(AccessType::WRITE_ONLY);
-            if (!buffer)
-                return false;
-
-            loadPFM(filename, InternalFormat::RGBA32F, w, h, (float*)buffer);
-            unmap();
-            return true;
+    // TODO: only pfm support at the momemt. support other formats.
+    
+    if(ext == "pfm") {
+        int numComponents = formatGetNumComponents(InternalFormat::RGBA32F);
+        int w, h;
+        if (loadPFM(filename, numComponents, w, h, nullptr)) {
+            bool rc = setup(w, h, InternalFormat::RGBA32F);
+            if (rc) {
+                auto buffer = map(AccessType::WRITE_ONLY);
+                if (!buffer)
+                    return false;
+
+                loadPFM(filename, numComponents, w, h, (float*)buffer);
+                unmap();
+                return true;
+            }
         }
     }
     return false;
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/FrameBufferGL.cpp nanovdb-20201022/nanovdb/cmd/viewer/FrameBufferGL.cpp
--- nanovdb-20200925/nanovdb/cmd/viewer/FrameBufferGL.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/FrameBufferGL.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -451,7 +451,7 @@
     mInternalFormat = formatFromGL(internalFormatGL);
     mBufferTypeGL = bufferType;
 
-    mElementSize = getElementSizeForFormat(mInternalFormat);
+    mElementSize = formatGetElementSize(mInternalFormat);
 
     if (mElementSize == 0) {
         std::stringstream msg;
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/FrameBuffer.h nanovdb-20201022/nanovdb/cmd/viewer/FrameBuffer.h
--- nanovdb-20200925/nanovdb/cmd/viewer/FrameBuffer.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/FrameBuffer.h	2020-10-22 03:52:50.000000000 +0200
@@ -60,7 +60,7 @@
     //! return the internal texture format.
     InternalFormat internalFormat() const { return mInternalFormat; }
 
-    static int getElementSizeForFormat(InternalFormat format)
+    static int formatGetElementSize(InternalFormat format)
     {
         switch (format) {
         case InternalFormat::RGBA32F:
@@ -80,9 +80,41 @@
         }
     }
 
+    static bool formatIsFloat(InternalFormat format)
+    {
+        switch (format) {
+        case InternalFormat::DEPTH_COMPONENT32F:
+        case InternalFormat::R32F:
+        case InternalFormat::RGBA32F:
+        case InternalFormat::RGB32F:
+            return true;
+        case InternalFormat::DEPTH_COMPONENT32:
+        case InternalFormat::RGBA8UI:
+        default:
+            return false;
+        }
+    }
+
+    static int formatGetNumComponents(InternalFormat format)
+    {
+        switch (format) {
+        case InternalFormat::RGBA32F:
+        case InternalFormat::RGBA8UI:
+            return 4;
+        case InternalFormat::RGB32F:
+            return 3;
+        case InternalFormat::DEPTH_COMPONENT32F:
+        case InternalFormat::DEPTH_COMPONENT32:
+        case InternalFormat::R32F:
+            return 1;
+        default:
+            return 0;
+        }
+    }
+
     void  invalidate() const { ++mBufferUpdateId; }
-    bool  save(const char* filename);
-    bool  load(const char* filename);
+    bool  save(const char* filename, const char* fileformat, int quality = 80);
+    bool  load(const char* filename, const char* fileformat);
     float computePSNR(FrameBufferBase& other);
 
     virtual void* map(AccessType access) = 0;
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/FrameBufferHost.cpp nanovdb-20201022/nanovdb/cmd/viewer/FrameBufferHost.cpp
--- nanovdb-20200925/nanovdb/cmd/viewer/FrameBufferHost.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/FrameBufferHost.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -67,7 +67,7 @@
 
 bool FrameBufferHost::setup(int w, int h, InternalFormat format)
 {
-    mElementSize = getElementSizeForFormat(format);
+    mElementSize = formatGetElementSize(format);
     mWidth = w;
     mHeight = h;
     mSize = w * h * mElementSize;
Seulement dans nanovdb-20201022/nanovdb/cmd/viewer: GridAssetUrl.cpp
Seulement dans nanovdb-20201022/nanovdb/cmd/viewer: GridAssetUrl.h
Seulement dans nanovdb-20201022/nanovdb/cmd/viewer: GridManager.cpp
Seulement dans nanovdb-20201022/nanovdb/cmd/viewer: GridManager.h
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/nanovdb_viewer.cpp nanovdb-20201022/nanovdb/cmd/viewer/nanovdb_viewer.cpp
--- nanovdb-20200925/nanovdb/cmd/viewer/nanovdb_viewer.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/nanovdb_viewer.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -14,113 +14,133 @@
 #if defined(NANOVDB_USE_GLFW)
 #include "Viewer.h"
 #endif
+
 #include "BatchRenderer.h"
+#include "StringUtils.h"
 
 #include <nanovdb/util/IO.h> // this is required to read (and write) NanoVDB files on the host
+#include <iomanip>
+#include <numeric>
+
+static std::string makeStringCsv(const char* const* strs, int n)
+{
+    std::string str;
+    if (n > 0) {
+        str = strs[0];
+        for (int i = 1; i < n; ++i) {
+            str += ',' + strs[i];
+        }
+    }
+    return str;
+}
+
+struct ParamInfo
+{
+    std::string type;
+    std::string description;
+};
+
+static const std::map<std::string, ParamInfo> kRenderParamMap{
+    {"width", {"integer", "framebuffer width"}},
+    {"height", {"integer", "framebuffer height"}},
+    {"start", {"integer", "start frame"}},
+    {"end", {"integer", "end frame"}},
+    {"background", {"boolean", "use background"}},
+    {"lighting", {"boolean", "use lighting"}},
+    {"shadows", {"boolean", "use shadows"}},
+    {"ground", {"boolean", "use ground-plane"}},
+    {"ground-reflections", {"boolean", "use ground-plane reflections"}},
+    {"tonemapping", {"boolean", "use tonemapping"}},
+    {"tonemapping-whitepoint", {"scalar", "tonemapping whitepoint"}},
+    {"camera-samples", {"integer", "camera samples per ray"}},
+    {"camera-turntable", {"boolean", "use camera turntable"}},
+    {"camera-turntable-rate", {"scalar", "camera turntable revolutions per frame-sequence"}},
+    {"material-override", {"string", "the render method override: {" + makeStringCsv(kMaterialClassTypeStrings, (int)MaterialClass::kNumTypes) + "}"}},
+    {"camera-lens", {"string", "the camera lens type: {" + makeStringCsv(kCameraLensTypeStrings, (int)Camera::LensType::kNumTypes) + "}"}},
+    {"iterations", {"integer", "number of proressive iterations per frame."}},
+    {"gold", {"filename", "The input filename (e.g. \"./reference/gold.%04d.png\""}},
+    {"output", {"filename", "The output filename (e.g. \"output.%04d.jpg\""}},
+    {"output-format", {"string", "the output format override: {png, jpg, tga, bmp, hdr, pfm}"}},
+};
 
 void usage [[noreturn]] (const std::string& progName, int exitStatus = EXIT_FAILURE)
 {
     std::cerr << "\n"
-              << "Usage: " << progName << " [options] *.nvdb\n"
-              << "Description: Render grids from one or more NanoVDB files\n"
+              << "Usage: " << progName << " [options] <url>...\n"
+              << "\n"
+              << "Where URL is:\n"
+              << "(<nodename>=)<url>(#<gridname>)([<start>-<end>])\n"
               << "\n"
-              << "Options:\n"
+              << "Render grids from one or more NanoVDB files\n"
+              << "\n"
+              << "--- General Options ---\n"
               << "-h,--help\tPrints this message\n"
-              << "-g,--grid name\tView all grids matching the specified string name\n"
               << "-b,--batch\tUse headless batch render\n"
-              << "-p,--render-platform\tThe rendering platform to use by name\n"
-              << "-o,--output\tThe output filename prefix (format = ./<output>.frame.ext)\n"
-              << "-l,--render-platform-list\tList the available rendering platforms\n"
-              << "-n,--count\trender <count> frames\n"
-              << "--turntable\tRender a 360 turntable within the frame count\n"
-              << "--width\tThe render width\n"
-              << "--height\tThe render height\n"
-              << "--samples\tThe render sample count\n"
+              << "-p,--platform\tThe rendering platform to use by name\n"
+              << "-l,--platform-list\tList the available rendering platforms\n"
               << "\n"
-              << "Examples:\n"
-              << "* Render temperature grid using CUDA with 32 samples:\n"
-              << "\t" << progName << " -p cuda --grid temperature --samples 32 explosion.0023.vdb\n"
-              << "* Render density grid sequence:\n"
-              << "\t" << progName << " --grid density explosion.%04d.vdb:0-100\n"
-              << "\n";
+              << "--- Render Options ---\n";
+
+    for (auto& param : kRenderParamMap) {
+        std::cerr << std::left << "--render-" << std::setw(16) << param.first << "\t" << std::setw(12) << param.second.type << "\t" << param.second.description << "\n";
+    }
+
+    std::cerr
+        << "\n"
+        << "--- Examples ---\n"
+        << "* Render temperature grid using CUDA with 32 samples:\n"
+        << "\t"
+        << progName
+        << " -p cuda --render-camera-samples 32 explosion.0023.vdb#temperature\n"
+        << "* Render density grid sequence of frames 1-10:\n"
+        << "\t"
+        << progName
+        << " explosion.%04d.vdb#density[0-10]\n"
+        << "* Render single grid sequence of frames 1-5:\n"
+        << "\t"
+        << progName
+        << " explosion.%04d.vdb#[0-5]\n"
+        << "\n";
     exit(exitStatus);
 }
 
+void printPlatformList()
+{
+    RenderLauncher renderLauncher;
+    auto           names = renderLauncher.getPlatformNames();
+    for (const auto& it : names) {
+        std::cout << it << std::endl;
+    }
+}
+
 int main(int argc, char* argv[])
 {
-    int exitStatus = EXIT_SUCCESS;
+    std::string                                       platformName;
+    std::vector<std::pair<std::string, GridAssetUrl>> urls;
+    RendererParams                                    rendererParams;
+
+    bool batch = false;
 
-    std::string                                      platformName;
-    std::string                                      gridName;
-    std::vector<std::pair<std::string, std::string>> fileNames;
-    RendererParams                                   rendererParams;
-    bool                                             batch = false;
+    // make an invalid range.
+    rendererParams.mFrameStart = 0;
+    rendererParams.mFrameEnd = -1;
+
+    StringMap renderStringParams;
+
+    // make an invalid range.
+    rendererParams.mFrameStart = 0;
+    rendererParams.mFrameEnd = -1;
 
     for (int i = 1; i < argc; ++i) {
         std::string arg = argv[i];
         if (arg[0] == '-') {
             if (arg == "-h" || arg == "--help") {
                 usage(argv[0], EXIT_SUCCESS);
-            } else if (arg == "-g" || arg == "--grid") {
-                if (i + 1 == argc) {
-                    std::cerr << "\nExpected a grid name to follow the -g,--grid option\n";
-                    usage(argv[0]);
-                } else {
-                    gridName.assign(argv[++i]);
-                }
             } else if (arg == "-l" || arg == "--list") {
-                RenderLauncher renderLauncher;
-                auto           names = renderLauncher.getPlatformNames();
-                for (const auto& it : names) {
-                    std::cout << it << std::endl;
-                }
+                printPlatformList();
                 return 0;
             } else if (arg == "-b" || arg == "--batch") {
                 batch = true;
-            } else if (arg == "-o" || arg == "--output") {
-                if (i + 1 == argc) {
-                    std::cerr << "\nExpected a filename to follow the -o,--output option\n";
-                    usage(argv[0]);
-                } else {
-                    rendererParams.mOutputPrefix.assign(argv[++i]);
-                }
-            } else if (arg == "--gold") {
-                if (i + 1 == argc) {
-                    std::cerr << "\nExpected a filename to follow the --gold option\n";
-                    usage(argv[0]);
-                } else {
-                    rendererParams.mGoldPrefix.assign(argv[++i]);
-                }
-            } else if (arg == "--samples") {
-                if (i + 1 == argc) {
-                    std::cerr << "\nExpected an integer to follow the --samples option\n";
-                    usage(argv[0]);
-                } else {
-                    rendererParams.mOptions.samplesPerPixel = atoi(argv[++i]);
-                }
-            } else if (arg == "--width") {
-                if (i + 1 == argc) {
-                    std::cerr << "\nExpected an integer to follow the --width option\n";
-                    usage(argv[0]);
-                } else {
-                    rendererParams.mWidth = atoi(argv[++i]);
-                }
-            } else if (arg == "--height") {
-                if (i + 1 == argc) {
-                    std::cerr << "\nExpected an integer to follow the --height option\n";
-                    usage(argv[0]);
-                } else {
-                    rendererParams.mHeight = atoi(argv[++i]);
-                }
-            } else if (arg == "-n" || arg == "--count") {
-                if (i + 1 == argc) {
-                    std::cerr << "\nExpected an integer to follow the -n,--count option\n";
-                    usage(argv[0]);
-                } else {
-                    rendererParams.mFrameCount = atoi(argv[++i]);
-                }
-            } else if (arg == "--turntable") {
-                rendererParams.mUseTurntable = true;
             } else if (arg == "-p" || arg == "--platform") {
                 if (i + 1 == argc) {
                     std::cerr << "\nExpected a string to follow the -p,--platform option\n";
@@ -128,52 +148,72 @@
                 } else {
                     platformName.assign(argv[++i]);
                 }
+            } else if (arg.substr(0, 9) == "--render-") {
+                // collect render options...
+                for (auto& param : kRenderParamMap) {
+                    if (arg.substr(9) == param.first) {
+                        if (i + 1 == argc) {
+                            std::cerr << "\nExpected a " << param.second.type << " to follow --render-" << param.first << "\n";
+                            usage(argv[0]);
+                        } else {
+                            renderStringParams.set(param.first, argv[++i]);
+                        }
+                    }
+                }
             } else {
                 std::cerr << "\nUnrecognized option: \"" << arg << "\"\n";
                 usage(argv[0]);
             }
         } else if (!arg.empty()) {
-            // check for sequence...
-            if (arg.find("%", 0) != std::string::npos) {
-                auto pos = arg.find_last_of(':');
-                auto range = arg.substr(pos + 1);
-                auto filename = arg.substr(0, pos);
-
-                int start = 0, end = rendererParams.mFrameCount;
-
-                if ((pos = range.find('-', 0)) != std::string::npos) {
-                    start = atoi(range.substr(0, pos).c_str());
-                    end = atoi(range.substr(pos + 1).c_str());
-                }
+            // <nodeName>=<GridAssetUrl>
+            std::string urlStr = arg;
+            std::string nodeName = "";
+            auto        pos = arg.find('=');
+            if (pos != std::string::npos) {
+                urlStr = arg.substr(pos + 1);
+                nodeName = arg.substr(0, pos);
+            }
 
-                if (end - start == 0) {
-                    std::cerr << "Invalid filename range\n";
-                    exit(1);
-                }
+            GridAssetUrl url(urlStr);
+            urls.push_back(std::make_pair(nodeName, url));
 
-                char fileNameBuf[FILENAME_MAX];
-                for (int i = start; i < end; ++i) {
-                    sprintf(fileNameBuf, filename.c_str(), i);
-                    //std::cout << "filename: " << fileNameBuf << "\n";
-                    fileNames.push_back(std::make_pair(arg, fileNameBuf));
+            // update frame range...
+            if (url.isSequence()) {
+                if (rendererParams.mFrameEnd < rendererParams.mFrameStart) {
+                    rendererParams.mFrameStart = url.frameStart();
+                    rendererParams.mFrameEnd = url.frameEnd();
                 }
-            } else {
-                fileNames.push_back(std::make_pair(arg, arg));
             }
         }
     }
 
-    if (fileNames.size() == 0) {
-        fileNames.push_back(std::make_pair("__internal", "internal://points_sphere_100"));
-        fileNames.push_back(std::make_pair("__internal", "internal://points_box_100"));
-        fileNames.push_back(std::make_pair("__internal", "internal://points_torus_100"));
-        fileNames.push_back(std::make_pair("__internal", "internal://fog_sphere_100"));
-        fileNames.push_back(std::make_pair("__internal", "internal://fog_box_100"));
-        fileNames.push_back(std::make_pair("__internal", "internal://fog_torus_100"));
-        fileNames.push_back(std::make_pair("__internal", "internal://ls_sphere_100"));
-        fileNames.push_back(std::make_pair("__internal", "internal://ls_box_100"));
-        fileNames.push_back(std::make_pair("__internal", "internal://ls_bbox_100"));
-        fileNames.push_back(std::make_pair("__internal", "internal://ls_torus_100"));
+    // collect the final parameters...
+    rendererParams.mFrameStart = renderStringParams.get<int>("start", rendererParams.mFrameStart);
+    rendererParams.mFrameEnd = renderStringParams.get<int>("end", rendererParams.mFrameEnd);
+    rendererParams.mWidth = renderStringParams.get<int>("width", rendererParams.mWidth);
+    rendererParams.mHeight = renderStringParams.get<int>("height", rendererParams.mHeight);
+    rendererParams.mOutputFilePath = renderStringParams.get<std::string>("output", rendererParams.mOutputFilePath);
+    rendererParams.mOutputExtension = renderStringParams.get<std::string>("output-format", rendererParams.mOutputExtension);
+    rendererParams.mGoldPrefix = renderStringParams.get<std::string>("gold", rendererParams.mGoldPrefix);
+    rendererParams.mMaterialOverride = renderStringParams.getEnum<MaterialClass>("material-override", kMaterialClassTypeStrings, (int)MaterialClass::kNumTypes, rendererParams.mMaterialOverride);
+
+    rendererParams.mSceneParameters.samplesPerPixel = renderStringParams.get<int>("camera-samples", rendererParams.mSceneParameters.samplesPerPixel);
+    rendererParams.mSceneParameters.useBackground = renderStringParams.get<bool>("background", rendererParams.mSceneParameters.useBackground);
+    rendererParams.mSceneParameters.useLighting = renderStringParams.get<bool>("lighting", rendererParams.mSceneParameters.useLighting);
+    rendererParams.mSceneParameters.useShadows = renderStringParams.get<bool>("shadows", rendererParams.mSceneParameters.useShadows);
+    rendererParams.mSceneParameters.useGround = renderStringParams.get<bool>("ground", rendererParams.mSceneParameters.useGround);
+    rendererParams.mSceneParameters.useGroundReflections = renderStringParams.get<bool>("ground-reflections", rendererParams.mSceneParameters.useGroundReflections);
+    rendererParams.mSceneParameters.useTonemapping = renderStringParams.get<bool>("tonemapping", rendererParams.mSceneParameters.useTonemapping);
+    rendererParams.mSceneParameters.tonemapWhitePoint = renderStringParams.get<float>("tonemapping-whitepoint", rendererParams.mSceneParameters.tonemapWhitePoint);
+    rendererParams.mSceneParameters.camera.lensType() = renderStringParams.getEnum<Camera::LensType>("camera-lens", kCameraLensTypeStrings, (int)Camera::LensType::kNumTypes, rendererParams.mSceneParameters.camera.lensType());
+    rendererParams.mUseTurntable = renderStringParams.get<bool>("camera-turntable", rendererParams.mUseTurntable);
+    rendererParams.mTurntableRate = renderStringParams.get<float>("camera-turntable-rate", rendererParams.mTurntableRate);
+    rendererParams.mMaxProgressiveSamples = renderStringParams.get<int>("iterations", rendererParams.mMaxProgressiveSamples);
+
+    // if range still invalid, then make a default frame range...
+    if (rendererParams.mFrameEnd < rendererParams.mFrameStart) {
+        rendererParams.mFrameStart = 0;
+        rendererParams.mFrameEnd = 0;
     }
 
 #if defined(__EMSCRIPTEN__)
@@ -185,54 +225,63 @@
     rendererParams.mHeight = 64;
 #endif
 
-    std::unique_ptr<RendererBase> renderer;
-
+    try {
+        std::unique_ptr<RendererBase> renderer;
+        if (batch) {
+            renderer.reset(new BatchRenderer(rendererParams));
+        } else {
 #if defined(NANOVDB_USE_GLFW)
-    if (batch)
-        renderer.reset(new BatchRenderer(rendererParams));
-    else
-        renderer.reset(new Viewer(rendererParams));
+            renderer.reset(new Viewer(rendererParams));
 #else
-    renderer.reset(new BatchRenderer(rendererParams));
+            std::cerr << "Warning: GLFW was not enabled in your build configuration. Using batch mode.\n";
+            renderer.reset(new BatchRenderer(rendererParams));
 #endif
+        }
 
-    if (platformName.empty() == false) {
-        if (renderer->setRenderPlatformByName(platformName) == false) {
-            std::cerr << "Unrecognized platform: " << platformName << std::endl;
-            return exitStatus;
+        if (platformName.empty() == false) {
+            if (renderer->setRenderPlatformByName(platformName) == false) {
+                std::cerr << "Unrecognized platform: " << platformName << std::endl;
+                return EXIT_FAILURE;
+            }
         }
-    }
 
-    const auto nameKey = nanovdb::io::stringHash(gridName);
+        if (urls.size() > 0) {
+            // ensure only one node is made for each specified node name.
+            std::map<std::string, std::vector<GridAssetUrl>> nodeGridMap;
+            for (auto& nodeUrlPairs : urls) {
+                nodeGridMap[nodeUrlPairs.first].push_back(nodeUrlPairs.second);
+            }
 
-    try {
-        for (auto& file : fileNames) {
-            if (gridName.empty())
-                renderer->addGrid(file.first, file.second);
-            else
-                renderer->addGrid(file.first, file.second, gridName);
+            // attach the grids.
+            for (auto& it : nodeGridMap) {
+                auto nodeId = renderer->addSceneNode(it.first);
+                for (int i = 0; i < it.second.size(); ++i) {
+                    renderer->addGridAsset(it.second[i]);
+                    renderer->setSceneNodeGridAttachment(nodeId, i, it.second[i]);
+                }
+#if 1
+                // waiting for load will enable the frameing to work when we reset the camera!
+                if (!renderer->updateNodeAttachmentRequests(renderer->findNode(nodeId), true, true)) {
+                    throw std::runtime_error("Some assets have errors. Unable to render scene node " + it.first + "; bad asset");
+                }
+#endif
+                renderer->selectSceneNodeByIndex(0);
+                renderer->resetCamera();
+            }
         }
-    }
-    catch (const std::exception& e) {
-        std::cerr << "An exception occurred: \"" << e.what() << "\"" << std::endl;
-        return 1;
-    }
-    catch (...) {
-        std::cerr << "Exception of unexpected type caught" << std::endl;
-        return 1;
-    }
 
-    try {
         renderer->open();
         renderer->run();
         renderer->close();
     }
     catch (const std::exception& e) {
         std::cerr << "An exception occurred: \"" << e.what() << "\"" << std::endl;
+        return EXIT_FAILURE;
     }
     catch (...) {
         std::cerr << "Exception of unexpected type caught" << std::endl;
+        return EXIT_FAILURE;
     }
 
-    return exitStatus;
+    return EXIT_SUCCESS;
 }
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/optix/camera.cu nanovdb-20201022/nanovdb/cmd/viewer/optix/camera.cu
--- nanovdb-20200925/nanovdb/cmd/viewer/optix/camera.cu	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/optix/camera.cu	2020-10-22 03:52:50.000000000 +0200
@@ -9,7 +9,7 @@
 #include "RenderUtils.h"
 
 extern "C" {
-__constant__ Params params;
+__constant__ Params constantParams;
 }
 
 extern "C" __global__ void __raygen__nanovdb_camera()
@@ -23,45 +23,22 @@
     const uint3    dim = optixGetLaunchDimensions();
     int            ix = idx.x;
     int            iy = idx.y;
-    const uint32_t offset = params.width * idx.y + idx.x;
-    auto&          camera = *(const Camera<float>*)optixGetSbtDataPointer();
+    const uint32_t offset = constantParams.width * idx.y + idx.x;
+    const auto&    sceneParams = constantParams.sceneConstants;
 
     float3 color = {0, 0, 0};
 
-    for (int sampleIndex = 0; sampleIndex < params.constants.samplesPerPixel; ++sampleIndex) {
-        uint32_t pixelSeed = render::hash((sampleIndex + (params.numAccumulations + 1) * params.constants.samplesPerPixel)) ^ render::hash(ix, iy);
+    for (int sampleIndex = 0; sampleIndex < sceneParams.samplesPerPixel; ++sampleIndex) {
+        uint32_t pixelSeed = render::hash((sampleIndex + (constantParams.numAccumulations + 1) * sceneParams.samplesPerPixel)) ^ render::hash(ix, iy);
 
-        float u = ix + 0.5f;
-        float v = iy + 0.5f;
-
-        if (params.numAccumulations > 0 || params.constants.samplesPerPixel > 0) {
-#if 1
-            float jitterX, jitterY;
-            render::cmj(jitterX, jitterY, (sampleIndex + (params.numAccumulations + 1) * params.constants.samplesPerPixel) % 64, 8, 8, pixelSeed);
-            u += jitterX - 0.5f;
-            v += jitterY - 0.5f;
-#else
-            float randVar1 = render::randomf(pixelSeed + 0);
-            float randVar2 = render::randomf(pixelSeed + 1);
-            u += randVar1 - 0.5f;
-            v += randVar2 - 0.5f;
-#endif
-        }
-
-        u /= params.width;
-        v /= params.height;
-
-        //if (ix == params.width/2 && iy == params.height/2)
-        //    printf("pixel(%d, %d, %d, %d, %f, %f)\n", ix, iy, pixelSeed, sampleIndex, u, v);
-
-        RayT wRay = camera.getRay(u, v);
+        RayT wRay = render::getRayFromPixelCoord(ix, iy, constantParams.width, constantParams.height, constantParams.numAccumulations, sceneParams.samplesPerPixel, pixelSeed, sceneParams);
 
         float3 result;
         optixTrace(
-            params.handle,
+            constantParams.handle,
             make_float3(wRay.eye()),
             make_float3(wRay.dir()),
-            params.sceneEpsilon,
+            constantParams.sceneEpsilon,
             1e16f,
             0.0f,
             OptixVisibilityMask(1),
@@ -74,19 +51,22 @@
         color += result;
     }
 
-    color /= (float)params.constants.samplesPerPixel;
+    color /= (float)sceneParams.samplesPerPixel;
 
-    if (params.numAccumulations > 1) {
-        float3 prevPixel = make_float3(params.imgBuffer[offset]);
+    if (constantParams.numAccumulations > 1) {
+        float3 prevPixel = make_float3(constantParams.imgBuffer[offset]);
 
         float3 oldLinearPixel;
-        if (params.constants.useTonemapping)
-            render::invTonemapReinhard(*(nanovdb::Vec3f*)&oldLinearPixel, *(nanovdb::Vec3f*)&prevPixel, params.constants.tonemapWhitePoint);
-        color = oldLinearPixel + (color - oldLinearPixel) * (1.0f / params.numAccumulations);
+        if (sceneParams.useTonemapping)
+            render::invTonemapReinhard(*(nanovdb::Vec3f*)&oldLinearPixel, *(nanovdb::Vec3f*)&prevPixel, sceneParams.tonemapWhitePoint);
+        else
+            render::invTonemapPassthru(*(nanovdb::Vec3f*)&oldLinearPixel, *(nanovdb::Vec3f*)&prevPixel);
+
+        color = oldLinearPixel + (color - oldLinearPixel) * (1.0f / constantParams.numAccumulations);
     }
 
-    if (params.constants.useTonemapping)
-        render::tonemapReinhard(*(nanovdb::Vec3f*)&color, *(nanovdb::Vec3f*)&color, params.constants.tonemapWhitePoint);
+    if (sceneParams.useTonemapping)
+        render::tonemapReinhard(*(nanovdb::Vec3f*)&color, *(nanovdb::Vec3f*)&color, sceneParams.tonemapWhitePoint);
 
-    params.imgBuffer[offset] = make_float4(color, 1.f);
+    constantParams.imgBuffer[offset] = make_float4(color, 1.f);
 }
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/optix/geometry.cu nanovdb-20201022/nanovdb/cmd/viewer/optix/geometry.cu
--- nanovdb-20200925/nanovdb/cmd/viewer/optix/geometry.cu	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/optix/geometry.cu	2020-10-22 03:52:50.000000000 +0200
@@ -11,7 +11,7 @@
 //#define OPTIX_PERF_USE_LEAF_DDA
 
 extern "C" {
-__constant__ Params params;
+__constant__ Params constantParams;
 }
 
 __device__ inline bool
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/optix/NanoVDB_optix.h nanovdb-20201022/nanovdb/cmd/viewer/optix/NanoVDB_optix.h
--- nanovdb-20200925/nanovdb/cmd/viewer/optix/NanoVDB_optix.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/optix/NanoVDB_optix.h	2020-10-22 03:52:50.000000000 +0200
@@ -13,11 +13,13 @@
 
 struct Params
 {
-    uint32_t        numAccumulations;
-    float4*         imgBuffer;
-    uint32_t        width;
-    uint32_t        height;
-    RenderConstants constants;
+    uint32_t              numAccumulations;
+    float4*               imgBuffer;
+    uint32_t              width;
+    uint32_t              height;
+
+    MaterialParameters    materialConstants;
+    SceneRenderParameters sceneConstants;
 
     int   maxDepth;
     float sceneEpsilon;
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/optix/shading.cu nanovdb-20201022/nanovdb/cmd/viewer/optix/shading.cu
--- nanovdb-20200925/nanovdb/cmd/viewer/optix/shading.cu	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/optix/shading.cu	2020-10-22 03:52:50.000000000 +0200
@@ -8,7 +8,6 @@
 
 #include "NanoVDB_optix.h"
 #include "helpers.h"
-//#include "random.h"
 
 #include "RenderFogVolumeUtils.h"
 #include "RenderUtils.h"
@@ -16,7 +15,7 @@
 #include <nanovdb/util/Ray.h>
 
 extern "C" {
-__constant__ Params params;
+__constant__ Params constantParams;
 }
 
 // -----------------------------------------------------------------------------
@@ -24,54 +23,93 @@
 {
     const MissData* sbt_data = (MissData*)optixGetSbtDataPointer();
 
+    const auto& sceneParams = constantParams.sceneConstants;
+
     const float3 wRayEye = optixGetWorldRayOrigin();
     const float3 wRayDir = optixGetWorldRayDirection();
 
-    float groundIntensity = 0.0f;
-    float groundMix = 0.0f;
-
     using Vec3T = nanovdb::Vec3f;
     using RayT = nanovdb::Ray<float>;
 
-    if (params.constants.useGround > 0) {
-        // intersect with ground plane and draw checker if camera is above...
+    float bgIntensity = 0.0f;
 
-        float wGroundT = (params.constants.groundHeight - wRayEye.y) / wRayDir.y;
+    if (sceneParams.useBackground) {
+        float groundIntensity = 0.0f;
+        float groundMix = 0.0f;
+
+        if (sceneParams.useGround) {
+            // intersect with ground plane and draw checker if camera is above...
+
+            float wGroundT = (sceneParams.groundHeight - wRayEye.y) / wRayDir.y;
+
+            if (wRayDir.y != 0 && wGroundT > 0.f) {
+                auto wGroundPos = wRayEye + wGroundT * wRayDir;
+
+                groundIntensity = render::evalGroundMaterial(wGroundT, sceneParams.groundFalloff, reinterpret_cast<const Vec3T&>(wGroundPos), wRayDir.y, groundMix);
+
+                if (sceneParams.useLighting && sceneParams.useShadows) {
+                    const float3 wLightDir = make_float3(0.0f, 1.0f, 0.0f);
+                    float        attenuation = 0.0f;
+
+                    optixTrace(
+                        constantParams.handle,
+                        reinterpret_cast<const float3&>(wGroundPos),
+                        wLightDir,
+                        0.01f,
+                        1e16f,
+                        0.0f,
+                        OptixVisibilityMask(1),
+                        OPTIX_RAY_FLAG_DISABLE_ANYHIT | OPTIX_RAY_FLAG_TERMINATE_ON_FIRST_HIT | OPTIX_RAY_FLAG_DISABLE_CLOSESTHIT,
+                        RAY_TYPE_OCCLUSION,
+                        RAY_TYPE_COUNT,
+                        RAY_TYPE_OCCLUSION,
+                        reinterpret_cast<uint32_t&>(attenuation));
 
-        if (wGroundT > 0.f) {
-            auto wGroundPos = wRayEye + wGroundT * wRayDir;
+                    groundIntensity *= attenuation;
+                }
+            }
+        }
 
-            render::rayTraceGround(wGroundT, params.constants.groundFalloff, reinterpret_cast<const Vec3T&>(wGroundPos), wRayDir.y, groundIntensity, groundMix);
+        float skyIntensity = render::evalSkyMaterial(nanovdb::Vec3f(wRayDir.x, wRayDir.y, wRayDir.z));
+        bgIntensity = (1.f - groundMix) * skyIntensity + groundMix * groundIntensity;
+    }
 
-            if (params.constants.useShadows > 0) {
-                const float3 wLightDir = make_float3(0.0f, 1.0f, 0.0f);
-                float        attenuation = 0.0f;
+    optixSetPayload_0(float_as_int(bgIntensity));
+    optixSetPayload_1(float_as_int(bgIntensity));
+    optixSetPayload_2(float_as_int(bgIntensity));
+}
 
-                optixTrace(
-                    params.handle,
-                    reinterpret_cast<const float3&>(wGroundPos),
-                    wLightDir,
-                    0.01f,
-                    1e16f,
-                    0.0f,
-                    OptixVisibilityMask(1),
-                    OPTIX_RAY_FLAG_DISABLE_ANYHIT | OPTIX_RAY_FLAG_TERMINATE_ON_FIRST_HIT | OPTIX_RAY_FLAG_DISABLE_CLOSESTHIT,
-                    RAY_TYPE_OCCLUSION,
-                    RAY_TYPE_COUNT,
-                    RAY_TYPE_OCCLUSION,
-                    reinterpret_cast<uint32_t&>(attenuation));
+// -----------------------------------------------------------------------------
+extern "C" __global__ void __miss__env_radiance()
+{
+    using Vec3T = nanovdb::Vec3f;
+    using RayT = nanovdb::Ray<float>;
 
-                groundIntensity *= attenuation;
+    const MissData* sbt_data = (MissData*)optixGetSbtDataPointer();
+    const float3 wRayEye = optixGetWorldRayOrigin();
+    const float3 wRayDir = optixGetWorldRayDirection();
+
+    const auto& sceneParams = constantParams.sceneConstants;
+
+    float bgIntensity = 0.0f;
+    if (sceneParams.useBackground) {
+        float groundIntensity = 0.0f;
+        float groundMix = 0.0f;
+        if (sceneParams.useGround) {
+            // intersect with ground plane and draw checker if camera is above...
+            float wGroundT = (sceneParams.groundHeight - wRayEye.y) / wRayDir.y;
+            if (wRayDir.y != 0 && wGroundT > 0.f) {
+                auto wGroundPos = wRayEye + wGroundT * wRayDir;
+                groundIntensity = render::evalGroundMaterial(wGroundT, sceneParams.groundFalloff, reinterpret_cast<const Vec3T&>(wGroundPos), wRayDir.y, groundMix);
             }
         }
+        float skyIntensity = render::evalSkyMaterial(nanovdb::Vec3f(wRayDir.x, wRayDir.y, wRayDir.z));
+        bgIntensity = (1.f - groundMix) * skyIntensity + groundMix * groundIntensity;
     }
 
-    float skyIntensity = 0.75f + 0.25f * wRayDir.y;
-    auto  radiance = (1.f - groundMix) * skyIntensity + groundMix * groundIntensity;
-
-    optixSetPayload_0(float_as_int(radiance));
-    optixSetPayload_1(float_as_int(radiance));
-    optixSetPayload_2(float_as_int(radiance));
+    optixSetPayload_0(float_as_int(bgIntensity));
+    optixSetPayload_1(float_as_int(bgIntensity));
+    optixSetPayload_2(float_as_int(bgIntensity));
 }
 
 extern "C" __global__ void __miss__occlusion()
@@ -87,6 +125,9 @@
     using RayT = nanovdb::Ray<float>;
     using Vec3T = nanovdb::Vec3f;
 
+    const auto& sceneParams = constantParams.sceneConstants;
+    const auto& params = constantParams.materialConstants;
+
     const VolumeGeometry* volume = reinterpret_cast<VolumeGeometry*>(optixGetSbtDataPointer());
     const auto*           grid = reinterpret_cast<const nanovdb::FloatGrid*>(volume->grid);
     auto                  acc = grid->tree().getAccessor();
@@ -110,12 +151,11 @@
     auto wNormal = make_float3(grid->indexToWorldDirF(iNormal).normalize());
 
     const float3 wLightDir = {0.0f, 1.0f, 0.0f};
-    float        useLighting = params.constants.useLighting;
     float        intensity = 1.0f;
     float        occlusion = 0.0f;
     float        voxelUniformSize = float(grid->voxelSize()[0]);
 
-    if (params.constants.useOcclusion > 0) {
+    if (params.useOcclusion > 0) {
         float attenuation = 0.0f;
         auto  pixelSeed = render::hash(float_as_int(wRayDir.x), float_as_int(wRayDir.y));
         float randVar1 = render::randomf(pixelSeed + 0);
@@ -123,7 +163,7 @@
         auto  occDir = render::lambertNoTangent(reinterpret_cast<const Vec3T&>(wNormal), randVar1, randVar2);
 
         optixTrace(
-            params.handle,
+            constantParams.handle,
             wSurfacePos - 0.01f * wRayDir,
             make_float3(occDir),
             1e-3f,
@@ -137,12 +177,12 @@
             reinterpret_cast<uint32_t&>(attenuation));
 
         if (attenuation < 1)
-            occlusion = params.constants.useOcclusion;
+            occlusion = 1;
 
         intensity = 1.0f - occlusion;
     }
 
-    if (useLighting > 0) {
+    if (sceneParams.useLighting) {
         float ambient = 1.0f;
         float shadowFactor = 0.0f;
 
@@ -152,11 +192,11 @@
         float       diffuseKey = fmaxf(0.0f, (dot(wNormal, wLightDir) + diffuseWrap) / (1.0f + diffuseWrap));
         float       diffuseFill = fmaxf(0.0f, -dot(wNormal, wRayDir));
 
-        if (params.constants.useShadows > 0) {
+        if (sceneParams.useShadows) {
             float attenuation = 0.0f;
 
             optixTrace(
-                params.handle,
+                constantParams.handle,
                 wSurfacePos - 0.01f * wRayDir,
                 wLightDir,
                 1e-3f,
@@ -170,11 +210,10 @@
                 reinterpret_cast<uint32_t&>(attenuation));
 
             if (attenuation < 1)
-                shadowFactor = params.constants.useShadows;
+                shadowFactor = 1;
         }
 
-        intensity = useLighting * ((1.0f - shadowFactor) * ((shadowKey * 0.2f) + (diffuseKey * 0.8f)) + (1.0f - occlusion) * (diffuseFill * 0.2f + (ambient * 0.1f)));
-        intensity = intensity + ((1.0f - useLighting) * (1.0f - occlusion));
+        intensity = ((1.0f - shadowFactor) * ((shadowKey * 0.2f) + (diffuseKey * 0.8f)) + (1.0f - occlusion) * (diffuseFill * 0.2f + (ambient * 0.1f)));
     }
 
     optixSetPayload_0(float_as_int(intensity));
@@ -191,22 +230,31 @@
     using RayT = nanovdb::Ray<float>;
     using Vec3T = nanovdb::Vec3f;
 
+    const auto& sceneParams = constantParams.sceneConstants;
+    const auto& params = constantParams.materialConstants;
+
     const HitGroupData* sbt_data = (HitGroupData*)optixGetSbtDataPointer();
 
-    const auto* grid = reinterpret_cast<const nanovdb::FloatGrid*>(sbt_data->geometry.volume.grid);
-    const auto& tree = grid->tree();
+    const auto* densityGrid = reinterpret_cast<const nanovdb::FloatGrid*>(sbt_data->geometry.volume.grid);
 
     const Vec3T wLightDir = Vec3T(0, 1, 0);
-    const Vec3T iLightDir = grid->worldToIndexDirF(wLightDir).normalize();
+    const Vec3T iLightDir = densityGrid->worldToIndexDirF(wLightDir).normalize();
 
-    auto acc = tree.getAccessor();
+    const auto& densityTree = densityGrid->tree();
+    const auto  densityAcc = densityTree.getAccessor();
+    const auto  densitySampler = nanovdb::createSampler<0, decltype(densityAcc), false>(densityAcc);
 
     HeterogenousMedium medium;
-    medium.densityFactor = params.constants.volumeDensity;
-    medium.densityMin = grid->tree().root().valueMin() * medium.densityFactor;
-    medium.densityMax = medium.densityFactor; //grid->tree().root().valueMax() * medium.densityFactor;
+    medium.densityScale = params.volumeDensityScale;
+    medium.densityMin = valueToScalar(densityGrid->tree().root().valueMin()) * medium.densityScale;
+    medium.densityMax = valueToScalar(densityGrid->tree().root().valueMax()) * medium.densityScale;
     medium.densityMax = fmaxf(medium.densityMin, fmaxf(medium.densityMax, 0.001f));
-    medium.hgMeanCosine = 0.f;
+    medium.hgMeanCosine = params.phase;
+    medium.temperatureScale = params.volumeTemperatureScale;
+    medium.transmittanceMethod = params.transmittanceMethod;
+    medium.transmittanceThreshold = params.transmittanceThreshold;
+    medium.maxPathDepth = params.maxPathDepth;
+    medium.albedo = params.volumeAlbedo;
 
     const float3 wRayEye = optixGetWorldRayOrigin();
     const float3 wRayDir = optixGetWorldRayDirection();
@@ -218,24 +266,23 @@
                            reinterpret_cast<const Vec3T&>(wRayDir),
                            t0,
                            t1);
-    RayT       iRay = wRay.worldToIndexF(*grid);
+    RayT       iRay = wRay.worldToIndexF(*densityGrid);
 
     const uint3    idx = optixGetLaunchIndex();
     const uint3    dim = optixGetLaunchDimensions();
-    const uint32_t offset = params.width * idx.y + idx.x;
+    const uint32_t offset = constantParams.width * idx.y + idx.x;
 
-    auto pixelSeed = render::hash(offset + params.width * params.height * params.numAccumulations);
+    auto pixelSeed = render::hash(offset + constantParams.width * constantParams.height * constantParams.numAccumulations);
 
     Vec3T radiance = Vec3T(0);
-    if (params.constants.useLighting) {
-        iRay.setTimes();
-        radiance = traceVolume(iRay, acc, medium, pixelSeed, iLightDir);
-    }
-
+    
     iRay.setTimes();
-    float  transmittance = getTransmittance(iRay, acc, medium, pixelSeed);
+    float throughput;
+    bool  isFullyAbsorbed;
+    radiance = traceFogVolume(throughput, isFullyAbsorbed, iRay, densitySampler, medium, pixelSeed, sceneParams, iLightDir);
+
     float3 sceneRadiance = {0.0f, 0.0f, 0.0f};
-    if (transmittance > 0.01f) {
+    if (throughput > 0 && isFullyAbsorbed == false) {
         optixTrace(0, // only run miss program
                    wRayEye,
                    wRayDir,
@@ -250,7 +297,7 @@
                    float3_as_args(sceneRadiance));
     }
 
-    float3 result = sceneRadiance * transmittance + make_float3(radiance);
+    float3 result = sceneRadiance * throughput + make_float3(radiance);
 
     optixSetPayload_0(float_as_int(result.x));
     optixSetPayload_1(float_as_int(result.y));
@@ -263,17 +310,23 @@
     using RayT = nanovdb::Ray<float>;
     using Vec3T = nanovdb::Vec3f;
 
+    const auto& sceneParams = constantParams.sceneConstants;
+    const auto& params = constantParams.materialConstants;
+
     const HitGroupData* sbt_data = (HitGroupData*)optixGetSbtDataPointer();
 
-    const auto* grid = reinterpret_cast<const nanovdb::FloatGrid*>(sbt_data->geometry.volume.grid);
-    auto        acc = grid->tree().getAccessor();
+    const auto* densityGrid = reinterpret_cast<const nanovdb::FloatGrid*>(sbt_data->geometry.volume.grid);
+    const auto& densityTree = densityGrid->tree();
+    const auto  densityAcc = densityTree.getAccessor();
+    const auto  densitySampler = nanovdb::createSampler<0, decltype(densityAcc), false>(densityAcc);
 
     HeterogenousMedium medium;
-    medium.densityFactor = params.constants.volumeDensity;
-    medium.densityMin = grid->tree().root().valueMin() * medium.densityFactor;
-    medium.densityMax = medium.densityFactor; //grid->tree().root().valueMax() * medium.densityFactor;
+    medium.densityScale = params.volumeDensityScale;
+    medium.densityMin = densityGrid->tree().root().valueMin() * medium.densityScale;
+    medium.densityMax = densityGrid->tree().root().valueMax() * medium.densityScale;
     medium.densityMax = fmaxf(medium.densityMin, fmaxf(medium.densityMax, 0.001f));
     medium.hgMeanCosine = 0.f;
+    medium.albedo = params.volumeAlbedo;
 
     const float3 wRayEye = optixGetWorldRayOrigin();
     const float3 wRayDir = optixGetWorldRayDirection();
@@ -285,16 +338,16 @@
                            reinterpret_cast<const Vec3T&>(wRayDir),
                            t0,
                            t1);
-    RayT       iRay = wRay.worldToIndexF(*grid);
+    RayT       iRay = wRay.worldToIndexF(*densityGrid);
     Vec3T      radiance = Vec3T(0);
 
     const uint3    idx = optixGetLaunchIndex();
     const uint3    dim = optixGetLaunchDimensions();
-    const uint32_t offset = params.width * idx.y + idx.x;
-    auto           pixelSeed = render::hash(offset + params.width * params.height * params.numAccumulations);
+    const uint32_t offset = constantParams.width * idx.y + idx.x;
+    auto           pixelSeed = render::hash(offset + constantParams.width * constantParams.height * constantParams.numAccumulations);
 
     iRay.setTimes();
-    float transmittance = getTransmittance(iRay, acc, medium, pixelSeed);
+    float transmittance = getTransmittance(iRay, densitySampler, medium, pixelSeed);
     optixSetPayload_0(float_as_int(transmittance));
 }
 
@@ -302,6 +355,8 @@
 {
     const MissData* sbtData = (MissData*)optixGetSbtDataPointer();
 
+    const auto& sceneParams = constantParams.sceneConstants;
+
     const float3 wRayEye = optixGetWorldRayOrigin();
     const float3 wRayDir = optixGetWorldRayDirection();
 
@@ -313,17 +368,17 @@
 
     float wT = 1e16f;
 
-    if (params.constants.useGround > 0) {
+    if (sceneParams.useBackground) {
         // intersect with ground plane and draw checker if camera is above...
 
-        float wGroundT = (params.constants.groundHeight - wRayEye.y) / wRayDir.y;
+        float wGroundT = (sceneParams.groundHeight - wRayEye.y) / wRayDir.y;
 
-        if (wGroundT > 0.f) {
+        if (wRayDir.y != 0 && wGroundT > 0.f) {
             float3 wGroundPos = wRayEye + wGroundT * wRayDir;
 
-            render::rayTraceGround(wGroundT, params.constants.groundFalloff, reinterpret_cast<const Vec3T&>(wGroundPos), wRayDir.y, groundIntensity, groundMix);
+            groundIntensity = render::evalGroundMaterial(wGroundT, sceneParams.groundFalloff, reinterpret_cast<const Vec3T&>(wGroundPos), wRayDir.y, groundMix);
 
-            if (params.constants.useShadows > 0) {
+            if (sceneParams.useLighting && sceneParams.useShadows > 0) {
                 const float3 wLightDir = {0.0f, 1.0f, 0.0f};
 
                 // HACK: temporrary hack to ensure the ray is not within the volume.
@@ -331,7 +386,7 @@
 
                 float attenuation = 0.0f;
                 optixTrace(
-                    params.handle,
+                    constantParams.handle,
                     wGroundPos,
                     wLightDir,
                     0.01f,
@@ -349,7 +404,7 @@
         }
     }
 
-    float skyIntensity = 0.75f + 0.25f * wRayDir.y;
+    float skyIntensity = render::evalSkyMaterial(nanovdb::Vec3f(wRayDir.x, wRayDir.y, wRayDir.z));
 
     auto radiance = (1.f - groundMix) * skyIntensity + groundMix * groundIntensity;
 
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/optix/stdint.h nanovdb-20201022/nanovdb/cmd/viewer/optix/stdint.h
--- nanovdb-20200925/nanovdb/cmd/viewer/optix/stdint.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/optix/stdint.h	2020-10-22 03:52:50.000000000 +0200
@@ -54,6 +54,20 @@
     #define PTRDIFF_MIN INTPTR_MIN
     #define PTRDIFF_MAX INTPTR_MAX
     #define SIZE_MAX    UINT64_MAX
+
+    #define INT8_C(x)    (x)
+    #define INT16_C(x)   (x)
+    #define INT32_C(x)   (x)
+    #define INT64_C(x)   (x ## LL)
+
+    #define UINT8_C(x)   (x)
+    #define UINT16_C(x)  (x)
+    #define UINT32_C(x)  (x ## U)
+    #define UINT64_C(x)  (x ## ULL)
+
+    #define INTMAX_C(x)  INT64_C(x)
+    #define UINTMAX_C(x) UINT64_C(x)
+
     } // namespace __jitify_stdint_ns
     namespace std { using namespace __jitify_stdint_ns; }
     using namespace __jitify_stdint_ns;;
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/RenderConstants.h nanovdb-20201022/nanovdb/cmd/viewer/RenderConstants.h
--- nanovdb-20200925/nanovdb/cmd/viewer/RenderConstants.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/RenderConstants.h	2020-10-22 03:52:50.000000000 +0200
@@ -16,6 +16,11 @@
 #include <nanovdb/NanoVDB.h>
 #include <nanovdb/util/Ray.h>
 
+enum class VolumeTransmittanceMethod : int { kRiemannSum = 0,
+                                             kDeltaTracking,
+                                             kRatioTracking,
+                                             kResidualRatioTracking };
+
 struct RendererAttributeParams
 {
     int   attribute;
@@ -23,71 +28,182 @@
     float offset;
 };
 
-struct RenderConstants
+struct MaterialParameters
 {
-    float                   groundHeight;
-    float                   groundFalloff;
-    float                   useLighting;
-    float                   useGround;
-    float                   useOcclusion;
-    float                   useShadows;
-    float                   useGroundReflections;
-    int                     samplesPerPixel;
-    float                   volumeDensity;
-    bool                    useTonemapping;
-    float                   tonemapWhitePoint;
-    RendererAttributeParams attributeSemanticMap[(int)nanovdb::GridBlindDataSemantic::End];
+    float                     useOcclusion;
+    float                     volumeDensityScale;
+    float                     volumeTemperatureScale;
+    VolumeTransmittanceMethod transmittanceMethod;
+    float                     transmittanceThreshold;
+    float                     phase;
+    int                       maxPathDepth;
+    float                     volumeAlbedo;
+    int                       interpolationOrder;
+    RendererAttributeParams   attributeSemanticMap[(int)nanovdb::GridBlindDataSemantic::End];
 };
 
+inline MaterialParameters makeMaterialParameters()
+{
+    MaterialParameters params;
+    params.useOcclusion = 0;
+    params.volumeDensityScale = 1;
+    params.volumeTemperatureScale = 1;
+    params.transmittanceMethod = VolumeTransmittanceMethod::kRatioTracking;
+    params.transmittanceThreshold = 0.01f;
+    params.phase = 0.f;
+    params.maxPathDepth = 4;
+    params.volumeAlbedo = 0.5f;
+    params.interpolationOrder = 0;
+    return params;
+}
+
 struct RenderStatistics
 {
     float mDuration;
 };
 
 /// @brief A minimal perspective camera for ray generation
-template<typename RealT = float, typename Vec3T = nanovdb::Vec3<RealT>, typename RayT = nanovdb::Ray<RealT>>
 class Camera
 {
-    Vec3T mEye, mW, mU, mV;
-
-    __hostdev__ void init(RealT vfov, RealT aspect)
-    {
-        const RealT halfHeight = RealT(tan(vfov * 3.14159265358979323846 / 360));
-        const RealT halfWidth = aspect * halfHeight;
-        mW = halfWidth * mU + halfHeight * mV + mW; // remove eye here and in getRay
-        mU *= 2 * halfWidth;
-        mV *= 2 * halfHeight;
-    }
+    using RealT = float;
+    using Vec3T = nanovdb::Vec3<RealT>;
+    using RayT = nanovdb::Ray<RealT>;
 
 public:
+    enum class LensType : int { kPinHole = 0,
+                                kSpherical,
+                                kODS,
+                                kNumTypes };
+
     /// @brief default Ctor.
     Camera() = default;
 
     /// @brief Ctor. // vfov is top to bottom in degrees
     /// @note  up is assumed to be a unit-vector
-    __hostdev__ Camera(const Vec3T& eye, const Vec3T& lookat, const Vec3T& up, RealT vfov, RealT aspect)
-        : mEye(eye)
+    __hostdev__ Camera(LensType type, const Vec3T& eye, const Vec3T& lookat, const Vec3T& up, RealT vfov, RealT aspect)
+        : mLensType(type)
+        , mEye(eye)
         , mW((eye - lookat).normalize())
         , mU(up.cross(mW))
         , mV(up)
+        , mFovY(vfov)
+        , mAspect(aspect)
     {
-        this->init(vfov, aspect);
     }
-    __hostdev__ void update(const Vec3T& eye, const Vec3T& lookat, const Vec3T& up, RealT vfov, RealT aspect)
+
+    /// @brief {u,v} are are assumed to be [0,1]
+    __hostdev__ RayT getRay(RealT u, RealT v) const
     {
-        mEye = eye;
-        mV = up;
-        mW = mEye - lookat;
-        mW.normalize();
-        mU = mV.cross(mW);
-        this->init(vfov, aspect);
+        if (mLensType == LensType::kPinHole) {
+            const RealT halfHeight = RealT(tanf(mFovY * 3.14159265358979323846f / 360.f));
+            const RealT halfWidth = mAspect * halfHeight;
+            auto        W = halfWidth * mU + halfHeight * mV + mW;
+            auto        U = mU * 2 * halfWidth;
+            auto        V = mV * 2 * halfHeight;
+            auto        rd = (u * U + v * V - W).normalize();
+            return RayT(mEye, rd);
+        } else if (mLensType == LensType::kSpherical) {
+            v -= 0.5f;
+            float theta = -u * (3.14165f * 2.f);
+            float phi = v * (3.14165f);
+            auto  rd = Vec3T(sinf(theta) * cosf(phi),
+                            sinf(phi),
+                            cosf(theta) * cosf(phi));
+
+            auto camDir = mU * rd[0] + mV * rd[1] + mW * rd[2];
+            auto camEye = mEye;
+            return RayT(camEye, camDir.normalize());
+        } else if (mLensType == LensType::kODS) {
+            float s = mIpd * 0.5f;
+            if (v > 0.5)
+                s = -s;
+            v = fmod(v, 0.5f) * 2.0f;
+
+            v -= 0.5f;
+            float theta = -u * (3.14165f * 2.f);
+            float phi = v * (3.14165f);
+
+            auto rd = Vec3T(sinf(theta) * cosf(phi),
+                            sinf(phi),
+                            cosf(theta) * cosf(phi));
+
+            auto camDir = mU * rd[0] + mV * rd[1] + mW * rd[2];
+            auto camEye = mEye + Vec3T(cos(theta) * s, 0, sin(theta) * s);
+            return RayT(camEye, camDir.normalize());
+        } else {
+            return RayT(mEye, Vec3T(0, 0, -1));
+        }
     }
-    /// @brief {u,v} are are assumed to be [0,1]
-    __hostdev__ RayT getRay(RealT u, RealT v) const { return RayT(mEye, u * mU + v * mV - mW); }
 
     __hostdev__ const Vec3T& P() const { return mEye; }
     __hostdev__ const Vec3T& U() const { return mU; }
     __hostdev__ const Vec3T& V() const { return mV; }
     __hostdev__ const Vec3T& W() const { return mW; }
 
+    __hostdev__ const LensType& lensType() const { return mLensType; }
+    __hostdev__ LensType& lensType() { return mLensType; }
+
+    __hostdev__ const float& ipd() const { return mIpd; }
+    __hostdev__ float&       ipd() { return mIpd; }
+
+    __hostdev__ const float& fov() const { return mFovY; }
+    __hostdev__ float&       fov() { return mFovY; }
+
+    __hostdev__ const float& aspect() const { return mAspect; }
+    __hostdev__ float&       aspect() { return mAspect; }
+
+    static Camera makeDefaultCamera()
+    {
+        Camera camera;
+        camera.mLensType = LensType::kPinHole;
+        camera.mAspect = 1.0f;
+        camera.mIpd = 1.0f;
+        camera.mFovY = 60.f;
+        return camera;
+    }
+
+private:
+    LensType mLensType;
+    Vec3T    mEye, mW, mU, mV;
+    float    mAspect;
+    float    mIpd;
+    float    mFovY;
 }; // Camera
+
+struct SceneRenderParameters
+{
+    float  groundHeight;
+    float  groundFalloff;
+    int    useTonemapping;
+    float  tonemapWhitePoint;
+    int    useBackground;
+    int    useGround;
+    int    useShadows;
+    int    useLighting;
+    int    useGroundReflections;
+    int    samplesPerPixel;
+    Camera camera;
+};
+
+inline SceneRenderParameters makeSceneRenderParameters()
+{
+    SceneRenderParameters params;
+    params.groundHeight = 0;
+    params.groundFalloff = 0;
+    params.useTonemapping = false;
+    params.tonemapWhitePoint = 1.5f;
+    params.useBackground = 1;
+    params.useGround = 1;
+    params.useShadows = 1;
+    params.useLighting = 1;
+    params.useGroundReflections = 0;
+    params.samplesPerPixel = 1;
+    params.camera = Camera::makeDefaultCamera();
+    return params;
+}
+
+struct GridRenderParameters
+{
+    nanovdb::BBox<nanovdb::Vec3R> bounds;
+    void*                         gridHandle;
+};
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/Renderer.cpp nanovdb-20201022/nanovdb/cmd/viewer/Renderer.cpp
--- nanovdb-20200925/nanovdb/cmd/viewer/Renderer.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/Renderer.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -2,7 +2,7 @@
 // SPDX-License-Identifier: MPL-2.0
 
 /*!
-	\file RendererBase.cpp
+	\file Renderer.cpp
 
 	\author Wil Braithwaite
 
@@ -12,6 +12,7 @@
 */
 
 #define _USE_MATH_DEFINES
+#include <cstring>
 #include <iomanip>
 #include <iostream>
 #include <sstream>
@@ -19,66 +20,25 @@
 #include <cassert>
 #include <chrono>
 #include <cmath>
+#include <unordered_set>
 
+#include "StringUtils.h"
 #include "Renderer.h"
 #include "RenderLauncher.h"
 
-#include <nanovdb/util/IO.h> // for NanoVDB file import
-#include <nanovdb/util/GridBuilder.h>
-#if defined(NANOVDB_USE_OPENVDB)
-#include <nanovdb/util/OpenToNanoVDB.h>
-#endif
-
-static nanovdb::GridHandle<> createInternalGrid(std::string internalName)
-{
-    if (internalName == "ls_sphere_100") {
-        return nanovdb::createLevelSetSphere(100.0f, nanovdb::Vec3d(0), 1.0f, 3.0f, nanovdb::Vec3R(0), internalName);
-    } else if (internalName == "ls_torus_100") {
-        return nanovdb::createLevelSetTorus(100.0f, 50.f, nanovdb::Vec3d(0), 1.0f, 3.0f, nanovdb::Vec3R(0), internalName);
-    } else if (internalName == "ls_box_100") {
-        return nanovdb::createLevelSetBox(100.0f, 100.0f, 100.0f, nanovdb::Vec3d(0), 1.0f, 3.0f, nanovdb::Vec3R(0), internalName);
-    } else if (internalName == "fog_sphere_100") {
-        return nanovdb::createFogVolumeSphere(100.0f, nanovdb::Vec3d(0), 1.0f, 3.0f, nanovdb::Vec3R(0), internalName);
-    } else if (internalName == "fog_torus_100") {
-        return nanovdb::createFogVolumeTorus(100.0f, 50.f, nanovdb::Vec3d(0), 1.0f, 3.0f, nanovdb::Vec3R(0), internalName);
-    } else if (internalName == "fog_box_100") {
-        return nanovdb::createFogVolumeBox(100.0f, 100.0f, 100.0f, nanovdb::Vec3d(0), 1.0f, 3.0f, nanovdb::Vec3R(0), internalName);
-    } else if (internalName == "points_sphere_100") {
-        return nanovdb::createPointSphere(1, 100.0f, nanovdb::Vec3d(0), 1.0f, nanovdb::Vec3R(0), internalName);
-    } else if (internalName == "points_torus_100") {
-        return nanovdb::createPointTorus(1, 100.0f, 50.f, nanovdb::Vec3d(0), 1.0f, nanovdb::Vec3R(0), internalName);
-    } else if (internalName == "points_box_100") {
-        return nanovdb::createPointBox(1, 100.0f, 100.0f, 100.0f, nanovdb::Vec3d(0), 1.0f, nanovdb::Vec3R(0), internalName);
-    } else if (internalName == "ls_bbox_100") {
-        return nanovdb::createLevelSetBBox(100.0f, 100.0f, 100.0f, 10.f, nanovdb::Vec3d(0), 1.0f, 3.0f, nanovdb::Vec3R(0), internalName);
-    } else {
-        return nanovdb::GridHandle<>();
-    }
-}
-
 RendererParams::RendererParams()
 {
-    mOptions.useLighting = 1;
-    mOptions.useGround = 1;
-    mOptions.useOcclusion = 0;
-    mOptions.useShadows = 1;
-    mOptions.useGroundReflections = 0;
-    mOptions.samplesPerPixel = 1;
-    mOptions.volumeDensity = 0.5f;
-    mOptions.tonemapWhitePoint = 1.5f;
-    mOptions.useTonemapping = true;
+    mSceneParameters = makeSceneRenderParameters();
 }
 
 RendererBase::RendererBase(const RendererParams& params)
     : mParams(params)
 {
-#if defined(NANOVDB_USE_OPENVDB)
-    openvdb::initialize();
-#endif
+    mGridManager.initialize();
 
     setRenderPlatform(0);
 
-    mFrame = 0;
+    mPendingSceneFrame = 0;
 }
 
 void RendererBase::close()
@@ -113,143 +73,348 @@
 {
 }
 
-void RendererBase::resize(int width, int height)
+void RendererBase::resizeFrameBuffer(int width, int height)
 {
     mFrameBuffer->setup(width, height, FrameBufferBase::InternalFormat::RGBA32F);
     resetAccumulationBuffer();
 }
 
-void RendererBase::addGrid(std::string groupName, std::string fileName)
+SceneNode::Ptr RendererBase::ensureSceneNode(const std::string& nodeName)
 {
-    if (fileName.find("internal://", 0) != std::string::npos) {
-        groupName = "__internal";
+    if (nodeName.empty())
+        return nullptr;
+
+    SceneNode::Ptr sceneNode = nullptr;
+
+    // find existing sceneNode...
+    for (auto& it : mSceneNodes) {
+        if (it->mName == nodeName) {
+            sceneNode = it;
+        }
     }
 
-    if (groupName == "__internal") {
-        auto internalGridName = fileName;
-        if (fileName.find("internal://", 0) != std::string::npos) {
-            internalGridName = fileName.substr(11);
-        }
-        addGrid(groupName, groupName, internalGridName);
-    } else if (fileName.substr(fileName.find_last_of(".") + 1) == "vdb") {
-#if defined(NANOVDB_USE_OPENVDB)
-        openvdb::io::File file(fileName);
-        file.open(true);
-        auto grids = file.getGrids();
-        for (auto& grid : *grids) {
-            addGrid(groupName, fileName, grid->getName());
-        }
-#else
-        throw std::runtime_error("OpenVDB is not supported in this build. Please recompile with OpenVDB support.");
-#endif
-    } else {
-        // load all the grids in the file...
-        auto list = nanovdb::io::readGridMetaData(fileName);
-        for (auto& m : list)
-            addGrid(groupName, fileName, m.gridName);
+    if (!sceneNode) {
+        logInfo("Creating sceneNode[" + nodeName + "]");
+
+        sceneNode = std::make_shared<SceneNode>();
+        sceneNode->mMaterialClass = mParams.mMaterialOverride;
+        sceneNode->mName = nodeName;
+        sceneNode->mIndex = mSceneNodes.size();
+        sceneNode->mMaterialParameters = makeMaterialParameters();
+        mSceneNodes.push_back(sceneNode);
+
+        // we currently only support 2 grid attachments.
+        // if more are needed, then add them here.
+        static constexpr int kMaxAttachments = 2;
+
+        for (int i = 0; i < kMaxAttachments; ++i) {
+            auto attachment = std::make_shared<SceneNodeGridAttachment>();
+            attachment->mStatus = GridManager::AssetGridStatus::kUnknown;
+            attachment->mIndex = i;
+            sceneNode->mAttachments.push_back(attachment);
+        }
     }
+
+    // if no nodes are selected, then select this.
+    // this will make the viewer to show the first created node by default.
+    if (mSelectedSceneNodeIndex < 0)
+        mSelectedSceneNodeIndex = mSceneNodes.size() - 1;
+
+    return sceneNode;
 }
 
-void RendererBase::addGrid(std::string groupName, std::string fileName, std::string gridName)
+SceneNode::Ptr RendererBase::findNode(const std::string& name)
 {
-    // check it is not already resident!
-    std::shared_ptr<GridGroup> group = nullptr;
-    for (auto& it : mGridGroups) {
-        if (it->mName == groupName) {
-            group = it;
+    for (int i = 0; i < mSceneNodes.size(); ++i) {
+        if (mSceneNodes[i]->mName == name) {
+            return mSceneNodes[i];
         }
     }
+    return nullptr;
+}
 
-    if (!group) {
-        group = std::make_shared<GridGroup>();
-        group->mRenderMethod = RenderMethod::AUTO;
-        group->mName = groupName;
-        mGridGroups.push_back(group);
-        //std::cout << "Creating group[" << groupName << "]" << std::endl;
+std::string RendererBase::nextUniqueNodeId(const std::string& name)
+{
+    // find name in the scene graph
+    int  index = 0;
+    auto prefix = name;
+    if (prefix.empty())
+        prefix = "node";
+    std::ostringstream ss(prefix);
+    while (findNode(ss.str())) {
+        // add index to name...
+        ss.str("");
+        ss.clear();
+        ss << prefix << index++;
+    }
+    return ss.str();
+}
 
-    } else {
-        for (auto& it : group->mInstances) {
-            if (it->mFileName == fileName && it->mGridName == gridName) {
-                throw std::runtime_error("Grid already loaded.");
-            }
+GridManager::AssetGridStatus RendererBase::updateAttachmentState(const std::string& url, const GridManager::AssetStatusInfoType& residentAssetMap, SceneNode::Ptr sceneNode, SceneNodeGridAttachment::Ptr attachment)
+{
+    bool isBlocking = false;
+
+    auto assetUrl = attachment->mAssetUrl;
+    if (!assetUrl)
+        return GridManager::AssetGridStatus::kUnknown;
+
+    auto assetIt = residentAssetMap.find(url);
+    if (assetIt == residentAssetMap.end()) {
+        return GridManager::AssetGridStatus::kUnknown;
+    }
+
+    // if we got this far then the asset exists.
+    // we need to check the asset contains the grid-asset...
+
+    auto assetInfo = assetIt->second;
+    if (assetInfo.first) {
+        // the asset had an error.
+        return GridManager::AssetGridStatus::kError;
+    }
+
+    auto gridName = assetUrl.gridName();
+    if (gridName.empty() && assetInfo.second.size() > 0)
+        gridName = assetInfo.second.begin()->first;
+
+    // if sceneNode gridname is specified, then find status of this asset & grid...
+    GridManager::AssetGridStatus gridStatus = GridManager::AssetGridStatus::kUnknown;
+
+    auto git = assetInfo.second.find(gridName);
+    if (git != assetInfo.second.end())
+        gridStatus = git->second;
+
+    return gridStatus;
+}
+
+bool RendererBase::updateNodeAttachmentRequests(SceneNode::Ptr node, bool isSyncing, bool isPrinting, bool* isSelectedNodePending)
+{
+    if (!node)
+        return false;
+
+    // collect the latest resident assets and grids.
+    auto residentAssetMap = mGridManager.getGridNameStatusInfo();
+
+    bool hasErrors = false;
+
+    // build request-list for selected nodes' attachments...
+    std::vector<std::tuple<std::string, std::string>> urlRequests;
+
+    for (auto& attachment : node->mAttachments) {
+        auto assetUrl = attachment->mAssetUrl;
+        if (!assetUrl)
+            continue;
+
+        auto url = attachment->mAssetUrl.updateUrlWithFrame(mPendingSceneFrame);
+        auto gridAssetStatus = updateAttachmentState(url, residentAssetMap, node, attachment);
+        updateAttachment(node, attachment.get(), url, assetUrl.gridName(), gridAssetStatus);
+
+        // we ignore any assets that have errored or loaded, so we don't keep trying every frame.
+        // NOTE: to reload an asset which has errored, we must remove the asset from the gridmanager.
+        if (gridAssetStatus == GridManager::AssetGridStatus::kUnknown) {
+            urlRequests.push_back({url, assetUrl.gridName()});
         }
+
+        hasErrors |= (gridAssetStatus == GridManager::AssetGridStatus::kError);
     }
 
-    nanovdb::GridHandle<> gridHdl;
+    if (isSelectedNodePending && urlRequests.size())
+        *isSelectedNodePending = true;
 
-    if (groupName == "__internal") {
-        auto internalName = gridName;
-        gridHdl = createInternalGrid(internalName);
-    } else if (fileName.substr(fileName.find_last_of(".") + 1) == "vdb") {
-#if defined(NANOVDB_USE_OPENVDB)
-        openvdb::io::File file(fileName);
-        file.open(false); //disable delayed loading
-        auto grid = file.readGrid(gridName);
-        std::cout << "Importing OpenVDB grid[" << grid->getName() << "]...\n";
-        gridHdl = nanovdb::openToNanoVDB(grid);
-#endif
-    } else {
-        std::cout << "Importing NanoVDB grid[" << gridName << "]...\n";
-        if (gridName.length() > 0)
-            gridHdl = nanovdb::io::readGrid<>(fileName, gridName);
-        else
-            gridHdl = nanovdb::io::readGrid<>(fileName);
+    // submit selected nodes' attachment requests...
+    for (auto& request : urlRequests) {
+        mGridManager.addGrid(std::get<0>(request), std::get<1>(request));
+    }
+
+    if (isSyncing) {
+        do {
+            updateEventLog(isPrinting);
+
+            // we collect the latest resident assets and grids.
+            auto residentAssetMap = mGridManager.getGridNameStatusInfo();
+
+            // for each node, update the attachments...
+            for (auto& attachment : node->mAttachments) {
+                auto assetUrl = attachment->mAssetUrl;
+                if (!assetUrl)
+                    continue;
+
+                auto url = assetUrl.updateUrlWithFrame(mPendingSceneFrame);
+                auto gridAssetStatus = updateAttachmentState(url, residentAssetMap, node, attachment);
+                hasErrors |= (gridAssetStatus == GridManager::AssetGridStatus::kError);
+
+                updateAttachment(node, attachment.get(), url, assetUrl.gridName(), gridAssetStatus);
+            }
+
+        } while (isSyncing && mGridManager.poll()); // optionally loop while any asset requests are in flight...
     }
 
-    if (!gridHdl) {
-        std::stringstream ss;
-        ss << "Unable to read " << gridName << " from " << fileName;
-        throw std::runtime_error(ss.str());
+    updateEventLog(isPrinting);
+
+    return !hasErrors;
+}
+
+void RendererBase::updateAttachment(SceneNode::Ptr sceneNode, SceneNodeGridAttachment* attachment, const std::string& frameUrl, const std::string& gridName, GridManager::AssetGridStatus gridStatus)
+{
+    attachment->mStatus = gridStatus;
+
+    // update given the asset's status...
+
+    auto gridHdlPtr = std::get<1>(mGridManager.getGrid(frameUrl, gridName));
+    if (!gridHdlPtr || gridStatus != GridManager::AssetGridStatus::kLoaded) {
+        return;
     }
 
-    auto* meta = gridHdl.gridMetaData();
+    // the first time we find a loaded grid instance, we perform setup...
+    if (attachment->mFrameUrl != frameUrl) {
+        // the grid is now ready...
+        // each new frame of this grid may require setup if it has changed.
 
-    auto gridInstance = std::make_shared<GridInstance>();
+        resetAccumulationBuffer();
+        /*
+        std::ostringstream ss;
+        ss << "sceneNode[" << sceneNode->mName << "].attachment[" << frameUrl << "#" << gridName << "] is now ready.";
+        logDebug(ss.str());
+*/
+        attachment->mFrameUrl = frameUrl;
 
-    // update the grid instance's attribute map...
-    if (gridHdl.gridMetaData()->isPointData()) {
-        auto grid = gridHdl.grid<uint32_t>();
-        assert(grid);
+        auto& gridHdl = *gridHdlPtr;
+        auto* meta = gridHdl.gridMetaData();
 
-        char** names;
-        int    n = grid->blindDataCount();
-        names = new char*[n];
+        // update the grid instance's attribute map...
+        if (gridHdl.gridMetaData()->isPointData()) {
+            auto grid = gridHdl.grid<uint32_t>();
+            assert(grid);
+
+            char** names;
+            int    n = grid->blindDataCount();
+            names = new char*[n];
+
+            // set defaults...
+            for (int i = 0; i < (int)nanovdb::GridBlindDataSemantic::End; ++i) {
+                attachment->attributeSemanticMap[i].attribute = -1;
+                attachment->attributeSemanticMap[i].gain = 1.0f;
+                attachment->attributeSemanticMap[i].offset = 0.0f;
+            }
+            attachment->attributeSemanticMap[(int)nanovdb::GridBlindDataSemantic::PointRadius].offset = 0.5f;
 
-        // set defaults...
-        for (int i = 0; i < (int)nanovdb::GridBlindDataSemantic::End; ++i) {
-            gridInstance->attributeSemanticMap[i].attribute = -1;
-            gridInstance->attributeSemanticMap[i].gain = 1.0f;
-            gridInstance->attributeSemanticMap[i].offset = 0.0f;
+            for (int i = 0; i < n; ++i) {
+                auto meta = grid->blindMetaData(i);
+                attachment->attributeSemanticMap[(int)meta.mSemantic].attribute = i;
+                attachment->attributeSemanticMap[(int)meta.mSemantic].gain = 1.0f;
+                attachment->attributeSemanticMap[(int)meta.mSemantic].offset = 0.0f;
+            }
         }
-        gridInstance->attributeSemanticMap[(int)nanovdb::GridBlindDataSemantic::PointRadius].offset = 0.5f;
 
-        for (int i = 0; i < n; ++i) {
-            auto meta = grid->blindMetaData(i);
-            gridInstance->attributeSemanticMap[(int)meta.mSemantic].attribute = i;
-            gridInstance->attributeSemanticMap[(int)meta.mSemantic].gain = 1.0f;
-            gridInstance->attributeSemanticMap[(int)meta.mSemantic].offset = 0.0f;
+        attachment->mGridClassOverride = meta->gridClass();
+
+        // this modifies the sceneNode's bounds.
+
+        if (sceneNode->mBounds.empty()) {
+            //std::cout << "initializing sceneNode bounds...\n";
+            if (meta->activeVoxelCount() > 0) {
+                sceneNode->mBounds = meta->worldBBox();
+            }
+        } else {
+            //std::cout << "expanding sceneNode bounds...\n";
+            if (meta->activeVoxelCount() > 0) {
+                sceneNode->mBounds.expand(meta->worldBBox().max());
+                sceneNode->mBounds.expand(meta->worldBBox().min());
+            }
         }
     }
+}
 
-    gridInstance->mGridHandle = std::move(gridHdl);
-    gridInstance->mFileName = fileName.substr(fileName.find_last_of('/') + 1).substr(fileName.find_last_of('\\') + 1);
-    gridInstance->mFilePath = fileName;
-    gridInstance->mGridName = meta->gridName();
-    gridInstance->mGridClassOverride = meta->gridClass();
+void RendererBase::updateEventLog(bool isPrinting)
+{
+    std::vector<GridManager::EventMessage> eventMessages;
+    mLastEventIndex += mGridManager.getEventMessages(eventMessages, mLastEventIndex);
+    for (int i = 0; i < eventMessages.size(); ++i) {
+        if (isPrinting) {
+            const auto& e = eventMessages[i];
+            if (e.mType == GridManager::EventMessage::Type::kError)
+                std::cout << "[ERR]: ";
+            else if (e.mType == GridManager::EventMessage::Type::kDebug)
+                std::cout << "[DBG]: ";
+            else if (e.mType == GridManager::EventMessage::Type::kWarning)
+                std::cout << "[WRN]: ";
+            else if (e.mType == GridManager::EventMessage::Type::kInfo)
+                std::cout << "[INF]: ";
+            std::cout << e.mMessage << std::endl;
+        }
 
-    if (meta->activeVoxelCount() > 0) {
-        group->mBounds.expand(meta->worldBBox().max());
-        group->mBounds.expand(meta->worldBBox().min());
+        mEventMessages.emplace_back(std::move(eventMessages[i]));
     }
+}
 
-    group->mCurrentGridIndex = int(group->mInstances.size());
+std::string RendererBase::updateFilePathWithFrame(const std::string& url, int frame) const
+{
+    if (url.find('%') != std::string::npos) {
+        std::string tmp = url;
+        char        fileNameBuf[FILENAME_MAX];
+        while (1) {
+            auto pos = tmp.find_last_of('%');
+            if (pos == std::string::npos)
+                break;
+            auto segment = tmp.substr(pos);
+            sprintf(fileNameBuf, segment.c_str(), frame);
+            segment.assign(fileNameBuf);
+            tmp = tmp.substr(0, pos) + segment;
+        }
+        return tmp;
+    }
+    return url;
+}
 
-    group->mInstances.emplace_back(gridInstance);
+void RendererBase::logDebug(const std::string& msg)
+{
+    mGridManager.addEventMessage(GridManager::EventMessage{GridManager::EventMessage::Type::kDebug, msg});
+    updateEventLog(true);
+}
 
-    //std::cout << "Added instance[" << fileName << "] to group[" << group->mName << "]" << std::endl;
+void RendererBase::logError(const std::string& msg)
+{
+    mGridManager.addEventMessage(GridManager::EventMessage{GridManager::EventMessage::Type::kError, msg});
+    updateEventLog(true);
+}
 
-    setGridIndex(int(mGridGroups.size()) - 1, int(group->mInstances.size()) - 1);
-    resetCamera();
+void RendererBase::logInfo(const std::string& msg)
+{
+    mGridManager.addEventMessage(GridManager::EventMessage{GridManager::EventMessage::Type::kInfo, msg});
+    updateEventLog(true);
+}
+
+std::string RendererBase::addSceneNode(const std::string& nodeName)
+{
+    auto newName = nextUniqueNodeId(nodeName);
+    ensureSceneNode(newName);
+    return newName;
+}
+
+void RendererBase::setSceneNodeGridAttachment(const std::string& nodeName, int attachmentIndex, const GridAssetUrl& url)
+{
+    auto node = ensureSceneNode(nodeName);
+    if (node) {
+        logInfo(nodeName + " attaching grid: " + url.fullname());
+        if (node->mAttachments[attachmentIndex]->mAssetUrl != url) {
+            node->mAttachments[attachmentIndex]->mAssetUrl = url;
+            node->mAttachments[attachmentIndex]->mStatus = GridManager::AssetGridStatus::kUnknown;
+            node->mAttachments[attachmentIndex]->mFrameUrl = "";
+            node->mAttachments[attachmentIndex]->mGridClassOverride = nanovdb::GridClass::Unknown;
+            // clear the bounds
+            node->mBounds = nanovdb::BBoxR();
+        }
+    }
+}
+
+void RendererBase::addGridAsset(const GridAssetUrl& url)
+{
+    if (url.isSequence()) {
+        // request the pending frame.
+        auto frameUrl = url.updateUrlWithFrame(mPendingSceneFrame);
+        mGridManager.addGrid(frameUrl, url.gridName());
+    } else {
+        mGridManager.addGrid(url.url(), url.gridName());
+    }
 }
 
 void RendererBase::resetAccumulationBuffer()
@@ -293,101 +458,106 @@
     return true;
 }
 
-void RendererBase::render(int frame)
+bool RendererBase::render(int frame)
 {
-    if (mGridGroups.size() == 0) {
-        return;
+    if (mSceneNodes.size() == 0) {
+        return false;
     }
 
-    bool hasCameraChanged = updateCamera(frame);
+    auto sceneNode = mSceneNodes[mSelectedSceneNodeIndex];
+    assert(sceneNode->mAttachments.size() >= 0);
+
+    bool hasCameraChanged = updateCamera();
 
     if (hasCameraChanged) {
         resetAccumulationBuffer();
     }
 
-    auto        group = mGridGroups[mRenderGroupIndex];
-    auto        instance = group->mInstances[group->mCurrentGridIndex];
-    const auto& gridHdl = instance->mGridHandle;
-
-    size_t gridByteSize = gridHdl.size();
-    assert(gridByteSize);
-
-    // modify RenderConstants...
-    auto renderConstants = mParams.mOptions;
-    renderConstants.useGroundReflections = false;
+    auto attachment = sceneNode->mAttachments[0];
+
+    // modify MaterialParameters...
+    auto materialParameters = sceneNode->mMaterialParameters;
+    std::memcpy(materialParameters.attributeSemanticMap, attachment->attributeSemanticMap, sizeof(RendererAttributeParams) * size_t(nanovdb::GridBlindDataSemantic::End));
 
-    auto wBbox = group->mBounds;
-    auto wBboxSize = wBbox.max() - wBbox.min();
-    renderConstants.groundHeight = wBbox.min()[1];
-    renderConstants.groundFalloff = 1000.f * float(wBboxSize.length());
     int w = mFrameBuffer->width();
     int h = mFrameBuffer->height();
     int numAccumulations = (mParams.mUseAccumulation) ? ++mNumAccumulations : 0;
 
-    Camera<float> camera(mCurrentCameraState->eye(), mCurrentCameraState->target(), mCurrentCameraState->V(), mCurrentCameraState->mFovY, float(w) / h);
+    // build scene render parameters...
+    auto wBbox = sceneNode->mBounds;
+    if (wBbox.empty()) {
+        // an invalid bounds will cause issues, so fixup.
+        wBbox = nanovdb::BBoxR(nanovdb::Vec3R(0), nanovdb::Vec3R(1));
+    }
+    auto wBboxSize = wBbox.max() - wBbox.min();
+    auto sceneParameters = mParams.mSceneParameters;
+    sceneParameters.groundHeight = wBbox.min()[1];
+    sceneParameters.groundFalloff = 1000.f * float(wBboxSize.length());
+    sceneParameters.camera = Camera(mParams.mSceneParameters.camera.lensType(), mCurrentCameraState->eye(), mCurrentCameraState->target(), mCurrentCameraState->V(), mCurrentCameraState->mFovY, float(w) / h);
+    sceneParameters.camera.ipd() = mParams.mSceneParameters.camera.ipd();
 
     bool renderRc = false;
 
-    auto renderMethod = group->mRenderMethod;
-    if (renderMethod == RenderMethod::AUTO) {
-        if (instance->mGridClassOverride == nanovdb::GridClass::FogVolume)
-            renderMethod = RenderMethod::FOG_VOLUME;
-        else if (instance->mGridClassOverride == nanovdb::GridClass::LevelSet)
-            renderMethod = RenderMethod::LEVELSET;
-        else if (instance->mGridClassOverride == nanovdb::GridClass::PointData)
-            renderMethod = RenderMethod::POINTS;
-        else if (instance->mGridClassOverride == nanovdb::GridClass::PointIndex)
-            renderMethod = RenderMethod::POINTS;
+    // update the material type based on the grid class and preset the values.
+    auto materialClass = sceneNode->mMaterialClass;
+    if (materialClass == MaterialClass::kAuto) {
+        if (attachment->mGridClassOverride == nanovdb::GridClass::FogVolume)
+            materialClass = MaterialClass::kFogVolumePathTracer;
+        else if (attachment->mGridClassOverride == nanovdb::GridClass::LevelSet)
+            materialClass = MaterialClass::kLevelSetFast;
+        else if (attachment->mGridClassOverride == nanovdb::GridClass::PointData)
+            materialClass = MaterialClass::kPointsFast;
+        else if (attachment->mGridClassOverride == nanovdb::GridClass::PointIndex)
+            materialClass = MaterialClass::kPointsFast;
         else
-            renderMethod = RenderMethod::GRID;
+            materialClass = MaterialClass::kGrid;
+    }
+
+    // collect the grid pointers...
+    std::vector<GridRenderParameters> gridsAttachmentPtrs;
+    for (int i = 0; i < sceneNode->mAttachments.size(); ++i) {
+        auto attachment = sceneNode->mAttachments[i];
+        auto url = attachment->mAssetUrl.updateUrlWithFrame(frame);
+        auto gridName = attachment->mAssetUrl.gridName();
+        auto gridAssetData = mGridManager.getGrid(url, gridName);
+        gridsAttachmentPtrs.push_back(GridRenderParameters{std::get<0>(gridAssetData), std::get<1>(gridAssetData).get()});
     }
 
-    renderRc = mRenderLauncher.render(renderMethod, w, h, mFrameBuffer.get(), camera, gridHdl, numAccumulations, renderConstants, &mRenderStats);
+    renderRc = mRenderLauncher.render(materialClass, w, h, mFrameBuffer.get(), numAccumulations, gridsAttachmentPtrs.size(), gridsAttachmentPtrs.data(), sceneParameters, materialParameters, &mRenderStats);
+    return renderRc;
 }
 
-void RendererBase::setGridIndex(int groupIndex, int gridIndex)
+bool RendererBase::selectSceneNodeByIndex(int nodeIndex)
 {
-    if (mGridGroups.size() > 0) {
-        if (groupIndex < 0)
-            groupIndex = int(mGridGroups.size()) - 1;
-        else if (groupIndex > int(mGridGroups.size()) - 1)
-            groupIndex = 0;
-    }
+    bool hasChanged = false;
 
-    if (groupIndex < 0) {
-        mRenderGroupIndex = groupIndex;
+    if (mSceneNodes.size() == 0) {
+        mSelectedSceneNodeIndex = -1;
         resetAccumulationBuffer();
-        return;
+        return true;
     }
 
-    auto group = mGridGroups[groupIndex];
-
-    if (gridIndex < 0)
-        gridIndex = int(group->mInstances.size()) - 1;
-    else if (gridIndex > int(group->mInstances.size()) - 1)
-        gridIndex = 0;
-
-    if (group->mCurrentGridIndex == gridIndex && mRenderGroupIndex == groupIndex) {
-        // no change!
-        return;
+    // clamp sceneNode index to valid range...
+    if (mSceneNodes.size() > 0) {
+        if (nodeIndex < 0)
+            nodeIndex = int(mSceneNodes.size()) - 1;
+        else if (nodeIndex > int(mSceneNodes.size()) - 1)
+            nodeIndex = 0;
+
+        if (mSelectedSceneNodeIndex != nodeIndex) {
+            hasChanged = true;
+            mSelectedSceneNodeIndex = nodeIndex;
+        }
     }
 
-    mRenderGroupIndex = groupIndex;
-    group->mCurrentGridIndex = gridIndex;
-
-    //std::cout << "Selecting group[" << groupIndex << "].instance[" << gridIndex << "]\n";
-
-    if (gridIndex < 0)
-        return;
-
-    // update the attribute map...
-    auto instance = group->mInstances[gridIndex];
-    memcpy(mParams.mOptions.attributeSemanticMap, instance->attributeSemanticMap, sizeof(RendererAttributeParams) * size_t(nanovdb::GridBlindDataSemantic::End));
+    if (hasChanged) {
+        resetAccumulationBuffer();
+    }
 
-    resetAccumulationBuffer();
+    return hasChanged;
 }
 
-void RendererBase::removeGridIndices(std::vector<int> indices)
+void RendererBase::removeSceneNodes(std::vector<int> indices)
 {
     if (indices.size() == 0)
         return;
@@ -396,74 +566,199 @@
     std::reverse(indices.begin(), indices.end());
 
     for (int i = 0; i < indices.size(); ++i) {
-        mGridGroups.erase(mGridGroups.begin() + indices[i]);
+        mSceneNodes.erase(mSceneNodes.begin() + indices[i]);
     }
 
-    int i = mRenderGroupIndex;
-    if (i >= int(mGridGroups.size()))
-        i = int(mGridGroups.size()) - 1;
+    int i = mSelectedSceneNodeIndex;
+    if (i >= int(mSceneNodes.size()))
+        i = int(mSceneNodes.size()) - 1;
 
-    setGridIndex(i, 0);
+    selectSceneNodeByIndex(i);
 }
 
-void RendererBase::printHelp() const
+void RendererBase::printHelp(std::ostream& s) const
 {
-    std::cout << "-------------------------------------\n";
-    std::cout << "- Renderer-platform     = (" << mRenderLauncher.getNameForPlatformIndex(mParams.mRenderLauncherType) << ")\n";
-    std::cout << "- Render Group          = (" << (mRenderGroupIndex) << ")\n";
-    std::cout << "- Render Progressive    = (" << (mParams.mUseAccumulation ? "ON" : "OFF") << ")\n";
-    std::cout << "- Render Lighting       = (" << (mParams.mOptions.useLighting ? "ON" : "OFF") << ")\n";
-    std::cout << "- Render Shadows        = (" << (mParams.mOptions.useShadows ? "ON" : "mFrameBufferOFF") << ")\n";
-    std::cout << "- Render Ground-plane   = (" << (mParams.mOptions.useGround ? "ON" : "OFF") << ")\n";
-    std::cout << "- Render Occlusion      = (" << (mParams.mOptions.useOcclusion ? "ON" : "OFF") << ")\n";
-    std::cout << "-------------------------------------\n";
-    std::cout << "\n";
+    s << "-------------------------------------\n";
+    s << "- Renderer-platform     = (" << mRenderLauncher.getNameForPlatformIndex(mParams.mRenderLauncherType) << ")\n";
+    s << "- Render Group          = (" << (mSelectedSceneNodeIndex) << ")\n";
+    s << "- Render Progressive    = (" << (mParams.mUseAccumulation ? "ON" : "OFF") << ")\n";
+    s << "-------------------------------------\n";
+    s << "\n";
 }
 
 void RendererBase::resetCamera()
 {
-    if (mRenderGroupIndex < 0) {
-        return;
-    }
+    nanovdb::BBox<nanovdb::Vec3R> bbox(nanovdb::Vec3R(-100), nanovdb::Vec3R(100));
 
-    // calculate camera target and distance.
+    if (mSelectedSceneNodeIndex >= 0) {
+        if (!mSceneNodes[mSelectedSceneNodeIndex]->mBounds.empty()) {
+            bbox = mSceneNodes[mSelectedSceneNodeIndex]->mBounds;
+        }
+    }
 
-    auto bbox = mGridGroups[mRenderGroupIndex]->mBounds;
+    // calculate camera target and distance...
+    auto  bboxSize = (bbox.max() - bbox.min());
+    float halfWidth = 0.5f * nanovdb::Max(1.0f, float(bboxSize.length()));
+
+    if (mParams.mSceneParameters.camera.lensType() == Camera::LensType::kSpherical ||
+        mParams.mSceneParameters.camera.lensType() == Camera::LensType::kODS) {
+        mCurrentCameraState->mCameraLookAt = nanovdb::Vec3f(bbox.min() + bboxSize * 0.5);
+        mCurrentCameraState->mCameraDistance = halfWidth;
+        mCurrentCameraState->mCameraRotation = nanovdb::Vec3f(0, 0, 0);
+        mCurrentCameraState->mCameraLookAt[1] = 0;
+    } else {
+        mCurrentCameraState->mCameraLookAt = nanovdb::Vec3f(bbox.min() + bboxSize * 0.5);
+        mCurrentCameraState->mCameraDistance = halfWidth / tanf(mCurrentCameraState->mFovY * 0.5f * (3.142f / 180.f));
+        mCurrentCameraState->mCameraRotation = nanovdb::Vec3f(M_PI / 8, (M_PI) / 4, 0);
+    }
 
-    auto bboxSize = (bbox.max() - bbox.min());
-    mCurrentCameraState->mCameraDistance = nanovdb::Max(1.0f, float(bboxSize.length()) * 30.f);
-    mCurrentCameraState->mCameraLookAt = nanovdb::Vec3f(bbox.min() + bboxSize * 0.5);
-    mCurrentCameraState->mCameraRotation = nanovdb::Vec3f(M_PI / 8, (M_PI) / 4, 0);
     mCurrentCameraState->mIsViewChanged = true;
     mCurrentCameraState->update();
 }
 
-bool RendererBase::updateCamera(int frame)
+void RendererBase::setSceneFrame(int frame)
 {
-    if (mParams.mUseTurntable) {
-        int count = (mParams.mFrameCount == 0) ? 1 : mParams.mFrameCount;
-        mCurrentCameraState->mCameraRotation[1] = (frame * 2.0f * M_PI) / count;
+    // wrap requested frame into valid range...
+    int frameCount = (mParams.mFrameEnd - mParams.mFrameStart + 1);
+    if (frame > mParams.mFrameEnd) {
+        if (mParams.mFrameLoop) {
+            frame -= mParams.mFrameStart;
+            frame = frame % frameCount;
+            frame += mParams.mFrameStart;
+        } else
+            frame = mParams.mFrameEnd;
+    } else if (frame < mParams.mFrameStart) {
+        if (mParams.mFrameLoop) {
+            frame -= mParams.mFrameStart;
+            frame = (frame % frameCount + frameCount) % frameCount;
+            frame += mParams.mFrameStart;
+        } else
+            frame = mParams.mFrameStart;
+    }
+
+    mPendingSceneFrame = frame;
+    mLastSceneFrame = mPendingSceneFrame - 1;
+}
+
+int RendererBase::getSceneFrame() const
+{
+    return mLastSceneFrame;
+}
+
+bool RendererBase::updateScene()
+{
+    if (mPendingSceneFrame == mLastSceneFrame)
+        return false;
+    mLastSceneFrame = mPendingSceneFrame;
+    return true;
+}
+
+void RendererBase::renderSequence()
+{
+    if (mSelectedSceneNodeIndex < 0)
+        return;
+
+    auto oldFrame = getSceneFrame();
+
+    bool isSingleFrame = (mParams.mFrameEnd <= mParams.mFrameStart);
+
+    std::stringstream ss;
+    if (isSingleFrame) {
+        ss << "Rendering frame " << mParams.mFrameStart;
+    } else {
+        ss << "Rendering frames " << mParams.mFrameStart << " - " << mParams.mFrameEnd;
+    }
+    if (mParams.mOutputFilePath.length()) {
+        ss << " to " << mParams.mOutputFilePath;
+        if (mParams.mOutputExtension.length()) {
+            ss << " as " << mParams.mOutputExtension;
+        }
+    }
+    logInfo(ss.str());
+
+    bool hasError = false;
+
+    for (int frame = mParams.mFrameStart; frame <= mParams.mFrameEnd; ++frame) {
+        setSceneFrame(frame);
+
+        // sync the grid manager.
+        bool areAttachmentsReady = updateNodeAttachmentRequests(mSceneNodes[mSelectedSceneNodeIndex], true, mIsDumpingLog);
+        if (areAttachmentsReady == false) {
+            hasError = true;
+            logError("Unable to render frame " + ss.str() + "; bad asset");
+            break;
+        }
+
+        updateScene();
+
+        for (int i = (mParams.mUseAccumulation) ? mParams.mMaxProgressiveSamples : 1; i > 0; --i) {
+            render(frame);
+        }
+
+        if (mParams.mOutputFilePath.empty() == false) {
+            hasError = (saveFrameBuffer(frame) == false);
+            if (hasError) {
+                break;
+            }
+        }
+    }
+
+    if (hasError == false) {
+        logInfo("Rendering complete.");
+    } else {
+        logError("Rendering failed.");
+    }
+
+    setSceneFrame(oldFrame);
+}
+
+bool RendererBase::updateCamera()
+{
+    int  sceneFrame = getSceneFrame();
+    bool isChanged = false;
+
+    if (mCurrentCameraState->mFrame != sceneFrame) {
+        isChanged = true;
+        mCurrentCameraState->mFrame = sceneFrame;
+    }
+
+    if (mParams.mUseTurntable && isChanged) {
+        int count = (mParams.mFrameEnd - mParams.mFrameStart + 1);
+        mCurrentCameraState->mCameraRotation[1] = ((float(sceneFrame) * 2.0f * float(M_PI)) / count) / std::max(mParams.mTurntableRate, 1.0f);
         mCurrentCameraState->mIsViewChanged = true;
     }
-    return mCurrentCameraState->update();
+
+    isChanged |= mCurrentCameraState->update();
+    return isChanged;
 }
 
-bool RendererBase::saveFrameBuffer(bool useFrame, int frame)
+bool RendererBase::saveFrameBuffer(int frame)
 {
     assert(mFrameBuffer);
 
-    if (mParams.mOutputPrefix.empty()) {
-        //std::cerr << "Output prefix must be specified on command-line to take screenshots." << std::endl;
+    if (mParams.mOutputFilePath.empty()) {
+        logError("Output filename must be specified for framebuffer export.");
         return false;
     }
 
-    std::stringstream ss;
-    if (useFrame) {
-        ss << mParams.mOutputPrefix << '.' << std::setfill('0') << std::setw(4) << frame << std::setfill('\0') << ".pfm";
-    } else {
-        ss << mParams.mOutputPrefix << ".pfm";
+    auto ext = mParams.mOutputExtension;
+    if (ext.empty()) {
+        ext = urlGetPathExtension(mParams.mOutputFilePath);
+    }
+
+    if (ext.empty()) {
+        logError("File format can not be determined from output filename, \"" + mParams.mOutputFilePath + "\"");
+        return false;
     }
-    return mFrameBuffer->save(ss.str().c_str());
+
+    auto filename = updateFilePathWithFrame(mParams.mOutputFilePath, frame);
+    logDebug("Exporting framebuffer to " + filename);
+
+    if (mFrameBuffer->save(filename.c_str(), ext.c_str(), 80) == false) {
+        logError("Unable to export framebuffer to filename \"" + filename + "\" as \"" + ext + "\"");
+        return false;
+    }
+    return true;
 }
 
 float RendererBase::computePSNR(FrameBufferBase& other)
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/Renderer.h nanovdb-20201022/nanovdb/cmd/viewer/Renderer.h
--- nanovdb-20200925/nanovdb/cmd/viewer/Renderer.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/Renderer.h	2020-10-22 03:52:50.000000000 +0200
@@ -15,10 +15,40 @@
 
 #include <string>
 #include <vector>
+#include <queue>
+#include <mutex>
 
+#include "GridAssetUrl.h"
 #include "FrameBuffer.h"
 #include <nanovdb/util/GridHandle.h>
 #include "RenderLauncher.h"
+#include "GridManager.h"
+
+// struct representing a scene graph node's grid attachment.
+struct SceneNodeGridAttachment
+{
+    using Ptr = std::shared_ptr<SceneNodeGridAttachment>;
+
+    int                          mIndex;
+    GridManager::AssetGridStatus mStatus;
+    std::string                  mFrameUrl;
+    GridAssetUrl                 mAssetUrl;
+    nanovdb::GridClass           mGridClassOverride;
+    RendererAttributeParams      attributeSemanticMap[(int)nanovdb::GridBlindDataSemantic::End];
+};
+
+// struct representing a scene graph node.
+struct SceneNode
+{
+    using Ptr = std::shared_ptr<SceneNode>;
+
+    int                                       mIndex;
+    std::string                               mName;
+    std::vector<SceneNodeGridAttachment::Ptr> mAttachments;
+    nanovdb::BBox<nanovdb::Vec3d>             mBounds;
+    MaterialClass                             mMaterialClass = MaterialClass::kAuto;
+    MaterialParameters                        mMaterialParameters;
+};
 
 inline std::string getStringForBlindDataSemantic(nanovdb::GridBlindDataSemantic semantic)
 {
@@ -38,16 +68,22 @@
 {
     RendererParams();
 
-    int         mWidth = 512;
-    int         mHeight = 512;
-    std::string mOutputPrefix;
-    std::string mGoldPrefix;
-    bool        mUseTurntable = false;
-    bool        mUseAccumulation = true;
-    int         mRenderLauncherType = 0;
-    //RenderMethod    mRenderMethod = RenderMethod::AUTO;
-    int             mFrameCount = 0;
-    RenderConstants mOptions;
+    int                   mWidth = 512;
+    int                   mHeight = 512;
+    std::string           mOutputFilePath;
+    std::string           mOutputExtension;
+    int                   mOutputPadding = 4;
+    std::string           mGoldPrefix;
+    bool                  mUseTurntable = false;
+    float                 mTurntableRate = 1;
+    MaterialClass         mMaterialOverride = MaterialClass::kAuto;
+    bool                  mUseAccumulation = true;
+    int                   mRenderLauncherType = 0;
+    int                   mFrameStart = 0;
+    int                   mFrameEnd = 99;
+    bool                  mFrameLoop = true;
+    int                   mMaxProgressiveSamples = 1;
+    SceneRenderParameters mSceneParameters;
 };
 
 class RendererBase
@@ -60,33 +96,59 @@
 
     virtual void   open() = 0;
     virtual void   close();
-    virtual void   render(int frame);
-    virtual void   resize(int width, int height);
+    virtual bool   render(int frame);
+    virtual void   resizeFrameBuffer(int width, int height);
     virtual void   renderViewOverlay();
     virtual double getTime();
-    virtual bool   updateCamera(int frame);
-    virtual void   printHelp() const;
+    bool           updateScene();
+    void           setSceneFrame(int frame);
+    int            getSceneFrame() const;
+    virtual bool   updateCamera();
+    virtual void   printHelp(std::ostream& s) const;
+    void           renderSequence();
+    bool           updateNodeAttachmentRequests(SceneNode::Ptr node, bool isSyncing, bool isPrinting, bool* isSelectedNodePending = nullptr);
+
+    std::string    addSceneNode(const std::string& nodeName = "");
+    void           setSceneNodeGridAttachment(const std::string& nodeName, int attachmentIndex, const GridAssetUrl& url);
+    void           addGridAsset(const GridAssetUrl& url);
+    std::string    updateFilePathWithFrame(const std::string& filePath, int frame) const;
+    SceneNode::Ptr findNode(const std::string& name);
+
+    GridManager::AssetGridStatus updateAttachmentState(const std::string& url, const GridManager::AssetStatusInfoType& residentAssetMap, SceneNode::Ptr node, SceneNodeGridAttachment::Ptr attachment);
+
+    std::string nextUniqueNodeId(const std::string& prefix = "");
+
+    void logError(const std::string& msg);
+    void logInfo(const std::string& msg);
+    void logDebug(const std::string& msg);
 
     void  resetAccumulationBuffer();
-    void  addGrid(std::string groupName, std::string fileName);
-    void  addGrid(std::string groupName, std::string fileName, std::string gridName);
     bool  setRenderPlatformByName(std::string name);
-    bool  saveFrameBuffer(bool useFrame, int frame = 0);
+    bool  saveFrameBuffer(int frame = 0);
     float computePSNR(FrameBufferBase& other);
 
-protected:
-    void setRenderPlatform(int platform);
-    void setGridIndex(int groupIndex, int gridIndex);
-    void removeGridIndices(std::vector<int> indices);
     void resetCamera();
+    bool selectSceneNodeByIndex(int nodeIndex);
 
+protected:
+    void setRenderPlatform(int platform);
+    
+    void removeSceneNodes(std::vector<int> indices);    
+    void updateEventLog(bool isPrinting = false);
+
+    GridManager                            mGridManager;
+    bool                                   mIsDumpingLog = true;
+    int                                    mLastEventIndex = 0;
+    std::vector<GridManager::EventMessage> mEventMessages;
     std::unique_ptr<class FrameBufferBase> mFrameBuffer;
     int                                    mNumAccumulations = 0;
     RenderLauncher                         mRenderLauncher;
     RendererParams                         mParams;
-    int                                    mRenderGroupIndex = -1;
-    int                                    mFrame = 0;
+    int                                    mSelectedSceneNodeIndex = -1;
+    int                                    mPendingSceneFrame = 0;
+    int                                    mLastSceneFrame = 0;
     RenderStatistics                       mRenderStats;
+    uint32_t                               mNextUniqueId = 0;
 
     class CameraState
     {
@@ -95,7 +157,8 @@
         float          mCameraDistance = 1000.0f;
         nanovdb::Vec3f mCameraLookAt = nanovdb::Vec3f(0);
         nanovdb::Vec3f mCameraRotation = nanovdb::Vec3f(0, 3.142f / 2, 0);
-        float          mFovY = 90.0f * 3.142f / 180.f;
+        float          mFovY = 60.0f;
+        float          mFrame = 0;
 
         nanovdb::Vec3f U() const { return mCameraAxis[0]; }
         nanovdb::Vec3f V() const { return mCameraAxis[1]; }
@@ -106,30 +169,14 @@
         bool update();
 
     private:
-        nanovdb::Vec3f mCameraPosition;
-        nanovdb::Vec3f mCameraAxis[3];
-    };
-
-    struct GridInstance
-    {
-        nanovdb::GridHandle<> mGridHandle;
-        std::string           mFileName;
-        std::string           mFilePath;
-        std::string           mGridName;
-        nanovdb::GridClass    mGridClassOverride;
-        RendererAttributeParams attributeSemanticMap[(int)nanovdb::GridBlindDataSemantic::End];
+        nanovdb::Vec3f mCameraPosition = nanovdb::Vec3f{0,0,0};
+        nanovdb::Vec3f mCameraAxis[3] = {{1,0,0},{0,1,0},{0,0,1}};
     };
 
-    struct GridGroup
-    {
-        std::vector<std::shared_ptr<GridInstance>> mInstances;
-        std::string                                mName;
-        int                                        mCurrentGridIndex;
-        nanovdb::BBox<nanovdb::Vec3d>              mBounds;
-        RenderMethod                               mRenderMethod;
-    };
+    SceneNode::Ptr ensureSceneNode(const std::string& nodeName);
+    void           updateAttachment(SceneNode::Ptr sceneNode, SceneNodeGridAttachment* attachment, const std::string& frameUrl, const std::string& gridName, GridManager::AssetGridStatus gridStatus);
 
-    std::vector<std::shared_ptr<GridGroup>> mGridGroups;
+    std::vector<SceneNode::Ptr> mSceneNodes;
 
     CameraState  mDefaultCameraState;
     CameraState* mCurrentCameraState = &mDefaultCameraState;
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/RenderFogVolumeUtils.h nanovdb-20201022/nanovdb/cmd/viewer/RenderFogVolumeUtils.h
--- nanovdb-20200925/nanovdb/cmd/viewer/RenderFogVolumeUtils.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/RenderFogVolumeUtils.h	2020-10-22 03:52:50.000000000 +0200
@@ -11,14 +11,15 @@
 	\brief General C++ implementation of the FogVolume rendering code.
 */
 
+#pragma once
+
 #include <nanovdb/NanoVDB.h>
 #include <nanovdb/util/HDDA.h>
 #include <nanovdb/util/Ray.h>
+#include <nanovdb/util/SampleFromVoxels.h>
 #include "RenderConstants.h"
 #include "RenderUtils.h"
 
-#define NANOVDB_VIEWER_USE_RATIO_TRACKED_TRANSMISSION
-
 namespace render {
 namespace fogvolume {
 
@@ -30,112 +31,173 @@
 
 inline __hostdev__ float valueToScalar(const nanovdb::Vec3f& v)
 {
-    return (v[0] + v[1] + v[2]) / 3.0f;
+    return luminance<float>(v);
 }
 
 inline __hostdev__ double valueToScalar(const nanovdb::Vec3d& v)
 {
-    return (v[0] + v[1] + v[2]) / 3.0;
+    return luminance<double>(v);
+}
+
+template<typename ValueT>
+inline __hostdev__ nanovdb::Vec3f colorFromTemperature(const ValueT& v, float scale)
+{
+    float r = v;
+    float g = r * r;
+    float b = g * g;
+    return scale * nanovdb::Vec3f(r * r * r, g * g * g, b * b * b);
 }
 
 struct HeterogenousMedium
 {
-    float densityFactor;
-    float densityMin;
-    float densityMax;
-    float hgMeanCosine;
+    int                       maxPathDepth;
+    float                     densityScale;
+    float                     densityMin;
+    float                     densityMax;
+    float                     hgMeanCosine;
+    float                     temperatureScale;
+    VolumeTransmittanceMethod transmittanceMethod;
+    float                     transmittanceThreshold;
+    float                     albedo;
 };
 
-template<typename RayT, typename AccT>
-inline __hostdev__ float deltaTracking(RayT& ray, AccT& acc, float densityMax, float densityFactor, uint32_t& seed)
+template<typename VecT, typename SamplerT>
+inline __hostdev__ float sampleDensity(const SamplerT& sampler, const VecT& pos, const HeterogenousMedium& medium)
 {
-    if (!ray.clip(acc.root().bbox()))
-        return -1;
-    float densityMaxInv = 1.0f / densityMax;
-    float t = ray.t0();
+    auto densityValue = sampler(pos);
+    return valueToScalar(densityValue) * medium.densityScale;
+}
+
+template<typename RayT, typename SamplerT>
+inline __hostdev__ float deltaTracking(RayT& ray, SamplerT& sampler, const HeterogenousMedium& medium, uint32_t& seed)
+{
+    const float densityMaxInv = 1.0f / medium.densityMax;
+    float       t = ray.t0();
     do {
-        t += -logf(randomf(seed++)) * densityMaxInv;
-    } while (t < ray.t1() && valueToScalar(acc.getValue(nanovdb::Coord::Floor(ray(t)))) * densityFactor * densityMaxInv < randomf(seed++));
+        t += -logf(randomXorShift(seed)) * densityMaxInv;
+    } while (t < ray.t1() && sampleDensity(sampler, ray(t), medium) * densityMaxInv < randomXorShift(seed));
     return t;
 }
 
-template<typename RayT, typename AccT>
-inline __hostdev__ float getTransmittance(RayT& ray, AccT& acc, const HeterogenousMedium& medium, uint32_t& seed)
+template<typename RayT, typename SamplerT>
+inline __hostdev__ float getTransmittanceRiemannSum(const RayT& ray, const SamplerT& sampler, const HeterogenousMedium& medium, uint32_t& seed)
 {
-    if (!ray.clip(acc.root().bbox()))
-        return 1.0f;
+    //const float& kTransmittanceThreshold = medium.transmittanceThreshold;
+    static constexpr float kTransmittanceThreshold = 0.001f;
+    static constexpr float kTransmittanceReimannSumDeltaStep = 0.5f;
+
+    float transmittance = 1.f;
+    float t = ray.t0() - randomXorShift(seed) * kTransmittanceReimannSumDeltaStep;
+    for (; t < ray.t1(); t += kTransmittanceReimannSumDeltaStep) {
+        float sigmaT = sampleDensity(sampler, ray(t), medium);
+        transmittance *= expf(-sigmaT * kTransmittanceReimannSumDeltaStep);
+        if (transmittance < kTransmittanceThreshold) {
+            return 0.f;
+        }
+    }
+    return transmittance;
+}
 
 #if 0
-    float      transmittance = 1.f;
-    nanovdb::HDDA<RayT> dda(ray, 1);
+template<typename RayT, typename SamplerT>
+inline __hostdev__ float getTransmittanceDDA(const RayT& ray, const SamplerT& sampler, const HeterogenousMedium& medium, uint32_t& seed)
+{
+    float              transmittance = 1.f;
+    nanovdb::DDA<RayT> dda(ray);
+    float              t = 0.0f;
+    auto               ijk = dda.voxel();
+    float              sigmaT = sampleDensity(sampler, ijk, medium);
     while (dda.step()) {
-        auto  densityValue = acc.getValue(dda.voxel());
-        float densityScalar = valueToScalar(densityValue) * medium.densityFactor;
-        densityScalar = nanovdb::Clamp(densityScalar, medium.densityMin, medium.densityMax); // just in case these are soft extrema
-
-        transmittance *= 1.f - densityScalar;
-
-        if (transmittance < 0.01f)
+        float dt = dda.time() - t;
+        transmittance *= expf(-sigmaT * dt);
+        t = dda.time();
+        sigmaT = sampleDensity(sampler, dda.voxel(), medium);
+        if (transmittance < medium.transmittanceThreshold) {
             return transmittance;
+        }
     }
     return transmittance;
-#elif 0
-    float       transmittance = 1.f;
-    const float dt = 0.5f;
-    for (float t = ray.t0(); t < ray.t1(); t += dt) {
-        auto  densityValue = acc.getValue(nanovdb::Coord::Floor(ray(t)));
-        float densityScalar = valueToScalar(densityValue) * medium.densityFactor;
-        densityScalar = nanovdb::Clamp(densityScalar, medium.densityMin, medium.densityMax); // just in case these are soft extrema
-
-        transmittance *= 1.f - densityScalar;
+}
 
-        if (transmittance < 0.01f)
+template<typename RayT, typename SamplerT>
+inline __hostdev__ float getTransmittanceHDDA(const RayT& ray, const SamplerT& sampler, const HeterogenousMedium& medium, uint32_t& seed)
+{
+    float               transmittance = 1.f;
+    nanovdb::HDDA<RayT> dda(ray, 1);
+    float               t = dda.time();
+    while (dda.step()) {
+        float dt = dda.time() - t;
+        t = dda.time();
+        float sigmaT = sampleDensity(sampler, dda.voxel(), medium);
+        transmittance *= expf(-sigmaT * dt);
+        if (transmittance < medium.transmittanceThreshold) {
             return transmittance;
+        }
     }
     return transmittance;
-#elif !defined(NANOVDB_VIEWER_USE_RATIO_TRACKED_TRANSMISSION)
+}
+#endif
+
+template<typename RayT, typename SamplerT>
+inline __hostdev__ float getTransmittanceDeltaTracking(const RayT& ray, const SamplerT& sampler, const HeterogenousMedium& medium, uint32_t& seed)
+{
     // delta tracking.
-    // faster due to earlier termination, but we need multiple samples
-    // to reduce variance.
+    // faster due to earlier termination, but we need multiple samples to reduce variance.
     const float densityMaxInv = 1.0f / medium.densityMax;
     const int   nSamples = 2;
     float       transmittance = 0.f;
     for (int n = 0; n < nSamples; n++) {
         float t = ray.t0();
         while (true) {
-            t -= logf(randomf(seed++)) * densityMaxInv;
-
+            t -= logf(randomXorShift(seed)) * densityMaxInv;
             if (t >= ray.t1()) {
                 transmittance += 1.0f;
                 break;
             }
-
-            auto density = acc.getValue(nanovdb::Coord::Floor(ray(t))) * medium.densityFactor;
-            density = nanovdb::Clamp(density, medium.densityMin, medium.densityMax); // just in case these are soft extrema
-
-            if (density * densityMaxInv >= randomf(seed++))
+            if (sampleDensity(sampler, ray(t), medium) * densityMaxInv >= randomXorShift(seed))
                 break;
         }
     }
     return transmittance / nSamples;
-#elif 0
+}
+
+template<typename RayT, typename SamplerT>
+inline __hostdev__ float getTransmittanceRatioTracking(const RayT& ray, const SamplerT& sampler, const HeterogenousMedium& medium, uint32_t& seed)
+{
+    //const float& kTransmittanceThreshold = medium.transmittanceThreshold;
+    static constexpr float kTransmittanceThreshold = 0.001f;
+
     // ratio tracking.
     // slower due to no early termination, but better estimation.
     float densityMaxInv = 1.0f / medium.densityMax;
     float transmittance = 1.f;
     float t = ray.t0();
     while (true) {
-        t -= logf(randomf(seed++)) * densityMaxInv;
+        t -= logf(randomLCG(seed)) * densityMaxInv;
         if (t >= ray.t1())
             break;
-        auto density = acc.getValue(nanovdb::Coord::Floor(ray(t))) * medium.densityFactor;
-        density = nanovdb::Clamp(density, medium.densityMin, medium.densityMax); // just in case these are soft extrema
-
-        transmittance *= 1.0f - density * densityMaxInv;
+        float sigmaT = sampleDensity(sampler, ray(t), medium);
+        transmittance *= 1.0f - sigmaT * densityMaxInv;
+        /*
+        // Russian roulette.
+        const float prob = 1.f - transmittance;
+        if (randomf(seed++) < prob)
+            return 0.f;
+        transmittance /= 1.f - prob;
+        */
+        if (transmittance < kTransmittanceThreshold)
+            return 0.f;
     }
     return transmittance;
-#elif 1
-        // residual ratio tracking.
+}
+
+template<typename RayT, typename SamplerT>
+inline __hostdev__ float getTransmittanceResidualRatioTracking(const RayT& ray, const SamplerT& sampler, const HeterogenousMedium& medium, uint32_t& seed)
+{
+    //const float& kTransmittanceThreshold = medium.transmittanceThreshold;
+    static constexpr float kTransmittanceThreshold = 0.001f;
+
+    // residual ratio tracking.
 #if 1
     // control is minimum.
     const float controlDensity = medium.densityMin;
@@ -153,124 +215,206 @@
     const float residualDensityMax = fmaxf(0.001f, fabsf(residualDensityMax1));
 #endif
     const float residualDensityMaxInv = 1.0f / residualDensityMax;
-    float controlTransmittance = expf(-controlDensity * (ray.t1() - ray.t0()));
-    float residualTransmittance = 1.f;
-    float t = ray.t0() - logf(randomf(seed++)) * residualDensityMaxInv;
+    float       controlTransmittance = expf(-controlDensity * (ray.t1() - ray.t0()));
+    float       residualTransmittance = 1.f;
+    float       t = ray.t0() - logf(randomXorShift(seed)) * residualDensityMaxInv;
     while (t < ray.t1()) {
-        const auto densityValue = acc.getValue(nanovdb::Coord::Floor(ray(t)));
-        float densityScalar = valueToScalar(densityValue) * medium.densityFactor;
-        densityScalar = nanovdb::Clamp(densityScalar, medium.densityMin, medium.densityMax); // just in case these are soft extrema
+        float sigmaT = sampleDensity(sampler, ray(t), medium);
 
-        auto residualDensity = densityScalar - controlDensity;
+        auto residualDensity = sigmaT - controlDensity;
         residualTransmittance *= 1.0f - residualDensity / residualDensityMax1;
-        t -= logf(randomf(seed++)) * residualDensityMaxInv;
+        t -= logf(randomXorShift(seed)) * residualDensityMaxInv;
+
+        if (residualTransmittance * controlTransmittance < kTransmittanceThreshold)
+            return 0.f;
     }
     return residualTransmittance * controlTransmittance;
-#endif // NANOVDB_VIEWER_USE_RATIO_TRACKED_TRANSMISSION
+}
+
+template<typename RayT, typename SamplerT>
+inline __hostdev__ float getTransmittance(RayT& ray, const SamplerT& sampler, const HeterogenousMedium& medium, uint32_t& seed)
+{
+    if (!ray.clip(sampler.accessor().root().bbox()))
+        return 1.0f;
+
+    switch (medium.transmittanceMethod) {
+    case VolumeTransmittanceMethod::kResidualRatioTracking: return getTransmittanceResidualRatioTracking(ray, sampler, medium, seed);
+    case VolumeTransmittanceMethod::kRatioTracking: return getTransmittanceRatioTracking(ray, sampler, medium, seed);
+    case VolumeTransmittanceMethod::kDeltaTracking: return getTransmittanceDeltaTracking(ray, sampler, medium, seed);
+    case VolumeTransmittanceMethod::kRiemannSum: return getTransmittanceRiemannSum(ray, sampler, medium, seed);
+    //case VolumeTransmittanceMethod::kHDDA: return getTransmittanceHDDA(ray, sampler, medium, seed);
+    //case VolumeTransmittanceMethod::kDDA: return getTransmittanceDDA(ray, sampler, medium, seed);
+    default: return 1.f;
+    }
 }
 
 inline __hostdev__ float henyeyGreenstein(float g, float cosTheta)
 {
-    // phase function pdf.
-#if 1
-    // isotropic.
-    return 1.0f / (3.14159265359f * 4.f);
-#else
-    float denom = 1.f + g * g - 2.f * g * cosTheta;
-    return (1.0f / (3.14159265359f * 4.f)) * (1.f - g * g) / (denom * sqrtf(denom));
-#endif
+    if (g == 0) {
+        return 1.0f / (3.14159265359f * 4.f);
+    } else {
+        float denom = nanovdb::Max(0.001f, 1.f + g * g - 2.f * g * cosTheta);
+        return (1.0f / (3.14159265359f * 4.f)) * (1.f - g * g) / (denom * sqrtf(denom));
+    }
 }
 
-inline __hostdev__ nanovdb::Vec3f sampleHG(float g, float e1, float e2)
+inline __hostdev__ nanovdb::Vec3f sampleHG(const nanovdb::Vec3f& dir, float g, float e1, float e2)
 {
-    // phase function.
-#if 1
-    // isotropic
-    const float phi = (float)(2.0f * 3.14165f) * e1;
-    const float cosTheta = 1.0f - 2.0f * e2;
-    const float sinTheta = sqrtf(1.0f - cosTheta * cosTheta);
-#else
-    const float phi = (float)(2.0f * 3.14159265359f) * e2;
-    const float s = 2.0f * e1 - 1.0f;
-    const float denom = nanovdb::Max(0.001f, (1.0f + g * s));
-    const float f = (1.0f - g * g) / denom;
-    const float cosTheta = 0.5f * (1.0f / g) * (1.0f + g * g - f * f);
-    const float sinTheta = sqrtf(1.0f - cosTheta * cosTheta);
-#endif
-    return nanovdb::Vec3f(cosf(phi) * sinTheta, sinf(phi) * sinTheta, cosTheta);
+    if (g == 0) {
+        const float phi = (float)(2.0f * 3.14165f) * e1;
+        const float cosTheta = 1.0f - 2.0f * e2;
+        const float sinTheta = sqrtf(1.0f - cosTheta * cosTheta);
+        return nanovdb::Vec3f(cosf(phi) * sinTheta, sinf(phi) * sinTheta, cosTheta);
+    } else {
+        const float phi = 2.0f * 3.14159265359f * e2;
+        const float s = 2.0f * e1 - 1.0f;
+        const float denom = nanovdb::Max(0.001f, (1.0f + g * s));
+        const float f = (1.0f - g * g) / denom;
+        const float cosTheta = 0.5f * (1.0f / g) * (1.0f + g * g - f * f);
+        const float sinTheta = nanovdb::Sqrt(1.0f - cosTheta * cosTheta);
+        const auto  phase = nanovdb::Vec3f(cosf(phi) * sinTheta, sinf(phi) * sinTheta, cosTheta);
+        // tangent frame.
+        const auto tangent = perpStark(dir);
+        const auto bitangent = dir.cross(tangent);
+        return (phase[0] * tangent + phase[1] * bitangent + phase[2] * dir).normalize();
+    }
 }
 
-template<typename Vec3T, typename AccT>
-inline __hostdev__ Vec3T estimateLight(const Vec3T& pos, const Vec3T& dir, const AccT& acc, const HeterogenousMedium& medium, uint32_t& seed, const Vec3T& lightDir)
+template<typename Vec3T, typename SamplerT>
+inline __hostdev__ Vec3T estimateLight(const Vec3T& pos, const Vec3T& dir, const SamplerT& sampler, const HeterogenousMedium& medium, uint32_t& seed, const Vec3T& lightDir)
 {
     const Vec3T lightRadiance = Vec3T(1) * 1.f;
     auto        shadowRay = nanovdb::Ray<float>(pos, lightDir);
-    auto        transmittance = getTransmittance(shadowRay, acc, medium, seed);
-    float       pdf = 1.0f;//henyeyGreenstein(medium.hgMeanCosine, dir.dot(lightDir));
+    auto        transmittance = getTransmittance(shadowRay, sampler, medium, seed);
+    float       pdf = 1.0f; //henyeyGreenstein(medium.hgMeanCosine, dir.dot(lightDir));
     return pdf * lightRadiance * transmittance;
 }
 
-template<typename RayT, typename AccT>
-inline __hostdev__ nanovdb::Vec3f traceVolume(RayT& ray, AccT& acc, const HeterogenousMedium& medium, uint32_t& seed, const nanovdb::Vec3f& lightDir)
+template<typename Vec3T, typename SamplerT>
+inline __hostdev__ Vec3T estimateBlackbodyEmission(const Vec3T& pos, const SamplerT& temperatureSampler, const HeterogenousMedium& medium, uint32_t& seed)
 {
-    using namespace nanovdb;
-    using Vec3T = typename RayT::Vec3T;
-    float throughput = 1.0f;
+    const auto value = temperatureSampler(pos);
+    return colorFromTemperature(value, medium.temperatureScale);
+}
 
-    float albedo = 0.8f;
+template<typename DensitySamplerT>
+inline __hostdev__ nanovdb::Vec3f traceFogVolume(float& throughput, bool& isFullyAbsorbed, nanovdb::Ray<float>& ray, const DensitySamplerT& densitySampler, const HeterogenousMedium& medium, uint32_t& seed, const SceneRenderParameters& sceneParams, const nanovdb::Vec3f& lightDir)
+{
+    using namespace nanovdb;
 
-    int max_interactions = 40;
-    int num_interactions = 0;
+    throughput = 1.0f;
+    isFullyAbsorbed = false;
 
-    if (!ray.clip(acc.root().bbox())) {
+    if (!ray.clip(densitySampler.accessor().root().bbox())) {
         return Vec3f(0.0f);
     }
 
-    RayT pathRay = ray;
+    // Fix the path depth for performance...
+    //const int            kMaxPathDepth = medium.maxPathDepth;
+    static constexpr int kMaxPathDepth = 4;
 
     Vec3f radiance = Vec3f(0.f);
+    auto  pathRay = ray;
+    int   numInteractions = 0;
 
-    while (true) {
-        float s = deltaTracking(pathRay, acc, medium.densityMax, medium.densityFactor, seed);
-        if (s >= pathRay.t1())
+    while (numInteractions++ < kMaxPathDepth) {
+        float s = deltaTracking(pathRay, densitySampler, medium, seed);
+        if (s >= pathRay.t1()) {
             break;
+        }
 
-        if (s < 0)
-            return Vec3f(0.0f);
+        auto pos = pathRay(s);
+
+        if (sceneParams.useLighting) {
+            radiance += throughput * estimateLight(pos, pathRay.dir(), densitySampler, medium, seed, lightDir);
+        }
+
+        throughput *= medium.albedo;
+
+        // Russian roulette absorption.
+        if (throughput < 0.2f) {
+            auto r1 = randomXorShift(seed);
+            if (r1 > throughput * 5.0f) {
+                isFullyAbsorbed = true;
+                return Vec3f(0.0f);
+            }
+            throughput = 0.2f;
+        }
 
-        if (num_interactions++ >= max_interactions)
+        // modify ray using phase function.
+        auto r2 = randomXorShift(seed);
+        auto r3 = randomXorShift(seed);
+        pathRay = Ray<float>(pos, sampleHG(pathRay.dir(), medium.hgMeanCosine, r2, r3));
+
+        if (!pathRay.clip(densitySampler.accessor().root().bbox())) {
             return Vec3f(0.0f);
+        }
+    }
+
+    return radiance;
+}
+
+template<typename DensitySamplerT, typename EmissionSamplerT>
+inline __hostdev__ nanovdb::Vec3f traceBlackbodyVolume(float& throughput, bool& isFullyAbsorbed, nanovdb::Ray<float>& ray, const DensitySamplerT& densitySampler, const EmissionSamplerT& emissionSampler, const HeterogenousMedium& medium, uint32_t& seed, const SceneRenderParameters& sceneParams, const nanovdb::Vec3f& lightDir)
+{
+    using namespace nanovdb;
+    throughput = 1.0f;
+
+    int numInteractions = 0;
+
+    if (!ray.clip(densitySampler.accessor().root().bbox())) {
+        return Vec3f(0.0f);
+    }
+
+    auto& pathRay = ray;
+
+    Vec3f radiance = Vec3f(0.f);
+    isFullyAbsorbed = false;
+
+    // Fix the path depth for performance...
+    //const int            kMaxPathDepth = medium.maxPathDepth;
+    static constexpr int kMaxPathDepth = 4;
+
+    while (numInteractions++ < kMaxPathDepth) {
+        float s = deltaTracking(pathRay, densitySampler, medium, seed);
+        if (s >= pathRay.t1()) {
+            break;
+        }
 
         auto pos = pathRay(s);
 
-        // sample key light.
-        radiance = radiance + throughput * estimateLight(pos, pathRay.dir(), acc, medium, seed, lightDir);
+        if (sceneParams.useLighting) {
+            radiance += throughput * estimateLight(pos, pathRay.dir(), densitySampler, medium, seed, lightDir);
+        }
 
-        throughput *= albedo;
+        radiance += throughput * estimateBlackbodyEmission(pos, emissionSampler, medium, seed);
+
+        throughput *= medium.albedo;
 
         // Russian roulette absorption.
         if (throughput < 0.2f) {
-            auto r1 = randomf(seed++);
-            if (r1 > throughput * 5.0f)
+            auto r1 = randomXorShift(seed);
+            if (r1 > throughput * 5.0f) {
+                isFullyAbsorbed = true;
                 return Vec3f(0.0f); // full absorbtion.
+            }
             throughput = 0.2f; // unbias.
         }
 
         // modify ray using phase function.
-        auto r2 = randomf(seed++);
-        auto r3 = randomf(seed++);
-        pathRay = RayT(pos, sampleHG(medium.hgMeanCosine, r2, r3));
+        auto r2 = randomXorShift(seed);
+        auto r3 = randomXorShift(seed);
+        pathRay = Ray<float>(pos, sampleHG(pathRay.dir(), medium.hgMeanCosine, r2, r3));
 
-        if (!pathRay.clip(acc.root().bbox()))
+        if (!pathRay.clip(densitySampler.accessor().root().bbox())) {
             return Vec3f(0.0f);
+        }
     }
-    /*
-	const float f = (0.5f + 0.5f * ray.dir()[1]) * throughput;
-	radiance = radiance + Vec3f(f);*/
 
     return radiance;
 }
 
+template<typename ValueT, int InterpolationOrder>
 struct RenderVolumeRgba32fFn
 {
     using RealT = float;
@@ -278,115 +422,269 @@
     using CoordT = nanovdb::Coord;
     using RayT = nanovdb::Ray<RealT>;
 
-    template<typename ValueT>
-    inline __hostdev__ void operator()(int ix, int iy, int width, int height, float* imgBuffer, Camera<float> camera, const nanovdb::NanoGrid<ValueT>* grid, int numAccumulations, const RenderConstants params) const
+    inline __hostdev__ void operator()(int ix, int iy, int width, int height, float* imgBuffer, int numAccumulations, const nanovdb::BBoxR proxy, const nanovdb::NanoGrid<ValueT>* densityGrid, const SceneRenderParameters sceneParams, const MaterialParameters params) const
     {
         float* outPixel = &imgBuffer[4 * (ix + width * iy)];
+        float  color[4] = {0, 0, 0, 0};
+
+        if (!densityGrid) {
+            RayT wRay = getRayFromPixelCoord(ix, iy, width, height, sceneParams);
 
-        const auto& tree = grid->tree();
+            auto envRadiance = traceEnvironment(wRay, sceneParams);
 
-        const Vec3T wLightDir = Vec3T(0, 1, 0);
-        const Vec3T iLightDir = grid->worldToIndexDirF(wLightDir).normalize();
+            color[0] = envRadiance;
+            color[1] = envRadiance;
+            color[2] = envRadiance;
+
+        } else {
+            const Vec3T wLightDir = Vec3T(0, 1, 0);
+            const Vec3T iLightDir = densityGrid->worldToIndexDirF(wLightDir).normalize();
+
+            const auto& densityTree = densityGrid->tree();
+            const auto  densityAcc = densityTree.getAccessor();
+            const auto  densitySampler = nanovdb::createSampler<InterpolationOrder, decltype(densityAcc), false>(densityAcc);
+
+            HeterogenousMedium medium;
+            medium.densityScale = params.volumeDensityScale;
+            medium.densityMin = valueToScalar(densityGrid->tree().root().valueMin()) * medium.densityScale;
+            medium.densityMax = valueToScalar(densityGrid->tree().root().valueMax()) * medium.densityScale;
+            medium.densityMax = fmaxf(medium.densityMin, fmaxf(medium.densityMax, 0.001f));
+            medium.hgMeanCosine = params.phase;
+            medium.temperatureScale = params.volumeTemperatureScale;
+            medium.transmittanceMethod = params.transmittanceMethod;
+            medium.transmittanceThreshold = params.transmittanceThreshold;
+            medium.maxPathDepth = params.maxPathDepth;
+            medium.albedo = params.volumeAlbedo;
+
+            for (int sampleIndex = 0; sampleIndex < sceneParams.samplesPerPixel; ++sampleIndex) {
+                uint32_t pixelSeed = hash((sampleIndex + (numAccumulations + 1) * sceneParams.samplesPerPixel)) ^ hash(ix, iy);
+
+                RayT wRay = getRayFromPixelCoord(ix, iy, width, height, numAccumulations, sceneParams.samplesPerPixel, pixelSeed, sceneParams);
+
+                RayT iRay = wRay.worldToIndexF(*densityGrid);
+
+                bool  isFullyAbsorbed = false;
+                float pathThroughput = 1.0f;
+                Vec3T radiance = traceFogVolume(pathThroughput, isFullyAbsorbed, iRay, densitySampler, medium, pixelSeed, sceneParams, iLightDir);
+
+                if (!isFullyAbsorbed && sceneParams.useBackground && pathThroughput > 0.0f) {
+                    float bgIntensity = 0.0f;
+                    float groundIntensity = 0.0f;
+                    float groundMix = 0.0f;
+
+                    // BUG: this causes trouble.
+                    //wRay = iRay.indexToWorldF(*densityGrid);
+
+                    if (sceneParams.useGround) {
+                        // intersect with ground plane and draw checker if camera is above...
+                        float wGroundT = (sceneParams.groundHeight - wRay.eye()[1]) / wRay.dir()[1];
+                        if (wRay.dir()[1] != 0 && wGroundT > 0.f) {
+                            Vec3T wGroundPos = wRay(wGroundT);
+                            groundIntensity = evalGroundMaterial(wGroundT, sceneParams.groundFalloff, wGroundPos, wRay.dir()[1], groundMix);
+
+                            if (sceneParams.useLighting && sceneParams.useShadows) {
+                                Vec3T iGroundPos = densityGrid->worldToIndexF(wGroundPos);
+                                RayT  iShadowRay(iGroundPos, iLightDir);
+                                float shadowTransmittance = getTransmittance(iShadowRay, densitySampler, medium, pixelSeed);
+                                groundIntensity *= shadowTransmittance;
+                            }
+                        }
+                    }
 
-        auto acc = tree.getAccessor();
+                    float skyIntensity = evalSkyMaterial(wRay.dir());
+                    bgIntensity = (1.f - groundMix) * skyIntensity + groundMix * groundIntensity;
+                    radiance += nanovdb::Vec3f(pathThroughput * bgIntensity);
+                }
 
-        HeterogenousMedium medium;
-        medium.densityFactor = params.volumeDensity;
-        medium.densityMin = valueToScalar(grid->tree().root().valueMin()) * medium.densityFactor;
-        medium.densityMax = medium.densityFactor; //grid->tree().root().valueMax() * medium.densityFactor;
-        medium.densityMax = fmaxf(medium.densityMin, fmaxf(medium.densityMax, 0.001f));
-        medium.hgMeanCosine = 0.f;
+                color[0] += radiance[0];
+                color[1] += radiance[1];
+                color[2] += radiance[2];
+            }
 
-        float color[4] = {0, 0, 0, 0};
+            for (int k = 0; k < 3; ++k)
+                color[k] = color[k] / sceneParams.samplesPerPixel;
+        }
 
-        for (int sampleIndex = 0; sampleIndex < params.samplesPerPixel; ++sampleIndex) {
-            uint32_t pixelSeed = hash((sampleIndex + (numAccumulations + 1) * params.samplesPerPixel)) ^ hash(ix, iy);
+        compositeFn(outPixel, color, numAccumulations, sceneParams);
+    }
+};
 
-            float u = ix + 0.5f;
-            float v = iy + 0.5f;
+template<typename ValueT, int InterpolationOrder>
+struct RenderBlackBodyVolumeRgba32fFn
+{
+    using RealT = float;
+    using Vec3T = nanovdb::Vec3<RealT>;
+    using CoordT = nanovdb::Coord;
+    using RayT = nanovdb::Ray<RealT>;
 
-            if (numAccumulations > 0 || params.samplesPerPixel > 0) {
-#if 1
-                float jitterX, jitterY;
-                cmj(jitterX, jitterY, (sampleIndex + (numAccumulations + 1) * params.samplesPerPixel) % 64, 8, 8, pixelSeed);
-                u += jitterX - 0.5f;
-                v += jitterY - 0.5f;
-#else
-                float randVar1 = randomf(pixelSeed + 0);
-                float randVar2 = randomf(pixelSeed + 1);
-                u += randVar1 - 0.5f;
-                v += randVar2 - 0.5f;
-#endif
-            }
+    inline __hostdev__ void operator()(int ix, int iy, int width, int height, float* imgBuffer, int numAccumulations, const nanovdb::BBoxR proxy, const nanovdb::NanoGrid<ValueT>* densityGrid, const nanovdb::NanoGrid<ValueT>* temperatureGrid, const SceneRenderParameters sceneParams, const MaterialParameters params) const
+    {
+        float* outPixel = &imgBuffer[4 * (ix + width * iy)];
+        float  color[4] = {0, 0, 0, 0};
+
+        if (!densityGrid || !temperatureGrid) {
+            RayT wRay = getRayFromPixelCoord(ix, iy, width, height, sceneParams);
 
-            u /= width;
-            v /= height;
+            auto envRadiance = traceEnvironment(wRay, sceneParams);
+
+            color[0] = envRadiance;
+            color[1] = envRadiance;
+            color[2] = envRadiance;
+
+        } else {
+            const auto& densityTree = densityGrid->tree();
+            const auto& temperatureTree = temperatureGrid->tree();
+            const auto  densityAcc = densityTree.getAccessor();
+            const auto  temperatureAcc = temperatureTree.getAccessor();
+            const auto  densitySampler = nanovdb::createSampler<InterpolationOrder, decltype(densityAcc), false>(densityAcc);
+            const auto  temperatureSampler = nanovdb::createSampler<InterpolationOrder, decltype(temperatureAcc), false>(temperatureAcc);
+
+            const Vec3T wLightDir = Vec3T(0, 1, 0);
+            const Vec3T iLightDir = densityGrid->worldToIndexDirF(wLightDir).normalize();
+
+            HeterogenousMedium medium;
+            medium.densityScale = params.volumeDensityScale;
+            medium.densityMin = valueToScalar(densityTree.root().valueMin()) * medium.densityScale;
+            medium.densityMax = valueToScalar(densityTree.root().valueMax()) * medium.densityScale;
+            medium.densityMax = fmaxf(medium.densityMin, fmaxf(medium.densityMax, 0.001f));
+            medium.hgMeanCosine = params.phase;
+            medium.temperatureScale = params.volumeTemperatureScale;
+            medium.transmittanceMethod = params.transmittanceMethod;
+            medium.transmittanceThreshold = params.transmittanceThreshold;
+            medium.maxPathDepth = params.maxPathDepth;
+            medium.albedo = params.volumeAlbedo;
+
+            for (int sampleIndex = 0; sampleIndex < sceneParams.samplesPerPixel; ++sampleIndex) {
+                uint32_t pixelSeed = hash((sampleIndex + (numAccumulations + 1) * sceneParams.samplesPerPixel)) ^ hash(ix, iy);
+
+                RayT wRay = getRayFromPixelCoord(ix, iy, width, height, numAccumulations, sceneParams.samplesPerPixel, pixelSeed, sceneParams);
+
+                RayT iRay = wRay.worldToIndexF(*densityGrid);
+
+                bool  isFullyAbsorbed = false;
+                float pathThroughput = 1.0f;
+                Vec3T radiance = traceBlackbodyVolume(pathThroughput, isFullyAbsorbed, iRay, densitySampler, temperatureSampler, medium, pixelSeed, sceneParams, iLightDir);
+
+                if (!isFullyAbsorbed && sceneParams.useBackground && pathThroughput > 0.0f) {
+                    float bgIntensity = 0.0f;
+                    float groundIntensity = 0.0f;
+                    float groundMix = 0.0f;
+
+                    // BUG: this causes trouble.
+                    //wRay = iRay.indexToWorldF(*densityGrid);
+
+                    if (sceneParams.useGround) {
+                        // intersect with ground plane and draw checker if camera is above...
+                        float wGroundT = (sceneParams.groundHeight - wRay.eye()[1]) / wRay.dir()[1];
+                        if (wRay.dir()[1] != 0 && wGroundT > 0.f) {
+                            Vec3T wGroundPos = wRay(wGroundT);
+                            groundIntensity = evalGroundMaterial(wGroundT, sceneParams.groundFalloff, wGroundPos, wRay.dir()[1], groundMix);
+
+                            if (sceneParams.useLighting && sceneParams.useShadows) {
+                                Vec3T iGroundPos = densityGrid->worldToIndexF(wGroundPos);
+                                RayT  iShadowRay(iGroundPos, iLightDir);
+                                float shadowTransmittance = getTransmittance(iShadowRay, densitySampler, medium, pixelSeed);
+                                groundIntensity *= shadowTransmittance;
+                            }
+                        }
+                    }
 
-            RayT wRay = camera.getRay(u, v);
-            RayT iRay = wRay.worldToIndexF(*grid);
+                    float skyIntensity = evalSkyMaterial(wRay.dir());
+                    bgIntensity = (1.f - groundMix) * skyIntensity + groundMix * groundIntensity;
+                    radiance += nanovdb::Vec3f(pathThroughput * bgIntensity);
+                }
 
-            Vec3T iRayDir = iRay.dir();
-            Vec3T wRayDir = wRay.dir();
-            Vec3T wRayEye = wRay.eye();
-
-            Vec3T radiance = Vec3T(0);
-            if (params.useLighting > 0) {
-                radiance = traceVolume(iRay, acc, medium, pixelSeed, iLightDir);
+                color[0] += radiance[0];
+                color[1] += radiance[1];
+                color[2] += radiance[2];
             }
 
-            float transmittance = getTransmittance(iRay, acc, medium, pixelSeed);
+            for (int k = 0; k < 3; ++k)
+                color[k] = color[k] / sceneParams.samplesPerPixel;
+        }
 
-            if (transmittance > 0.01f) {
-                float groundIntensity = 0.0f;
-                float groundMix = 0.0f;
+        compositeFn(outPixel, color, numAccumulations, sceneParams);
+    }
+};
 
-                if (params.useGround > 0) {
-                    // intersect with ground plane and draw checker if camera is above...
+struct FogVolumeFastRenderFn
+{
+    using RealT = float;
+    using Vec3T = nanovdb::Vec3<RealT>;
+    using CoordT = nanovdb::Coord;
+    using RayT = nanovdb::Ray<RealT>;
+
+    template<typename ValueT>
+    inline __hostdev__ void operator()(int ix, int iy, int width, int height, float* imgBuffer, int numAccumulations, const nanovdb::BBoxR proxy, const nanovdb::NanoGrid<ValueT>* densityGrid, const SceneRenderParameters sceneParams, const MaterialParameters params) const
+    {
+        float* outPixel = &imgBuffer[4 * (ix + width * iy)];
+        float  color[4] = {0, 0, 0, 0};
 
-                    float wGroundT = (params.groundHeight - wRayEye[1]) / wRayDir[1];
+        if (!densityGrid) {
+            RayT wRay = getRayFromPixelCoord(ix, iy, width, height, sceneParams);
 
-                    if (wGroundT > 0.f) {
-                        Vec3T wGroundPos = wRayEye + wGroundT * wRayDir;
-                        Vec3T iGroundPos = grid->worldToIndexF(wGroundPos);
+            auto envRadiance = traceEnvironment(wRay, sceneParams);
+
+            color[0] = envRadiance;
+            color[1] = envRadiance;
+            color[2] = envRadiance;
+
+        } else {
+            auto&              densityTree = densityGrid->tree();
+            HeterogenousMedium medium;
+            medium.densityScale = params.volumeDensityScale;
+            medium.densityMin = valueToScalar(densityTree.root().valueMin()) * medium.densityScale;
+            medium.densityMax = valueToScalar(densityTree.root().valueMax()) * medium.densityScale;
+            medium.densityMax = fmaxf(medium.densityMin, fmaxf(medium.densityMax, 0.001f));
+            medium.transmittanceMethod = params.transmittanceMethod;
+            medium.transmittanceThreshold = params.transmittanceThreshold;
+
+            uint32_t pixelSeed = hash((numAccumulations + 1)) ^ hash(ix, iy);
+
+            RayT wRay = getRayFromPixelCoord(ix, iy, width, height, sceneParams);
+
+            RayT iRay = wRay.worldToIndexF(*densityGrid);
+
+            const auto densityAcc = densityTree.getAccessor();
+            const auto densitySampler = nanovdb::createSampler<0, decltype(densityAcc), false>(densityAcc);
 
-                        rayTraceGround(wGroundT, params.groundFalloff, wGroundPos, wRayDir[1], groundIntensity, groundMix);
+            const Vec3T wLightDir = Vec3T(0, 1, 0);
+            const Vec3T iLightDir = densityGrid->worldToIndexDirF(wLightDir).normalize();
 
-                        if (params.useShadows > 0) {
+            float radiance = 0;
+            float pathThroughput = getTransmittance(iRay, densitySampler, medium, pixelSeed);
+
+            if (sceneParams.useBackground && pathThroughput > 0.0f) {
+                float bgIntensity = 0.0f;
+                float groundIntensity = 0.0f;
+                float groundMix = 0.0f;
+                if (sceneParams.useGround) {
+                    // intersect with ground plane and draw checker if camera is above...
+                    float wGroundT = (sceneParams.groundHeight - wRay.eye()[1]) / wRay.dir()[1];
+                    if (wGroundT > 0.f) {
+                        Vec3T wGroundPos = wRay(wGroundT);
+                        groundIntensity = evalGroundMaterial(wGroundT, sceneParams.groundFalloff, wGroundPos, wRay.dir()[1], groundMix);
+
+                        if (sceneParams.useLighting && sceneParams.useShadows) {
+                            Vec3T iGroundPos = densityGrid->worldToIndexF(wGroundPos);
                             RayT  iShadowRay(iGroundPos, iLightDir);
-                            float shadowTransmittance = getTransmittance(iShadowRay, acc, medium, pixelSeed);
+                            float shadowTransmittance = getTransmittance(iShadowRay, densitySampler, medium, pixelSeed);
                             groundIntensity *= shadowTransmittance;
                         }
                     }
                 }
 
-                float skyIntensity = 0.75f + 0.25f * wRayDir[1];
-
-                radiance = radiance + nanovdb::Vec3f(transmittance * ((1.f - groundMix) * skyIntensity + groundMix * groundIntensity));
+                float skyIntensity = evalSkyMaterial(wRay.dir());
+                bgIntensity = (1.f - groundMix) * skyIntensity + groundMix * groundIntensity;
+                radiance += pathThroughput * bgIntensity;
             }
 
-            color[0] += radiance[0];
-            color[1] += radiance[1];
-            color[2] += radiance[2];
-        }
-
-        for (int k = 0; k < 3; ++k)
-            color[k] = color[k] / params.samplesPerPixel;
-
-        if (numAccumulations > 1) {
-            float oldLinearPixel[3];
-            if (params.useTonemapping)
-                invTonemapReinhard(oldLinearPixel, outPixel, params.tonemapWhitePoint);
-            else
-                invTonemapPassthru(oldLinearPixel, outPixel);
-            for (int k = 0; k < 3; ++k)
-                color[k] = oldLinearPixel[k] + (color[k] - oldLinearPixel[k]) * (1.0f / numAccumulations);
+            color[0] += radiance;
+            color[1] += radiance;
+            color[2] += radiance;
         }
 
-        if (params.useTonemapping)
-            tonemapReinhard(outPixel, color, params.tonemapWhitePoint);
-        else
-            tonemapPassthru(outPixel, color);
-        outPixel[3] = 1.0;
+        compositeFn(outPixel, color, numAccumulations, sceneParams);
     }
 };
 }
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/RenderGridUtils.h nanovdb-20201022/nanovdb/cmd/viewer/RenderGridUtils.h
--- nanovdb-20200925/nanovdb/cmd/viewer/RenderGridUtils.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/RenderGridUtils.h	2020-10-22 03:52:50.000000000 +0200
@@ -11,6 +11,8 @@
 	\brief General C++ implementation of the Grid rendering code.
 */
 
+#pragma once
+
 #include <nanovdb/NanoVDB.h>
 #include <nanovdb/util/HDDA.h>
 #include <nanovdb/util/Ray.h>
@@ -28,76 +30,67 @@
     using RayT = nanovdb::Ray<RealT>;
 
     template<typename ValueType>
-    inline __hostdev__ void operator()(int ix, int iy, int width, int height, float* imgBuffer, Camera<float> camera, const nanovdb::NanoGrid<ValueType>* grid, int numAccumulations, const RenderConstants params) const
+    inline __hostdev__ void operator()(int ix, int iy, int width, int height, float* imgBuffer, int numAccumulations, const nanovdb::NanoGrid<ValueType>* grid, const SceneRenderParameters sceneParams, const MaterialParameters params) const
     {
         int pixelSeed = numAccumulations + hash(ix, iy);
 
         auto outPixel = &imgBuffer[4 * (ix + width * iy)];
 
-        const auto& tree = grid->tree();
+        float color[4] = {0, 0, 0, 0};
 
-        float u = ix + 0.5f;
-        float v = iy + 0.5f;
+        if (!grid) {
+            RayT wRay = getRayFromPixelCoord(ix, iy, width, height, sceneParams);
 
-        u /= width;
-        v /= height;
+            auto envRadiance = traceEnvironment(wRay, sceneParams);
 
-        RayT wRay = camera.getRay(u, v);
-        RayT iRay = wRay.worldToIndexF(*grid);
-
-        Vec3T iRayDir = iRay.dir();
-        Vec3T wRayDir = wRay.dir();
-        Vec3T wRayEye = wRay.eye();
-
-        float color[4];
-
-        {
-            auto acc = tree.getAccessor();
-            using AccT = decltype(acc);
-            nanovdb::TreeMarcher<typename AccT::NodeT0, nanovdb::Ray<float>, AccT> marcher(acc);
-            if (marcher.init(iRay)) {
-                float                        nodeSpanAccum = 0;
-                float                        nodeCount = 0;
-                const typename AccT::NodeT0* node;
-                float                        t0 = 0, t1 = 0;
-                while (marcher.step(&node, t0, t1)) {
-                    nodeSpanAccum += (t1 - t0);
-                    nodeCount += 1.0f;
-                }
+            color[0] = envRadiance;
+            color[1] = envRadiance;
+            color[2] = envRadiance;
+        } else {
+            
+            float groundIntensity = 0.0f;
+            float groundMix = 0.0f;
+
+            RayT wRay = getRayFromPixelCoord(ix, iy, width, height, sceneParams);
+
+            RayT  iRay = wRay.worldToIndexF(*grid);
+            Vec3T iRayDir = iRay.dir();
+            Vec3T wRayDir = wRay.dir();
+            Vec3T wRayEye = wRay.eye();
+
+            {
+                const auto& tree = grid->tree();
+                using TreeT = nanovdb::NanoTree<ValueType>;
+                auto acc = tree.getAccessor();
+                using AccT = decltype(acc);
+                nanovdb::TreeMarcher<typename TreeT::LeafNodeType, nanovdb::Ray<float>, AccT> marcher(acc);
+                if (marcher.init(iRay)) {
+                    float                        nodeSpanAccum = 0;
+                    float                        nodeCount = 0;
+                    const typename TreeT::LeafNodeType* node;
+                    float                        t0 = 0, t1 = 0;
+                    while (marcher.step(&node, t0, t1)) {
+                        nodeSpanAccum += (t1 - t0);
+                        nodeCount += 1.0f;
+                    }
 
-                if (nodeCount == 0) {
-                    // hit no nodes!
-                    color[0] = 0;
-                    color[1] = 1;
-                    color[2] = 0;
+                    if (nodeCount == 0) {
+                        // hit no nodes!
+                        color[0] = 0;
+                        color[1] = 1;
+                        color[2] = 0;
+                    } else {
+                        color[0] = nodeCount / 16.f;
+                        color[1] = 0;
+                        color[2] = 0;
+                    }
                 } else {
-                    color[0] = nodeCount / 16.f;
-                    color[1] = 0;
-                    color[2] = 0;
-                }
-            } else {
-                float groundIntensity = 0.0f;
-                float groundMix = 0.0f;
-
-                if (params.useGround > 0) {
-                    float wGroundT = (params.groundHeight - wRayEye[1]) / wRayDir[1];
-                    if (wGroundT > 0.f) {
-                        Vec3T wGroundPos = wRayEye + wGroundT * wRayDir;
-                        Vec3T iGroundPos = grid->worldToIndexF(wGroundPos);
-
-                        rayTraceGround(wGroundT, params.groundFalloff, wGroundPos, wRayDir[1], groundIntensity, groundMix);
+                    auto envRadiance = traceEnvironment(wRay, sceneParams);
 
-                        groundMix *= params.useGround;
-                    }
+                    color[0] = envRadiance;
+                    color[1] = envRadiance;
+                    color[2] = envRadiance;
                 }
-
-                float skyIntensity = 0.75f + 0.25f * wRayDir[1];
-
-                float bgIntensity = (1.f - groundMix) * skyIntensity + groundMix * groundIntensity;
-
-                color[0] = bgIntensity;
-                color[1] = bgIntensity;
-                color[2] = bgIntensity;
             }
         }
 
@@ -106,6 +99,5 @@
         outPixel[3] = 1.0;
     }
 };
-
 }
 } // namespace render::grid
\ Pas de fin de ligne Ã  la fin du fichier
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncherC99.cpp nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncherC99.cpp
--- nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncherC99.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncherC99.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -26,8 +26,13 @@
 
 extern "C" void launchRender(int method, int width, int height, vec4* imgPtr, const nanovdb_Node0_float* node0Level, const nanovdb_Node1_float* node1Level, const nanovdb_Node2_float* node2Level, const nanovdb_RootData_float* rootData, const nanovdb_RootData_Tile_float* rootDataTiles, const nanovdb_GridData* gridData, const ArgUniforms* uniforms);
 
-bool RenderLauncherC99::render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& gridHdl, int numAccumulations, const RenderConstants& params, RenderStatistics* stats)
+bool RenderLauncherC99::render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats)
 {
+    if (grids[0].gridHandle == nullptr)
+        return false;
+
+    auto& gridHdl = *reinterpret_cast<const nanovdb::GridHandle<>*>(grids[0].gridHandle);
+
     float* imgPtr = (float*)imgBuffer->map((numAccumulations > 0) ? FrameBufferBase::AccessType::READ_WRITE : FrameBufferBase::AccessType::WRITE_ONLY);
     if (!imgPtr) {
         return false;
@@ -54,10 +59,10 @@
         auto rootData = &grid->tree().root();
         auto gridData = grid;
 
-        nanovdb::Vec3f cameraP = camera.P();
-        nanovdb::Vec3f cameraU = camera.U();
-        nanovdb::Vec3f cameraV = camera.V();
-        nanovdb::Vec3f cameraW = camera.W();
+        nanovdb::Vec3f cameraP = sceneParams.camera.P();
+        nanovdb::Vec3f cameraU = sceneParams.camera.U();
+        nanovdb::Vec3f cameraV = sceneParams.camera.V();
+        nanovdb::Vec3f cameraW = sceneParams.camera.W();
 
         // launch render...
 
@@ -66,16 +71,18 @@
         uniforms.width = width;
         uniforms.height = height;
         uniforms.numAccumulations = numAccumulations;
-        uniforms.useShadows = params.useShadows;
-        uniforms.useGround = params.useGround;
-        uniforms.useGroundReflections = params.useGroundReflections;
-        uniforms.useLighting = params.useLighting;
-        uniforms.useOcclusion = params.useOcclusion;
-        uniforms.volumeDensity = params.volumeDensity;
-        uniforms.tonemapWhitePoint = params.tonemapWhitePoint;
-        uniforms.samplesPerPixel = params.samplesPerPixel;
-        uniforms.groundHeight = params.groundHeight;
-        uniforms.groundFalloff = params.groundFalloff;
+
+        uniforms.useShadows = sceneParams.useShadows;
+        uniforms.useGroundReflections = sceneParams.useGroundReflections;
+        uniforms.useLighting = sceneParams.useLighting;
+        uniforms.useOcclusion = materialParams.useOcclusion;
+        uniforms.volumeDensityScale = materialParams.volumeDensityScale;
+
+        uniforms.samplesPerPixel = sceneParams.samplesPerPixel;
+        uniforms.useBackground = sceneParams.useBackground;
+        uniforms.tonemapWhitePoint = sceneParams.tonemapWhitePoint;
+        uniforms.groundHeight = sceneParams.groundHeight;
+        uniforms.groundFalloff = sceneParams.groundFalloff;
         uniforms.cameraPx = cameraP[0];
         uniforms.cameraPy = cameraP[1];
         uniforms.cameraPz = cameraP[2];
@@ -88,6 +95,8 @@
         uniforms.cameraWx = cameraW[0];
         uniforms.cameraWy = cameraW[1];
         uniforms.cameraWz = cameraW[2];
+        uniforms.cameraAspect = sceneParams.camera.aspect();
+        uniforms.cameraFovY = sceneParams.camera.fov();
 
         launchRender((int)method, width, height, (vec4*)imgPtr, (nanovdb_Node0_float*)node0Level, (nanovdb_Node1_float*)node1Level, (nanovdb_Node2_float*)node2Level, (nanovdb_RootData_float*)rootData, (nanovdb_RootData_Tile_float*)(rootData + 1), (nanovdb_GridData*)gridData, &uniforms);
     }
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncherCL.cpp nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncherCL.cpp
--- nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncherCL.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncherCL.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -473,29 +473,29 @@
                 uint32_t(RootT::memUsage(0)),
                 uint32_t(GridT::memUsage())};
 
-            auto node0Level = grid->tree().getNode<Node0T>(0);
-            auto node1Level = grid->tree().getNode<Node1T>(0);
-            auto node2Level = grid->tree().getNode<Node2T>(0);
-            auto rootData = &grid->tree().root();
-            auto gridData = grid;
-
-            uintptr_t gridBaseAddr = uintptr_t(grid);
-           // uintptr_t treeBaseAddr = uintptr_t(&grid->tree());
-            uint32_t  offsets[] = {
-                uint32_t(uintptr_t(node0Level) - gridBaseAddr),
-                uint32_t(uintptr_t(node1Level) - gridBaseAddr),
-                uint32_t(uintptr_t(node2Level) - gridBaseAddr),
-                uint32_t(uintptr_t(rootData) - gridBaseAddr + RootT::memUsage(0)),
-                uint32_t(uintptr_t(rootData) - gridBaseAddr),
-                uint32_t(uintptr_t(gridData) - gridBaseAddr)};
+            auto gridData = uintptr_t(grid);
+            auto rootData = uintptr_t(&grid->tree().root());
+            auto node2Level = (counts[2] > 0) ? uintptr_t(grid->tree().getNode<Node2T>(0)) : rootData + RootT::memUsage(0);
+            auto node1Level = (counts[1] > 0) ? uintptr_t(grid->tree().getNode<Node1T>(0)) : node2Level;
+            auto node0Level = (counts[0] > 0) ? uintptr_t(grid->tree().getNode<Node0T>(0)) : node1Level;
+
+            uint32_t offsets[] = {
+                uint32_t(node0Level - gridData),
+                uint32_t(node1Level - gridData),
+                uint32_t(node2Level - gridData),
+                uint32_t(rootData - gridData + RootT::memUsage(0)),
+                uint32_t(rootData - gridData),
+                uint32_t(gridData - gridData)};
 
-            cl_mem nodeLevelBuffers[6];
+            cl_mem nodeLevelBuffers[6] = {nullptr};
             for (int i = 0; i < 6; ++i) {
-                cl_buffer_region region;
-                region.origin = offsets[i];
-                region.size = counts[i];
-                nodeLevelBuffers[i] = clCreateSubBuffer(gridbuffer, CL_MEM_READ_ONLY, CL_BUFFER_CREATE_TYPE_REGION, &region, &err);
-                NANOVDB_CL_SAFE_CALL(err);
+                if (counts[i] > 0) {
+                    cl_buffer_region region;
+                    region.origin = offsets[i];
+                    region.size = counts[i];
+                    nodeLevelBuffers[i] = clCreateSubBuffer(gridbuffer, CL_MEM_READ_ONLY, CL_BUFFER_CREATE_TYPE_REGION, &region, &err);
+                    NANOVDB_CL_SAFE_CALL(err);
+                }
             }
 
             resource->mQueueCl = queue;
@@ -625,8 +625,13 @@
     return buffer;
 }
 
-bool RenderLauncherCL::render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& gridHdl, int numAccumulations, const RenderConstants& params, RenderStatistics* stats)
+bool RenderLauncherCL::render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats)
 {
+    if (grids[0].gridHandle == nullptr)
+        return false;
+
+    auto& gridHdl = *reinterpret_cast<const nanovdb::GridHandle<>*>(grids[0].gridHandle);
+
     void* contextGL = nullptr;
     void* displayGL = nullptr;
 #if defined(NANOVDB_USE_OPENGL)
@@ -656,24 +661,20 @@
 
     // prepare data...
 
-    nanovdb::Vec3f cameraP = camera.P();
-    nanovdb::Vec3f cameraU = camera.U();
-    nanovdb::Vec3f cameraV = camera.V();
-    nanovdb::Vec3f cameraW = camera.W();
-
-    // launch GL render...
-
     struct Uniforms
     {
         cl_int         width;
         cl_int         height;
         cl_int         numAccumulations;
-        float          useGround;
-        float          useShadows;
-        float          useGroundReflections;
-        float          useLighting;
+        cl_int         useBackground;
+        cl_int         useGround;
+        cl_int         useShadows;
+        cl_int         useGroundReflections;
+        cl_int         useLighting;
         float          useOcclusion;
-        float          volumeDensity;
+        float          volumeDensityScale;
+        float          volumeAlbedo;
+        int            useTonemapping;
         float          tonemapWhitePoint;
         int            samplesPerPixel;
         float          groundHeight;
@@ -682,33 +683,44 @@
         nanovdb::Vec3f cameraU;
         nanovdb::Vec3f cameraV;
         nanovdb::Vec3f cameraW;
+        float          cameraAspect;
+        float          cameraFovY;
     };
 
     Uniforms uniforms;
     uniforms.width = width;
     uniforms.height = height;
     uniforms.numAccumulations = numAccumulations;
-    uniforms.useGround = params.useGround;
-    uniforms.useShadows = params.useShadows;
-    uniforms.useGroundReflections = params.useGroundReflections;
-    uniforms.useLighting = params.useLighting;
-    uniforms.useOcclusion = params.useOcclusion;
-    uniforms.volumeDensity = params.volumeDensity;
-    uniforms.tonemapWhitePoint = params.tonemapWhitePoint;
-    uniforms.samplesPerPixel = params.samplesPerPixel;
-    uniforms.groundHeight = params.groundHeight;
-    uniforms.groundFalloff = params.groundFalloff;
-    uniforms.cameraP = cameraP;
-    uniforms.cameraU = cameraU;
-    uniforms.cameraV = cameraV;
-    uniforms.cameraW = cameraW;
+
+    uniforms.useOcclusion = materialParams.useOcclusion;
+    uniforms.volumeDensityScale = materialParams.volumeDensityScale;
+    uniforms.volumeAlbedo = materialParams.volumeAlbedo;
+
+    uniforms.samplesPerPixel = sceneParams.samplesPerPixel;
+    uniforms.useGround = sceneParams.useGround;
+    uniforms.useShadows = sceneParams.useShadows;
+    uniforms.useGroundReflections = sceneParams.useGroundReflections;
+    uniforms.useLighting = sceneParams.useLighting;
+    uniforms.useBackground = sceneParams.useBackground;
+    uniforms.useTonemapping = sceneParams.useTonemapping;
+    uniforms.tonemapWhitePoint = sceneParams.tonemapWhitePoint;
+    uniforms.groundHeight = sceneParams.groundHeight;
+    uniforms.groundFalloff = sceneParams.groundFalloff;
+    uniforms.cameraP = sceneParams.camera.P();
+    uniforms.cameraU = sceneParams.camera.U();
+    uniforms.cameraV = sceneParams.camera.V();
+    uniforms.cameraW = sceneParams.camera.W();
+    uniforms.cameraAspect = sceneParams.camera.aspect();
+    uniforms.cameraFovY = sceneParams.camera.fov();
+
+    // launch GL render...
 
     cl_kernel kernelCl = nullptr;
-    if (method == RenderMethod::LEVELSET) {
+    if (method == MaterialClass::kLevelSetFast) {
         kernelCl = (cl_kernel)resource->mKernelLevelSetCl;
-    } else if (method == RenderMethod::FOG_VOLUME) {
+    } else if (method == MaterialClass::kFogVolumePathTracer) {
         kernelCl = (cl_kernel)resource->mKernelFogVolumeCl;
-    }
+    } 
 
     if (!kernelCl)
         return false;
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncher.cpp nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncher.cpp
--- nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncher.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncher.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -19,6 +19,9 @@
 #include "FrameBuffer.h"
 #include "RenderLauncherImpl.h"
 
+const char* kMaterialClassTypeStrings[(int)MaterialClass::kNumTypes] = {"Auto", "LevelSetFast", "FogVolumePathTracer", "Grid", "PointsFast", "BlackBodyVolumePathTracer", "FogVolumeFast", "CameraDiagnostic"};
+const char* kCameraLensTypeStrings[(int)Camera::LensType::kNumTypes] = {"PinHole", "Spherical", "ODS"};
+
 RenderLauncher::RenderLauncher()
     : mIndex(0)
 {
@@ -79,53 +82,50 @@
     return mImpls[mIndex]->name();
 }
 
-template<typename FnT, typename... Args>
-static void launchRender(int width, int height, const FnT& fn, Args... args)
+struct Launcher
 {
-    for (int iy = 0; iy < height; ++iy) {
-        for (int ix = 0; ix < width; ++ix) {
-            fn(ix, iy, width, height, args...);
+    template<typename ValueT>
+    const nanovdb::NanoGrid<ValueT>* grid(const void* gridPtr)
+    {
+        auto gridHdl = reinterpret_cast<const nanovdb::GridHandle<>*>(gridPtr);
+        if (!gridHdl)
+            return nullptr;
+        return gridHdl->grid<ValueT>();
+    }
+
+    template<typename FnT, typename... Args>
+    bool render(int width, int height, const FnT& fn, Args... args) const
+    {
+        for (int iy = 0; iy < height; ++iy) {
+            for (int ix = 0; ix < width; ++ix) {
+                fn(ix, iy, width, height, args...);
+            }
         }
+
+        return true;
     }
-}
+};
 
-bool RenderLauncherCpu::render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& gridHdl, int numAccumulations, const RenderConstants& params, RenderStatistics* stats)
+bool RenderLauncherCpu::render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats)
 {
     using ClockT = std::chrono::high_resolution_clock;
     auto t0 = ClockT::now();
-    
+
     float* imgPtr = (float*)imgBuffer->map((numAccumulations > 0) ? FrameBufferBase::AccessType::READ_WRITE : FrameBufferBase::AccessType::WRITE_ONLY);
-    
+
     if (!imgPtr) {
         return false;
     }
 
-    if (gridHdl.gridMetaData()->gridType() == nanovdb::GridType::Float) {
-        auto grid = gridHdl.grid<float>();
-
-        if (method == RenderMethod::GRID) {
-            launchRender(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        } else if (method == RenderMethod::FOG_VOLUME) {
-            launchRender(width, height, render::fogvolume::RenderVolumeRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        } else if (method == RenderMethod::LEVELSET) {
-            launchRender(width, height, render::levelset::RenderLevelSetRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        }
-    } else if (gridHdl.gridMetaData()->gridType() == nanovdb::GridType::UInt32) {
-        auto grid = gridHdl.grid<uint32_t>();
-
-        if (method == RenderMethod::GRID) {
-            launchRender(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        } else if (method == RenderMethod::POINTS) {
-            launchRender(width, height, render::points::RenderPointsRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        }
-    }
+    Launcher methodLauncher;
+    launchRender(methodLauncher, method, width, height, imgPtr, numAccumulations, grids, sceneParams, materialParams);
 
     imgBuffer->unmap();
 
     if (stats) {
         auto t1 = ClockT::now();
-        stats->mDuration = std::chrono::duration_cast<std::chrono::microseconds>(t1-t0).count()/1000.f;
+        stats->mDuration = std::chrono::duration_cast<std::chrono::microseconds>(t1 - t0).count() / 1000.f;
     }
-    
+
     return true;
 }
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncherCpuMT.cpp nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncherCpuMT.cpp
--- nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncherCpuMT.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncherCpuMT.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -27,131 +27,89 @@
 #endif
 #include <iostream>
 
-template<typename FnT, typename... Args>
-static void launchRender(int width, int height, const FnT& fn, Args... args)
+struct Launcher
 {
+    template<typename ValueT>
+    const nanovdb::NanoGrid<ValueT>* grid(const void* gridPtr) const
+    {
+        auto gridHdl = reinterpret_cast<const nanovdb::GridHandle<>*>(gridPtr);
+        if (!gridHdl)
+            return nullptr;
+        return gridHdl->grid<ValueT>();        
+    }
+
+    template<typename FnT, typename... Args>
+    bool render(int width, int height, const FnT& fn, Args... args) const
+    {
 #if defined(NANOVDB_USE_TBB)
-    auto kernel2D = [&](const tbb::blocked_range2d<int>& r) {
-        for (int iy = r.cols().begin(); iy < r.cols().end(); ++iy) {
-            for (int ix = r.rows().begin(); ix < r.rows().end(); ++ix) {
-                fn(ix, iy, width, height, args...);
+        auto kernel2D = [&](const tbb::blocked_range2d<int>& r) {
+            for (int iy = r.cols().begin(); iy < r.cols().end(); ++iy) {
+                for (int ix = r.rows().begin(); ix < r.rows().end(); ++ix) {
+                    fn(ix, iy, width, height, args...);
+                }
             }
-        }
-    };
-    tbb::blocked_range2d<int> range2D(0, width, 0, height);
-    tbb::parallel_for(range2D, kernel2D);
+        };
+        tbb::blocked_range2d<int> range2D(0, width, 0, height);
+        tbb::parallel_for(range2D, kernel2D);
 #else
 
-    const int blockSize = 8;
-    const int nBlocksX = (width + (blockSize - 1)) / blockSize;
-    const int nBlocksY = (height + (blockSize - 1)) / blockSize;
-    const int nBlocks = nBlocksX * nBlocksY;
-
-    auto renderBlock = [=](int i) {
-        const int blockOffsetX = blockSize * (i % nBlocksX);
-        const int blockOffsetY = blockSize * (i / nBlocksY);
-
-        for (int iy = 0; iy < blockSize; ++iy) {
-            for (int ix = 0; ix < blockSize; ++ix) {
-                fn(ix + blockOffsetX, iy + blockOffsetY, width, height, args...);
+        const int blockSize = 8;
+        const int nBlocksX = (width + (blockSize - 1)) / blockSize;
+        const int nBlocksY = (height + (blockSize - 1)) / blockSize;
+        const int nBlocks = nBlocksX * nBlocksY;
+
+        auto renderBlock = [=](int i) {
+            const int blockOffsetX = blockSize * (i % nBlocksX);
+            const int blockOffsetY = blockSize * (i / nBlocksY);
+
+            for (int iy = 0; iy < blockSize; ++iy) {
+                for (int ix = 0; ix < blockSize; ++ix) {
+                    fn(ix + blockOffsetX, iy + blockOffsetY, width, height, args...);
+                }
             }
-        }
-    };
+        };
 
-    unsigned                 numCores = std::thread::hardware_concurrency();
-    std::vector<std::thread> threads(numCores);
-    std::atomic<int>         tileCounter(0);
-
-    for (int i = 0; i < threads.size(); ++i) {
-        threads[i] = std::thread([&tileCounter, nBlocks, i, renderBlock] {
-            for (;;) {
-                const int blockIndex = tileCounter++;
-                if (blockIndex >= nBlocks) {
-                    break;
+        unsigned                 numCores = std::thread::hardware_concurrency();
+        std::vector<std::thread> threads(numCores);
+        std::atomic<int>         tileCounter(0);
+
+        for (int i = 0; i < threads.size(); ++i) {
+            threads[i] = std::thread([&tileCounter, nBlocks, i, renderBlock] {
+                for (;;) {
+                    const int blockIndex = tileCounter++;
+                    if (blockIndex >= nBlocks) {
+                        break;
+                    }
+                    renderBlock(blockIndex);
                 }
-                renderBlock(blockIndex);
-            }
-        });
-    }
+            });
+        }
 
-    for (auto& t : threads)
-        t.join();
+        for (auto& t : threads)
+            t.join();
 #endif
-}
+        return true;
+    }
+};
 
-bool RenderLauncherCpuMT::render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& gridHdl, int numAccumulations, const RenderConstants& params, RenderStatistics* stats)
+bool RenderLauncherCpuMT::render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats)
 {
     using ClockT = std::chrono::high_resolution_clock;
     auto t0 = ClockT::now();
-    
+
     float* imgPtr = (float*)imgBuffer->map((numAccumulations > 0) ? FrameBufferBase::AccessType::READ_WRITE : FrameBufferBase::AccessType::WRITE_ONLY);
     if (!imgPtr) {
         return false;
     }
 
-    if (gridHdl.gridMetaData()->gridType() == nanovdb::GridType::Float) {
-        auto grid = gridHdl.grid<float>();
-
-        if (method == RenderMethod::GRID) {
-            launchRender(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        } else if (method == RenderMethod::FOG_VOLUME) {
-            launchRender(width, height, render::fogvolume::RenderVolumeRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        } else if (method == RenderMethod::LEVELSET) {
-            launchRender(width, height, render::levelset::RenderLevelSetRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        }
-    } else if (gridHdl.gridMetaData()->gridType() == nanovdb::GridType::Double) {
-        auto grid = gridHdl.grid<double>();
-
-        if (method == RenderMethod::GRID) {
-            launchRender(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        } else if (method == RenderMethod::FOG_VOLUME) {
-            launchRender(width, height, render::fogvolume::RenderVolumeRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        } else if (method == RenderMethod::LEVELSET) {
-            launchRender(width, height, render::levelset::RenderLevelSetRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        }
-    } else if (gridHdl.gridMetaData()->gridType() == nanovdb::GridType::UInt32) {
-        auto grid = gridHdl.grid<uint32_t>();
-
-        if (method == RenderMethod::GRID) {
-            launchRender(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        } else if (method == RenderMethod::POINTS) {
-            launchRender(width, height, render::points::RenderPointsRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        }
-    } else if (gridHdl.gridMetaData()->gridType() == nanovdb::GridType::Vec3f) {
-        auto grid = gridHdl.grid<nanovdb::Vec3f>();
-
-        if (method == RenderMethod::GRID) {
-            launchRender(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        } else if (method == RenderMethod::FOG_VOLUME) {
-            launchRender(width, height, render::fogvolume::RenderVolumeRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        }
-    } else if (gridHdl.gridMetaData()->gridType() == nanovdb::GridType::Vec3d) {
-        auto grid = gridHdl.grid<nanovdb::Vec3d>();
-
-        if (method == RenderMethod::GRID) {
-            launchRender(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        } else if (method == RenderMethod::FOG_VOLUME) {
-            launchRender(width, height, render::fogvolume::RenderVolumeRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        }
-    } else if (gridHdl.gridMetaData()->gridType() == nanovdb::GridType::Int64) {
-        auto grid = gridHdl.grid<int64_t>();
-
-        if (method == RenderMethod::GRID) {
-            launchRender(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        } 
-    } else if (gridHdl.gridMetaData()->gridType() == nanovdb::GridType::Int32) {
-        auto grid = gridHdl.grid<int32_t>();
-
-        if (method == RenderMethod::GRID) {
-            launchRender(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, camera, grid, numAccumulations, params);
-        } 
-    } 
+    Launcher methodLauncher;
+    launchRender(methodLauncher, method, width, height, imgPtr, numAccumulations, grids, sceneParams, materialParams);
 
     imgBuffer->unmap();
 
     if (stats) {
         auto t1 = ClockT::now();
-        stats->mDuration = std::chrono::duration_cast<std::chrono::microseconds>(t1-t0).count()/1000.f;
+        stats->mDuration = std::chrono::duration_cast<std::chrono::microseconds>(t1 - t0).count() / 1000.f;
     }
 
     return true;
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncherCUDA.cu nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncherCUDA.cu
--- nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncherCUDA.cu	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncherCUDA.cu	2020-10-22 03:52:50.000000000 +0200
@@ -52,38 +52,78 @@
     fn(ix, iy, width, height, args...);
 }
 
-template<typename FnT, typename... Args>
-static void launchRender(int width, int height, FnT fn, Args... args)
+struct CudaLauncher
 {
-    auto       divRoundUp = [](int a, int b) { return (a + b - 1) / b; };
-    const dim3 threadsPerBlock(8, 8), numBlocks(divRoundUp(width, threadsPerBlock.x), divRoundUp(height, threadsPerBlock.y));
-    launchRenderKernel<<<numBlocks, threadsPerBlock, 0, 0>>>(width, height, fn, args...);
-    auto code = cudaGetLastError();
-    if (code != cudaSuccess) {
-        std::cerr << "launchRenderCuda CUDA error: " << cudaGetErrorString(code) << std::endl;
-        exit(code);
+    RenderLauncherCUDA* mOwner;
+
+    CudaLauncher(RenderLauncherCUDA* owner)
+        : mOwner(owner)
+    {
+    }
+
+    template<typename ValueT>
+    const nanovdb::NanoGrid<ValueT>* grid(const void* gridPtr)
+    {
+        auto gridHdl = reinterpret_cast<const nanovdb::GridHandle<>*>(gridPtr);
+
+        if (!gridHdl)
+            return nullptr;
+
+        auto resource = mOwner->ensureGridResource(gridHdl);
+        if (!resource || !resource->mInitialized) {
+            return nullptr;
+        }
+        return reinterpret_cast<const nanovdb::NanoGrid<ValueT>*>(resource->mDeviceGrid);
     }
-}
+
+    template<typename FnT, typename... Args>
+    bool render(int width, int height, const FnT& fn, Args... args) const
+    {
+        auto       divRoundUp = [](int a, int b) { return (a + b - 1) / b; };
+        const dim3 threadsPerBlock(8, 8), numBlocks(divRoundUp(width, threadsPerBlock.x), divRoundUp(height, threadsPerBlock.y));
+        launchRenderKernel<<<numBlocks, threadsPerBlock, 0, 0>>>(width, height, fn, args...);
+        auto code = cudaGetLastError();
+        if (code != cudaSuccess) {
+            std::cerr << "launchRenderCuda CUDA error: " << cudaGetErrorString(code) << std::endl;
+            return false;
+        }
+        return true;
+    }
+};
 
 RenderLauncherCUDA::~RenderLauncherCUDA()
 {
-    for (auto& it : mResources) {
+    for (auto& it : mGridResources) {
         cudaFree(it.second->mDeviceGrid);
     }
-    mResources.clear();
+    mGridResources.clear();
 }
 
-std::shared_ptr<RenderLauncherCUDA::Resource> RenderLauncherCUDA::ensureResource(const nanovdb::GridHandle<>* gridHdl)
+std::shared_ptr<RenderLauncherCUDA::ImageResource> RenderLauncherCUDA::ensureImageResource()
 {
-    std::shared_ptr<Resource> resource;
-    auto                      it = mResources.find(gridHdl);
-    if (it != mResources.end()) {
+    std::shared_ptr<ImageResource> resource;
+    if (mImageResource) {
+        resource = mImageResource;
+    } else {
+        std::cout << "Initializing CUDA image resource..." << std::endl;
+        resource = std::make_shared<ImageResource>();
+        mImageResource = resource;
+        resource->mInitialized = true;
+    }
+
+    return resource;
+}
+std::shared_ptr<RenderLauncherCUDA::GridResource> RenderLauncherCUDA::ensureGridResource(const nanovdb::GridHandle<>* gridHdl)
+{
+    std::shared_ptr<GridResource> resource;
+    auto                      it = mGridResources.find(gridHdl);
+    if (it != mGridResources.end()) {
         resource = it->second;
     } else {
-        std::cout << "Initializing CUDA renderer..." << std::endl;
+        std::cout << "Initializing CUDA grid["<< gridHdl->gridMetaData()->gridName() <<"] resource..." << std::endl;
 
-        resource = std::make_shared<Resource>();
-        mResources.insert(std::make_pair(gridHdl, resource));
+        resource = std::make_shared<GridResource>();
+        mGridResources.insert(std::make_pair(gridHdl, resource));
 
         NANOVDB_CUDA_SAFE_CALL(cudaMalloc((void**)&resource->mDeviceGrid, gridHdl->size()));
         NANOVDB_CUDA_SAFE_CALL(cudaMemcpy(resource->mDeviceGrid, gridHdl->data(), gridHdl->size(), cudaMemcpyHostToDevice));
@@ -97,10 +137,11 @@
         resource->mInitialized = true;
     }
 
+    resource->mLastUsedTime = std::chrono::steady_clock::now();
     return resource;
 }
 
-void RenderLauncherCUDA::unmapCUDA(const std::shared_ptr<Resource>& resource, FrameBufferBase* imgBuffer, void* stream)
+void RenderLauncherCUDA::unmapCUDA(const std::shared_ptr<ImageResource>& resource, FrameBufferBase* imgBuffer, void* stream)
 {
 #if defined(NANOVDB_USE_OPENGL)
     auto imgBufferGL = dynamic_cast<FrameBufferGL*>(imgBuffer);
@@ -118,7 +159,7 @@
     imgBuffer->invalidate();
 }
 
-void* RenderLauncherCUDA::mapCUDA(int access, const std::shared_ptr<Resource>& resource, FrameBufferBase* imgBuffer, void* stream)
+void* RenderLauncherCUDA::mapCUDA(int access, const std::shared_ptr<ImageResource>& resource, FrameBufferBase* imgBuffer, void* stream)
 {
     if (!imgBuffer->size()) {
         return nullptr;
@@ -127,11 +168,10 @@
 #if defined(NANOVDB_USE_OPENGL)
     auto imgBufferGL = dynamic_cast<FrameBufferGL*>(imgBuffer);
     if (imgBufferGL) {
-
         if (resource->mGlTextureResourceCUDAError)
             return nullptr;
 
-        auto     accessGL = FrameBufferBase::AccessType(access);
+        auto accessGL = FrameBufferBase::AccessType(access);
 
         uint32_t accessCUDA = cudaGraphicsMapFlagsNone;
         if (accessGL == FrameBufferBase::AccessType::READ_ONLY) {
@@ -201,91 +241,35 @@
     return imgBuffer->cudaMap(FrameBufferBase::AccessType(access));
 }
 
-bool RenderLauncherCUDA::render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& gridHdl, int numAccumulations, const RenderConstants& params, RenderStatistics* stats)
+bool RenderLauncherCUDA::render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats)
 {
-    auto resource = ensureResource(&gridHdl);
-    if (!resource || !resource->mInitialized) {
-        return false;
-    }
-
     using ClockT = std::chrono::high_resolution_clock;
     auto t0 = ClockT::now();
 
+    auto imageResource = ensureImageResource();
+    if (!imageResource || imageResource->mInitialized == false)
+        return false;
+
     float* imgPtr = (float*)mapCUDA(
         (int)((numAccumulations > 0) ? FrameBufferBase::AccessType::READ_WRITE : FrameBufferBase::AccessType::WRITE_ONLY),
-        resource,
+        imageResource,
         imgBuffer);
 
     if (!imgPtr) {
         return false;
     }
 
-    if (gridHdl.gridMetaData()->gridType() == nanovdb::GridType::Float) {
-        auto deviceGrid = reinterpret_cast<const nanovdb::NanoGrid<float>*>(resource->mDeviceGrid);
-
-        if (method == RenderMethod::GRID) {
-            launchRender(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, camera, deviceGrid, numAccumulations, params);
-        } else if (method == RenderMethod::FOG_VOLUME) {
-            launchRender(width, height, render::fogvolume::RenderVolumeRgba32fFn(), imgPtr, camera, deviceGrid, numAccumulations, params);
-        } else if (method == RenderMethod::LEVELSET) {
-            launchRender(width, height, render::levelset::RenderLevelSetRgba32fFn(), imgPtr, camera, deviceGrid, numAccumulations, params);
-        }
-    } else if (gridHdl.gridMetaData()->gridType() == nanovdb::GridType::Double) {
-        auto deviceGrid = reinterpret_cast<const nanovdb::NanoGrid<double>*>(resource->mDeviceGrid);
-
-        if (method == RenderMethod::GRID) {
-            launchRender(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, camera, deviceGrid, numAccumulations, params);
-        } else if (method == RenderMethod::FOG_VOLUME) {
-            launchRender(width, height, render::fogvolume::RenderVolumeRgba32fFn(), imgPtr, camera, deviceGrid, numAccumulations, params);
-        } else if (method == RenderMethod::LEVELSET) {
-            launchRender(width, height, render::levelset::RenderLevelSetRgba32fFn(), imgPtr, camera, deviceGrid, numAccumulations, params);
-        }
-    } else if (gridHdl.gridMetaData()->gridType() == nanovdb::GridType::UInt32) {
-        auto deviceGrid = reinterpret_cast<const nanovdb::NanoGrid<uint32_t>*>(resource->mDeviceGrid);
-
-        if (method == RenderMethod::GRID) {
-            launchRender(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, camera, deviceGrid, numAccumulations, params);
-        } else if (method == RenderMethod::POINTS) {
-            launchRender(width, height, render::points::RenderPointsRgba32fFn(), imgPtr, camera, deviceGrid, numAccumulations, params);
-        }
-    } else if (gridHdl.gridMetaData()->gridType() == nanovdb::GridType::Vec3f) {
-        auto deviceGrid = reinterpret_cast<const nanovdb::NanoGrid<nanovdb::Vec3f>*>(resource->mDeviceGrid);
-
-        if (method == RenderMethod::GRID) {
-            launchRender(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, camera, deviceGrid, numAccumulations, params);
-        } else if (method == RenderMethod::FOG_VOLUME) {
-            launchRender(width, height, render::fogvolume::RenderVolumeRgba32fFn(), imgPtr, camera, deviceGrid, numAccumulations, params);
-        }
-    } else if (gridHdl.gridMetaData()->gridType() == nanovdb::GridType::Vec3d) {
-        auto deviceGrid = reinterpret_cast<const nanovdb::NanoGrid<nanovdb::Vec3d>*>(resource->mDeviceGrid);
-
-        if (method == RenderMethod::GRID) {
-            launchRender(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, camera, deviceGrid, numAccumulations, params);
-        } else if (method == RenderMethod::FOG_VOLUME) {
-            launchRender(width, height, render::fogvolume::RenderVolumeRgba32fFn(), imgPtr, camera, deviceGrid, numAccumulations, params);
-        }
-    } else if (gridHdl.gridMetaData()->gridType() == nanovdb::GridType::Int64) {
-        auto deviceGrid = reinterpret_cast<const nanovdb::NanoGrid<int64_t>*>(resource->mDeviceGrid);
-
-        if (method == RenderMethod::GRID) {
-            launchRender(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, camera, deviceGrid, numAccumulations, params);
-        }
-    } else if (gridHdl.gridMetaData()->gridType() == nanovdb::GridType::Int32) {
-        auto deviceGrid = reinterpret_cast<const nanovdb::NanoGrid<int32_t>*>(resource->mDeviceGrid);
-
-        if (method == RenderMethod::GRID) {
-            launchRender(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, camera, deviceGrid, numAccumulations, params);
-        }
-    }
-
-    unmapCUDA(resource, imgBuffer);
+    CudaLauncher methodLauncher(this);    
+    launchRender(methodLauncher, method, width, height, imgPtr, numAccumulations, grids, sceneParams, materialParams);
+    
+    unmapCUDA(imageResource, imgBuffer);
 
     if (stats) {
-        cudaDeviceSynchronize();
+        NANOVDB_CUDA_SAFE_CALL(cudaDeviceSynchronize());
         auto t1 = ClockT::now();
-        stats->mDuration = std::chrono::duration_cast<std::chrono::microseconds>(t1-t0).count()/1000.f;
+        stats->mDuration = std::chrono::duration_cast<std::chrono::microseconds>(t1 - t0).count() / 1000.f;
     }
-    
+
     return true;
 }
 
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncherGL.cpp nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncherGL.cpp
--- nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncherGL.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncherGL.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -125,9 +125,7 @@
     if (!file) {
         std::stringstream msg;
         msg << "Unable to load code: " << filename;
-        //throw std::runtime_error(msg.str().c_str());
-        std::cerr << "Error: " << msg.str() << std::endl;
-        return "";
+        throw std::runtime_error(msg.str().c_str());
     }
 
     std::string str;
@@ -141,7 +139,7 @@
     return str;
 }
 
-bool RenderLauncherGL::ensureProgramResource(const std::shared_ptr<Resource>& resource, std::string valueType, RenderMethod method)
+bool RenderLauncherGL::ensureProgramResource(const std::shared_ptr<Resource>& resource, std::string valueType, MaterialClass method)
 {
     if (resource->mUniformBufferId)
         glDeleteBuffers(1, &resource->mUniformBufferId);
@@ -169,19 +167,28 @@
     std::string includeFilePath = std::string(__FILE__);
     includeFilePath = includeFilePath.substr(0, includeFilePath.find_last_of('/')).substr(0, includeFilePath.find_last_of('\\')) + "/";
 
-    ss << fileToString(includeFilePath + g_kKernelString_Platform_h);
-    ss << fileToString(includeFilePath + g_kKernelString_HDDA_h);
-    ss << fileToString(includeFilePath + g_kKernelString_NanoVDB_h);
-    ss << fileToString(includeFilePath + g_kKernelString_Platform_c);
-    ss << fileToString(includeFilePath + g_kKernelString_NanoVDB_c);
-    ss << fileToString(includeFilePath + g_kKernelString_HDDA_c);
-    ss << fileToString(includeFilePath + g_kKernelString_renderCommon_h);
-    if (method == RenderMethod::LEVELSET) {
-        ss << fileToString(includeFilePath + g_kKernelString_renderLevelSet_c);
-    } else if (method == RenderMethod::FOG_VOLUME) {
-        ss << fileToString(includeFilePath + g_kKernelString_renderFogVolume_c);
-    } else {
-        ss << fileToString(includeFilePath + g_kKernelString_renderGrid_c);
+    try {
+        ss << fileToString(includeFilePath + g_kKernelString_Platform_h);
+        ss << fileToString(includeFilePath + g_kKernelString_HDDA_h);
+        ss << fileToString(includeFilePath + g_kKernelString_NanoVDB_h);
+        ss << fileToString(includeFilePath + g_kKernelString_Platform_c);
+        ss << fileToString(includeFilePath + g_kKernelString_NanoVDB_c);
+        ss << fileToString(includeFilePath + g_kKernelString_HDDA_c);
+        ss << fileToString(includeFilePath + g_kKernelString_renderCommon_h);
+        if (method == MaterialClass::kLevelSetFast) {
+            ss << fileToString(includeFilePath + g_kKernelString_renderLevelSet_c);
+        } else if (method == MaterialClass::kFogVolumePathTracer) {
+            ss << fileToString(includeFilePath + g_kKernelString_renderFogVolume_c);
+        } else {
+            ss << fileToString(includeFilePath + g_kKernelString_renderGrid_c);
+        }
+    }
+    catch (const std::exception& e) {
+        std::cerr << "GLSL error: " << e.what() << std::endl;
+        return false;
+    }
+    catch (...) {
+        return false;
     }
 
     auto codeStr = new char[ss.str().length() + 1];
@@ -237,7 +244,7 @@
     return true;
 }
 
-std::shared_ptr<RenderLauncherGL::Resource> RenderLauncherGL::ensureResource(const nanovdb::GridHandle<>& gridHdl, void* glContext, void* glDisplay, RenderMethod method)
+std::shared_ptr<RenderLauncherGL::Resource> RenderLauncherGL::ensureResource(const nanovdb::GridHandle<>& gridHdl, void* glContext, void* glDisplay, MaterialClass method)
 {
     std::shared_ptr<Resource> resource;
     auto                      it = mResources.find(&gridHdl);
@@ -249,7 +256,7 @@
         resource = std::make_shared<Resource>();
         mResources.insert(std::make_pair(&gridHdl, resource));
         resource->mMethod = method;
-        
+
         if (glContext == nullptr || glDisplay == nullptr) {
             return resource;
         }
@@ -266,8 +273,13 @@
     return resource;
 }
 
-bool RenderLauncherGL::render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& gridHdl, int numAccumulations, const RenderConstants& params, RenderStatistics* stats)
+bool RenderLauncherGL::render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats)
 {
+    if (grids[0].gridHandle == nullptr)
+        return false;
+
+    auto& gridHdl = *reinterpret_cast<const nanovdb::GridHandle<>*>(grids[0].gridHandle);
+
     void* contextGL = nullptr;
     void* displayGL = nullptr;
     auto  imgBufferGL = dynamic_cast<FrameBufferGL*>(imgBuffer);
@@ -293,10 +305,10 @@
 
     // prepare data...
 
-    nanovdb::Vec3f cameraP = camera.P();
-    nanovdb::Vec3f cameraU = camera.U();
-    nanovdb::Vec3f cameraV = camera.V();
-    nanovdb::Vec3f cameraW = camera.W();
+    nanovdb::Vec3f cameraP = sceneParams.camera.P();
+    nanovdb::Vec3f cameraU = sceneParams.camera.U();
+    nanovdb::Vec3f cameraV = sceneParams.camera.V();
+    nanovdb::Vec3f cameraW = sceneParams.camera.W();
 
     // launch GL render...
 
@@ -309,12 +321,15 @@
         int   width;
         int   height;
         int   numAccumulations;
-        float useGround;
-        float useShadows;
-        float useGroundReflections;
-        float useLighting;
+        int   useBackground;
+        int   useGround;
+        int   useShadows;
+        int   useGroundReflections;
+        int   useLighting;
         float useOcclusion;
-        float volumeDensity;
+        float volumeDensityScale;
+        float volumeAlbedo;
+        int   useTonemapping;
         float tonemapWhitePoint;
         int   samplesPerPixel;
         float groundHeight;
@@ -323,6 +338,8 @@
         float cameraUx, cameraUy, cameraUz;
         float cameraVx, cameraVy, cameraVz;
         float cameraWx, cameraWy, cameraWz;
+        float cameraAspect;
+        float cameraFovY;
     };
 
     auto args = (ArgUniforms*)glMapBuffer(GL_UNIFORM_BUFFER, GL_WRITE_ONLY);
@@ -331,16 +348,21 @@
         uniforms.width = width;
         uniforms.height = height;
         uniforms.numAccumulations = numAccumulations;
-        uniforms.useShadows = params.useShadows;
-        uniforms.useGround = params.useGround;
-        uniforms.useGroundReflections = params.useGroundReflections;
-        uniforms.useLighting = params.useLighting;
-        uniforms.useOcclusion = params.useOcclusion;
-        uniforms.volumeDensity = params.volumeDensity;
-        uniforms.tonemapWhitePoint = params.tonemapWhitePoint;
-        uniforms.samplesPerPixel = params.samplesPerPixel;
-        uniforms.groundHeight = params.groundHeight;
-        uniforms.groundFalloff = params.groundFalloff;
+
+        uniforms.useShadows = sceneParams.useShadows;
+        uniforms.useGroundReflections = sceneParams.useGroundReflections;
+        uniforms.useLighting = sceneParams.useLighting;
+        uniforms.useOcclusion = materialParams.useOcclusion;
+        uniforms.volumeDensityScale = materialParams.volumeDensityScale;
+        uniforms.volumeAlbedo = materialParams.volumeAlbedo;
+
+        uniforms.samplesPerPixel = sceneParams.samplesPerPixel;
+        uniforms.useBackground = sceneParams.useBackground;
+        uniforms.useGround = sceneParams.useGround;
+        uniforms.useTonemapping = sceneParams.useTonemapping;
+        uniforms.tonemapWhitePoint = sceneParams.tonemapWhitePoint;
+        uniforms.groundHeight = sceneParams.groundHeight;
+        uniforms.groundFalloff = sceneParams.groundFalloff;
         uniforms.cameraPx = cameraP[0];
         uniforms.cameraPy = cameraP[1];
         uniforms.cameraPz = cameraP[2];
@@ -353,6 +375,9 @@
         uniforms.cameraWx = cameraW[0];
         uniforms.cameraWy = cameraW[1];
         uniforms.cameraWz = cameraW[2];
+        uniforms.cameraAspect = sceneParams.camera.aspect();
+        uniforms.cameraFovY = sceneParams.camera.fov();
+
         glUnmapBuffer(GL_UNIFORM_BUFFER);
     }
 
@@ -380,9 +405,9 @@
     if (stats) {
         glFinish();
         auto t1 = ClockT::now();
-        stats->mDuration = std::chrono::duration_cast<std::chrono::microseconds>(t1-t0).count()/1000.f;
+        stats->mDuration = std::chrono::duration_cast<std::chrono::microseconds>(t1 - t0).count() / 1000.f;
     }
-    
+
     return true;
 }
 
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncher.h nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncher.h
--- nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncher.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncher.h	2020-10-22 03:52:50.000000000 +0200
@@ -25,12 +25,18 @@
 
 class FrameBufferBase;
 
-enum class RenderMethod { AUTO = 0,
-                          LEVELSET = 1,
-                          FOG_VOLUME = 2,
-                          GRID = 3,
-                          POINTS = 4,
-                          COUNT = 5 };
+enum class MaterialClass { kAuto = 0,
+                           kLevelSetFast,
+                           kFogVolumePathTracer,
+                           kGrid,
+                           kPointsFast,
+                           kBlackBodyVolumePathTracer,
+                           kFogVolumeFast,
+                           kCameraDiagnostic,
+                           kNumTypes };
+
+extern const char* kMaterialClassTypeStrings[(int)MaterialClass::kNumTypes];
+extern const char* kCameraLensTypeStrings[(int)Camera::LensType::kNumTypes];
 
 class RenderLauncherImplBase
 {
@@ -41,7 +47,7 @@
 
     virtual int getPriority() const { return 0; }
 
-    virtual bool render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& gridHdl, int numAccumulations, const RenderConstants& params, RenderStatistics* stats = nullptr) = 0;
+    virtual bool render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats = nullptr) = 0;
 };
 
 class RenderLauncher
@@ -53,11 +59,11 @@
 
     void setPlatform(int index) { mIndex = std::max(std::min(index, (int)mImpls.size() - 1), 0); }
 
-    bool render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& grid, int numAccumulations, const RenderConstants& params, RenderStatistics* stats);
+    bool render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats);
 
     int size() const { return (int)mImpls.size(); }
 
-    int getPlatformIndexFromName(std::string name) const;
+    int         getPlatformIndexFromName(std::string name) const;
     std::string getNameForPlatformIndex(int i) const;
 
     std::vector<std::string> getPlatformNames() const;
@@ -67,9 +73,7 @@
     std::vector<std::shared_ptr<RenderLauncherImplBase>> mImpls;
 };
 
-inline bool RenderLauncher::render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& gridHdl, int numAccumulations, const RenderConstants& params, RenderStatistics* stats)
+inline bool RenderLauncher::render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats)
 {
-    if (gridHdl.gridMetaData()->activeVoxelCount() == 0)
-        return false;
-    return mImpls[mIndex]->render(method, width, height, imgBuffer, camera, gridHdl, numAccumulations, params, stats);
+    return mImpls[mIndex]->render(method, width, height, imgBuffer, numAccumulations, numGrids, grids, sceneParams, materialParams, stats);
 }
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncherImpl.h nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncherImpl.h
--- nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncherImpl.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncherImpl.h	2020-10-22 03:52:50.000000000 +0200
@@ -22,15 +22,259 @@
 #include <string>
 #include <chrono>
 #include "RenderLauncher.h"
+#include "RenderFogVolumeUtils.h"
+#include "RenderLevelSetUtils.h"
+#include "RenderGridUtils.h"
+#include "RenderPointsUtils.h"
 
 class FrameBufferBase;
 
+template<MaterialClass>
+struct LauncherForType;
+
+inline bool gridIsType(const void* gridPtr, const nanovdb::GridType gridType)
+{
+    if (!gridPtr)
+        return false;
+    auto gridHdl = reinterpret_cast<const nanovdb::GridHandle<>*>(gridPtr);
+    return gridHdl->gridMetaData()->gridType() == gridType;
+}
+
+template<>
+struct LauncherForType<MaterialClass::kGrid>
+{
+    template<typename LauncherT>
+    void operator()(LauncherT launcher, int width, int height, float* imgPtr, int numAccumulations, const GridRenderParameters& gridParams, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams) const
+    {
+        auto gridBounds = gridParams.bounds;
+
+        if (gridBounds.empty()) {
+            launcher.render(width, height, render::RenderEnvRgba32fFn(), imgPtr, numAccumulations, sceneParams, materialParams);
+            return;
+        }
+
+        if (gridIsType(gridParams.gridHandle, nanovdb::GridType::Float)) {
+            auto grid = launcher.template grid<float>(gridParams.gridHandle);
+            launcher.render(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, numAccumulations, grid, sceneParams, materialParams);
+        } else if (gridIsType(gridParams.gridHandle, nanovdb::GridType::Double)) {
+            auto grid = launcher.template grid<double>(gridParams.gridHandle);
+            launcher.render(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, numAccumulations, grid, sceneParams, materialParams);
+        } else if (gridIsType(gridParams.gridHandle, nanovdb::GridType::UInt32)) {
+            auto grid = launcher.template grid<uint32_t>(gridParams.gridHandle);
+            launcher.render(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, numAccumulations, grid, sceneParams, materialParams);
+        } else if (gridIsType(gridParams.gridHandle, nanovdb::GridType::Int64)) {
+            auto grid = launcher.template grid<int64_t>(gridParams.gridHandle);
+            launcher.render(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, numAccumulations, grid, sceneParams, materialParams);
+        } else if (gridIsType(gridParams.gridHandle, nanovdb::GridType::Vec3f)) {
+            auto grid = launcher.template grid<nanovdb::Vec3f>(gridParams.gridHandle);
+            launcher.render(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, numAccumulations, grid, sceneParams, materialParams);
+        } else if (gridIsType(gridParams.gridHandle, nanovdb::GridType::Vec3d)) {
+            auto grid = launcher.template grid<nanovdb::Vec3d>(gridParams.gridHandle);
+            launcher.render(width, height, render::grid::RenderGridRgba32fFn(), imgPtr, numAccumulations, grid, sceneParams, materialParams);
+        } else {
+            launcher.render(width, height, render::RenderEnvRgba32fFn(), imgPtr, numAccumulations, sceneParams, materialParams);
+        }
+    }
+};
+
+template<>
+struct LauncherForType<MaterialClass::kFogVolumePathTracer>
+{
+    template<typename LauncherT>
+    void operator()(LauncherT launcher, int width, int height, float* imgPtr, int numAccumulations, const GridRenderParameters& densityGridParams, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams) const
+    {
+        auto densityBounds = densityGridParams.bounds;
+
+        if (densityBounds.empty()) {
+            launcher.render(width, height, render::RenderEnvRgba32fFn(), imgPtr, numAccumulations, sceneParams, materialParams);
+            return;
+        }
+
+        if (gridIsType(densityGridParams.gridHandle, nanovdb::GridType::Float)) {
+            auto densityGrid = launcher.template grid<float>(densityGridParams.gridHandle);
+            switch (materialParams.interpolationOrder) {
+            default:
+            case 1: launcher.render(width, height, render::fogvolume::RenderVolumeRgba32fFn<float, 1>(), imgPtr, numAccumulations, densityBounds, densityGrid, sceneParams, materialParams); break;
+            case 0: launcher.render(width, height, render::fogvolume::RenderVolumeRgba32fFn<float, 0>(), imgPtr, numAccumulations, densityBounds, densityGrid, sceneParams, materialParams); break;
+            }
+        } else if (gridIsType(densityGridParams.gridHandle, nanovdb::GridType::Double)) {
+            auto densityGrid = launcher.template grid<double>(densityGridParams.gridHandle);
+            switch (materialParams.interpolationOrder) {
+            default:
+            case 1: launcher.render(width, height, render::fogvolume::RenderVolumeRgba32fFn<double, 1>(), imgPtr, numAccumulations, densityBounds, densityGrid, sceneParams, materialParams); break;
+            case 0: launcher.render(width, height, render::fogvolume::RenderVolumeRgba32fFn<double, 0>(), imgPtr, numAccumulations, densityBounds, densityGrid, sceneParams, materialParams); break;
+            }
+        } else if (gridIsType(densityGridParams.gridHandle, nanovdb::GridType::Vec3f)) {
+            auto densityGrid = launcher.template grid<nanovdb::Vec3f>(densityGridParams.gridHandle);
+            switch (materialParams.interpolationOrder) {
+            default:
+            case 1: launcher.render(width, height, render::fogvolume::RenderVolumeRgba32fFn<nanovdb::Vec3f, 1>(), imgPtr, numAccumulations, densityBounds, densityGrid, sceneParams, materialParams); break;
+            case 0: launcher.render(width, height, render::fogvolume::RenderVolumeRgba32fFn<nanovdb::Vec3f, 0>(), imgPtr, numAccumulations, densityBounds, densityGrid, sceneParams, materialParams); break;
+            }
+        } else if (gridIsType(densityGridParams.gridHandle, nanovdb::GridType::Vec3d)) {
+            auto densityGrid = launcher.template grid<nanovdb::Vec3d>(densityGridParams.gridHandle);
+            switch (materialParams.interpolationOrder) {
+            default:
+            case 1: launcher.render(width, height, render::fogvolume::RenderVolumeRgba32fFn<nanovdb::Vec3d, 1>(), imgPtr, numAccumulations, densityBounds, densityGrid, sceneParams, materialParams); break;
+            case 0: launcher.render(width, height, render::fogvolume::RenderVolumeRgba32fFn<nanovdb::Vec3d, 0>(), imgPtr, numAccumulations, densityBounds, densityGrid, sceneParams, materialParams); break;
+            }
+        } else {
+            launcher.render(width, height, render::RenderEnvRgba32fFn(), imgPtr, numAccumulations, sceneParams, materialParams);
+        }
+    }
+};
+
+template<>
+struct LauncherForType<MaterialClass::kBlackBodyVolumePathTracer>
+{
+    template<typename LauncherT>
+    void operator()(LauncherT launcher, int width, int height, float* imgPtr, int numAccumulations, const GridRenderParameters& densityGridParams, const GridRenderParameters& temperatureGridParams, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams) const
+    {
+        auto densityBounds = densityGridParams.bounds;
+
+        if (densityBounds.empty()) {
+            launcher.render(width, height, render::RenderEnvRgba32fFn(), imgPtr, numAccumulations, sceneParams, materialParams);
+            return;
+        }
+
+        if (gridIsType(densityGridParams.gridHandle, nanovdb::GridType::Float)) {
+            auto densityGrid = launcher.template grid<float>(densityGridParams.gridHandle);
+            auto temperatureGrid = launcher.template grid<float>(temperatureGridParams.gridHandle);
+            switch (materialParams.interpolationOrder) {
+            default:
+            case 1: launcher.render(width, height, render::fogvolume::RenderBlackBodyVolumeRgba32fFn<float, 1>(), imgPtr, numAccumulations, densityBounds, densityGrid, temperatureGrid, sceneParams, materialParams); break;
+            case 0: launcher.render(width, height, render::fogvolume::RenderBlackBodyVolumeRgba32fFn<float, 0>(), imgPtr, numAccumulations, densityBounds, densityGrid, temperatureGrid, sceneParams, materialParams); break;
+            }
+        } else if (gridIsType(densityGridParams.gridHandle, nanovdb::GridType::Double)) {
+            auto densityGrid = launcher.template grid<double>(densityGridParams.gridHandle);
+            auto temperatureGrid = launcher.template grid<double>(temperatureGridParams.gridHandle);
+            switch (materialParams.interpolationOrder) {
+            default:
+            case 1: launcher.render(width, height, render::fogvolume::RenderBlackBodyVolumeRgba32fFn<double, 1>(), imgPtr, numAccumulations, densityBounds, densityGrid, temperatureGrid, sceneParams, materialParams); break;
+            case 0: launcher.render(width, height, render::fogvolume::RenderBlackBodyVolumeRgba32fFn<double, 0>(), imgPtr, numAccumulations, densityBounds, densityGrid, temperatureGrid, sceneParams, materialParams); break;
+            }
+        } else {
+            launcher.render(width, height, render::RenderEnvRgba32fFn(), imgPtr, numAccumulations, sceneParams, materialParams);
+        }
+    }
+};
+
+template<>
+struct LauncherForType<MaterialClass::kFogVolumeFast>
+{
+    template<typename LauncherT>
+    void operator()(LauncherT launcher, int width, int height, float* imgPtr, int numAccumulations, const GridRenderParameters& densityGridParams, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams) const
+    {
+        auto densityBounds = densityGridParams.bounds;
+
+        if (densityBounds.empty()) {
+            launcher.render(width, height, render::RenderEnvRgba32fFn(), imgPtr, numAccumulations, sceneParams, materialParams);
+            return;
+        }
+
+        if (gridIsType(densityGridParams.gridHandle, nanovdb::GridType::Float)) {
+            auto densityGrid = launcher.template grid<float>(densityGridParams.gridHandle);
+            launcher.render(width, height, render::fogvolume::FogVolumeFastRenderFn(), imgPtr, numAccumulations, densityBounds, densityGrid, sceneParams, materialParams);
+        } else if (gridIsType(densityGridParams.gridHandle, nanovdb::GridType::Double)) {
+            auto densityGrid = launcher.template grid<double>(densityGridParams.gridHandle);
+            launcher.render(width, height, render::fogvolume::FogVolumeFastRenderFn(), imgPtr, numAccumulations, densityBounds, densityGrid, sceneParams, materialParams);
+        } else {
+            launcher.render(width, height, render::RenderEnvRgba32fFn(), imgPtr, numAccumulations, sceneParams, materialParams);
+        }
+    }
+};
+
+template<>
+struct LauncherForType<MaterialClass::kLevelSetFast>
+{
+    template<typename LauncherT>
+    void operator()(LauncherT launcher, int width, int height, float* imgPtr, int numAccumulations, const GridRenderParameters& gridParams, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams) const
+    {
+        auto gridBounds = gridParams.bounds;
+
+        if (gridBounds.empty()) {
+            launcher.render(width, height, render::RenderEnvRgba32fFn(), imgPtr, numAccumulations, sceneParams, materialParams);
+            return;
+        }
+
+        if (gridIsType(gridParams.gridHandle, nanovdb::GridType::Float)) {
+            auto lsGrid = launcher.template grid<float>(gridParams.gridHandle);
+            switch (materialParams.interpolationOrder) {
+            default:
+            case 1: launcher.render(width, height, render::levelset::RenderLevelSetRgba32fFn<float, 1>(), imgPtr, numAccumulations, gridBounds, lsGrid, sceneParams, materialParams); break;
+            case 0: launcher.render(width, height, render::levelset::RenderLevelSetRgba32fFn<float, 0>(), imgPtr, numAccumulations, gridBounds, lsGrid, sceneParams, materialParams); break;
+            }
+        } else if (gridIsType(gridParams.gridHandle, nanovdb::GridType::Double)) {
+            auto lsGrid = launcher.template grid<double>(gridParams.gridHandle);
+            switch (materialParams.interpolationOrder) {
+            default:
+            case 1: launcher.render(width, height, render::levelset::RenderLevelSetRgba32fFn<double, 1>(), imgPtr, numAccumulations, gridBounds, lsGrid, sceneParams, materialParams); break;
+            case 0: launcher.render(width, height, render::levelset::RenderLevelSetRgba32fFn<double, 0>(), imgPtr, numAccumulations, gridBounds, lsGrid, sceneParams, materialParams); break;
+            }
+        } else {
+            launcher.render(width, height, render::RenderEnvRgba32fFn(), imgPtr, numAccumulations, sceneParams, materialParams);
+        }
+    }
+};
+
+template<>
+struct LauncherForType<MaterialClass::kPointsFast>
+{
+    template<typename LauncherT>
+    void operator()(LauncherT launcher, int width, int height, float* imgPtr, int numAccumulations, const GridRenderParameters& gridParams, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams) const
+    {
+        auto gridBounds = gridParams.bounds;
+
+        if (gridBounds.empty()) {
+            launcher.render(width, height, render::RenderEnvRgba32fFn(), imgPtr, numAccumulations, sceneParams, materialParams);
+            return;
+        }
+
+        if (gridIsType(gridParams.gridHandle, nanovdb::GridType::UInt32)) {
+            auto pointGrid = launcher.template grid<uint32_t>(gridParams.gridHandle);
+            launcher.render(width, height, render::points::RenderPointsRgba32fFn(), imgPtr, numAccumulations, pointGrid, sceneParams, materialParams);
+        } else {
+            launcher.render(width, height, render::RenderEnvRgba32fFn(), imgPtr, numAccumulations, sceneParams, materialParams);
+        }
+    }
+};
+
+template<>
+struct LauncherForType<MaterialClass::kCameraDiagnostic>
+{
+    template<typename LauncherT>
+    void operator()(LauncherT launcher, int width, int height, float* imgPtr, int numAccumulations, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams) const
+    {
+        launcher.render(width, height, render::CameraDiagnosticRenderer(), imgPtr, numAccumulations, sceneParams, materialParams);
+    }
+};
+
+template<typename LauncherT>
+void launchRender(LauncherT& methodLauncher, MaterialClass method, int width, int height, float* imgPtr, int numAccumulations, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams)
+{
+    if (method == MaterialClass::kGrid) {
+        LauncherForType<MaterialClass::kGrid>()(methodLauncher, width, height, imgPtr, numAccumulations, grids[0], sceneParams, materialParams);
+    } else if (method == MaterialClass::kFogVolumePathTracer) {
+        LauncherForType<MaterialClass::kFogVolumePathTracer>()(methodLauncher, width, height, imgPtr, numAccumulations, grids[0], sceneParams, materialParams);
+    } else if (method == MaterialClass::kLevelSetFast) {
+        LauncherForType<MaterialClass::kLevelSetFast>()(methodLauncher, width, height, imgPtr, numAccumulations, grids[0], sceneParams, materialParams);
+    } else if (method == MaterialClass::kPointsFast) {
+        LauncherForType<MaterialClass::kPointsFast>()(methodLauncher, width, height, imgPtr, numAccumulations, grids[0], sceneParams, materialParams);
+    } else if (method == MaterialClass::kBlackBodyVolumePathTracer) {
+        LauncherForType<MaterialClass::kBlackBodyVolumePathTracer>()(methodLauncher, width, height, imgPtr, numAccumulations, grids[0], grids[1], sceneParams, materialParams);
+    } else if (method == MaterialClass::kFogVolumeFast) {
+        LauncherForType<MaterialClass::kFogVolumeFast>()(methodLauncher, width, height, imgPtr, numAccumulations, grids[0], sceneParams, materialParams);
+    } else if (method == MaterialClass::kCameraDiagnostic) {
+        LauncherForType<MaterialClass::kCameraDiagnostic>()(methodLauncher, width, height, imgPtr, numAccumulations, sceneParams, materialParams);
+    }
+}
+
 class RenderLauncherCpu : public RenderLauncherImplBase
 {
 public:
     using RenderLauncherImplBase::render;
 
-    bool render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& gridHdl, int numAccumulations, const RenderConstants& params, RenderStatistics* stats) override;
+    bool render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats) override;
 
     std::string name() const override { return "host"; }
 
@@ -42,7 +286,7 @@
 public:
     using RenderLauncherImplBase::render;
 
-    bool render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& gridHdl, int numAccumulations, const RenderConstants& params, RenderStatistics* stats) override;
+    bool render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats) override;
 
     std::string name() const override { return "host-mt"; }
 
@@ -55,7 +299,7 @@
 public:
     using RenderLauncherImplBase::render;
 
-    bool render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& gridHdl, int numAccumulations, const RenderConstants& params, RenderStatistics* stats) override;
+    bool render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats) override;
 
     std::string name() const override { return "cuda"; }
 
@@ -63,22 +307,30 @@
 
     ~RenderLauncherCUDA() override;
 
-private:
-    struct Resource
+public:
+    struct GridResource
+    {
+        bool                                  mInitialized = false;
+        std::chrono::steady_clock::time_point mLastUsedTime;
+        void*                                 mDeviceGrid = nullptr;
+    };
+
+    struct ImageResource
     {
         bool   mInitialized = false;
-        void*  mDeviceGrid = nullptr;
         bool   mGlTextureResourceCUDAError = false;
         void*  mGlTextureResourceCUDA = nullptr;
         size_t mGlTextureResourceSize = 0;
         int    mGlTextureResourceId = 0;
     };
 
-    std::shared_ptr<Resource> ensureResource(const nanovdb::GridHandle<>* gridHdl);
-    void*                     mapCUDA(int access, const std::shared_ptr<Resource>& resource, FrameBufferBase* imgBuffer, void* stream = 0);
-    void                      unmapCUDA(const std::shared_ptr<Resource>& resource, FrameBufferBase* imgBuffer, void* stream = 0);
+    std::shared_ptr<ImageResource> ensureImageResource();
+    std::shared_ptr<GridResource>  ensureGridResource(const nanovdb::GridHandle<>* gridHdl);
+    void*                          mapCUDA(int access, const std::shared_ptr<ImageResource>& resource, FrameBufferBase* imgBuffer, void* stream = 0);
+    void                           unmapCUDA(const std::shared_ptr<ImageResource>& resource, FrameBufferBase* imgBuffer, void* stream = 0);
 
-    std::map<const void*, std::shared_ptr<Resource>> mResources;
+    std::shared_ptr<ImageResource>                       mImageResource;
+    std::map<const void*, std::shared_ptr<GridResource>> mGridResources;
 };
 #endif
 
@@ -88,7 +340,7 @@
 public:
     using RenderLauncherImplBase::render;
 
-    bool render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& gridHdl, int numAccumulations, const RenderConstants& params, RenderStatistics* stats) override;
+    bool render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats) override;
 
     std::string name() const override { return "optix"; }
 
@@ -101,16 +353,16 @@
     {
         ~Resource();
 
-        bool         mInitialized = false;
-        void*        mDeviceGrid = nullptr;
-        void*        mGlTextureResourceCUDA = nullptr;
-        size_t       mGlTextureResourceSize = 0;
-        int          mGlTextureResourceId = 0;
-        void*        mOptixRenderState = nullptr;
-        RenderMethod mRenderMethod = RenderMethod::AUTO;
+        bool          mInitialized = false;
+        void*         mDeviceGrid = nullptr;
+        void*         mGlTextureResourceCUDA = nullptr;
+        size_t        mGlTextureResourceSize = 0;
+        int           mGlTextureResourceId = 0;
+        void*         mOptixRenderState = nullptr;
+        MaterialClass mMaterialClass = MaterialClass::kAuto;
     };
 
-    std::shared_ptr<Resource> ensureResource(const nanovdb::GridHandle<>& gridHdl, RenderMethod renderMethod);
+    std::shared_ptr<Resource> ensureResource(const nanovdb::GridHandle<>& gridHdl, MaterialClass renderMethod);
     void*                     mapCUDA(int access, const std::shared_ptr<Resource>& resource, FrameBufferBase* imgBuffer, void* stream = 0);
     void                      unmapCUDA(const std::shared_ptr<Resource>& resource, FrameBufferBase* imgBuffer, void* stream = 0);
 
@@ -124,7 +376,7 @@
 public:
     using RenderLauncherImplBase::render;
 
-    bool render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& gridHdl, int numAccumulations, const RenderConstants& params, RenderStatistics* stats) override;
+    bool render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats) override;
 
     std::string name() const override { return "opencl"; }
 
@@ -167,7 +419,7 @@
 public:
     using RenderLauncherImplBase::render;
 
-    bool render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& gridHdl, int numAccumulations, const RenderConstants& params, RenderStatistics* stats) override;
+    bool render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats) override;
 
     std::string name() const override { return "glsl"; }
 
@@ -178,17 +430,17 @@
 private:
     struct Resource
     {
-        bool         mInitialized = false;
-        RenderMethod mMethod = RenderMethod::AUTO;
-        uint32_t     mBufferId = 0;
-        uint32_t     mUniformBufferId = 0;
-        uint32_t     mUniformBufferSize = 0;
-        uint32_t     mProgramId = 0;
-        uint32_t     mUniformBufferBindIndex = 0;
+        bool          mInitialized = false;
+        MaterialClass mMethod = MaterialClass::kAuto;
+        uint32_t      mBufferId = 0;
+        uint32_t      mUniformBufferId = 0;
+        uint32_t      mUniformBufferSize = 0;
+        uint32_t      mProgramId = 0;
+        uint32_t      mUniformBufferBindIndex = 0;
     };
 
-    std::shared_ptr<Resource> ensureResource(const nanovdb::GridHandle<>& gridHdl, void* glContext, void* glDisplay, RenderMethod method);
-    bool                      ensureProgramResource(const std::shared_ptr<Resource>& resource, std::string valueType, RenderMethod method);
+    std::shared_ptr<Resource> ensureResource(const nanovdb::GridHandle<>& gridHdl, void* glContext, void* glDisplay, MaterialClass method);
+    bool                      ensureProgramResource(const std::shared_ptr<Resource>& resource, std::string valueType, MaterialClass method);
     bool                      ensureGridResource(const std::shared_ptr<Resource>& resource, const nanovdb::NanoGrid<float>* grid, size_t gridByteSize);
 
     std::map<const nanovdb::GridHandle<>*, std::shared_ptr<Resource>> mResources;
@@ -200,7 +452,7 @@
 public:
     using RenderLauncherImplBase::render;
 
-    bool render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& gridHdl, int numAccumulations, const RenderConstants& params, RenderStatistics* stats) override;
+    bool render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats) override;
 
     std::string name() const override { return "host-c99"; }
 
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncherOptix.cpp nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncherOptix.cpp
--- nanovdb-20200925/nanovdb/cmd/viewer/RenderLauncherOptix.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/RenderLauncherOptix.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -57,9 +57,9 @@
     T data;
 };
 
-typedef Record<Camera<float>> RayGenRecord;
-typedef Record<MissData>      MissRecord;
-typedef Record<HitGroupData>  HitGroupRecord;
+typedef Record<Camera>       RayGenRecord;
+typedef Record<MissData>     MissRecord;
+typedef Record<HitGroupData> HitGroupRecord;
 
 struct RenderState
 {
@@ -467,7 +467,7 @@
     state.raygen_prog_group = cam_prog_group;
 }
 
-static void createVolumeProgram(RenderMethod renderMethod, RenderState& state, std::vector<OptixProgramGroup>& program_groups)
+static void createVolumeProgram(MaterialClass renderMethod, RenderState& state, std::vector<OptixProgramGroup>& program_groups)
 {
     char   log[2048];
     size_t sizeof_log = sizeof(log);
@@ -481,11 +481,11 @@
         radiance_prog_group_desc.hitgroup.moduleCH = state.shading_module;
         radiance_prog_group_desc.hitgroup.moduleAH = nullptr;
 
-        if (renderMethod == RenderMethod::LEVELSET) {
+        if (renderMethod == MaterialClass::kLevelSetFast) {
             radiance_prog_group_desc.hitgroup.entryFunctionNameIS = "__intersection__nanovdb_levelset";
             radiance_prog_group_desc.hitgroup.entryFunctionNameCH = "__closesthit__nanovdb_levelset_radiance";
             radiance_prog_group_desc.hitgroup.entryFunctionNameAH = nullptr;
-        } else if (renderMethod == RenderMethod::FOG_VOLUME) {
+        } else if (renderMethod == MaterialClass::kFogVolumePathTracer) {
             radiance_prog_group_desc.hitgroup.entryFunctionNameIS = "__intersection__nanovdb_fogvolume";
             radiance_prog_group_desc.hitgroup.entryFunctionNameCH = "__closesthit__nanovdb_fogvolume_radiance";
             radiance_prog_group_desc.hitgroup.entryFunctionNameAH = nullptr;
@@ -518,13 +518,13 @@
         occlusion_prog_group_desc.hitgroup.entryFunctionNameCH = nullptr;
         occlusion_prog_group_desc.hitgroup.entryFunctionNameAH = nullptr;
 
-        if (renderMethod == RenderMethod::LEVELSET) {
+        if (renderMethod == MaterialClass::kLevelSetFast) {
             occlusion_prog_group_desc.hitgroup.entryFunctionNameIS = "__intersection__nanovdb_levelset";
-        } else if (renderMethod == RenderMethod::FOG_VOLUME) {
+        } else if (renderMethod == MaterialClass::kFogVolumePathTracer) {
             occlusion_prog_group_desc.hitgroup.entryFunctionNameIS = "__intersection__nanovdb_fogvolume";
             occlusion_prog_group_desc.hitgroup.moduleCH = state.shading_module;
             occlusion_prog_group_desc.hitgroup.entryFunctionNameCH = "__closesthit__nanovdb_fogvolume_occlusion";
-        } else if (renderMethod == RenderMethod::GRID) {
+        } else {
             occlusion_prog_group_desc.hitgroup.entryFunctionNameIS = "__intersection__nanovdb_grid";
         }
 
@@ -536,7 +536,7 @@
     }
 }
 
-static void createMissProgram(RenderMethod renderMethod, RenderState& state, std::vector<OptixProgramGroup>& program_groups)
+static void createMissProgram(MaterialClass renderMethod, RenderState& state, std::vector<OptixProgramGroup>& program_groups)
 {
     char   log[2048];
     size_t sizeof_log = sizeof(log);
@@ -553,10 +553,12 @@
 
         miss_prog_group_desc.kind = OPTIX_PROGRAM_GROUP_KIND_MISS;
         miss_prog_group_desc.miss.module = state.shading_module;
-        if (renderMethod == RenderMethod::LEVELSET || renderMethod == RenderMethod::GRID) {
+        if (renderMethod == MaterialClass::kLevelSetFast || renderMethod == MaterialClass::kGrid) {
             miss_prog_group_desc.miss.entryFunctionName = "__miss__levelset_radiance";
-        } else if (renderMethod == RenderMethod::FOG_VOLUME) {
+        } else if (renderMethod == MaterialClass::kFogVolumeFast || renderMethod == MaterialClass::kFogVolumePathTracer || renderMethod == MaterialClass::kBlackBodyVolumePathTracer) {
             miss_prog_group_desc.miss.entryFunctionName = "__miss__fogvolume_radiance";
+        } else {
+            miss_prog_group_desc.miss.entryFunctionName = "__miss__env_radiance";
         }
 
         OPTIX_CHECK_LOG(optixProgramGroupCreate(state.context,
@@ -592,7 +594,7 @@
     }
 }
 
-void createPipeline(RenderMethod renderMethod, RenderState& state)
+void createPipeline(MaterialClass renderMethod, RenderState& state)
 {
     std::vector<OptixProgramGroup> program_groups;
 
@@ -602,7 +604,7 @@
     state.pipeline_compile_options.numPayloadValues = 3;
     state.pipeline_compile_options.numAttributeValues = 6;
     state.pipeline_compile_options.exceptionFlags = OPTIX_EXCEPTION_FLAG_NONE;
-    state.pipeline_compile_options.pipelineLaunchParamsVariableName = "params";
+    state.pipeline_compile_options.pipelineLaunchParamsVariableName = "constantParams";
 
     // Prepare program groups
     createModules(state);
@@ -627,7 +629,7 @@
                                         &state.pipeline));
 }
 
-void syncCameraDataToSbt(RenderState& state, const Camera<float>& camera)
+void syncCameraDataToSbt(RenderState& state, const Camera& camera)
 {
     RayGenRecord rg_sbt;
 
@@ -713,7 +715,6 @@
     state.params.numAccumulations = 0u;
     state.params.maxDepth = g_sMaxTrace;
     state.params.sceneEpsilon = 1.e-4f;
-    state.params.constants = RenderConstants();
 
     NANOVDB_CUDA_SAFE_CALL(cudaStreamCreate(&state.stream));
     NANOVDB_CUDA_SAFE_CALL(cudaMalloc(reinterpret_cast<void**>(&state.d_params), sizeof(Params)));
@@ -732,40 +733,25 @@
     cudaFree(mDeviceGrid);
 }
 
-std::shared_ptr<RenderLauncherOptix::Resource> RenderLauncherOptix::ensureResource(const nanovdb::GridHandle<>& gridHdl, RenderMethod renderMethod)
+std::shared_ptr<RenderLauncherOptix::Resource> RenderLauncherOptix::ensureResource(const nanovdb::GridHandle<>& gridHdl, MaterialClass renderMethod)
 {
-    auto realRenderMethod = renderMethod;
-    if (renderMethod == RenderMethod::AUTO) {
-        if (gridHdl.gridMetaData()->isFogVolume())
-            renderMethod = RenderMethod::FOG_VOLUME;
-        else if (gridHdl.gridMetaData()->isLevelSet())
-            renderMethod = RenderMethod::LEVELSET;
-        else if (gridHdl.gridMetaData()->isPointIndex())
-            renderMethod = RenderMethod::POINTS;
-        else if (gridHdl.gridMetaData()->isPointData())
-            renderMethod = RenderMethod::POINTS;
-        else
-            renderMethod = RenderMethod::GRID;
-    }
+    assert(renderMethod != MaterialClass::kAuto);
 
     std::shared_ptr<Resource> resource;
     auto                      it = mResources.find(&gridHdl);
-    if (it != mResources.end() && it->second->mRenderMethod == realRenderMethod) {
+    if (it != mResources.end() && it->second->mMaterialClass == renderMethod) {
         resource = it->second;
     } else {
         std::cout << "Initializing OptiX renderer..." << std::endl;
 
         resource = std::make_shared<Resource>();
-        resource->mRenderMethod = realRenderMethod;
+        resource->mMaterialClass = renderMethod;
 
         if (it != mResources.end())
             mResources.erase(it);
 
         mResources.insert(std::make_pair(&gridHdl, resource));
 
-        if (!(gridHdl.gridMetaData()->isLevelSet() || gridHdl.gridMetaData()->isFogVolume()))
-            return nullptr;
-
         NANOVDB_CUDA_SAFE_CALL(cudaMalloc((void**)&resource->mDeviceGrid, gridHdl.size()));
         NANOVDB_CUDA_SAFE_CALL(cudaMemcpy(resource->mDeviceGrid, gridHdl.data(), gridHdl.size(), cudaMemcpyHostToDevice));
 
@@ -840,12 +826,14 @@
         std::cout << "BVH contains " << aabbs.size() << " AABBs" << std::endl;
 
         createContext(state);
-        createGeometry(aabbs, d_boundingBoxes, state);
+
+        if (aabbs.size() > 0) {
+            createGeometry(aabbs, d_boundingBoxes, state);
+        }
+
         createPipeline(renderMethod, state);
         createSBT(volume_geometry, volume_material, state);
-
         initLaunchParams(state);
-
         resource->mOptixRenderState = rs;
         resource->mInitialized = true;
     }
@@ -944,8 +932,13 @@
     return imgBuffer->cudaMap(FrameBufferBase::AccessType(access));
 }
 
-bool RenderLauncherOptix::render(RenderMethod method, int width, int height, FrameBufferBase* imgBuffer, Camera<float> camera, const nanovdb::GridHandle<>& gridHdl, int numAccumulations, const RenderConstants& params, RenderStatistics* stats)
+bool RenderLauncherOptix::render(MaterialClass method, int width, int height, FrameBufferBase* imgBuffer, int numAccumulations, int numGrids, const GridRenderParameters* grids, const SceneRenderParameters& sceneParams, const MaterialParameters& materialParams, RenderStatistics* stats)
 {
+    if (grids[0].gridHandle == nullptr)
+        return false;
+
+    auto& gridHdl = *reinterpret_cast<const nanovdb::GridHandle<>*>(grids[0].gridHandle);
+
     auto resource = ensureResource(gridHdl, method);
     if (!resource || !resource->mInitialized)
         return false;
@@ -963,13 +956,14 @@
 
     auto& optixRenderState = *reinterpret_cast<RenderState*>(resource->mOptixRenderState);
 
-    syncCameraDataToSbt(optixRenderState, camera);
+    syncCameraDataToSbt(optixRenderState, sceneParams.camera);
 
     optixRenderState.params.width = width;
     optixRenderState.params.height = height;
     optixRenderState.params.imgBuffer = (float4*)imgPtr;
     optixRenderState.params.numAccumulations = numAccumulations;
-    optixRenderState.params.constants = params;
+    optixRenderState.params.materialConstants = materialParams;
+    optixRenderState.params.sceneConstants = sceneParams;
 
     NANOVDB_CUDA_SAFE_CALL(cudaMemcpyAsync(
         reinterpret_cast<void*>(optixRenderState.d_params), &optixRenderState.params, sizeof(Params), cudaMemcpyHostToDevice, optixRenderState.stream));
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/RenderLevelSetUtils.h nanovdb-20201022/nanovdb/cmd/viewer/RenderLevelSetUtils.h
--- nanovdb-20200925/nanovdb/cmd/viewer/RenderLevelSetUtils.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/RenderLevelSetUtils.h	2020-10-22 03:52:50.000000000 +0200
@@ -11,6 +11,8 @@
 	\brief General C++ implementation of the LevelSet rendering code.
 */
 
+#pragma once
+
 #include <nanovdb/NanoVDB.h>
 #include <nanovdb/util/HDDA.h>
 #include <nanovdb/util/Ray.h>
@@ -20,6 +22,7 @@
 namespace render {
 namespace levelset {
 
+template<typename ValueT, int InterpolationOrder>
 struct RenderLevelSetRgba32fFn
 {
     using RealT = float;
@@ -27,169 +30,142 @@
     using CoordT = nanovdb::Coord;
     using RayT = nanovdb::Ray<RealT>;
 
-    template<typename ValueT>
-    inline __hostdev__ void operator()(int ix, int iy, int width, int height, float* imgBuffer, Camera<float> camera, const nanovdb::NanoGrid<ValueT>* grid, int numAccumulations, const RenderConstants params) const
+    inline __hostdev__ void operator()(int ix, int iy, int width, int height, float* imgBuffer, int numAccumulations, const nanovdb::BBoxR proxy, const nanovdb::NanoGrid<ValueT>* grid, const SceneRenderParameters sceneParams, const MaterialParameters params) const
     {
         auto outPixel = &imgBuffer[4 * (ix + width * iy)];
 
-        const Vec3T wLightDir = Vec3T(0, 1, 0);
-        const Vec3T iLightDir = grid->worldToIndexDirF(wLightDir).normalize();
-
-        const auto& tree = grid->tree();
-        auto        acc = tree.getAccessor();
-
         float color[4] = {0, 0, 0, 0};
 
-        for (int sampleIndex = 0; sampleIndex < params.samplesPerPixel; ++sampleIndex) {
-            uint32_t pixelSeed = hash(sampleIndex + numAccumulations * params.samplesPerPixel ^ hash(ix, iy));
-
-            float randVar1 = randomf(pixelSeed + 0);
-            float randVar2 = randomf(pixelSeed + 1);
-
-            float u = ix + 0.5f;
-            float v = iy + 0.5f;
+        if (!grid) {
+            RayT wRay = getRayFromPixelCoord(ix, iy, width, height, sceneParams);
 
-            if (numAccumulations > 0) {
-#if 1
-                float jitterX, jitterY;
-                cmj(jitterX, jitterY, numAccumulations % 64, 8, 8, pixelSeed);
-                u += jitterX - 0.5f;
-                v += jitterY - 0.5f;
-#else
-                u += randVar1 - 0.5f;
-                v += randVar2 - 0.5f;
-#endif
-            }
-
-            u /= width;
-            v /= height;
-
-            RayT wRay = camera.getRay(u, v);
-            RayT iRay = wRay.worldToIndexF(*grid);
-
-            Vec3T iRayDir = iRay.dir();
-            Vec3T wRayDir = wRay.dir();
-            Vec3T wRayEye = wRay.eye();
-
-            CoordT ijk;
-            float  v0 = 0.0f;
-            float  t;
-            if (nanovdb::ZeroCrossing(iRay, acc, ijk, v0, t)) {
-                Vec3T iPrimaryPos = Vec3T(RealT(ijk[0]), RealT(ijk[1]), RealT(ijk[2]));
-                Vec3T wPrimaryPos = grid->indexToWorldF(iPrimaryPos);
-
-                Vec3T iNormal(-v0);
-                ijk[0] += 1;
-                iNormal[0] += acc.getValue(ijk);
-                ijk[0] -= 1;
-                ijk[1] += 1;
-                iNormal[1] += acc.getValue(ijk);
-                ijk[1] -= 1;
-                ijk[2] += 1;
-                iNormal[2] += acc.getValue(ijk);
-                iNormal.normalize();
-
-                Vec3T iSurfacePos = iPrimaryPos + iNormal * 2.0f;
-
-                Vec3T intensity = Vec3T(1);
-                float occlusion = 0.0f;
-
-                if (params.useOcclusion > 0) {
-                    RayT iOccRay(iSurfacePos, lambertNoTangent(iNormal, randVar1, randVar2));
-                    if (nanovdb::ZeroCrossing(iOccRay, acc, ijk, v0, t))
-                        occlusion = params.useOcclusion;
-                    intensity = Vec3T(1.0f - occlusion);
-                }
+            auto envRadiance = traceEnvironment(wRay, sceneParams);
 
-                if (params.useLighting > 0) {
-                    Vec3T diffuseKey = Vec3T(1);
-                    Vec3T diffuseFill = Vec3T(1);
-                    float ambient = 1.0f;
-                    float specularKey = 0.f;
-                    float shadowFactor = 0.0f;
-
-                    Vec3T H = (iLightDir + -iRayDir).normalize();
-                    specularKey = powf(fmaxf(0.0f, iNormal.dot(H)), 10.f);
-                    const float diffuseWrap = 0.25f;
-                    diffuseKey *= fmaxf(0.0f, (iNormal.dot(iLightDir) + diffuseWrap) / (1.0f + diffuseWrap));
-                    diffuseFill *= fmaxf(0.0f, iNormal.dot(-iRayDir));
-
-                    if (params.useShadows > 0) {
-                        RayT iShadowRay(iSurfacePos, iLightDir);
-                        if (nanovdb::ZeroCrossing(iShadowRay, acc, ijk, v0, t))
-                            shadowFactor = params.useShadows;
+            color[0] = envRadiance;
+            color[1] = envRadiance;
+            color[2] = envRadiance;
+
+        } else {
+            const Vec3T wLightDir = Vec3T(0, 1, 0);
+            const Vec3T iLightDir = grid->worldToIndexDirF(wLightDir).normalize();
+
+            const auto& tree = grid->tree();
+            const auto  acc = tree.getAccessor();
+            const auto  sampler = nanovdb::createSampler<0, decltype(acc), false>(acc);
+
+            for (int sampleIndex = 0; sampleIndex < sceneParams.samplesPerPixel; ++sampleIndex) {
+                uint32_t pixelSeed = hash((sampleIndex + (numAccumulations + 1) * sceneParams.samplesPerPixel)) ^ hash(ix, iy);
+
+                RayT wRay = getRayFromPixelCoord(ix, iy, width, height, numAccumulations, sceneParams.samplesPerPixel, pixelSeed, sceneParams);
+
+                RayT  iRay = wRay.worldToIndexF(*grid);
+
+                CoordT ijk;
+                ValueT v0 = 0.0f;
+                float  t;
+                if (nanovdb::ZeroCrossing(iRay, acc, ijk, v0, t)) {
+                    Vec3T iPrimaryPos = Vec3T(RealT(ijk[0]), RealT(ijk[1]), RealT(ijk[2]));
+                    Vec3T wPrimaryPos = grid->indexToWorldF(iPrimaryPos);
+
+                    Vec3T iNormal((float)-v0);
+                    ijk[0] += 1;
+                    iNormal[0] += (float)acc.getValue(ijk);
+                    ijk[0] -= 1;
+                    ijk[1] += 1;
+                    iNormal[1] += (float)acc.getValue(ijk);
+                    ijk[1] -= 1;
+                    ijk[2] += 1;
+                    iNormal[2] += (float)acc.getValue(ijk);
+                    iNormal.normalize();
+
+                    Vec3T iSurfacePos = iPrimaryPos + iNormal * 2.0f;
+
+                    Vec3T intensity = Vec3T(1);
+                    float occlusion = 0.0f;
+
+                    if (params.useOcclusion > 0) {
+                        RayT iOccRay(iSurfacePos, lambertNoTangent(iNormal, randomXorShift(pixelSeed), randomXorShift(pixelSeed)));
+                        if (nanovdb::ZeroCrossing(iOccRay, acc, ijk, v0, t))
+                            occlusion = 1;
+                        intensity = Vec3T(1.0f - occlusion);
                     }
 
-                    intensity = params.useLighting * ((1.0f - shadowFactor) * (Vec3T(specularKey * 0.2f) + (diffuseKey * 0.8f)) + (1.0f - occlusion) * (diffuseFill * 0.2f + Vec3T(ambient * 0.1f)));
-                    intensity = intensity + Vec3T((1.0f - params.useLighting) * (1.0f - occlusion));
-                }
-
-                color[0] += intensity[0];
-                color[1] += intensity[1];
-                color[2] += intensity[2];
-            } else {
-                float groundIntensity = 0.0f;
-                float groundMix = 0.0f;
-
-                if (params.useGround > 0) {
-                    float wGroundT = (params.groundHeight - wRayEye[1]) / wRayDir[1];
-                    if (wGroundT > 0.f) {
-                        const Vec3T wGroundPos = wRayEye + wGroundT * wRayDir;
-                        const Vec3T iGroundPos = grid->worldToIndexF(wGroundPos);
-                        const Vec3T iGroundNormal = Vec3T(0,1,0);
-
-                        rayTraceGround(wGroundT, params.groundFalloff, wGroundPos, wRayDir[1], groundIntensity, groundMix);
-
-                        groundMix *= params.useGround;
-
-                        if (params.useOcclusion > 0) {
-                            RayT iOccRay(iGroundPos, lambertNoTangent(iGroundNormal, randVar1, randVar2));
-                            if (nanovdb::ZeroCrossing(iOccRay, acc, ijk, v0, t))
-                                groundIntensity = groundIntensity * (1.0f - params.useOcclusion);
-                        }
+                    if (sceneParams.useLighting) {
+                        Vec3T diffuseKey = Vec3T(1);
+                        Vec3T diffuseFill = Vec3T(1);
+                        float ambient = 1.0f;
+                        float specularKey = 0.f;
+                        float shadowFactor = 0.0f;
+
+                        Vec3T H = (iLightDir + -iRay.dir()).normalize();
+                        specularKey = powf(fmaxf(0.0f, iNormal.dot(H)), 10.f);
+                        const float diffuseWrap = 0.25f;
+                        diffuseKey *= fmaxf(0.0f, (iNormal.dot(iLightDir) + diffuseWrap) / (1.0f + diffuseWrap));
+                        diffuseFill *= fmaxf(0.0f, iNormal.dot(-iRay.dir()));
 
-                        if (params.useShadows > 0) {
-                            RayT iShadowRay(iGroundPos, iLightDir);
+                        if (sceneParams.useShadows) {
+                            RayT iShadowRay(iSurfacePos, iLightDir);
                             if (nanovdb::ZeroCrossing(iShadowRay, acc, ijk, v0, t))
-                                groundIntensity = groundIntensity - params.useShadows * groundIntensity;
+                                shadowFactor = 1.f;
                         }
 
-                        if (params.useGroundReflections > 0) {
-                            RayT iReflRay(iGroundPos, iRayDir - Vec3T(0.f, 2.0f * iRayDir[1], 0.f));
-                            if (nanovdb::ZeroCrossing(iReflRay, acc, ijk, v0, t))
-                                groundIntensity = groundIntensity - params.useGroundReflections * groundIntensity;
-                        }
+                        intensity = ((1.0f - shadowFactor) * (Vec3T(specularKey * 0.2f) + (diffuseKey * 0.8f)) + (1.0f - occlusion) * (diffuseFill * 0.2f + Vec3T(ambient * 0.1f)));
                     }
-                }
 
-                float skyIntensity = 0.75f + 0.25f * wRayDir[1];
+                    color[0] += intensity[0];
+                    color[1] += intensity[1];
+                    color[2] += intensity[2];
+                } else {
+                    float bgIntensity = 0;
+
+                    if (sceneParams.useBackground) {
+                        float groundIntensity = 0.0f;
+                        float groundMix = 0.0f;
+
+                        if (sceneParams.useGround) {
+                            float wGroundT = (sceneParams.groundHeight - wRay.eye()[1]) / wRay.dir()[1];
+                            if (wRay.dir()[1] != 0 && wGroundT > 0.f) {
+                                const Vec3T wGroundPos = wRay(wGroundT);
+                                const Vec3T iGroundPos = grid->worldToIndexF(wGroundPos);
+                                const Vec3T iGroundNormal = Vec3T(0, 1, 0);
+
+                                groundIntensity = evalGroundMaterial(wGroundT, sceneParams.groundFalloff, wGroundPos, wRay.dir()[1], groundMix);
+
+                                if (params.useOcclusion) {
+                                    RayT iOccRay(iGroundPos, lambertNoTangent(iGroundNormal, randomXorShift(pixelSeed), randomXorShift(pixelSeed)));
+                                    if (nanovdb::ZeroCrossing(iOccRay, acc, ijk, v0, t))
+                                        groundIntensity = 0.f;
+                                }
+
+                                if (sceneParams.useShadows) {
+                                    RayT iShadowRay(iGroundPos, iLightDir);
+                                    if (nanovdb::ZeroCrossing(iShadowRay, acc, ijk, v0, t))
+                                        groundIntensity = 0.f;
+                                }
+
+                                if (sceneParams.useGroundReflections) {
+                                    RayT iReflRay(iGroundPos, iRay.dir() - Vec3T(0.f, 2.0f * iRay.dir()[1], 0.f));
+                                    if (nanovdb::ZeroCrossing(iReflRay, acc, ijk, v0, t))
+                                        groundIntensity = 0;
+                                }
+                            }
+                        }
 
-                float bgIntensity = (1.f - groundMix) * skyIntensity + groundMix * groundIntensity;
+                        float skyIntensity = evalSkyMaterial(wRay.dir());
+                        bgIntensity = (1.f - groundMix) * skyIntensity + groundMix * groundIntensity;
+                    }
 
-                color[0] += bgIntensity;
-                color[1] += bgIntensity;
-                color[2] += bgIntensity;
+                    color[0] += bgIntensity;
+                    color[1] += bgIntensity;
+                    color[2] += bgIntensity;
+                }
             }
-        }
-
-        for (int k = 0; k < 3; ++k)
-            color[k] = color[k] / params.samplesPerPixel;
 
-        if (numAccumulations > 1) {
-            float oldLinearPixel[3];
-            if (params.useTonemapping)
-                invTonemapReinhard(oldLinearPixel, outPixel, params.tonemapWhitePoint);
-            else
-                invTonemapPassthru(oldLinearPixel, outPixel);
             for (int k = 0; k < 3; ++k)
-                color[k] = oldLinearPixel[k] + (color[k] - oldLinearPixel[k]) * (1.0f / numAccumulations);
+                color[k] = color[k] / sceneParams.samplesPerPixel;
         }
 
-        if (params.useTonemapping)
-            tonemapReinhard(outPixel, color, params.tonemapWhitePoint);
-        else
-            tonemapPassthru(outPixel, color);
-        outPixel[3] = 1.0;
+        compositeFn(outPixel, color, numAccumulations, sceneParams);
     }
 };
 
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/RenderPointsUtils.h nanovdb-20201022/nanovdb/cmd/viewer/RenderPointsUtils.h
--- nanovdb-20200925/nanovdb/cmd/viewer/RenderPointsUtils.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/RenderPointsUtils.h	2020-10-22 03:52:50.000000000 +0200
@@ -11,6 +11,8 @@
 	\brief General C++ implementation of the Grid rendering code.
 */
 
+#pragma once
+
 #include <nanovdb/NanoVDB.h>
 #include <nanovdb/util/HDDA.h>
 #include <nanovdb/util/Ray.h>
@@ -81,7 +83,7 @@
     }
 
     template<typename GridT, typename AccT>
-    inline __hostdev__ static float getTransmittance(RayT& ray, const GridT& grid, AccT& acc, const PointCloud& geometry, uint32_t& seed, const nanovdb::Vec3f& lightDir, const RenderConstants params)
+    inline __hostdev__ static float getTransmittance(RayT& ray, const GridT& grid, AccT& acc, const PointCloud& geometry, uint32_t& seed, const nanovdb::Vec3f& lightDir, const MaterialParameters params)
     {
         using namespace nanovdb;
 
@@ -90,9 +92,10 @@
         const RendererAttributeParams radiusAttribute = params.attributeSemanticMap[(int)nanovdb::GridBlindDataSemantic::PointRadius];
         const RendererAttributeParams positionAttribute = params.attributeSemanticMap[(int)nanovdb::GridBlindDataSemantic::PointPosition];
 
-        nanovdb::TreeMarcher<typename AccT::NodeT0, RayT, AccT> marcher(acc);
+        using TreeT = typename GridT::TreeType;
+        nanovdb::TreeMarcher<typename TreeT::LeafNodeType, RayT, AccT> marcher(acc);
         if (marcher.init(ray)) {
-            const typename AccT::NodeT0* node;
+            const typename TreeT::LeafNodeType* node;
             float                        t0 = 0, t1 = 0;
 
             while (marcher.step(&node, t0, t1)) {
@@ -118,7 +121,7 @@
                             int i = beginIndex + j;
 
                             const float radius = sampleAttribute<float>(grid, ijk, i, radiusAttribute);
-                            const Vec3T pos = sampleAttribute<Vec3T>(grid, ijk, i, positionAttribute) + Vec3T(0.5f);
+                            const Vec3T pos = sampleAttribute<Vec3T>(grid, ijk, i, positionAttribute);
 
                             // distance to point from ray.
                             float s = ray.dir().cross(pos - ray.eye()).lengthSqr();
@@ -139,7 +142,7 @@
     }
 
     template<typename GridT, typename AccT>
-    inline __hostdev__ static Vec3T traceGeometry(RayT& ray, const GridT& grid, AccT& acc, const PointCloud& geometry, uint32_t& seed, const nanovdb::Vec3f& lightDir, float& transmittance, const RenderConstants params)
+    inline __hostdev__ static Vec3T traceGeometry(RayT& ray, const GridT& grid, AccT& acc, const PointCloud& geometry, uint32_t& seed, const nanovdb::Vec3f& lightDir, float& transmittance, const MaterialParameters params)
     {
         using namespace nanovdb;
 
@@ -150,9 +153,10 @@
         Vec3T radiance(0);
         transmittance = 1.0f;
 
-        nanovdb::TreeMarcher<typename AccT::NodeT0, RayT, AccT> marcher(acc);
+        using TreeT = typename GridT::TreeType;
+        nanovdb::TreeMarcher<typename TreeT::LeafNodeType, RayT, AccT> marcher(acc);
         if (marcher.init(ray)) {
-            const typename AccT::NodeT0* node;
+            const typename TreeT::LeafNodeType* node;
             float                        t0 = 0, t1 = 0;
 
             while (marcher.step(&node, t0, t1)) {
@@ -178,7 +182,7 @@
                             int i = beginIndex + j;
 
                             const float radius = sampleAttribute<float>(grid, ijk, i, radiusAttribute);
-                            const Vec3T pos = sampleAttribute<Vec3T>(grid, ijk, i, positionAttribute) + Vec3T(0.5f);
+                            const Vec3T pos = sampleAttribute<Vec3T>(grid, ijk, i, positionAttribute);
 
                             // distance to point from ray.
                             float s = ray.dir().cross(pos - ray.eye()).lengthSqr();
@@ -188,7 +192,7 @@
 
                                 float shadowTransmittance = 1.0f;
 #if 0
-								if (params.useShadows > 0)
+								if (sceneParams.useShadows)
 								{
 									RayT iShadowRay(pos + lightDir * 0.1f, lightDir);
 									shadowTransmittance = getTransmittance(iShadowRay, grid, acc, geometry, seed, lightDir);
@@ -210,99 +214,82 @@
     }
 
     template<typename ValueType>
-    inline __hostdev__ void operator()(int ix, int iy, int width, int height, float* imgBuffer, Camera<float> camera, const nanovdb::NanoGrid<ValueType>* grid, int numAccumulations, const RenderConstants params) const
+    inline __hostdev__ void operator()(int ix, int iy, int width, int height, float* imgBuffer, int numAccumulations, const nanovdb::NanoGrid<ValueType>* grid, const SceneRenderParameters sceneParams, const MaterialParameters params) const
     {
         float* outPixel = &imgBuffer[4 * (ix + width * iy)];
 
-        const auto& tree = grid->tree();
-
-        const Vec3T wLightDir = Vec3T(0, 1, 0);
-        const Vec3T iLightDir = grid->worldToIndexDirF(wLightDir).normalize();
-
-        auto acc = tree.getAccessor();
+        float color[4] = {0, 0, 0, 0};
 
-        PointCloud geometry;
-        geometry.density = params.volumeDensity;
+        if (!grid) {
+            RayT wRay = getRayFromPixelCoord(ix, iy, width, height, sceneParams);
 
-        float color[4] = {0, 0, 0, 0};
+            auto envRadiance = traceEnvironment(wRay, sceneParams);
 
-        for (int sample = 0; sample < params.samplesPerPixel; ++sample) {
-            uint32_t pixelSeed = hash(sample + numAccumulations * params.samplesPerPixel ^ hash(ix, iy));
+            color[0] = envRadiance;
+            color[1] = envRadiance;
+            color[2] = envRadiance;
 
-            float u = ix + 0.5f;
-            float v = iy + 0.5f;
+        } else {
+            const Vec3T wLightDir = Vec3T(0, 1, 0);
+            const Vec3T iLightDir = grid->worldToIndexDirF(wLightDir).normalize();
 
-            float randVar1 = randomf(pixelSeed + 0);
-            float randVar2 = randomf(pixelSeed + 1);
+            const auto& tree = grid->tree();
+            const auto  acc = tree.getAccessor();
+            const auto  sampler = nanovdb::createSampler<0, decltype(acc), false>(acc);
 
-            if (numAccumulations > 0) {
-#if 1
-                float jitterX, jitterY;
-                cmj(jitterX, jitterY, numAccumulations % 64, 8, 8, pixelSeed);
-                u += jitterX - 0.5f;
-                v += jitterY - 0.5f;
-#else
-                u += randVar1 - 0.5f;
-                v += randVar2 - 0.5f;
-#endif
-            }
-            u /= width;
-            v /= height;
+            PointCloud geometry;
+            geometry.density = params.volumeDensityScale;
 
-            RayT wRay = camera.getRay(u, v);
-            RayT iRay = wRay.worldToIndexF(*grid);
+            for (int sampleIndex = 0; sampleIndex < sceneParams.samplesPerPixel; ++sampleIndex) {
+                uint32_t pixelSeed = hash((sampleIndex + (numAccumulations + 1) * sceneParams.samplesPerPixel)) ^ hash(ix, iy);
 
-            Vec3T iRayDir = iRay.dir();
-            Vec3T wRayDir = wRay.dir();
-            Vec3T wRayEye = wRay.eye();
+                RayT wRay = getRayFromPixelCoord(ix, iy, width, height, numAccumulations, sceneParams.samplesPerPixel, pixelSeed, sceneParams);
 
-            float transmittance = 1.0f;
-            Vec3T radiance = traceGeometry(iRay, *grid, acc, geometry, pixelSeed, iLightDir, transmittance, params);
+                RayT  iRay = wRay.worldToIndexF(*grid);
+                Vec3T iRayDir = iRay.dir();
 
-            if (transmittance > 0.01f) {
-                float groundIntensity = 0.0f;
-                float groundMix = 0.0f;
+                float pathThroughput = 1.0f;
+                Vec3T radiance = traceGeometry(iRay, *grid, acc, geometry, pixelSeed, iLightDir, pathThroughput, params);
 
-                if (params.useGround > 0) {
-                    // intersect with ground plane and draw checker if camera is above...
+                if (pathThroughput > 0.0f) {
+                    float bgIntensity = 0;
 
-                    float wGroundT = (params.groundHeight - wRayEye[1]) / wRayDir[1];
+                    if (sceneParams.useBackground) {
+                        float groundIntensity = 0.0f;
+                        float groundMix = 0.0f;
 
-                    if (wGroundT > 0.f) {
-                        Vec3T wGroundPos = wRayEye + wGroundT * wRayDir;
-                        Vec3T iGroundPos = grid->worldToIndexF(wGroundPos);
+                        if (sceneParams.useLighting && sceneParams.useGround) {
+                            // intersect with ground plane and draw checker if camera is above...
+                            float wGroundT = (sceneParams.groundHeight - wRay.eye()[1]) / wRay.dir()[1];
+                            if (wRay.dir()[1] != 0 && wGroundT > 0.f) {
+                                Vec3T wGroundPos = wRay(wGroundT);
+                                Vec3T iGroundPos = grid->worldToIndexF(wGroundPos);
 
-                        rayTraceGround(wGroundT, params.groundFalloff, wGroundPos, wRayDir[1], groundIntensity, groundMix);
+                                groundIntensity = evalGroundMaterial(wGroundT, sceneParams.groundFalloff, wGroundPos, wRay.dir()[1], groundMix);
 
-                        if (params.useShadows > 0) {
-                            RayT  iShadowRay(iGroundPos, iLightDir);
-                            float shadowTransmittance = getTransmittance(iShadowRay, *grid, acc, geometry, pixelSeed, iLightDir, params);
-                            groundIntensity *= shadowTransmittance;
+                                if (sceneParams.useShadows) {
+                                    RayT  iShadowRay(iGroundPos, iLightDir);
+                                    float shadowTransmittance = getTransmittance(iShadowRay, *grid, acc, geometry, pixelSeed, iLightDir, params);
+                                    groundIntensity *= shadowTransmittance;
+                                }
+                            }
                         }
+                        float skyIntensity = evalSkyMaterial(wRay.dir());
+                        bgIntensity = (1.f - groundMix) * skyIntensity + groundMix * groundIntensity;
                     }
+                    radiance += nanovdb::Vec3f(pathThroughput * bgIntensity);
                 }
 
-                float skyIntensity = 0.75f + 0.25f * wRayDir[1];
-
-                radiance = radiance + nanovdb::Vec3f(transmittance * ((1.f - groundMix) * skyIntensity + groundMix * groundIntensity));
+                color[0] += radiance[0];
+                color[1] += radiance[1];
+                color[2] += radiance[2];
             }
 
-            color[0] += radiance[0];
-            color[1] += radiance[1];
-            color[2] += radiance[2];
-        }
-
-        for (int k = 0; k < 3; ++k)
-            color[k] = color[k] / params.samplesPerPixel;
-
-        if (numAccumulations > 1) {
             for (int k = 0; k < 3; ++k)
-                color[k] = outPixel[k] + (color[k] - outPixel[k]) * (1.0f / numAccumulations);
+                color[k] = color[k] / sceneParams.samplesPerPixel;
         }
 
-        for (int k = 0; k < 3; ++k)
-            outPixel[k] = color[k];
-        outPixel[3] = 1.0;
+        compositeFn(outPixel, color, numAccumulations, sceneParams);
     }
 };
 
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/RenderUtils.h nanovdb-20201022/nanovdb/cmd/viewer/RenderUtils.h
--- nanovdb-20200925/nanovdb/cmd/viewer/RenderUtils.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/RenderUtils.h	2020-10-22 03:52:50.000000000 +0200
@@ -61,6 +61,12 @@
     out[2] = invReinhardFn(in[2] * w);
 }
 
+template<typename ValueT, typename Vec3T>
+inline __hostdev__ ValueT luminance(Vec3T v)
+{
+    return ValueT(v[0] * ValueT(0.2126) + v[1] * ValueT(0.7152) + v[2] * ValueT(0.0722));
+}
+
 template<typename Vec3T>
 inline __hostdev__ void tonemapACES(Vec3T& out, const Vec3T& in)
 {
@@ -77,6 +83,22 @@
     out[2] = nanovdb::Max(nanovdb::Min(b, 1.0f), 0.0f);
 }
 
+// LCG values from Numerical Recipes
+inline __hostdev__ float randomLCG(uint32_t& seed)
+{
+    seed = 1664525 * seed + 1013904223;
+    return seed / float(0xffffffffu);
+}
+
+// Xorshift algorithm from George Marsaglia
+inline __hostdev__ float randomXorShift(uint32_t& seed)
+{
+    seed ^= (seed << 13);
+    seed ^= (seed >> 17);
+    seed ^= (seed << 5);
+    return seed / float(0xffffffffu);
+}
+
 // http://www.burtleburtle.net/bob/hash/doobs.html
 inline __hostdev__ uint32_t hash(uint32_t x)
 {
@@ -118,20 +140,91 @@
     outY = (s / w + sx) / h;
 }
 
-inline __hostdev__ void rayTraceGround(float groundT, float falloffDistance, const nanovdb::Vec3f& pos, float rayDirY, float& outIntensity, float& outMix)
+inline __hostdev__ nanovdb::Ray<float> getRayFromPixelCoord(int ix, int iy, int width, int height, const SceneRenderParameters& sceneParams)
+{
+    float u = ix + 0.5f;
+    float v = iy + 0.5f;
+    return sceneParams.camera.getRay(u / width, v / height);
+}
+
+inline __hostdev__ nanovdb::Ray<float> getRayFromPixelCoord(int ix, int iy, int width, int height, int numAccumulations, int samplesPerPixel, uint32_t& pixelSeed, const SceneRenderParameters& sceneParams)
 {
-    const float checkerScale = 1.0f / 1024.0f;
+    float u = ix + 0.5f;
+    float v = iy + 0.5f;
+
+    if (numAccumulations > 0 || samplesPerPixel > 0) {
+#if 1
+        float jitterX, jitterY;
+        cmj(jitterX, jitterY, numAccumulations % 64, 8, 8, pixelSeed);
+        u += jitterX - 0.5f;
+        v += jitterY - 0.5f;
+#else
+        float randVar1 = randomf(pixelSeed + 0);
+        float randVar2 = randomf(pixelSeed + 1);
+        u += randVar1 - 0.5f;
+        v += randVar2 - 0.5f;
+#endif
+    }
+
+    return sceneParams.camera.getRay(u / width, v / height);
+}
 
-    auto iu = floorf(pos[0] * checkerScale);
-    auto iv = floorf(pos[2] * checkerScale);
-    outIntensity = fabsf(fmodf(iu + iv, 2.f));
+inline __hostdev__ float evalGroundMaterial(float groundT, float falloffDistance, const nanovdb::Vec3f& pos, float rayDirY, float& outMix)
+{
+    static constexpr float checkerScale = 1.0f / 1024.0f;
+    auto                   iu = floorf(pos[0] * checkerScale);
+    auto                   iv = floorf(pos[2] * checkerScale);
+    float                  outIntensity = fabsf(fmodf(iu + iv, 2.f));
     outIntensity = 0.25f + outIntensity * 0.5f;
-    //float m = expf( -wGroundT / falloffDistance );// * -rayDirY;
-    float m = (1.0f - groundT / falloffDistance) * -rayDirY;
-    outMix = fmaxf(0.f, m);
+    outMix = fmaxf(0.f, (1.0f - groundT / falloffDistance) * -(rayDirY));
+    return outIntensity;
+}
+
+inline __hostdev__ float evalSkyMaterial(const nanovdb::Vec3f& dir)
+{
+    return 0.75f + 0.25f * dir[1];
+}
+
+__hostdev__ inline float traceEnvironment(const nanovdb::Ray<float>& wRay, const SceneRenderParameters& sceneParams)
+{
+    if (!sceneParams.useBackground)
+        return 0.0f;
+
+    float skyIntensity = evalSkyMaterial(wRay.dir());
+
+    if (!sceneParams.useGround)
+        return skyIntensity;
+
+    float groundIntensity = 0.0f;
+    float groundMix = 0.0f;
+    if (sceneParams.useGround) {
+        float wGroundT = (sceneParams.groundHeight - wRay.eye()[1]) / wRay.dir()[1];
+        if (wRay.dir()[1] != 0 && wGroundT > 0.f) {
+            nanovdb::Vec3f wGroundPos = wRay.eye() + wGroundT * wRay.dir();
+            groundIntensity = evalGroundMaterial(wGroundT, sceneParams.groundFalloff, wGroundPos, wRay.dir()[1], groundMix);
+        }
+    }
+    float bgIntensity = (1.f - groundMix) * skyIntensity + groundMix * groundIntensity;
+    return bgIntensity;
+}
+
+// algorithm adapted from: https://github.com/NVIDIAGameWorks/Falcor/blob/master/Source/Falcor/Utils/Math/MathHelpers.slang
+// Generate a vector that is orthogonal to the input vector.
+inline __hostdev__ nanovdb::Vec3f perpStark(const nanovdb::Vec3f& u)
+{
+    auto a = nanovdb::Vec3f(nanovdb::Abs(u[0]), nanovdb::Abs(u[1]), nanovdb::Abs(u[2]));
+    auto uyx = (a[0] - a[1]) < 0 ? 1 : 0;
+    auto uzx = (a[0] - a[2]) < 0 ? 1 : 0;
+    auto uzy = (a[1] - a[2]) < 0 ? 1 : 0;
+    auto xm = uyx & uzx;
+    auto ym = (1 ^ xm) & uzy;
+    auto zm = 1 ^ (xm | ym); // 1 ^ (xm & ym)
+    auto v = u.cross(nanovdb::Vec3f(float(xm), float(ym), float(zm)));
+    return v;
 }
 
 // algorithm taken from: http://amietia.com/lambertnotangent.html
+// Return a vector in the cosine distribution.
 inline __hostdev__ nanovdb::Vec3f lambertNoTangent(nanovdb::Vec3f normal, float u, float v)
 {
     float theta = 6.283185f * u;
@@ -141,4 +234,60 @@
     return (normal + spherePoint).normalize();
 }
 
+inline __hostdev__ void compositeFn(float* outPixel, float* color, int numAccumulations, const SceneRenderParameters& sceneParams)
+{
+    if (numAccumulations > 1) {
+        float oldLinearPixel[3];
+        if (sceneParams.useTonemapping)
+            invTonemapReinhard(oldLinearPixel, outPixel, sceneParams.tonemapWhitePoint);
+        else
+            invTonemapPassthru(oldLinearPixel, outPixel);
+        for (int k = 0; k < 3; ++k)
+            color[k] = oldLinearPixel[k] + (color[k] - oldLinearPixel[k]) * (1.0f / numAccumulations);
+    }
+
+    if (sceneParams.useTonemapping)
+        tonemapReinhard(outPixel, color, sceneParams.tonemapWhitePoint);
+    else
+        tonemapPassthru(outPixel, color);
+    outPixel[3] = 1.0;
+}
+
+struct RenderEnvRgba32fFn
+{
+    inline __hostdev__ void operator()(int ix, int iy, int width, int height, float* imgBuffer, int numAccumulations, const SceneRenderParameters sceneParams, const MaterialParameters materialParams) const
+    {
+        auto wRay = getRayFromPixelCoord(ix, iy, width, height, sceneParams);
+        auto envRadiance = traceEnvironment(wRay, sceneParams);
+
+        float color[4];
+        color[0] = envRadiance;
+        color[1] = envRadiance;
+        color[2] = envRadiance;
+
+        auto outPixel = &imgBuffer[4 * (ix + width * iy)];
+        compositeFn(outPixel, color, numAccumulations, sceneParams);
+    }
+};
+
+struct CameraDiagnosticRenderer
+{
+    inline __hostdev__ void operator()(int ix, int iy, int width, int height, float* imgBuffer, int numAccumulations, const SceneRenderParameters sceneParams, const MaterialParameters materialParams) const
+    {
+        auto outPixel = &imgBuffer[4 * (ix + width * iy)];
+        auto wRay = getRayFromPixelCoord(ix, iy, width, height, sceneParams);
+
+        float color[4];
+        color[0] = wRay.dir()[0];
+        color[1] = wRay.dir()[1];
+        color[2] = wRay.dir()[2];
+        color[3] = 1;
+
+        outPixel[0] = color[0];
+        outPixel[1] = color[1];
+        outPixel[2] = color[2];
+        outPixel[3] = color[3];
+    }
+};
+
 } // namespace render
\ Pas de fin de ligne Ã  la fin du fichier
Seulement dans nanovdb-20201022/nanovdb/cmd/viewer: StringUtils.cpp
Seulement dans nanovdb-20201022/nanovdb/cmd/viewer: StringUtils.h
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/Viewer.cpp nanovdb-20201022/nanovdb/cmd/viewer/Viewer.cpp
--- nanovdb-20200925/nanovdb/cmd/viewer/Viewer.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/Viewer.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -63,8 +63,8 @@
 #if defined(NANOVDB_USE_IMGUI)
 #include <imgui.h>
 #include <imgui_internal.h>
-#include <examples/imgui_impl_glfw.h>
-#include <examples/imgui_impl_opengl3.h>
+#include <backends/imgui_impl_glfw.h>
+#include <backends/imgui_impl_opengl3.h>
 #endif
 
 #include "Viewer.h"
@@ -72,6 +72,7 @@
 
 #include "FrameBufferHost.h"
 #include "FrameBufferGL.h"
+#include "StringUtils.h"
 
 #include <nanovdb/util/IO.h> // for NanoVDB file import
 #if defined(NANOVDB_USE_OPENVDB)
@@ -164,6 +165,7 @@
 
     setRenderPlatform(0);
     mFps = 0;
+    setSceneFrame(params.mFrameStart);
 }
 
 Viewer::~Viewer()
@@ -195,14 +197,8 @@
     if (!mWindow)
         return;
 
-    if (mRenderGroupIndex < 0 || mGridGroups.size() == 0)
-        return;
-
-    auto group = mGridGroups[mRenderGroupIndex];
-    auto instance = group->mInstances[group->mCurrentGridIndex];
-
     std::ostringstream ss;
-    ss << "Viewer: " << group->mName << "[" << instance->mGridName << "] - " << mRenderLauncher.name() << " @ " << mFps << " fps";
+    ss << "NanoVDB Viewer: " << mRenderLauncher.name() << " @ " << mFps << " fps";
     glfwSetWindowTitle((GLFWwindow*)mWindow, ss.str().c_str());
 }
 
@@ -259,7 +255,9 @@
     glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 5);
 #endif
 
-    mWindow = glfwCreateWindow(mParams.mWidth, mParams.mHeight, "", NULL, NULL);
+    mWindowWidth = mParams.mWidth;
+    mWindowHeight = mParams.mHeight;
+    mWindow = glfwCreateWindow(mWindowWidth, mWindowHeight, "", NULL, NULL);
     if (!mWindow) {
         glfwTerminate();
         throw std::runtime_error("Error: Unable to create GLFW window");
@@ -294,25 +292,28 @@
     initializeGL();
 
     mFrameBuffer.reset(new FrameBufferGL(glContext, glDisplay));
-    resize(mParams.mWidth, mParams.mHeight);
-    resetAccumulationBuffer();
+    resizeFrameBuffer(mParams.mWidth, mParams.mHeight);
 
 #ifdef NANOVDB_USE_IMGUI
     IMGUI_CHECKVERSION();
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     (void)io;
+#if defined(NANOVDB_USE_IMGUI_DOCKING)
+    //io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
+    //io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;
+    //io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;
+#else
     io.ConfigWindowsMoveFromTitleBarOnly = true;
+#endif
 
     ImGui::StyleColorsDark();
 
     ImGui_ImplGlfw_InitForOpenGL((GLFWwindow*)mWindow, true);
     ImGui_ImplOpenGL3_Init("#version 100");
+#endif
 
     NANOVDB_GL_CHECKERRORS();
-#else
-    printHelp();
-#endif
 }
 
 void Viewer::mainLoop(void* userData)
@@ -327,11 +328,96 @@
     }
 }
 
+static ImGuiID dock_id_prop;
+static ImGuiID dock_id_bottom;
+static ImGuiID dock_id_center;
+
+static void showDockSpace(bool* p_open)
+{
+#if defined(NANOVDB_USE_IMGUI_DOCKING) && 0
+
+    static bool               opt_fullscreen_persistant = true;
+    bool                      opt_fullscreen = opt_fullscreen_persistant;
+    static ImGuiDockNodeFlags dockspace_flags = ImGuiDockNodeFlags_None | ImGuiDockNodeFlags_PassthruCentralNode | ImGuiDockNodeFlags_NoDockingInCentralNode;
+
+    // We are using the ImGuiWindowFlags_NoDocking flag to make the parent window not dockable into,
+    // because it would be confusing to have two docking targets within each others.
+    ImGuiWindowFlags window_flags = ImGuiWindowFlags_MenuBar | ImGuiWindowFlags_NoDocking;
+    if (opt_fullscreen) {
+        ImGuiViewport* viewport = ImGui::GetMainViewport();
+        ImGui::SetNextWindowPos(viewport->Pos);
+        ImGui::SetNextWindowSize(viewport->Size);
+        ImGui::SetNextWindowViewport(viewport->ID);
+        ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
+        ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0f);
+        window_flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove;
+        window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoNavFocus;
+    }
+
+    // When using ImGuiDockNodeFlags_PassthruCentralNode, DockSpace() will render our background
+    // and handle the pass-thru hole, so we ask Begin() to not render a background.
+    if (dockspace_flags & ImGuiDockNodeFlags_PassthruCentralNode)
+        window_flags |= ImGuiWindowFlags_NoBackground;
+
+    // Important: note that we proceed even if Begin() returns false (aka window is collapsed).
+    // This is because we want to keep our DockSpace() active. If a DockSpace() is inactive,
+    // all active windows docked into it will lose their parent and become undocked.
+    // We cannot preserve the docking relationship between an active window and an inactive docking, otherwise
+    // any change of dockspace/settings would lead to windows being stuck in limbo and never being visible.
+    ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));
+    ImGui::Begin("###DockSpace", p_open, window_flags);
+    ImGui::PopStyleVar();
+
+    if (opt_fullscreen)
+        ImGui::PopStyleVar(2);
+
+    // DockSpace
+    ImGuiIO& io = ImGui::GetIO();
+    if (io.ConfigFlags & ImGuiConfigFlags_DockingEnable) {
+        ImGuiID dockspace_id = ImGui::GetID("MyDockSpace");
+        //ImGui::DockSpace(dockspace_id, ImVec2(0.0f, 0.0f), dockspace_flags);
+
+        ImVec2 dockspace_size(800, 800);
+
+        if (ImGui::DockBuilderGetNode(dockspace_id) == nullptr) {
+            // setup initial config...
+            ImGui::DockBuilderRemoveNode(dockspace_id); // Clear out existing layout
+            ImGui::DockBuilderAddNode(dockspace_id, dockspace_flags); // Add empty node
+            ImGui::DockBuilderSetNodeSize(dockspace_id, dockspace_size);
+
+            ImGuiID dock_main_id = dockspace_id; // This variable will track the document node, however we are not using it here as we aren't docking anything into it.
+            dock_id_prop = ImGui::DockBuilderSplitNode(dock_main_id, ImGuiDir_Left, 0.20f, NULL, &dock_main_id);
+            dock_id_bottom = ImGui::DockBuilderSplitNode(dock_main_id, ImGuiDir_Down, 0.20f, NULL, &dock_main_id);
+            ImGuiDockNode* centerNode = ImGui::DockBuilderGetCentralNode(dockspace_id);
+            dock_id_center = -1;
+
+            ImGui::DockBuilderDockWindow("Event Log", dock_id_bottom);
+            ImGui::DockBuilderDockWindow("Grid-Sets", dock_id_prop);
+            ImGui::DockBuilderDockWindow("Grid Stats", dock_id_prop);
+            ImGui::DockBuilderDockWindow("Extra", dock_id_prop);
+            ImGui::DockBuilderFinish(dockspace_id);
+        }
+
+    } else {
+        //ShowDockingDisabledMessage();
+    }
+
+    ImGui::End();
+#endif
+}
+
 bool Viewer::runLoop()
 {
-    //printf("frame: %d\n", mFrame);
+    updateAnimationControl();
+
+    mIsDrawingPendingGlyph = false;
+    if (mSelectedSceneNodeIndex >= 0) {
+        updateNodeAttachmentRequests(mSceneNodes[mSelectedSceneNodeIndex], false, mIsDumpingLog, &mIsDrawingPendingGlyph);
+    }
 
-    render(mFrame);
+    updateScene();
+
+    render(getSceneFrame());
     renderViewOverlay();
 
 #if defined(NANOVDB_USE_IMGUI) && !defined(__EMSCRIPTEN__)
@@ -344,17 +430,32 @@
     ImGui_ImplOpenGL3_NewFrame();
     ImGui_ImplGlfw_NewFrame();
     ImGui::NewFrame();
+    ImGuiIO& io = ImGui::GetIO();
+
+    bool show = true;
+    showDockSpace(&show);
 
-    //ImGui::ShowDemoWindow();
     drawMenuBar();
-    drawGridOutliner();
+    drawSceneGraph();
     drawRenderOptionsDialog();
     drawRenderStatsOverlay();
-    drawGridStatsOverlay();
     drawAboutDialog();
     drawHelpDialog();
+    drawEventLog();
+    drawAssets();
+    drawPendingGlyph();
 
     ImGui::Render();
+
+#if defined(NANOVDB_USE_IMGUI_DOCKING)
+    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable) {
+        GLFWwindow* backup_current_context = glfwGetCurrentContext();
+        ImGui::UpdatePlatformWindows();
+        ImGui::RenderPlatformWindowsDefault();
+        glfwMakeContextCurrent(backup_current_context);
+    }
+#endif
+
     ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
     ImGui::EndFrame();
 #endif
@@ -375,7 +476,6 @@
 
     bool stop = (glfwWindowShouldClose((GLFWwindow*)mWindow) > 0);
 
-    ++mFrame;
     return !stop;
 }
 
@@ -407,84 +507,30 @@
 {
 }
 
-void Viewer::resize(int width, int height)
+void Viewer::resizeFrameBuffer(int width, int height)
 {
     auto fb = static_cast<FrameBufferGL*>(mFrameBuffer.get());
     fb->setupGL(width, height, nullptr, GL_RGBA32F, GL_DYNAMIC_DRAW);
     resetAccumulationBuffer();
 }
 
-void Viewer::render(int frame)
+bool Viewer::render(int frame)
 {
     if (mWindow == nullptr)
-        return;
+        return false;
 
     glfwMakeContextCurrent((GLFWwindow*)mWindow);
 
-    if (mGridGroups.size() == 0) {
+    if (RendererBase::render(frame) == false) {
         glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-        return;
-    }
-
-    if (mRenderGroupIndex < 0)
-        return;
-
-    auto        group = mGridGroups[mRenderGroupIndex];
-    auto        instance = group->mInstances[group->mCurrentGridIndex];
-    const auto& gridHdl = instance->mGridHandle;
-
-    bool hasCameraChanged = updateCamera(frame);
-
-    if (hasCameraChanged) {
-        resetAccumulationBuffer();
-    }
-
-    size_t gridByteSize = gridHdl.size();
-    assert(gridByteSize);
-
-    // modify RenderConstants...
-    auto renderConstants = mParams.mOptions;
-    renderConstants.useGroundReflections = false;
-
-    auto wBbox = group->mBounds;
-    auto wBboxSize = wBbox.max() - wBbox.min();
-    renderConstants.groundHeight = wBbox.min()[1];
-    renderConstants.groundFalloff = 1000.f * float(wBboxSize.length());
-    int w = mFrameBuffer->width();
-    int h = mFrameBuffer->height();
-    int numAccumulations = (mParams.mUseAccumulation) ? ++mNumAccumulations : 0;
-
-    Camera<float> camera(mCurrentCameraState->eye(), mCurrentCameraState->target(), mCurrentCameraState->V(), mCurrentCameraState->mFovY, float(w) / h);
-
-    // prevent progressive rendering to happen on turntable (as it looks displeasing)
-    renderConstants.useOcclusion *= (mParams.mUseTurntable || hasCameraChanged || mMouseDown) ? 0 : 1;
-    numAccumulations = (!mParams.mUseTurntable) ? numAccumulations : 0;
-
-    bool renderRc = false;
-
-    auto renderMethod = group->mRenderMethod;
-    if (renderMethod == RenderMethod::AUTO) {
-        if (instance->mGridClassOverride == nanovdb::GridClass::FogVolume)
-            renderMethod = RenderMethod::FOG_VOLUME;
-        else if (instance->mGridClassOverride == nanovdb::GridClass::LevelSet)
-            renderMethod = RenderMethod::LEVELSET;
-        else if (instance->mGridClassOverride == nanovdb::GridClass::PointData)
-            renderMethod = RenderMethod::POINTS;
-        else if (instance->mGridClassOverride == nanovdb::GridClass::PointIndex)
-            renderMethod = RenderMethod::POINTS;
-        else
-            renderMethod = RenderMethod::GRID;
+        return true;
+    } else {
+        mFrameBuffer->render(0, 0, mFrameBuffer->width(), mFrameBuffer->height());
+        return true;
     }
-
-    renderRc = mRenderLauncher.render(renderMethod, w, h, mFrameBuffer.get(), camera, gridHdl, numAccumulations, renderConstants, nullptr);
-
-    if (!renderRc)
-        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-    else
-        mFrameBuffer->render(0, 0, w, h);
 }
 
-void Viewer::printHelp() const
+void Viewer::printHelp(std::ostream& s) const
 {
     auto platforms = mRenderLauncher.getPlatformNames();
 
@@ -495,46 +541,78 @@
         platformList << "," << platforms[i];
     platformList << "]";
 
-    std::cout << "-------------------------------------\n";
-    std::cout << "Hot Keys:\n";
-    std::cout << "-------------------------------------\n";
-    std::cout << "\n";
-    std::cout << "- Show Hot-Keys                [I]\n";
-    std::cout << "- Renderer-platform            [1-9] = (" << (mParams.mRenderLauncherType) << " / " << platformList.str() << ")\n";
-    std::cout << "- Next grid                    [+/-] = (" << (mRenderGroupIndex) << ")\n";
-    std::cout << "\n";
-    std::cout << "View options ------------------------\n";
-    std::cout << "- Camera Home                  [H]\n";
-    std::cout << "- Camera Move                  [WASD]\n";
-    std::cout << "\n";
-    std::cout << "Render options ----------------------\n";
-    std::cout << "- Toggle Render Progressive    [P] = (" << (mParams.mUseAccumulation ? "ON" : "OFF") << ")\n";
-    std::cout << "- Toggle Render Lighting       [L] = (" << (mParams.mOptions.useLighting ? "ON" : "OFF") << ")\n";
-    std::cout << "- Toggle Render Shadows        [B] = (" << (mParams.mOptions.useShadows ? "ON" : "OFF") << ")\n";
-    std::cout << "- Toggle Render Ground-plane   [G] = (" << (mParams.mOptions.useGround ? "ON" : "OFF") << ")\n";
-    std::cout << "- Toggle Render Occlusion      [O] = (" << (mParams.mOptions.useOcclusion ? "ON" : "OFF") << ")\n";
-    std::cout << "-------------------------------------\n";
-    std::cout << "\n";
-}
-
-bool Viewer::updateCamera(int frame)
-{
-    if (mRenderGroupIndex < mGridGroups.size()) {
-        auto group = mGridGroups[mRenderGroupIndex];
-        if (mPlaybackState == PlaybackState::PLAY) {
-            setGridIndex(mRenderGroupIndex, ++group->mCurrentGridIndex);
-        }
+    s << "-------------------------------------\n";
+    s << "Hot Keys:\n";
+    s << "-------------------------------------\n";
+    s << "\n";
+    s << "- Show Hot-Keys                [H]\n";
+    s << "- Renderer-platform            [1 - 9] = (" << (mParams.mRenderLauncherType) << " / " << platformList.str() << ")\n";
+    s << "\n";
+    s << "Scene options ------------------------\n";
+    s << "- Select Next/Previous Node    [+ / -] = (" << ((mSelectedSceneNodeIndex >= 0) ? mSceneNodes[mSelectedSceneNodeIndex]->mName : "") << ")\n";
+    s << "\n";
+    s << "View options ------------------------\n";
+    s << "- Frame Selected               [F]\n";
+    s << "\n";
+    s << "Animation options ------------------------\n";
+    s << "- Toggle Play/Stop             [ENTER]\n";
+    s << "- Play From Start              [CTRL + ENTER]\n";
+    s << "- Previous/Next Frame          [< / >]\n";
+    s << "- Goto Start                   [CTRL + <]\n";
+    s << "- Goto End                     [CTRL + >]\n";
+    s << "- Scrub                        [TAB + MOUSE_LEFT]\n";
+    s << "\n";
+    s << "Render options ----------------------\n";
+    s << "- Toggle Render Progressive    [P] = (" << (mParams.mUseAccumulation ? "ON" : "OFF") << ")\n";
+    s << "- Toggle Render Lighting       [L] = (" << (mParams.mSceneParameters.useLighting ? "ON" : "OFF") << ")\n";
+    s << "- Toggle Render Background     [B] = (" << (mParams.mSceneParameters.useBackground ? "ON" : "OFF") << ")\n";
+    s << "- Toggle Render Shadows        [S] = (" << (mParams.mSceneParameters.useShadows ? "ON" : "OFF") << ")\n";
+    s << "- Toggle Render Ground-plane   [G] = (" << (mParams.mSceneParameters.useGround ? "ON" : "OFF") << ")\n";
+    s << "-------------------------------------\n";
+    s << "\n";
+}
+
+void Viewer::updateAnimationControl()
+{
+    if (mPlaybackState == PlaybackState::PLAY) {
+        float t = getTime();
+        if ((t - mPlaybackLastTime) * mPlaybackRate > 1.0f) {
+            mPlaybackTime += (t - mPlaybackLastTime) * mPlaybackRate;
+            mPlaybackLastTime = t;
+        }
+        RendererBase::setSceneFrame(mPlaybackTime);
+    }
+}
+
+void Viewer::setSceneFrame(int frame)
+{
+    RendererBase::setSceneFrame(frame);
+
+    mPlaybackLastTime = getTime();
+    mPlaybackTime = frame - mParams.mFrameStart;
+    mPlaybackState = PlaybackState::STOP;
+}
+
+bool Viewer::updateCamera()
+{
+    int  sceneFrame = getSceneFrame();
+    bool isChanged = false;
+
+    if (mCurrentCameraState->mFrame != sceneFrame) {
+        isChanged = true;
+        mCurrentCameraState->mFrame = sceneFrame;
     }
 
-    if (mParams.mUseTurntable) {
-        int count = (mParams.mFrameCount == 0) ? 100 : mParams.mFrameCount;
-        mCurrentCameraState->mCameraRotation[1] = (frame * 2.0f * 3.14159265f) / count;
+    if (mPlaybackState == PlaybackState::PLAY && mParams.mUseTurntable) {
+        int count = (mParams.mFrameEnd <= mParams.mFrameStart) ? 100 : (mParams.mFrameEnd - mParams.mFrameStart + 1);
+        mCurrentCameraState->mCameraRotation[1] = ((sceneFrame * 2.0f * 3.14159265f) / count) / std::max(mParams.mTurntableRate, 1.0f);
         mCurrentCameraState->mIsViewChanged = true;
     } else {
+#if 0
 #if defined(NANOVDB_USE_IMGUI)
         ImGuiIO& io = ImGui::GetIO();
         if (io.WantCaptureKeyboard)
-            return false;
+            return isChanged;
 #endif
 
         const float cameraSpeed = 5.0f;
@@ -554,19 +632,20 @@
             mCurrentCameraState->mCameraLookAt = mCurrentCameraState->mCameraLookAt - (cameraSpeed * mCurrentCameraState->U());
             mCurrentCameraState->mIsViewChanged = true;
         }
+#endif
     }
-    return mCurrentCameraState->update();
+
+    isChanged |= mCurrentCameraState->update();
+    return isChanged;
 }
 
 void Viewer::onDrop(int numPaths, const char** paths)
 {
     for (int i = 0; i < numPaths; i++) {
-        try {
-            addGrid(paths[i], paths[i]);
-        }
-        catch (const std::exception& e) {
-            std::cerr << "An exception occurred: \"" << e.what() << "\"" << std::endl;
-        }
+        auto nodeId = addSceneNode("");
+        addGridAsset(paths[i]);
+        setSceneNodeGridAttachment(nodeId, 0, paths[i]);
+        selectSceneNodeByIndex(findNode(nodeId)->mIndex);
     }
 }
 
@@ -581,55 +660,65 @@
     if (action == GLFW_PRESS) {
         if (key == GLFW_KEY_ESCAPE || key == 'Q') {
             glfwSetWindowShouldClose((GLFWwindow*)mWindow, true);
-        } else if (key == 'I') {
-            printHelp();
         } else if (key == 'H') {
+            mIsDrawingHelpDialog = !mIsDrawingHelpDialog;
+        } else if (key == 'F') {
             resetCamera();
             resetAccumulationBuffer();
         } else if (key == '`') {
-            mIsDrawingOutliner = !mIsDrawingOutliner;
+            mIsDrawingSceneGraph = !mIsDrawingSceneGraph;
         } else if (key == 'B') {
-            mParams.mOptions.useShadows = (mParams.mOptions.useShadows > 0) ? 0.f : 1.f;
+            mParams.mSceneParameters.useBackground = (mParams.mSceneParameters.useBackground > 0) ? 0 : 1;
             resetAccumulationBuffer();
-        } else if (key == 'G') {
-            mParams.mOptions.useGround = (mParams.mOptions.useGround > 0) ? 0.f : 1.f;
+        } else if (key == 'S') {
+            mParams.mSceneParameters.useShadows = (mParams.mSceneParameters.useShadows > 0) ? 0 : 1;
             resetAccumulationBuffer();
-        } else if (key == 'O') {
-            mParams.mOptions.useOcclusion = (mParams.mOptions.useOcclusion > 0) ? 0.f : 1.f;
+        } else if (key == 'G') {
+            mParams.mSceneParameters.useGround = (mParams.mSceneParameters.useGround > 0) ? 0 : 1;
             resetAccumulationBuffer();
         } else if (key == 'L') {
-            mParams.mOptions.useLighting = (mParams.mOptions.useLighting > 0) ? 0.f : 1.f;
+            mParams.mSceneParameters.useLighting = (mParams.mSceneParameters.useLighting > 0) ? 0 : 1;
             resetAccumulationBuffer();
         } else if (key == 'P') {
             mParams.mUseAccumulation = !mParams.mUseAccumulation;
             resetAccumulationBuffer();
+        } else if (key == GLFW_KEY_COMMA) {
+            if (glfwGetKey((GLFWwindow*)mWindow, GLFW_KEY_LEFT_CONTROL)) {
+                setSceneFrame(mParams.mFrameStart);
+            } else {
+                setSceneFrame(mLastSceneFrame - 1);
+            }
+        } else if (key == GLFW_KEY_PERIOD) {
+            if (glfwGetKey((GLFWwindow*)mWindow, GLFW_KEY_LEFT_CONTROL)) {
+                setSceneFrame(mParams.mFrameEnd);
+            } else {
+                setSceneFrame(mLastSceneFrame + 1);
+            }
+        } else if (key == GLFW_KEY_ENTER) {
+            if (glfwGetKey((GLFWwindow*)mWindow, GLFW_KEY_LEFT_CONTROL)) {
+                setSceneFrame(mParams.mFrameStart);
+                mPlaybackState = PlaybackState::PLAY;
+            } else {
+                if (mPlaybackState == PlaybackState::PLAY) {
+                    mPlaybackState = PlaybackState::STOP;
+                } else {
+                    mPlaybackLastTime = getTime();
+                    mPlaybackState = PlaybackState::PLAY;
+                }
+            }
         } else if (key == 'T') {
             mParams.mUseTurntable = !mParams.mUseTurntable;
             resetAccumulationBuffer();
         } else if (key == GLFW_KEY_MINUS) {
-            setGridIndex(mRenderGroupIndex, mGridGroups[mRenderGroupIndex]->mCurrentGridIndex - 1);
+            selectSceneNodeByIndex(mSelectedSceneNodeIndex - 1);
             updateWindowTitle();
-            resetAccumulationBuffer();
             mFps = 0;
         } else if (key == GLFW_KEY_EQUAL) {
-            setGridIndex(mRenderGroupIndex, mGridGroups[mRenderGroupIndex]->mCurrentGridIndex + 1);
-            updateWindowTitle();
-            resetAccumulationBuffer();
-            mFps = 0;
-        } else if (key == GLFW_KEY_LEFT_BRACKET) {
-            mRenderGroupIndex = (mRenderGroupIndex - 1) % mGridGroups.size();
-            setGridIndex(mRenderGroupIndex, mGridGroups[mRenderGroupIndex]->mCurrentGridIndex);
-            updateWindowTitle();
-            resetAccumulationBuffer();
-            mFps = 0;
-        } else if (key == GLFW_KEY_RIGHT_BRACKET) {
-            mRenderGroupIndex = (mRenderGroupIndex + 1) % mGridGroups.size();
-            setGridIndex(mRenderGroupIndex, mGridGroups[mRenderGroupIndex]->mCurrentGridIndex);
+            selectSceneNodeByIndex(mSelectedSceneNodeIndex + 1);
             updateWindowTitle();
-            resetAccumulationBuffer();
             mFps = 0;
         } else if (key == GLFW_KEY_PRINT_SCREEN) {
-            saveFrameBuffer(false);
+            saveFrameBuffer(getSceneFrame());
         } else if (key >= GLFW_KEY_1 && key <= GLFW_KEY_9) {
             setRenderPlatform((key - GLFW_KEY_1));
             updateWindowTitle();
@@ -649,11 +738,13 @@
     if (button == GLFW_MOUSE_BUTTON_LEFT) {
         if (action == GLFW_PRESS) {
             mMouseDown = true;
+            mIsFirstMouseMove = true;
         }
     } else if (button == GLFW_MOUSE_BUTTON_RIGHT) {
         if (action == GLFW_PRESS) {
             mMouseDown = true;
             mIsMouseRightDown = true;
+            mIsFirstMouseMove = true;
         }
     }
 
@@ -662,10 +753,23 @@
         mIsMouseRightDown = false;
     }
 
-    mIsFirstMouseMove = true;
     mCurrentCameraState->mIsViewChanged = true;
 
-    //printf("mouse(%f, %f, %d)\n", mMouseX, mMouseY, mMouseDown?1:0);
+    if (mMouseDown) {
+        if (glfwGetKey((GLFWwindow*)mWindow, GLFW_KEY_TAB) == GLFW_PRESS) {
+            double xpos, ypos;
+            glfwGetCursorPos((GLFWwindow*)mWindow, &xpos, &ypos);
+            int x = int(xpos);
+            int y = int(ypos);
+            mPendingSceneFrame = mParams.mFrameStart + ((float(x) / mWindowWidth) * (mParams.mFrameEnd - mParams.mFrameStart + 1));
+            if (mPendingSceneFrame > mParams.mFrameEnd)
+                mPendingSceneFrame = mParams.mFrameEnd;
+            else if (mPendingSceneFrame < mParams.mFrameStart)
+                mPendingSceneFrame = mParams.mFrameStart;
+            mPlaybackState = PlaybackState::STOP;
+            mCurrentCameraState->mIsViewChanged = true;
+        }
+    }
 }
 
 void Viewer::onMouseMove(int x, int y)
@@ -676,8 +780,21 @@
         return;
 #endif
 
+    if (mMouseDown) {
+        if (glfwGetKey((GLFWwindow*)mWindow, GLFW_KEY_TAB) == GLFW_PRESS) {
+            mPendingSceneFrame = mParams.mFrameStart + ((float(x) / mWindowWidth) * (mParams.mFrameEnd - mParams.mFrameStart + 1));
+            if (mPendingSceneFrame > mParams.mFrameEnd)
+                mPendingSceneFrame = mParams.mFrameEnd;
+            else if (mPendingSceneFrame < mParams.mFrameStart)
+                mPendingSceneFrame = mParams.mFrameStart;
+            mPlaybackState = PlaybackState::STOP;
+            mCurrentCameraState->mIsViewChanged = true;
+            return;
+        }
+    }
+
     const float orbitSpeed = 0.01f;
-    const float strafeSpeed = mCurrentCameraState->mCameraDistance * 0.00005f;
+    const float strafeSpeed = 0.005f * mCurrentCameraState->mCameraDistance * tanf(mCurrentCameraState->mFovY * 0.5f * (3.142f / 180.f));
 
     if (mIsFirstMouseMove) {
         mMouseX = float(x);
@@ -736,7 +853,39 @@
 
 void Viewer::onResize(int width, int height)
 {
-    resize(width, height);
+    mWindowWidth = width;
+    mWindowHeight = height;
+
+    resizeFrameBuffer(width, height);
+}
+
+#if defined(NANOVDB_USE_IMGUI)
+static void HelpMarker(const char* desc)
+{
+    ImGui::TextDisabled("(?)");
+    if (ImGui::IsItemHovered()) {
+        ImGui::BeginTooltip();
+        ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f);
+        ImGui::TextUnformatted(desc);
+        ImGui::PopTextWrapPos();
+        ImGui::EndTooltip();
+    }
+}
+#endif
+
+void Viewer::drawPendingGlyph()
+{
+#if defined(NANOVDB_USE_IMGUI)
+    if (!mIsDrawingPendingGlyph)
+        return;
+    ImGui::SetNextWindowPos(ImGui::GetMainViewport()->GetCenter(), ImGuiCond_Always, ImVec2(0.5f, 0.5f));
+    ImGui::SetNextWindowBgAlpha(0.35f);
+    ImGuiWindowFlags windowFlags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoMove;
+    if (ImGui::Begin("##PendingMessage", &mIsDrawingPendingGlyph, windowFlags)) {
+        ImGui::TextUnformatted("Loading...");
+    }
+    ImGui::End();
+#endif
 }
 
 void Viewer::drawHelpDialog()
@@ -746,8 +895,13 @@
     if (!mIsDrawingHelpDialog)
         return;
 
+    ImVec2 center = ImGui::GetMainViewport()->GetCenter();
+    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
+    ImGui::SetNextWindowSize(ImVec2(400, 400), ImGuiCond_Appearing);
     ImGui::Begin("Help", &mIsDrawingHelpDialog, ImGuiWindowFlags_None);
-    ImGui::Text("Coming soon...\n");
+    std::ostringstream ss;
+    printHelp(ss);
+    ImGui::TextWrapped("%s", ss.str().c_str());
     ImGui::End();
 #endif
 }
@@ -766,28 +920,52 @@
     ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None;
     if (ImGui::BeginTabBar("Render-options", tab_bar_flags)) {
         if (ImGui::BeginTabItem("Common")) {
-            auto               group = mGridGroups[mRenderGroupIndex];
-            static const char* methodNames = "Auto\0LevelSet\0FogVolume\0Grid\0Points\0\0";
-            isChanged |= ImGui::Combo("Method", (int*)&group->mRenderMethod, methodNames);
-            ImGui::Separator();
-
             drawRenderPlatformWidget("Platform");
+            ImGui::SameLine();
+            HelpMarker("The rendering platform.");
 
             ImGui::Separator();
 
             if (ImGui::CollapsingHeader("Output", ImGuiTreeNodeFlags_DefaultOpen)) {
-                static char outputStr[128] = "";
-                if (ImGui::InputTextWithHint("Output Prefix", mParams.mOutputPrefix.c_str(), outputStr, IM_ARRAYSIZE(outputStr))) {
-                    mParams.mOutputPrefix.assign(outputStr);
+                StringMap smap;
+
+                static std::vector<std::string> sFileFormats{"auto", "png", "jpg", "tga", "hdr", "pfm"};
+                smap["format"] = (mParams.mOutputExtension.empty()) ? "auto" : mParams.mOutputExtension;
+                int fileFormat = smap.getEnum("format", sFileFormats, fileFormat);
+                if (ImGui::Combo(
+                        "File Format", (int*)&fileFormat, [](void* data, int i, const char** outText) {
+                            auto& v = *static_cast<std::vector<std::string>*>(data);
+                            if (i < 0 || i >= static_cast<int>(v.size())) {
+                                return false;
+                            }
+                            *outText = v[i].c_str();
+                            return true;
+                        },
+                        static_cast<void*>(&sFileFormats),
+                        sFileFormats.size())) {
+                    mParams.mOutputExtension = sFileFormats[fileFormat];
+                    if (mParams.mOutputExtension == "auto")
+                        mParams.mOutputExtension = "";
+                    isChanged |= true;
                 }
+                ImGui::SameLine();
+                HelpMarker("The output file-format. Use \"auto\" to decide based on the file path extension.");
 
-#if defined(NANOVDB_USE_NFD)
+                static char outputStr[512] = "";
+                if (ImGui::InputTextWithHint("File Path", mParams.mOutputFilePath.c_str(), outputStr, IM_ARRAYSIZE(outputStr))) {
+                    mParams.mOutputFilePath.assign(outputStr);
+                }
+
+                ImGui::SameLine();
+                HelpMarker("The file path for the output file. C-style printf formatting can be used for the frame integer. e.g. \"./images/output.%04d.png\"");
+
+#if defined(NANOVDB_USE_NFD) && 0
                 ImGui::SameLine();
                 if (ImGui::Button("Browse...")) {
                     std::string newFilePath;
 
-                    auto currentFileName = mParams.mOutputPrefix;
-                    auto currentFilePath = mParams.mOutputPrefix;
+                    auto currentFileName = mParams.mOutputFilePath;
+                    auto currentFilePath = mParams.mOutputFilePath;
                     if (currentFilePath.find('/') != std::string::npos || currentFilePath.find('\\') != std::string::npos) {
                         currentFilePath = currentFilePath.substr(0, currentFilePath.find_last_of('/')).substr(0, currentFilePath.find_last_of('\\')) + '/';
                     } else {
@@ -810,120 +988,92 @@
                     if (openFolderDialog(newFilePath, currentFilePath)) {
                         newFilePath += '/';
                         printf("newFilePath: %s\n", newFilePath.c_str());
-                        mParams.mOutputPrefix = newFilePath + currentFileName;
-                        printf("mOutputPrefix: %s\n", mParams.mOutputPrefix.c_str());
+                        mParams.mOutputFilePath = newFilePath + currentFileName;
+                        printf("mOutputFilePath: %s\n", mParams.mOutputFilePath.c_str());
                     }
                 }
 #endif
-
-                isChanged |= ImGui::InputInt("Frame count", &mParams.mFrameCount, 1);
-
-                if (mParams.mOutputPrefix.empty()) {
-                    ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
-                    ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
-                }
-
-                if (ImGui::Button("Render")) {
-                    bool isSingleFrame = (mParams.mFrameCount <= 0);
-                    int  count = (isSingleFrame) ? 1 : mParams.mFrameCount;
-                    for (int i = 0; i < count; ++i) {
-                        render(i);
-                        saveFrameBuffer(!isSingleFrame, i);
-                    }
-                }
-
-                if (mParams.mOutputPrefix.empty()) {
-                    ImGui::PopItemFlag();
-                    ImGui::PopStyleVar();
-                }
             }
-            ImGui::Separator();
 
-            isChanged |= ImGui::Checkbox("Progressive", &mParams.mUseAccumulation);
-            ImGui::Separator();
-
-            ImGui::EndTabItem();
-        }
+            if (ImGui::CollapsingHeader("Animation", ImGuiTreeNodeFlags_DefaultOpen)) {
+                isChanged |= ImGui::InputInt("Frame start", &mParams.mFrameStart, 1);
+                ImGui::SameLine();
+                HelpMarker("The frame to start rendering from.");
+                isChanged |= ImGui::InputInt("Frame end", &mParams.mFrameEnd, 1);
+                ImGui::SameLine();
+                HelpMarker("The inclusive frame to end rendering.");
+                isChanged |= ImGui::DragFloat("Frame Rate (frames per second)", &mPlaybackRate, 0.1f, 0.1f, 120.0f, "%.1f");
+                ImGui::SameLine();
+                HelpMarker("The frame-rate for playblasting in real-time.");
+            }
 
-        auto renderMethod = RenderMethod::AUTO;
-        if (mRenderGroupIndex >= 0) {
-            auto group = mGridGroups[mRenderGroupIndex];
-            renderMethod = group->mRenderMethod;
-
-            auto& gridHdl = group->mInstances[group->mCurrentGridIndex]->mGridHandle;
-            if (renderMethod == RenderMethod::AUTO) {
-                if (gridHdl.gridMetaData()->isFogVolume())
-                    renderMethod = RenderMethod::FOG_VOLUME;
-                else if (gridHdl.gridMetaData()->isLevelSet())
-                    renderMethod = RenderMethod::LEVELSET;
-                else if (gridHdl.gridMetaData()->isPointIndex())
-                    renderMethod = RenderMethod::POINTS;
-                else if (gridHdl.gridMetaData()->isPointData())
-                    renderMethod = RenderMethod::POINTS;
-                else
-                    renderMethod = RenderMethod::GRID;
+            if (ImGui::CollapsingHeader("Lighting", ImGuiTreeNodeFlags_DefaultOpen)) {
+                isChanged |= ImGui::Checkbox("Use Lighting", (bool*)&mParams.mSceneParameters.useLighting);
+                ImGui::SameLine();
+                HelpMarker("Render with a key light.");
+                isChanged |= ImGui::Checkbox("Use Shadows", (bool*)&mParams.mSceneParameters.useShadows);
+                ImGui::SameLine();
+                HelpMarker("Render key light shadows.");
             }
-        }
 
-        if (renderMethod == RenderMethod::LEVELSET) {
-            if (ImGui::BeginTabItem("LevelSet")) {
-                if (ImGui::CollapsingHeader("Shading", ImGuiTreeNodeFlags_DefaultOpen)) {
-                    isChanged |= ImGui::SliderFloat("Occlusion", &mParams.mOptions.useOcclusion, 0.0f, 1.0f);
-                    isChanged |= ImGui::SliderFloat("Ground", &mParams.mOptions.useGround, 0.0f, 1.0f);
-                    isChanged |= ImGui::SliderFloat("Lighting", &mParams.mOptions.useLighting, 0.0f, 1.0f);
-                    isChanged |= ImGui::SliderFloat("Shadows", &mParams.mOptions.useShadows, 0.0f, 1.0f);
-                    isChanged |= ImGui::InputInt("SamplesPerPixel", &mParams.mOptions.samplesPerPixel, 1);
+            if (ImGui::CollapsingHeader("Camera", ImGuiTreeNodeFlags_DefaultOpen)) {
+                isChanged |= ImGui::Combo("Lens", (int*)&mParams.mSceneParameters.camera.lensType(), kCameraLensTypeStrings, (int)Camera::LensType::kNumTypes);
+                ImGui::SameLine();
+                HelpMarker("The camera lens type.");
+                if (mParams.mSceneParameters.camera.lensType() == Camera::LensType::kODS) {
+                    isChanged |= ImGui::DragFloat("IPD", &mParams.mSceneParameters.camera.ipd(), 0.1f, 0.f, 50.f, "%.2f");
+                    ImGui::SameLine();
+                    HelpMarker("The eye separation distance.");
                 }
-                ImGui::Separator();
-
-                if (ImGui::CollapsingHeader("Tonemap", ImGuiTreeNodeFlags_DefaultOpen)) {
-                    isChanged |= ImGui::SliderFloat("WhitePoint", &mParams.mOptions.tonemapWhitePoint, 1.0f, 20.0f);
+                if (mParams.mSceneParameters.camera.lensType() == Camera::LensType::kPinHole) {
+                    isChanged |= ImGui::DragFloat("Field of View", &mCurrentCameraState->mFovY, 1.0f, 1, 120, "%.0f");
+                    ImGui::SameLine();
+                    HelpMarker("The vertical field of view in degrees.");
                 }
 
-                ImGui::EndTabItem();
+                isChanged |= ImGui::DragInt("Samples", &mParams.mSceneParameters.samplesPerPixel, 0.1f, 1, 32);
+                ImGui::SameLine();
+                HelpMarker("The number of camera samples per ray.");
+                isChanged |= ImGui::Checkbox("Render Environment", (bool*)&mParams.mSceneParameters.useBackground);
+                ImGui::SameLine();
+                HelpMarker("Render the background environment.");
+                isChanged |= ImGui::Checkbox("Render Ground-plane", (bool*)&mParams.mSceneParameters.useGround);
+                ImGui::SameLine();
+                HelpMarker("Render the ground plane.");
+                isChanged |= ImGui::Checkbox("Render Ground-reflections", (bool*)&mParams.mSceneParameters.useGroundReflections);
+                ImGui::SameLine();
+                HelpMarker("Render ground reflections (work in progress).");
+                isChanged |= ImGui::Checkbox("Turntable Camera", &mParams.mUseTurntable);
+                ImGui::SameLine();
+                HelpMarker("Spin the camera around the pivot each frame step.");
+                isChanged |= ImGui::DragFloat("Turntable Inverse Rate", &mParams.mTurntableRate, 0.1f, 1.0f, 100.0f, "%.1f");
+                ImGui::SameLine();
+                HelpMarker("The number of frame-sequences per revolution.");
             }
-        }
-
-        if (renderMethod == RenderMethod::FOG_VOLUME) {
-            if (ImGui::BeginTabItem("FogVolume")) {
-                isChanged |= ImGui::SliderFloat("Volume density", &mParams.mOptions.volumeDensity, 0.0f, 1.0f);
 
-                ImGui::Separator();
+            if (ImGui::CollapsingHeader("Tonemapping", ImGuiTreeNodeFlags_DefaultOpen)) {
+                isChanged |= ImGui::Checkbox("Use Tonemapping", (bool*)&mParams.mSceneParameters.useTonemapping);
+                ImGui::SameLine();
+                HelpMarker("Use simple Reinhard tonemapping.");
+                isChanged |= ImGui::DragFloat("WhitePoint", &mParams.mSceneParameters.tonemapWhitePoint, 0.01f, 1.0f, 20.0f);
+                ImGui::SameLine();
+                HelpMarker("The Reinhard tonemapping whitepoint.");
+            }
 
-                if (ImGui::CollapsingHeader("Shading", ImGuiTreeNodeFlags_DefaultOpen)) {
-                    isChanged |= ImGui::SliderFloat("Occlusion", &mParams.mOptions.useOcclusion, 0.0f, 1.0f);
-                    isChanged |= ImGui::SliderFloat("Ground", &mParams.mOptions.useGround, 0.0f, 1.0f);
-                    isChanged |= ImGui::SliderFloat("Lighting", &mParams.mOptions.useLighting, 0.0f, 1.0f);
-                    isChanged |= ImGui::SliderFloat("Shadows", &mParams.mOptions.useShadows, 0.0f, 1.0f);
-                    isChanged |= ImGui::InputInt("SamplesPerPixel", &mParams.mOptions.samplesPerPixel, 1);
-                }
-                ImGui::Separator();
+            ImGui::Separator();
 
-                if (ImGui::CollapsingHeader("Tonemap", ImGuiTreeNodeFlags_DefaultOpen)) {
-                    isChanged |= ImGui::SliderFloat("WhitePoint", &mParams.mOptions.tonemapWhitePoint, 1.0f, 20.0f);
-                }
+            isChanged |= ImGui::Checkbox("Progressive", &mParams.mUseAccumulation);
+            ImGui::SameLine();
+            HelpMarker("do a progressive accumulation of the frame.");
+            isChanged |= ImGui::DragInt("Max Progressive Iterations", &mParams.mMaxProgressiveSamples, 1.f, 1, 256);
+            ImGui::SameLine();
+            HelpMarker("The maximum progressive iterations (used in batch rendering).");
 
-                ImGui::EndTabItem();
-            }
-        }
+            ImGui::Separator();
 
-        if (renderMethod == RenderMethod::POINTS) {
-            if (ImGui::BeginTabItem("Points")) {
-                isChanged |= ImGui::SliderFloat("Volume density", &mParams.mOptions.volumeDensity, 0.0f, 1.0f);
-                ImGui::Separator();
-                if (ImGui::CollapsingHeader("Attributes", ImGuiTreeNodeFlags_DefaultOpen)) {
-                    isChanged |= drawPointRenderOptionsWidget();
-                }
-                ImGui::EndTabItem();
-            }
+            ImGui::EndTabItem();
         }
 
-        if (renderMethod == RenderMethod::GRID) {
-            if (ImGui::BeginTabItem("Grid")) {
-                ImGui::Text("No parameters.");
-                ImGui::EndTabItem();
-            }
-        }
         ImGui::EndTabBar();
     }
 
@@ -934,80 +1084,6 @@
 #endif
 }
 
-bool Viewer::drawPointRenderOptionsWidget()
-{
-    bool isChanged = false;
-#if defined(NANOVDB_USE_IMGUI)
-
-    static std::vector<std::string> semanticNames;
-    if (semanticNames.empty()) {
-        for (int i = 1; i < (int)nanovdb::GridBlindDataSemantic::End; ++i)
-            semanticNames.push_back(getStringForBlindDataSemantic(nanovdb::GridBlindDataSemantic(i)));
-    }
-
-    auto  group = mGridGroups[mRenderGroupIndex];
-    auto& gridHdl = group->mInstances[group->mCurrentGridIndex]->mGridHandle;
-    if (gridHdl.gridMetaData()->isPointData()) {
-        auto grid = gridHdl.grid<uint32_t>();
-        assert(grid);
-
-        std::vector<std::string> attributeNames;
-        int                      n = grid->blindDataCount();
-
-        std::vector<nanovdb::GridBlindMetaData> attributeMeta;
-        attributeMeta.push_back(nanovdb::GridBlindMetaData{});
-        attributeNames.push_back("None");
-        for (int i = 0; i < n; ++i) {
-            auto meta = grid->blindMetaData(i);
-            attributeMeta.push_back(meta);
-            attributeNames.push_back(meta.mName + std::string(" (") + nanovdb::io::getStringForGridType(meta.mDataType) + std::string(")"));
-        }
-
-        static auto vector_getter = [](void* vec, int idx, const char** out_text) {
-            auto& vector = *static_cast<std::vector<std::string>*>(vec);
-            if (idx < 0 || idx >= static_cast<int>(vector.size())) {
-                return false;
-            }
-            *out_text = vector.at(idx).c_str();
-            return true;
-        };
-
-        int        attributeIndex = 0;
-        static int semanticIndex = 0;
-        // Left
-        {
-            ImGui::BeginChild("left pane", ImVec2(100, 200), true, ImGuiWindowFlags_AlwaysAutoResize);
-
-            //ImGui::ListBox("", &semanticIndex, vector_getter, static_cast<void*>(&semanticNames), semanticNames.size(), semanticNames.size()-1);
-
-            for (int i = 0; i < semanticNames.size(); i++) {
-                if (ImGui::Selectable(semanticNames[i].c_str(), semanticIndex == i))
-                    semanticIndex = i;
-            }
-            ImGui::EndChild();
-        }
-        ImGui::SameLine();
-
-        // Right
-        {
-            //ImGui::BeginGroup();
-            ImGui::BeginChild("item view", ImVec2(0, -ImGui::GetFrameHeightWithSpacing()), false, ImGuiWindowFlags_AlwaysAutoResize); // Leave room for 1 line below us
-            attributeIndex = mParams.mOptions.attributeSemanticMap[semanticIndex + 1].attribute + 1; // add one as item[0] is "None"
-            isChanged |= ImGui::Combo("Attribute", &attributeIndex, vector_getter, static_cast<void*>(&attributeNames), attributeNames.size());
-            isChanged |= ImGui::DragFloat("Offset", &mParams.mOptions.attributeSemanticMap[semanticIndex + 1].offset, 0.01, 0.0, 1.0);
-            isChanged |= ImGui::DragFloat("Gain", &mParams.mOptions.attributeSemanticMap[semanticIndex + 1].gain, 0.01, 0.0, 1.0);
-            ImGui::EndChild();
-            //ImGui::EndGroup();
-        }
-
-        if (isChanged) {
-            mParams.mOptions.attributeSemanticMap[semanticIndex + 1].attribute = attributeIndex - 1; // minus one as item[0] is "None"
-        }
-    }
-#endif
-    return isChanged;
-}
-
 void Viewer::drawAboutDialog()
 {
 #if defined(NANOVDB_USE_IMGUI)
@@ -1051,6 +1127,12 @@
 #ifdef NANOVDB_USE_OPENCL
         ImGui::BulletText("OpenCL");
 #endif
+#ifdef NANOVDB_USE_NFD
+        ImGui::BulletText("Native File Dialog");
+#endif
+#ifdef NANOVDB_USE_CURL
+        ImGui::BulletText("libCURL");
+#endif
         ImGui::EndChild();
     }
 
@@ -1087,122 +1169,582 @@
 #endif
 }
 
-void Viewer::drawGridTree()
+bool Viewer::drawMaterialGridAttachment(SceneNode::Ptr node, int attachmentIndex)
+{
+    bool isChanged = false;
+    char buf[1024];
+    auto attachment = node->mAttachments[attachmentIndex];
+    auto assetUrl = attachment->mAssetUrl.fullname();
+
+    std::memcpy(buf, assetUrl.c_str(), assetUrl.length());
+    buf[assetUrl.length()] = 0;
+
+    ImGui::PushID(attachmentIndex);
+    if (ImGui::InputText("##grid-value", buf, 1024, ImGuiInputTextFlags_EnterReturnsTrue)) {
+        setSceneNodeGridAttachment(node->mName, attachmentIndex, GridAssetUrl(buf));
+        isChanged = true;
+    }
+
+    if (ImGui::BeginPopupContextItem("context")) {
+        if (ImGui::Button("Clear")) {
+            setSceneNodeGridAttachment(node->mName, attachmentIndex, GridAssetUrl());
+            isChanged = true;
+        }
+        ImGui::EndPopup();
+    }
+
+    ImGui::PopID();
+
+    if (ImGui::BeginDragDropTarget()) {
+        const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("GRIDASSETURL");
+        if (payload) {
+            std::string s((const char*)(payload->Data), payload->DataSize);
+            setSceneNodeGridAttachment(node->mName, attachmentIndex, GridAssetUrl(s.c_str()));
+            isChanged = true;
+        }
+        ImGui::EndDragDropTarget();
+    }
+
+    return isChanged;
+}
+
+bool Viewer::drawPointRenderOptionsWidget(SceneNode::Ptr node, int attachmentIndex)
+{
+    bool isChanged = false;
+#if defined(NANOVDB_USE_IMGUI)
+
+    static std::vector<std::string> semanticNames;
+    if (semanticNames.empty()) {
+        for (int i = 1; i < (int)nanovdb::GridBlindDataSemantic::End; ++i)
+            semanticNames.push_back(getStringForBlindDataSemantic(nanovdb::GridBlindDataSemantic(i)));
+    }
+
+    auto attachment = node->mAttachments[attachmentIndex];
+
+    auto* gridHdl = std::get<1>(mGridManager.getGrid(attachment->mFrameUrl, attachment->mAssetUrl.gridName())).get();
+    if (!gridHdl) {
+        ImGui::TextUnformatted("ERROR: Grid not resident.");
+    } else if (gridHdl->gridMetaData()->isPointData() == false) {
+        ImGui::TextUnformatted("ERROR: Grid class must be PointData or PointIndex.");
+    } else {
+        auto grid = gridHdl->grid<uint32_t>();
+        assert(grid);
+
+        std::vector<std::string> attributeNames;
+        int                      n = grid->blindDataCount();
+
+        std::vector<nanovdb::GridBlindMetaData> attributeMeta;
+        attributeMeta.push_back(nanovdb::GridBlindMetaData{});
+        attributeNames.push_back("None");
+        for (int i = 0; i < n; ++i) {
+            auto meta = grid->blindMetaData(i);
+            attributeMeta.push_back(meta);
+            attributeNames.push_back(meta.mName + std::string(" (") + nanovdb::io::getStringForGridType(meta.mDataType) + std::string(")"));
+        }
+
+        static auto vector_getter = [](void* vec, int idx, const char** out_text) {
+            auto& vector = *static_cast<std::vector<std::string>*>(vec);
+            if (idx < 0 || idx >= static_cast<int>(vector.size())) {
+                return false;
+            }
+            *out_text = vector.at(idx).c_str();
+            return true;
+        };
+
+        int w = ImGui::GetColumnWidth(1);
+        ImGui::BeginChild("left pane", ImVec2(w, 100), false, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoDecoration);
+        ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 2));
+        ImGui::Columns(2);
+
+        ImGui::AlignTextToFramePadding();
+
+        int        attributeIndex = 0;
+        static int semanticIndex = 0;
+        // Left
+        {
+            for (int i = 0; i < semanticNames.size(); i++) {
+                if (ImGui::Selectable(semanticNames[i].c_str(), semanticIndex == i))
+                    semanticIndex = i;
+            }
+        }
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+
+        // Right
+        {
+            attributeIndex = attachment->attributeSemanticMap[semanticIndex + 1].attribute + 1; // add one as item[0] is "None"
+            isChanged |= ImGui::Combo("Attribute", &attributeIndex, vector_getter, static_cast<void*>(&attributeNames), attributeNames.size());
+            isChanged |= ImGui::DragFloat("Offset", &attachment->attributeSemanticMap[semanticIndex + 1].offset, 0.01, 0.0, 1.0);
+            isChanged |= ImGui::DragFloat("Gain", &attachment->attributeSemanticMap[semanticIndex + 1].gain, 0.01, 0.0, 1.0);
+        }
+
+        ImGui::NextColumn();
+
+        ImGui::Columns(1);
+        ImGui::Separator();
+        ImGui::PopStyleVar();
+        ImGui::EndChild();
+
+        if (isChanged) {
+            attachment->attributeSemanticMap[semanticIndex + 1].attribute = attributeIndex - 1; // minus one as item[0] is "None"
+        }
+    }
+#endif
+    return isChanged;
+}
+
+bool Viewer::drawMaterialParameters(SceneNode::Ptr node, MaterialClass mat)
+{
+    bool isChanged = false;
+
+    ImGui::AlignTextToFramePadding();
+
+    auto& params = node->mMaterialParameters;
+    if (mat == MaterialClass::kAuto) {
+        ImGui::BulletText("Grid");
+        ImGui::SameLine();
+        HelpMarker("The grid URL.\nFormat is <scheme>://<path>#<gridName><sequence>)\nwhere optional <sequence> is [<start>-<end>]\ne.g. file://explosion.%d.vdb#density[0-100]");
+
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= drawMaterialGridAttachment(node, 0);
+        ImGui::NextColumn();
+
+    } else if (mat == MaterialClass::kGrid) {
+        ImGui::BulletText("Grid");
+        ImGui::SameLine();
+        HelpMarker("The grid URL.\n(<scheme>://<path>#<gridName><sequence>)\nwhere optional <sequence> is [<start>-<end>]\ne.g. file://explosion.%d.vdb#density[0-100]");
+
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= drawMaterialGridAttachment(node, 0);
+        ImGui::NextColumn();
+
+    } else if (mat == MaterialClass::kLevelSetFast) {
+        ImGui::BulletText("LevelSet Grid");
+        ImGui::SameLine();
+        HelpMarker("The grid URL.\n(<scheme>://<path>#<gridName><sequence>)\nwhere optional <sequence> is [<start>-<end>]\ne.g. file://explosion.%d.vdb#density[0-100]");
+
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= drawMaterialGridAttachment(node, 0);
+        ImGui::NextColumn();
+        /*
+        // TODO:
+        ImGui::BulletText("Grid Interpolation Order");
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= ImGui::Combo("##interpolationOrder-value", (int*)&params.interpolationOrder, "Nearest\0Linear\0\0");
+        ImGui::NextColumn();
+        */
+        /*
+        // TODO:
+        ImGui::BulletText("Use Occlusion");
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= ImGui::DragFloat("##useOcclusion-value", &params.useOcclusion, 0.01f, 0, 1);
+        ImGui::NextColumn();*/
+
+    } else if (mat == MaterialClass::kPointsFast) {
+        ImGui::BulletText("Point Index Grid");
+        ImGui::SameLine();
+        HelpMarker("The grid URL.\n(<scheme>://<path>#<gridName><sequence>)\nwhere optional <sequence> is [<start>-<end>]\ne.g. file://explosion.%d.vdb#density[0-100]");
+
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= drawMaterialGridAttachment(node, 0);
+        ImGui::NextColumn();
+
+        ImGui::BulletText("Density");
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= ImGui::DragFloat("##density-value", &params.volumeDensityScale, 0.01f);
+        ImGui::NextColumn();
+
+        ImGui::BulletText("Attributes");
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= drawPointRenderOptionsWidget(node, 0);
+        ImGui::NextColumn();
+    } else if (mat == MaterialClass::kFogVolumePathTracer || mat == MaterialClass::kBlackBodyVolumePathTracer) {
+        ImGui::BulletText("Density Grid");
+        ImGui::SameLine();
+        HelpMarker("The grid URL.\n(<scheme>://<path>#<gridName><sequence>)\nwhere optional <sequence> is [<start>-<end>]\ne.g. file://explosion.%d.vdb#density[0-100]");
+
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= drawMaterialGridAttachment(node, 0);
+        ImGui::NextColumn();
+
+        ImGui::BulletText("Grid Interpolation Order");
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= ImGui::Combo("##interpolationOrder-value", (int*)&params.interpolationOrder, "Nearest\0Linear\0\0");
+        ImGui::NextColumn();
+
+        ImGui::BulletText("Density Scale");
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= ImGui::DragFloat("##volumeDensityScale-value", &params.volumeDensityScale, 0.01f, 0, 10);
+        ImGui::NextColumn();
+
+        ImGui::BulletText("Albedo");
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= ImGui::DragFloat("##volumeAlbedo-value", &params.volumeAlbedo, 0.01f, 0.0f, 1.0f);
+        ImGui::NextColumn();
+        /*
+        // TODO: outstanding CUDA hang with non-zero phase.
+        // presumably invalid floating-point numbers or divide-by-zero.
+        ImGui::BulletText("Phase");
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= ImGui::DragFloat("##phase-value", &params.phase, 0.01f, -1, 1);
+        ImGui::NextColumn();
+        */
+        ImGui::BulletText("Transmittance Method");
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= ImGui::Combo("##transmittancemethod-value", (int*)&params.transmittanceMethod, "ReimannSum\0DeltaTracking\0RatioTracking\0ResidualRatioTracking\0\0");
+        ImGui::NextColumn();
+
+    } else if (mat == MaterialClass::kFogVolumeFast) {
+        ImGui::BulletText("Density Grid");
+        ImGui::SameLine();
+        HelpMarker("The grid URL.\n(<scheme>://<path>#<gridName><sequence>)\nwhere optional <sequence> is [<start>-<end>]\ne.g. file://explosion.%d.vdb#density[0-100]");
+
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= drawMaterialGridAttachment(node, 0);
+        ImGui::NextColumn();
+
+        ImGui::BulletText("Grid Interpolation Order");
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= ImGui::Combo("##interpolationOrder-value", (int*)&params.interpolationOrder, "Nearest\0Linear\0\0");
+        ImGui::NextColumn();
+
+        ImGui::BulletText("Extinction");
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= ImGui::DragFloat("##extinction-value", &params.volumeDensityScale, 0.01f, 0, 10);
+        ImGui::NextColumn();
+
+        ImGui::BulletText("Transmittance Method");
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= ImGui::Combo("##transmittancemethod-value", (int*)&params.transmittanceMethod, "ReimannSum\0DeltaTracking\0RatioTracking\0ResidualRatioTracking\0\0");
+        ImGui::NextColumn();
+    }
+
+    if (mat == MaterialClass::kBlackBodyVolumePathTracer) {
+        ImGui::BulletText("Temperature Grid");
+        ImGui::SameLine();
+        HelpMarker("The grid URL.\n(<scheme>://<path>#<gridName><sequence>)\nwhere optional <sequence> is [<start>-<end>]\ne.g. file://explosion.%d.vdb#density[0-100]");
+
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= drawMaterialGridAttachment(node, 1);
+        ImGui::NextColumn();
+
+        ImGui::BulletText("Temperature Scale");
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= ImGui::DragFloat("##tempscale-value", &params.volumeTemperatureScale, 0.01f, 0, 10);
+        ImGui::NextColumn();
+    }
+
+    if (mat != MaterialClass::kAuto) {
+        /*
+        ImGui::BulletText("maxPathDepth");
+        ImGui::NextColumn();
+        ImGui::SetNextItemWidth(-1);
+        isChanged |= ImGui::InputInt("##maxPathDepth", &params.maxPathDepth, 1, 10);
+        ImGui::NextColumn();*/
+    }
+
+    return isChanged;
+}
+
+void Viewer::drawSceneGraphNodes()
 {
 #if defined(NANOVDB_USE_IMGUI)
+    bool             isChanged = false;
     std::vector<int> deleteRequests;
+    bool             openCreateNewNodePopup = false;
 
-    for (int i = 0; i < mGridGroups.size(); i++) {
-        auto group = mGridGroups[i];
+    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(2, 2));
 
-        if (ImGui::TreeNodeEx(group->mName.c_str(), ImGuiTreeNodeFlags_DefaultOpen)) {
-            for (int ins = 0; ins < group->mInstances.size(); ins++) {
-                const auto& instance = group->mInstances[ins];
-
-                bool  isSelected = (group->mCurrentGridIndex == ins);
-                auto& hdl = instance->mGridHandle;
-                if (ImGui::Selectable(instance->mGridName.c_str(), isSelected)) {
-                    setGridIndex(i, ins);
-                }
-            }
-            ImGui::TreePop();
+    if (ImGui::Button("Add...")) {
+        openCreateNewNodePopup = true;
+    }
+    ImGui::SameLine();
+    HelpMarker("Add an empty node");
+
+    ImGui::Separator();
+
+    ImGui::Columns(2);
+
+    for (int i = 0; i < mSceneNodes.size(); i++) {
+        auto node = mSceneNodes[i];
+
+        ImGui::PushID(i);
+        ImGui::AlignTextToFramePadding();
+
+        ImGuiTreeNodeFlags treeNodeFlags = ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_OpenOnArrow;
+        if (node->mIndex == mSelectedSceneNodeIndex)
+            treeNodeFlags |= ImGuiTreeNodeFlags_Selected;
+
+        std::stringstream label;
+        label << node->mName;
+
+        bool nodeOpen = ImGui::TreeNodeEx(label.str().c_str(), treeNodeFlags);
+        if (ImGui::IsItemClicked(ImGuiMouseButton_Left)) {
+            selectSceneNodeByIndex(i);
         }
 
-        if (ImGui::BeginPopupContextItem((group->mName + "-context").c_str())) {
-            if (ImGui::Button("Delete Grid"))
+        if (ImGui::BeginPopupContextItem("node context")) {
+            if (ImGui::Button("Delete...")) {
                 deleteRequests.push_back(i);
+            }
             ImGui::EndPopup();
         }
+
+        ImGui::NextColumn();
+        ImGui::AlignTextToFramePadding();
+        isChanged |= ImGui::Combo("##Material", (int*)&node->mMaterialClass, kMaterialClassTypeStrings, (int)MaterialClass::kNumTypes);
+        ImGui::NextColumn();
+
+        if (nodeOpen) {
+            auto attachment = node->mAttachments[0];
+            auto materialClass = node->mMaterialClass;
+            if (materialClass == MaterialClass::kAuto) {
+                if (attachment->mGridClassOverride == nanovdb::GridClass::FogVolume)
+                    materialClass = MaterialClass::kFogVolumePathTracer;
+                else if (attachment->mGridClassOverride == nanovdb::GridClass::LevelSet)
+                    materialClass = MaterialClass::kLevelSetFast;
+                else if (attachment->mGridClassOverride == nanovdb::GridClass::PointData)
+                    materialClass = MaterialClass::kPointsFast;
+                else if (attachment->mGridClassOverride == nanovdb::GridClass::PointIndex)
+                    materialClass = MaterialClass::kPointsFast;
+                else
+                    materialClass = MaterialClass::kGrid;
+            }
+
+            isChanged |= drawMaterialParameters(node, materialClass);
+            ImGui::Separator();
+            ImGui::TreePop();
+        }
+
+        ImGui::PopID();
     }
 
-    removeGridIndices(deleteRequests);
+    ImGui::Columns(1);
+    ImGui::PopStyleVar();
+
+    removeSceneNodes(deleteRequests);
 
+    if (isChanged) {
+        resetAccumulationBuffer();
+    }
+
+    if (openCreateNewNodePopup) {
+        ImGui::OpenPopup("Create New Node");
+    }
+
+    ImGui::SetNextWindowPos(ImGui::GetWindowViewport()->GetCenter(), ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
+    if (ImGui::BeginPopupModal("Create New Node", nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {
+        static char nameBuf[256] = {0};
+
+        ImGui::LabelText("##Name", "Name");
+        ImGui::SameLine();
+        ImGui::InputText("##NameText", nameBuf, 256);
+        ImGui::Separator();
+        if (ImGui::Button("Ok")) {
+            auto nodeId = addSceneNode(std::string(nameBuf));
+            selectSceneNodeByIndex(findNode(nodeId)->mIndex);
+
+            ImGui::CloseCurrentPopup();
+        }
+        ImGui::SameLine();
+        if (ImGui::Button("Cancel"))
+            ImGui::CloseCurrentPopup();
+        ImGui::EndPopup();
+    }
 #endif
 }
 
-void Viewer::drawGridOutliner()
+void Viewer::drawSceneGraph()
 {
-    if (!mIsDrawingOutliner)
+    if (!mIsDrawingSceneGraph)
         return;
 
 #if defined(NANOVDB_USE_IMGUI)
-
-    const float DISTANCE = 10.0f;
-    ImVec2      window_pos = ImVec2(DISTANCE, DISTANCE + 16);
-    ImVec2      window_pos_pivot = ImVec2(0, 0);
-    ImGui::SetNextWindowPos(window_pos, ImGuiCond_Always, window_pos_pivot);
-    ImGui::SetNextWindowBgAlpha(0.35f);
-
     ImGuiWindowFlags window_flags = ImGuiWindowFlags_None;
-    window_flags |= ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav; // | ImGuiWindowFlags_NoMove;
-    window_flags |= ImGuiWindowFlags_AlwaysAutoResize;
 
-    if (ImGui::Begin("Grids", &mIsDrawingOutliner, window_flags)) {
-        drawGridTree();
+    ImGui::SetNextWindowSize(ImVec2(200, 200), ImGuiCond_FirstUseEver);
+    if (ImGui::Begin("Scene", &mIsDrawingSceneGraph, window_flags)) {
+        drawSceneGraphNodes();
     }
     ImGui::End();
 #endif
 }
 
-void Viewer::drawGridStatsOverlay()
+void Viewer::drawGridInfo(const std::string& url, const std::string& gridName)
 {
-    if (!mIsDrawingGridStats)
+    nanovdb::GridHandle<>* gridHdl = std::get<1>(mGridManager.getGrid(url, gridName)).get();
+    if (gridHdl) {
+        auto meta = gridHdl->gridMetaData();
+        auto bbox = meta->worldBBox();
+        auto bboxMin = bbox.min();
+        auto bboxMax = bbox.max();
+        auto iBBox = meta->indexBBox();
+        auto effectiveSize = iBBox.max() - iBBox.min() + nanovdb::Coord(1);
+
+        ImGui::Text("Effective res:");
+        ImGui::SameLine(150);
+        ImGui::Text("%dx%dx%d", effectiveSize[0], effectiveSize[1], effectiveSize[2]);
+        ImGui::Text("BBox-min:");
+        ImGui::SameLine(150);
+        ImGui::Text("(%.2f,%.2f,%.2f)", bboxMin[0], bboxMin[1], bboxMin[2]);
+        ImGui::Text("BBox-max:");
+        ImGui::SameLine(150);
+        ImGui::Text("(%.2f,%.2f,%.2f)", bboxMax[0], bboxMax[1], bboxMax[2]);
+        ImGui::Text("Class(Type):");
+        ImGui::SameLine(150);
+        ImGui::Text("%s(%s)", nanovdb::io::getStringForGridClass(meta->gridClass()).c_str(), nanovdb::io::getStringForGridType(meta->gridType()).c_str());
+        if (meta->gridClass() == nanovdb::GridClass::PointData || meta->gridClass() == nanovdb::GridClass::PointIndex) {
+            ImGui::Text("Point count:");
+            ImGui::SameLine(150);
+            ImGui::Text("%" PRIu64, (meta->blindDataCount() > 0) ? meta->blindMetaData(0).mElementCount : 0);
+        } else {
+            ImGui::Text("Voxel count:");
+            ImGui::SameLine(150);
+            ImGui::Text("%" PRIu64, meta->activeVoxelCount());
+        }
+    } else {
+        ImGui::TextUnformatted("Loading...");
+    }
+}
+
+void Viewer::drawAssets()
+{
+    if (!mIsDrawingAssets)
         return;
 
 #if defined(NANOVDB_USE_IMGUI)
-    const float DISTANCE = 10.0f;
-    ImGuiIO&    io = ImGui::GetIO();
-    ImVec2      window_pos = ImVec2(DISTANCE, io.DisplaySize.y - DISTANCE);
-    ImVec2      window_pos_pivot = ImVec2(0, 1);
-    ImGui::SetNextWindowPos(window_pos, ImGuiCond_Always, window_pos_pivot);
-    ImGui::SetNextWindowBgAlpha(0.35f);
+    ImGuiWindowFlags window_flags = ImGuiWindowFlags_None;
 
-    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoMove;
-    window_flags |= ImGuiWindowFlags_AlwaysAutoResize;
+    ImGui::SetNextWindowSize(ImVec2(200, 200), ImGuiCond_FirstUseEver);
+    if (ImGui::Begin("Assets", &mIsDrawingAssets, window_flags)) {
+        // get the resident assets and grids.
+        auto residentAssetMap = mGridManager.getGridNameStatusInfo();
+
+        bool showErroredAssets = false;
+
+        for (auto& assetInfo : residentAssetMap) {
+            auto assetUrl = assetInfo.first;
+            auto statusAndGridInfos = assetInfo.second;
+            auto assetHasError = statusAndGridInfos.first;
+            if (!showErroredAssets && assetHasError) {
+                continue;
+            }
 
-    if (ImGui::Begin("Grid:", &mIsDrawingGridStats, window_flags)) {
-        if (mGridGroups.size() == 0) {
-            ImGui::Text("Drag and drop a file onto the window.");
-        } else {
-            auto group = mGridGroups[mRenderGroupIndex];
-            auto instance = group->mInstances[group->mCurrentGridIndex];
-            auto meta = instance->mGridHandle.gridMetaData();
-            auto bbox = meta->worldBBox();
-            auto bboxMin = bbox.min();
-            auto bboxMax = bbox.max();
-            auto iBBox = meta->indexBBox();
-            auto effectiveSize = iBBox.max() - iBBox.min() + nanovdb::Coord(1);
+            std::stringstream itemName;
+            itemName << assetUrl;
+            if (assetHasError)
+                itemName << " (error)";
+
+            ImGui::PushID(assetUrl.c_str());
+
+            if (ImGui::TreeNodeEx(itemName.str().c_str(), ImGuiTreeNodeFlags_DefaultOpen)) {
+                for (auto& assetGridInfo : statusAndGridInfos.second) {
+                    auto assetGridName = assetGridInfo.first;
+                    auto assetGridStatus = assetGridInfo.second;
+
+                    std::ostringstream ss;
+                    ss << assetGridName;
+                    if (assetGridStatus == GridManager::AssetGridStatus::kPending)
+                        ss << " (pending)";
+                    else if (assetGridStatus == GridManager::AssetGridStatus::kError)
+                        ss << " (error)";
+                    else if (assetGridStatus == GridManager::AssetGridStatus::kLoaded)
+                        ss << " (loaded)";
+
+                    auto gridAssetUrl = assetUrl + "#" + assetGridName;
+
+                    ImGui::PushID(gridAssetUrl.c_str());
+
+                    ImGuiTreeNodeFlags treeNodeFlags = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_OpenOnArrow;
+                    bool               nodeOpen = ImGui::TreeNodeEx(ss.str().c_str(), treeNodeFlags);
+
+                    if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_SourceAllowNullID)) {
+                        ImGui::SetDragDropPayload("GRIDASSETURL", gridAssetUrl.c_str(), gridAssetUrl.length(), ImGuiCond_Once);
+                        ImGui::TextUnformatted(gridAssetUrl.c_str());
+                        ImGui::EndDragDropSource();
+                    }
 
-            ImGui::Text("File:");
-            ImGui::SameLine(150);
-            ImGui::Text("%s", instance->mFileName.c_str());
-            ImGui::Text("Grid:");
-            ImGui::SameLine(150);
-            ImGui::Text("%s", meta->gridName());
-            ImGui::Text("Effective res:");
-            ImGui::SameLine(150);
-            ImGui::Text("%dx%dx%d", effectiveSize[0], effectiveSize[1], effectiveSize[2]);
-            ImGui::Text("BBox-min:");
-            ImGui::SameLine(150);
-            ImGui::Text("(%.2f,%.2f,%.2f)", bboxMin[0], bboxMin[1], bboxMin[2]);
-            ImGui::Text("BBox-max:");
-            ImGui::SameLine(150);
-            ImGui::Text("(%.2f,%.2f,%.2f)", bboxMax[0], bboxMax[1], bboxMax[2]);
-            ImGui::Text("Class(Type):");
-            ImGui::SameLine(150);
-            ImGui::Text("%s(%s)", nanovdb::io::getStringForGridClass(meta->gridClass()).c_str(), nanovdb::io::getStringForGridType(meta->gridType()).c_str());
-            if (meta->gridClass() == nanovdb::GridClass::PointData || meta->gridClass() == nanovdb::GridClass::PointIndex) {
-                ImGui::Text("Point count:");
-                ImGui::SameLine(150);
-                ImGui::Text("%" PRIu64, (meta->blindDataCount() > 0) ? meta->blindMetaData(0).mElementCount : 0);
-            } else {
-                ImGui::Text("Voxel count:");
-                ImGui::SameLine(150);
-                ImGui::Text("%" PRIu64, meta->activeVoxelCount());
+                    if (nodeOpen) {
+                        drawGridInfo(assetUrl, assetGridName);
+                        ImGui::TreePop();
+                    }
+
+                    ImGui::PopID();
+                }
+                ImGui::TreePop();
             }
+
+            ImGui::PopID();
         }
+        ImGui::End();
     }
+#endif
+}
+
+void Viewer::drawEventLog()
+{
+    if (!mIsDrawingEventLog)
+        return;
+
+#if defined(NANOVDB_USE_IMGUI)
+
+    ImGui::SetNextWindowSize(ImVec2(800, 100), ImGuiCond_FirstUseEver);
+    if (!ImGui::Begin("Log", &mIsDrawingEventLog, ImGuiWindowFlags_None)) {
+        ImGui::End();
+        return;
+    }
+
+    bool doClear = ImGui::Button("Clear");
+    ImGui::SameLine();
+    bool doCopy = ImGui::Button("Copy");
+
+    ImGui::BeginChild("scrolling", ImVec2(0, 0), false, ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_AlwaysVerticalScrollbar);
+
+    if (doClear)
+        mEventMessages.clear();
+    if (doCopy)
+        ImGui::LogToClipboard();
+
+    for (auto& eventMsg : mEventMessages) {
+        if (eventMsg.mType == GridManager::EventMessage::Type::kError)
+            ImGui::TextColored(ImVec4(1.0f, 0.0f, 1.0f, 1.0f), "[ERR]");
+        else if (eventMsg.mType == GridManager::EventMessage::Type::kWarning)
+            ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "[WRN]");
+        else if (eventMsg.mType == GridManager::EventMessage::Type::kDebug)
+            ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "[DBG]");
+        else
+            ImGui::TextColored(ImVec4(1.0f, 1.0f, 1.0f, 1.0f), "[INF]");
+        ImGui::SameLine();
+
+        ImGui::TextUnformatted(eventMsg.mMessage.c_str());
+    }
+    if (mLogAutoScroll) {
+        if (ImGui::GetScrollY() >= ImGui::GetScrollMaxY())
+            ImGui::SetScrollHereY(1.0f);
+    }
+    ImGui::EndChild();
     ImGui::End();
+
 #endif
 }
 
@@ -1212,18 +1754,25 @@
         return;
 
 #if defined(NANOVDB_USE_IMGUI)
+    ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize;
+#if defined(NANOVDB_USE_IMGUI_DOCKING)
+    auto viewPos = ImGui::GetMainViewport()->Pos;
+    auto viewSize = ImGui::GetMainViewport()->Size;
+#else
+    auto viewPos = ImGui::GetWindowPos()->Pos;
+    auto viewSize = ImGui::GetWindowSize()->Size;
+#endif
+    ImVec2 center = ImVec2(viewPos.x + viewSize.x / 2, viewPos.y + viewSize.y / 2);
+
+#if 1
     const float DISTANCE = 10.0f;
-    ImGuiIO&    io = ImGui::GetIO();
-    ImVec2      window_pos = ImVec2(io.DisplaySize.x - DISTANCE, DISTANCE + 16);
-    ImVec2      window_pos_pivot = ImVec2(1.0f, 0.0f);
-    ImGui::SetNextWindowPos(window_pos, ImGuiCond_Always, window_pos_pivot);
+    ImGui::SetNextWindowPos(ImVec2(viewPos.x + viewSize.x - DISTANCE, viewPos.y + DISTANCE + 16), ImGuiCond_Always, ImVec2(1.0f, 0.0f));
     ImGui::SetNextWindowBgAlpha(0.35f);
-
-    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoMove;
-
-    window_flags |= ImGuiWindowFlags_AlwaysAutoResize;
+    window_flags |= ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoMove;
+#endif
 
     if (ImGui::Begin("Render Stats:", &mIsDrawingRenderStats, window_flags)) {
+        ImGui::Text("Frame (%d - %d): %d", mParams.mFrameStart, mParams.mFrameEnd, mLastSceneFrame);
         ImGui::Text("FPS: %d", mFps);
         ImGui::Separator();
         drawRenderPlatformWidget("");
@@ -1236,55 +1785,123 @@
 {
 #if defined(NANOVDB_USE_IMGUI)
 
+    bool openLoadURL = false;
+
     if (ImGui::BeginMainMenuBar()) {
         if (ImGui::BeginMenu("File")) {
 #if defined(NANOVDB_USE_NFD)
-            if (ImGui::MenuItem("Open...", "O")) {
+            if (ImGui::MenuItem("Load from file...", nullptr)) {
                 std::string filePath;
                 if (openFileDialog(filePath)) {
                     try {
-                        addGrid(filePath, filePath);
+                        auto nodeId = addSceneNode();
+                        setSceneNodeGridAttachment(nodeId, 0, filePath);
+                        selectSceneNodeByIndex(findNode(nodeId)->mIndex);
+
+                        addGridAsset(filePath);
                     }
                     catch (const std::exception& e) {
                         std::cerr << "An exception occurred: \"" << e.what() << "\"" << std::endl;
                     }
                 }
             }
+#else
+            ImGui::MenuItem("Load from file...", "(Please build with NFD support)", false, false);
 #endif
-            if (ImGui::MenuItem("Quit", "Q"))
+            if (ImGui::MenuItem("Load from URL...")) {
+                openLoadURL = true;
+            }
+
+            if (ImGui::MenuItem("Quit", "Q")) {
                 glfwSetWindowShouldClose((GLFWwindow*)mWindow, 1);
+            }
             ImGui::EndMenu();
         }
 
         if (ImGui::BeginMenu("View")) {
-            if (ImGui::MenuItem("Show Outliner", NULL, mIsDrawingOutliner, true)) {
-                mIsDrawingOutliner = !mIsDrawingOutliner;
+            if (ImGui::MenuItem("Show Log", NULL, mIsDrawingEventLog, true)) {
+                mIsDrawingEventLog = !mIsDrawingEventLog;
+            }
+            if (ImGui::MenuItem("Show Scene Graph", NULL, mIsDrawingSceneGraph, true)) {
+                mIsDrawingSceneGraph = !mIsDrawingSceneGraph;
             }
-            if (ImGui::MenuItem("Show Grid Stats", NULL, mIsDrawingGridStats, true)) {
-                mIsDrawingGridStats = !mIsDrawingGridStats;
+            if (ImGui::MenuItem("Show Assets", NULL, mIsDrawingAssets, true)) {
+                mIsDrawingAssets = !mIsDrawingAssets;
             }
             if (ImGui::MenuItem("Show Render Stats", NULL, mIsDrawingRenderStats, true)) {
                 mIsDrawingRenderStats = !mIsDrawingRenderStats;
             }
-            if (ImGui::MenuItem("Turntable", "T", mParams.mUseTurntable, true)) {
-                mParams.mUseTurntable = !mParams.mUseTurntable;
-            }
 
             ImGui::EndMenu();
         }
 
-        if (ImGui::BeginMenu("Grids")) {
-            drawGridTree();
+        if (ImGui::BeginMenu("Scene")) {
+            if (ImGui::MenuItem("Add Empty Node")) {
+                auto nodeId = addSceneNode();
+                selectSceneNodeByIndex(findNode(nodeId)->mIndex);
+            }
+
+            if (ImGui::BeginMenu("Add Primitive Node")) {
+                static StringMap urls;
+                urls["ls_sphere"] = "internal://#ls_sphere_100";
+                urls["ls_torus"] = "internal://#ls_torus_100";
+                urls["ls_box"] = "internal://#ls_box_100";
+                urls["ls_bbox"] = "internal://#ls_bbox_100";
+                urls["fog_sphere"] = "internal://#fog_sphere_100";
+                urls["fog_torus"] = "internal://#fog_torus_100";
+                urls["fog_box"] = "internal://#fog_box_100";
+                urls["points_sphere"] = "internal://#points_sphere_100";
+                urls["points_torus"] = "internal://#points_torus_100";
+                urls["points_box"] = "internal://#points_box_100";
+
+                for (auto& it : urls) {
+                    if (ImGui::MenuItem(it.first.c_str())) {
+                        auto nodeId = addSceneNode(it.first);
+                        setSceneNodeGridAttachment(nodeId, 0, it.second);
+                        selectSceneNodeByIndex(findNode(nodeId)->mIndex);
+
+                        addGridAsset(it.second);
+                    }
+                }
+                ImGui::EndMenu();
+            }
+
+            ImGui::Separator();
+
+            if (ImGui::MenuItem("Play", "Enter", false, mPlaybackState == PlaybackState::STOP)) {
+                mPlaybackState = PlaybackState::PLAY;
+            }
+            if (ImGui::MenuItem("Stop", "Enter", false, mPlaybackState == PlaybackState::PLAY)) {
+                mPlaybackState = PlaybackState::STOP;
+            }
+            if (ImGui::MenuItem("Play from start", "Ctrl(Enter)", false)) {
+                mPendingSceneFrame = mParams.mFrameStart;
+                mPlaybackState = PlaybackState::PLAY;
+                mPlaybackLastTime = getTime();
+                mPlaybackTime = 0;
+            }
             ImGui::EndMenu();
         }
 
         if (ImGui::BeginMenu("Render")) {
-            std::string outputFilename = "no output prefix specified";
-            if (!mParams.mOutputPrefix.empty()) {
-                outputFilename = (mParams.mOutputPrefix + ".pfm");
-            }
-            if (ImGui::MenuItem("Save Screenshot", outputFilename.c_str(), false, !mParams.mOutputPrefix.empty())) {
-                saveFrameBuffer(false);
+            {
+                std::string screenshotLabel = "no output specified";
+                auto        sceneFrame = getSceneFrame();
+                if (!mParams.mOutputFilePath.empty()) {
+                    screenshotLabel = updateFilePathWithFrame(mParams.mOutputFilePath, sceneFrame);
+                }
+
+                bool areAttachmentsReady = true;
+                if (mSelectedSceneNodeIndex >= 0) {
+                    areAttachmentsReady = updateNodeAttachmentRequests(mSceneNodes[mSelectedSceneNodeIndex], true, mIsDumpingLog);
+                }
+
+                if (ImGui::MenuItem("Save Screenshot", screenshotLabel.c_str(), false, areAttachmentsReady && !mParams.mOutputFilePath.empty())) {
+                    for (int i = (mParams.mUseAccumulation) ? mParams.mMaxProgressiveSamples : 1; i > 0; --i) {
+                        render(sceneFrame);
+                    }
+                    saveFrameBuffer(sceneFrame);
+                }
             }
 
             ImGui::Separator();
@@ -1293,11 +1910,20 @@
                 mIsDrawingRenderOptions = true;
             }
 
-            if (ImGui::MenuItem("Play", nullptr, false, mPlaybackState == PlaybackState::STOP)) {
-                mPlaybackState = PlaybackState::PLAY;
+            ImGui::Separator();
+
+            if (mParams.mOutputFilePath.empty()) {
+                ImGui::PushItemFlag(ImGuiItemFlags_Disabled, true);
+                ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f);
             }
-            if (ImGui::MenuItem("Stop", nullptr, false, mPlaybackState == PlaybackState::PLAY)) {
-                mPlaybackState = PlaybackState::STOP;
+
+            if (ImGui::Button("Batch Render")) {
+                renderSequence();
+            }
+
+            if (mParams.mOutputFilePath.empty()) {
+                ImGui::PopItemFlag();
+                ImGui::PopStyleVar();
             }
 
             ImGui::EndMenu();
@@ -1314,5 +1940,38 @@
 
         ImGui::EndMainMenuBar();
     }
+
+    if (openLoadURL)
+        ImGui::OpenPopup("Load URL");
+
+#if defined(NANOVDB_USE_IMGUI_DOCKING)
+    auto viewPos = ImGui::GetMainViewport()->Pos;
+    auto viewSize = ImGui::GetMainViewport()->Size;
+#else
+    auto viewPos = ImGui::GetWindowPos()->Pos;
+    auto viewSize = ImGui::GetWindowSize()->Size;
+#endif
+    ImVec2 center = ImVec2(viewPos.x + viewSize.x / 2, viewPos.y + viewSize.y / 2);
+
+    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
+    if (ImGui::BeginPopupModal("Load URL", NULL, ImGuiWindowFlags_AlwaysAutoResize)) {
+        static char urlBuf[1024] = {0};
+        static char nameBuf[256] = {0};
+
+        ImGui::InputText("Node Name", nameBuf, 1024);
+        ImGui::InputText("Asset URL", urlBuf, 1024);
+
+        ImGui::Separator();
+        if (ImGui::Button("Load")) {
+            auto nodeId = addSceneNode(std::string(nameBuf));
+            setSceneNodeGridAttachment(nodeId, 0, urlBuf);
+            addGridAsset(urlBuf);
+            ImGui::CloseCurrentPopup();
+        }
+        ImGui::SameLine();
+        if (ImGui::Button("Cancel"))
+            ImGui::CloseCurrentPopup();
+        ImGui::EndPopup();
+    }
 #endif
 }
\ Pas de fin de ligne Ã  la fin du fichier
diff -aur nanovdb-20200925/nanovdb/cmd/viewer/Viewer.h nanovdb-20201022/nanovdb/cmd/viewer/Viewer.h
--- nanovdb-20200925/nanovdb/cmd/viewer/Viewer.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/cmd/viewer/Viewer.h	2020-10-22 03:52:50.000000000 +0200
@@ -22,13 +22,15 @@
 
     void   open() override;
     void   close() override;
-    void   render(int frame) override;
-    void   resize(int width, int height) override;
+    bool   render(int frame) override;
+    void   resizeFrameBuffer(int width, int height) override;
     void   run() override;
     void   renderViewOverlay() override;
     double getTime() override;
-    void   printHelp() const override;
-    bool   updateCamera(int frame) override;
+    void   printHelp(std::ostream& s) const override;
+    bool   updateCamera() override;
+    void   updateAnimationControl();
+    void   setSceneFrame(int frame);
 
     void onKey(int key, int action);
     void onMouseButton(int button, int action);
@@ -39,39 +41,52 @@
     void onDrop(int numPaths, const char** paths);
 
     static void mainLoop(void* userData);
-    bool runLoop();
+    bool        runLoop();
 
 protected:
     void updateWindowTitle();
 
-
 private:
     // gui.
-    bool mIsDrawingGridStats = true;
-    bool mIsDrawingRenderStats = true;
-    bool mIsDrawingAboutDialog = false;
-    bool mIsDrawingHelpDialog = false;
-    bool mIsDrawingOutliner = false;
-    bool mIsDrawingRenderOptions = false;
+    bool         mIsDrawingRenderStats = true;
+    bool         mIsDrawingAboutDialog = false;
+    bool         mIsDrawingHelpDialog = false;
+    bool         mIsDrawingSceneGraph = false;
+    bool         mIsDrawingAssets = false;
+    bool         mIsDrawingRenderOptions = false;
+    bool         mIsDrawingEventLog = false;
+    bool         mLogAutoScroll = true;
+    bool         mIsDrawingPendingGlyph = false;
 
-    bool drawPointRenderOptionsWidget();
+    bool drawPointRenderOptionsWidget(SceneNode::Ptr node, int attachmentIndex);
     void drawRenderStatsOverlay();
-    void drawGridStatsOverlay();
     void drawAboutDialog();
     void drawRenderPlatformWidget(const char* label);
     void drawMenuBar();
-    void drawGridOutliner();
-    void drawGridTree();
+    void drawSceneGraph();
+    void drawAssets();
+    void drawSceneGraphNodes();
     void drawHelpDialog();
     void drawRenderOptionsDialog();
-
-    void* mWindow = nullptr;
-    int   mFps = 0;
+    void drawEventLog();
+    void drawGridInfo(const std::string& url, const std::string& gridName);
+    bool drawMaterialParameters(SceneNode::Ptr node, MaterialClass mat);
+    bool drawMaterialGridAttachment(SceneNode::Ptr node, int attachmentIndex);
+    void drawPendingGlyph();
+
+    void*  mWindow = nullptr;
+    int    mWindowWidth = 0;
+    int    mWindowHeight = 0;
+    int    mFps = 0;
     size_t mFpsFrame = 0;
     double mTime = 0;
 
-    enum class PlaybackState { STOP=0,PLAY=1};
+    enum class PlaybackState { STOP = 0,
+                               PLAY = 1 };
     PlaybackState mPlaybackState = PlaybackState::STOP;
+    float         mPlaybackTime = 0;
+    float         mPlaybackLastTime = 0;
+    float         mPlaybackRate = 30;
 
     // mouse state.
     bool  mMouseDown = false;
diff -aur nanovdb-20200925/nanovdb/docker/development/Dockerfile.base nanovdb-20201022/nanovdb/docker/development/Dockerfile.base
--- nanovdb-20200925/nanovdb/docker/development/Dockerfile.base	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/docker/development/Dockerfile.base	2020-10-22 03:52:50.000000000 +0200
@@ -18,7 +18,7 @@
 	$ROOT_PATH/scripts/linux_install_core.sh && \
     dos2unix $ROOT_PATH/scripts/linux_install_gcc.sh && \
     chmod +x $ROOT_PATH/scripts/linux_install_gcc.sh && \
-	$ROOT_PATH/scripts/linux_install_gcc.sh 8 && \
+	$ROOT_PATH/scripts/linux_install_gcc.sh g++-8 && \
     dos2unix $ROOT_PATH/scripts/build_openvdb.sh && \
     chmod +x $ROOT_PATH/scripts/build_openvdb.sh && \
 	$ROOT_PATH/scripts/build_openvdb.sh latest clang++ Release 7 ON None -DOPENVDB_CXX_STRICT=ON
diff -aur nanovdb-20200925/nanovdb/docker/development/Dockerfile.test-build nanovdb-20201022/nanovdb/docker/development/Dockerfile.test-build
--- nanovdb-20200925/nanovdb/docker/development/Dockerfile.test-build	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/docker/development/Dockerfile.test-build	2020-10-22 03:52:50.000000000 +0200
@@ -14,6 +14,11 @@
 	chmod +x $ROOT_PATH/ci/*.sh
 
 RUN \
+    dos2unix ./docker/scripts/*.sh && \
+	chmod +x ./docker/scripts/*.sh && \
+    ./docker/scripts/linux_install_gcc.sh $COMPILER
+
+RUN \
     ./ci/build_core.sh default $COMPILER $CUDA_VER Release \
         -DNANOVDB_USE_OPTIX=OFF \
         -DNANOVDB_USE_CUDA=ON
@@ -27,20 +32,20 @@
 #
 # examples fails to run due to missing WINE implementation of fma.
 
-RUN \
-    wine --version && \
-    wine wineboot && \
-    ./ci/build_core_toolchain.sh msvc16 $ROOT_PATH/ci/wine-toolchain.cmake Release \
-        -DNANOVDB_USE_OPENVDB=OFF \
-        -DNANOVDB_USE_TBB=OFF \
-        -DNANOVDB_USE_ZLIB=OFF \
-        -DNANOVDB_USE_BLOSC=OFF \
-        -DNANOVDB_BUILD_TOOLS=ON \
-        -DNANOVDB_BUILD_UNITTESTS=OFF
+#RUN \
+#    wine --version && \
+#    wine wineboot && \
+#    ./ci/build_core_toolchain.sh msvc16 $ROOT_PATH/ci/wine-toolchain.cmake Release \
+#        -DNANOVDB_USE_OPENVDB=OFF \
+#        -DNANOVDB_USE_TBB=OFF \
+#        -DNANOVDB_USE_ZLIB=OFF \
+#        -DNANOVDB_USE_BLOSC=OFF \
+#        -DNANOVDB_BUILD_TOOLS=ON \
+#        -DNANOVDB_BUILD_UNITTESTS=OFF
 
-RUN \
-    ./ci/build_docs.sh
+#RUN \
+#    ./ci/build_docs.sh
 
 RUN \
-    ./ci/test_core.sh default && \
-    ./ci/test_render.sh default
+    ./ci/test_core.sh default
+#    ./ci/test_render.sh default
diff -aur nanovdb-20200925/nanovdb/docker/development/test.cmd nanovdb-20201022/nanovdb/docker/development/test.cmd
--- nanovdb-20200925/nanovdb/docker/development/test.cmd	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/docker/development/test.cmd	2020-10-22 03:52:50.000000000 +0200
@@ -21,7 +21,7 @@
 GOTO BuildImage
 :NoRepo
 pushd %REPO_DIR%
-tar --exclude="data" --exclude="out" --exclude=".git" --exclude="__*" -cvf %DIST_DIR%\repo.tar .
+tar --exclude="data" --exclude="out" --exclude=".git" --exclude="build" --exclude="__*" -cvf %DIST_DIR%\repo.tar .
 popd
 GOTO BuildImage
 
diff -aur nanovdb-20200925/nanovdb/docker/development/test.sh nanovdb-20201022/nanovdb/docker/development/test.sh
--- nanovdb-20200925/nanovdb/docker/development/test.sh	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/docker/development/test.sh	2020-10-22 03:52:50.000000000 +0200
@@ -22,7 +22,7 @@
     popd
 else
     pushd ${REPO_DIR}
-    tar --exclude="data" --exclude="out" --exclude=".git" --exclude="__*" -cvf ${DIST_DIR}/repo.tar .
+    tar --exclude="data" --exclude="out" --exclude=".git" --exclude="build" --exclude="__*" -cvf ${DIST_DIR}/repo.tar .
     popd
 fi
 
diff -aur nanovdb-20200925/nanovdb/docker/scripts/linux_install_gcc.sh nanovdb-20201022/nanovdb/docker/scripts/linux_install_gcc.sh
--- nanovdb-20200925/nanovdb/docker/scripts/linux_install_gcc.sh	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/docker/scripts/linux_install_gcc.sh	2020-10-22 03:52:50.000000000 +0200
@@ -2,8 +2,15 @@
 
 set -ex
 
-GCC_TOOLCHAIN="$1"; shift
+COMPILER="$1"; shift
+
+if [[ $COMPILER = gcc-* ]] || [[ $COMPILER = g++-* ]]; then
+    GCC_TOOLCHAIN=`echo $COMPILER | cut -d"-" -f 2`
+    COMPILER=`echo $COMPILER | cut -d"-" -f 1`
+    echo "COMPILER=$COMPILER GCC_TOOLCHAIN=$GCC_TOOLCHAIN"
+
+    sudo yum -y install devtoolset-${GCC_TOOLCHAIN}-gcc devtoolset-${GCC_TOOLCHAIN}-gcc-c++ || export RC=true
+    source scl_source enable devtoolset-${GCC_TOOLCHAIN} || export RC=true
+fi
 
 sudo yum -y install gtest-devel || export RC=true
-sudo yum -y install devtoolset-${GCC_TOOLCHAIN}-gcc devtoolset-${GCC_TOOLCHAIN}-gcc-c++ || export RC=true
-source scl_source enable devtoolset-${GCC_TOOLCHAIN} || export RC=true
diff -aur nanovdb-20200925/nanovdb/docs/FAQ.md nanovdb-20201022/nanovdb/docs/FAQ.md
--- nanovdb-20200925/nanovdb/docs/FAQ.md	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/docs/FAQ.md	2020-10-22 03:52:50.000000000 +0200
@@ -36,9 +36,5 @@
 
   That very much depends on your application and requirements. While the core NanoVDB data structure is robust and unlikely to change, its API (and ABI) might change based on the feedback we are soliciting from clients. The file format, on the other hand, is almost certainly going to change in order to support multiple grids and vector types. However, if your question is simply "is NanoVDB working today", then the answer is "yes to the best of our knowledge"! While the NanoVDB project is only a few months old, its underlying VDB data structure is over a decade old and more to the point it has been battle-tested since it was open-sourced in 2012. However, if you encounter any bugs please please let us know :)
 
-* **Will NanoVDB be open-sourced?**
-
-  While NanoVDB is currently shared with a restrictive license under NDA, there is consensus at NVIDIA to eventually contribute parts of NanoVDB back into to the OpenVDB library. When this happens and exactly what parts of NanoVDB depends on the feedback we receive from the few vendors we have decided to share it with. As such, it is important that you let us know if you continue to be interested in adopting NanoVDB and of course if there are missing features or blocking issues (including licensing concerns).
-
 ### Copyright Contributors to the OpenVDB Project
 ### SPDX-License-Identifier: MPL-2.0
\ Pas de fin de ligne Ã  la fin du fichier
diff -aur nanovdb-20200925/nanovdb/examples/benchmark/Benchmark.cpp nanovdb-20201022/nanovdb/examples/benchmark/Benchmark.cpp
--- nanovdb-20200925/nanovdb/examples/benchmark/Benchmark.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/examples/benchmark/Benchmark.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -43,6 +43,29 @@
 #include <tbb/blocked_range2d.h>
 #endif
 
+inline std::ostream&
+operator<<(std::ostream& os, const nanovdb::CoordBBox& b)
+{
+    os << "(" << b[0][0] << "," << b[0][1] << "," << b[0][2] << ") ->"
+       << "(" << b[1][0] << "," << b[1][1] << "," << b[1][2] << ")";
+    return os;
+}
+
+inline std::ostream&
+operator<<(std::ostream& os, const nanovdb::Coord& ijk)
+{
+    os << "(" << ijk[0] << "," << ijk[1] << "," << ijk[2] << ")";
+    return os;
+}
+
+template <typename T>
+inline std::ostream&
+operator<<(std::ostream& os, const nanovdb::Vec3<T>& v)
+{
+    os << "(" << v[0] << "," << v[1] << "," << v[2] << ")";
+    return os;
+}
+
 // define the enviroment variable VDB_DATA_PATH to use models from the web
 // e.g. setenv VDB_DATA_PATH /home/kmu/dev/data/vdb
 // or   export VDB_DATA_PATH=/Users/ken/dev/data/vdb
@@ -126,32 +149,70 @@
     using BBoxT = nanovdb::BBox<Vec3T>;
     using RayT = nanovdb::Ray<RealT>;
 
-    // test bbox clip
-    const Vec3T dir(-1.0, 2.0, 3.0);
-    const Vec3T eye(2.0, 1.0, 1.0);
-    RealT       t0 = 0.1, t1 = 12589.0;
-    RayT        ray(eye, dir, t0, t1);
-
-    // intersects the two faces of the box perpendicular to the y-axis!
-    EXPECT_TRUE(ray.clip(CoordBBoxT(CoordT(0, 2, 2), CoordT(2, 4, 6))));
-    EXPECT_EQ(0.5, ray.t0());
-    EXPECT_EQ(1.5, ray.t1());
-    EXPECT_EQ(ray(0.5)[1], 2); //lower y component of intersection
-    EXPECT_EQ(ray(1.5)[1], 4); //higher y component of intersection
-
-    ray.reset(eye, dir, t0, t1);
-    // intersects the lower edge anlong the z-axis of the box
-    EXPECT_TRUE(ray.clip(BBoxT(Vec3T(1.5, 2.0, 2.0), Vec3T(4.5, 4.0, 6.0))));
-    EXPECT_EQ(0.5, ray.t0());
-    EXPECT_EQ(0.5, ray.t1());
-    EXPECT_EQ(ray(0.5)[0], 1.5); //lower y component of intersection
-    EXPECT_EQ(ray(0.5)[1], 2.0); //higher y component of intersection
-
-    ray.reset(eye, dir, t0, t1);
-    // no intersections
-    EXPECT_TRUE(!ray.clip(CoordBBoxT(CoordT(4, 2, 2), CoordT(6, 4, 6))));
-    EXPECT_EQ(t0, ray.t0());
-    EXPECT_EQ(t1, ray.t1());
+    {// clip ray against an index bbox
+        // test bbox clip
+        const Vec3T dir(-1.0, 2.0, 3.0);
+        const Vec3T eye(2.0, 1.0, 1.0);
+        RealT       t0 = 0.1, t1 = 12589.0;
+        RayT        ray(eye, dir, t0, t1);
+
+        // intersects the two faces of the box perpendicular to the y-axis!
+        EXPECT_TRUE(ray.clip(CoordBBoxT(CoordT(0, 2, 2), CoordT(2, 4, 6))));
+        //std::cerr << "t0 = " << ray.t0() << ", ray.t1() = " << ray.t1() << std::endl;
+        //std::cerr << "ray(0.5) = " << ray(0.5) << std::endl;
+        //std::cerr << "ray(1.5) = " << ray(1.5) << std::endl;
+        //std::cerr << "ray(2.0) = " << ray(2.0) << std::endl;
+        EXPECT_EQ(0.5, ray.t0());
+        EXPECT_EQ(1.5, ray.t1());
+        EXPECT_EQ(ray(0.5)[1], 2); //lower y component of intersection
+        EXPECT_EQ(ray(1.5)[1], 4); //higher y component of intersection
+
+        ray.reset(eye, dir, t0, t1);
+        // intersects the lower edge anlong the z-axis of the box
+        EXPECT_TRUE(ray.clip(BBoxT(Vec3T(1.5, 2.0, 2.0), Vec3T(4.5, 4.0, 6.0))));
+        EXPECT_EQ(0.5, ray.t0());
+        EXPECT_EQ(0.5, ray.t1());
+        EXPECT_EQ(ray(0.5)[0], 1.5); //lower y component of intersection
+        EXPECT_EQ(ray(0.5)[1], 2.0); //higher y component of intersection
+
+        ray.reset(eye, dir, t0, t1);
+        // no intersections
+        EXPECT_TRUE(!ray.clip(CoordBBoxT(CoordT(4, 2, 2), CoordT(6, 4, 6))));
+        EXPECT_EQ(t0, ray.t0());
+        EXPECT_EQ(t1, ray.t1());
+    }
+    {// clip ray against an real bbox
+        // test bbox clip
+        const Vec3T dir(-1.0, 2.0, 3.0);
+        const Vec3T eye(2.0, 1.0, 1.0);
+        RealT       t0 = 0.1, t1 = 12589.0;
+        RayT        ray(eye, dir, t0, t1);
+
+        // intersects the two faces of the box perpendicular to the y-axis!
+        EXPECT_TRUE( ray.clip(CoordBBoxT(CoordT(0, 2, 2), CoordT(2, 4, 6)).asReal<double>()) );
+        //std::cerr << "t0 = " << ray.t0() << ", ray.t1() = " << ray.t1() << std::endl;
+        //std::cerr << "ray(0.5) = " << ray(0.5) << std::endl;
+        //std::cerr << "ray(1.5) = " << ray(1.5) << std::endl;
+        //std::cerr << "ray(2.0) = " << ray(2.0) << std::endl;
+        EXPECT_EQ(0.5, ray.t0());
+        EXPECT_EQ(2.0, ray.t1());
+        EXPECT_EQ(ray(0.5)[1], 2); //lower y component of intersection
+        EXPECT_EQ(ray(1.5)[1], 4); //higher y component of intersection
+
+        ray.reset(eye, dir, t0, t1);
+        // intersects the lower edge anlong the z-axis of the box
+        EXPECT_TRUE( ray.clip(BBoxT(Vec3T(1.5, 2.0, 2.0), Vec3T(4.5, 4.0, 6.0))) );
+        EXPECT_EQ(0.5, ray.t0());
+        EXPECT_EQ(0.5, ray.t1());
+        EXPECT_EQ(ray(0.5)[0], 1.5); //lower y component of intersection
+        EXPECT_EQ(ray(0.5)[1], 2.0); //higher y component of intersection
+
+        ray.reset(eye, dir, t0, t1);
+        // no intersections
+        EXPECT_TRUE(!ray.clip(CoordBBoxT(CoordT(4, 2, 2), CoordT(6, 4, 6)).asReal<double>()) );
+        EXPECT_EQ(t0, ray.t0());
+        EXPECT_EQ(t1, ray.t1());
+    }
 }
 
 TEST_F(Benchmark, HDDA)
@@ -278,7 +339,7 @@
 
     auto srcGrid = this->getSrcGrid();
     mTimer.start("Generating NanoVDB grid");
-    auto handle = nanovdb::openToNanoVDB(*srcGrid, /*mortonSort=*/false, /*verbose=*/0);
+    auto handle = nanovdb::openToNanoVDB(*srcGrid, nanovdb::StatsMode::BBox, nanovdb::ChecksumMode::Disable, /*mortonSort=*/false, /*verbose=*/0);
     mTimer.restart("Writing NanoVDB grid");
 #if defined(NANOVDB_USE_BLOSC)
     nanovdb::io::writeGrid("data/test.nvdb", handle, nanovdb::io::Codec::BLOSC);
diff -aur nanovdb-20200925/nanovdb/examples/ex_bump_pool_buffer/bump_pool_buffer.cpp nanovdb-20201022/nanovdb/examples/ex_bump_pool_buffer/bump_pool_buffer.cpp
--- nanovdb-20200925/nanovdb/examples/ex_bump_pool_buffer/bump_pool_buffer.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/examples/ex_bump_pool_buffer/bump_pool_buffer.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -110,8 +110,8 @@
         std::vector<nanovdb::GridHandle<PoolBuffer>> gridHdls;
 
         // create two grids...
-        gridHdls.push_back(nanovdb::createLevelSetSphere<float>(100.0f, nanovdb::Vec3R(-20, 0, 0), 1.0f, 3.0f, nanovdb::Vec3R(0), "spheref", nanovdb::ChecksumMode::Partial, bufferContext));
-        gridHdls.push_back(nanovdb::createLevelSetSphere<double>(100.0f, nanovdb::Vec3R(20, 0, 0), 1.0f, 3.0f, nanovdb::Vec3R(0), "sphered", nanovdb::ChecksumMode::Partial, bufferContext));
+        gridHdls.push_back(nanovdb::createLevelSetSphere<float>(100.0f, nanovdb::Vec3R(-20, 0, 0), 1.0f, 3.0f, nanovdb::Vec3R(0), "spheref", nanovdb::StatsMode::BBox, nanovdb::ChecksumMode::Partial, bufferContext));
+        gridHdls.push_back(nanovdb::createLevelSetSphere<double>(100.0f, nanovdb::Vec3R(20, 0, 0), 1.0f, 3.0f, nanovdb::Vec3R(0), "sphered", nanovdb::StatsMode::BBox, nanovdb::ChecksumMode::Partial, bufferContext));
 
         // Get a (raw) pointer to the NanoVDB grid form the GridManager.
         auto* dstGrid = gridHdls[0].grid<float>();
diff -aur nanovdb-20200925/nanovdb/examples/ex_map_pool_buffer/map_pool_buffer.cpp nanovdb-20201022/nanovdb/examples/ex_map_pool_buffer/map_pool_buffer.cpp
--- nanovdb-20200925/nanovdb/examples/ex_map_pool_buffer/map_pool_buffer.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/examples/ex_map_pool_buffer/map_pool_buffer.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -148,8 +148,8 @@
         std::vector<nanovdb::GridHandle<MapPoolBuffer>> gridHdls;
 
         // create two grids...
-        gridHdls.push_back(nanovdb::createLevelSetSphere<float>(100.0f, nanovdb::Vec3R(-20, 0, 0), 1.0f, 3.0f, nanovdb::Vec3R(0), "spheref", nanovdb::ChecksumMode::Partial, bufferContext));
-        gridHdls.push_back(nanovdb::createLevelSetSphere<double>(100.0f, nanovdb::Vec3R(20, 0, 0), 1.0f, 3.0f, nanovdb::Vec3R(0), "sphered", nanovdb::ChecksumMode::Partial, bufferContext));
+        gridHdls.push_back(nanovdb::createLevelSetSphere<float>(100.0f, nanovdb::Vec3R(-20, 0, 0), 1.0f, 3.0f, nanovdb::Vec3R(0), "spheref", nanovdb::StatsMode::BBox, nanovdb::ChecksumMode::Partial, bufferContext));
+        gridHdls.push_back(nanovdb::createLevelSetSphere<double>(100.0f, nanovdb::Vec3R(20, 0, 0), 1.0f, 3.0f, nanovdb::Vec3R(0), "sphered", nanovdb::StatsMode::BBox, nanovdb::ChecksumMode::Partial, bufferContext));
 
         // share grid[0]'s buffer into a parent-scope handle to prevent deletion.
         anotherHdl = nanovdb::GridHandle<MapPoolBuffer>(bufferContext.copy(gridHdls[0].buffer().mId));
Seulement dans nanovdb-20201022/nanovdb/external: stb
diff -aur nanovdb-20200925/nanovdb/Makefile nanovdb-20201022/nanovdb/Makefile
--- nanovdb-20200925/nanovdb/Makefile	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/Makefile	2020-10-22 03:52:50.000000000 +0200
@@ -23,6 +23,7 @@
 USE_JEMALLOC := no
 USE_OPENGL := yes
 USE_OPENCL := yes
+USE_INTRINSICS := yes
 
 BUILD_BENCHMARK := yes
 BUILD_UNITTESTS := yes
@@ -39,7 +40,12 @@
 endif
 
 #CC = clang -Wall -Wunused-parameter -march=native
-CC = g++ -Wall -Wunused-parameter -march=native
+CC = g++ -Wall -Wunused-parameter -Wno-invalid-offsetof -march=native
+
+ifeq (yes,$(USE_INTRINSICS))
+    CXXFLAGS += -DNANOVDB_USE_INTRINSICS
+endif 
+
 ifeq (yes,$(USE_OPENVDB))
     CXXFLAGS += -std=c++14
 else
@@ -54,7 +60,7 @@
 ARCHIVE = NanoVDB_$(shell date +%F_%Hh%Mm%Ss)_$(BRANCH)
 
 DEP = Makefile nanovdb/*.h nanovdb/util/*.h
-CMD = release/nanovdb_print release/nanovdb_convert release/nanovdb_viewer
+CMD = release/nanovdb_print release/nanovdb_convert release/nanovdb_viewer release/nanovdb_validate
 EXA = debug/bump_pool_buffer debug/make_custom_nanovdb debug/make_nanovdb_sphere debug/make_typed_grids \
       debug/map_pool_buffer debug/read_nanovdb_sphere debug/read_nanovdb_sphere_accessor
 ALL = $(CMD) $(EXA)
@@ -283,6 +289,8 @@
 
 nanovdb_viewer: release/nanovdb_viewer
 
+nanovdb_validate: release/nanovdb_validate
+
 # build object files
 
 release/TestNanoVDB.o: unittest/TestNanoVDB.cpp $(DEP)
@@ -381,6 +389,10 @@
 	@mkdir -p release
 	$(BUILD_RELEASE) $(INCLUDES) -o $@ -c $<
 
+release/nanovdb_validate.o: cmd/validate/nanovdb_validate.cpp $(DEP)
+	@mkdir -p release
+	$(BUILD_RELEASE) $(INCLUDES) -o $@ -c $<
+
 release/nanovdb_viewer.o: cmd/viewer/nanovdb_viewer.cpp $(DEP)
 	@mkdir -p release
 	$(BUILD_CUDA) $(INCLUDES) -o $@ -c $<
@@ -522,6 +534,9 @@
 	$(warning WARNING: nanovdb_convert requires OpenVDB. Set USE_OPENVDB := yes)
 endif
 
+release/nanovdb_validate: release/nanovdb_validate.o
+	$(BUILD_RELEASE) $(LIBRARY) -o $@ $^ $(LIBS)
+
 release/nanovdb_viewer: release/nanovdb_viewer.o \
                         release/FrameBuffer.o \
                         release/FrameBufferHost.o \
diff -aur nanovdb-20200925/nanovdb/nanovdb/NanoVDB.h nanovdb-20201022/nanovdb/nanovdb/NanoVDB.h
--- nanovdb-20200925/nanovdb/nanovdb/NanoVDB.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/nanovdb/NanoVDB.h	2020-10-22 03:52:50.000000000 +0200
@@ -30,7 +30,7 @@
 
 
     \warning NanoVDB grids can only be constructed from with tools like openToNanoVDB
-             or the GridBuilder. This explains why none of the grid nodes defined below 
+             or the GridBuilder. This explains why none of the grid nodes defined below
              have public constructors or destructors.
 
     \details Please see the following paper for more details on the data structure:
@@ -42,7 +42,10 @@
     Overview: This file implements the following fundamental class that when combined
           forms the backbone of the VDB tree data structure:
 
+          Coord- a signed integer coordinate
           Vec3 - a 3D vector
+          Vec4 - a 4D vector
+          BBox - a bounding box
           Mask - a bitmask essential to the non-root tree nodes
           Map  - an affine coordinate transformation
           Grid - contains a Tree and a ma for world<->index transformations. Use
@@ -58,16 +61,45 @@
           denoted voxel values, and values associated with other tree nodes are referred
           to as tile values, which by design cover a larger coordinate index domain.
 
+
+    Memory layout:
+
+    GridData: 672 bytes (e.g. magic, checksum, major, flags, world bbox, grid name, and affine transformation)
+    
+    TreeData: 64 bytes (node counts and byte offsets)
+    
+    ... optional padding ...
+    
+    RootData: size depends on ValueType (index bbox, voxel count, tile count, min/max/avg/standard deviation)
+    
+    Array of: RootData::Tile
+    
+    ... optional padding ...
+    
+    Array of: Upper InternalNodes of size 32^3:  bbox, two bit masks, 32768 tile values, and min/max/avg/standard deviation values
+    
+    ... optional padding ...
+    
+    Array of: Lower InternalNodes of size 16^3:  bbox, two bit masks, 4096 tile values, and min/max/avg/standard deviation values
+    
+    ... optional padding ...
+    
+    Array of: LeafNodes of size 8^3: bbox, bit masks, 512 voxel values, and min/max/avg/standard deviation values
+
+
+    Example layout: ("---" implies it has a custom offset, "..." implies zero or more)
+    [GridData(672B)][TreeData(64B)]---[RootData][N x Root::Tile]---[NodeData<5>]---[ModeData<4>]---[LeafData<3>]---[BLINDMETA...]---[BLIND0]---[BLIND1]---etc.
+
 */
 
 #ifndef NANOVDB_NANOVDB_H_HAS_BEEN_INCLUDED
 #define NANOVDB_NANOVDB_H_HAS_BEEN_INCLUDED
 
-#define NANOVDB_MAGIC_NUMBER 0x304244566f6e614eUL// "NanoVDB0" in hex - little endian (uint64_t)
+#define NANOVDB_MAGIC_NUMBER 0x304244566f6e614eUL // "NanoVDB0" in hex - little endian (uint64_t)
 
-#define NANOVDB_MAJOR_VERSION_NUMBER 25// reflects changes to the ABI
-#define NANOVDB_MINOR_VERSION_NUMBER  0// reflects changes to the API but not ABI
-#define NANOVDB_PATCH_VERSION_NUMBER  0// reflects bug-fixes with no ABI or API changes
+#define NANOVDB_MAJOR_VERSION_NUMBER 28 // reflects changes to the ABI
+#define NANOVDB_MINOR_VERSION_NUMBER 0 // reflects changes to the API but not ABI
+#define NANOVDB_PATCH_VERSION_NUMBER 0 // reflects bug-fixes with no ABI or API changes
 
 // This replaces a Coord key at the root level with a single uint64_t
 #define USE_SINGLE_ROOT_KEY
@@ -83,24 +115,33 @@
 
 #ifdef __CUDACC_RTC__
 
-typedef signed char         int8_t;
-typedef short               int16_t;
-typedef int                 int32_t;
-typedef long long           int64_t;
-typedef unsigned char       uint8_t;
-typedef unsigned int        uint32_t;
-typedef unsigned long long  uint64_t;
+typedef signed char        int8_t;
+typedef short              int16_t;
+typedef int                int32_t;
+typedef long long          int64_t;
+typedef unsigned char      uint8_t;
+typedef unsigned int       uint32_t;
+typedef unsigned long long uint64_t;
 
-#else
+#else // __CUDACC_RTC__
 
 #include <stdlib.h> //    for abs in clang7
 #include <stdint.h> //    for types like int32_t etc
 #include <stddef.h> //    for size_t type
 #include <cassert> //     for assert
 #include <cmath> //       for sqrt and fma
-#include <limits> //      for numeric_limits 
+#include <limits> //      for numeric_limits
+
+#if defined(NANOVDB_USE_INTRINSICS) && defined(_MSC_VER)
+#include <intrin.h>
+#pragma intrinsic(_BitScanReverse)
+#pragma intrinsic(_BitScanForward)
+#pragma intrinsic(_BitScanReverse64)
+#pragma intrinsic(_BitScanForward64)
 #endif
 
+#endif // __CUDACC_RTC__
+
 #ifdef __CUDACC__
 // Only define __hostdev__ when using NVIDIA CUDA compiler
 #define __hostdev__ __host__ __device__
@@ -110,23 +151,40 @@
 
 namespace nanovdb {
 
-// Implementation of std::is_same
-template <typename T1, typename T2>
+/// @brief C++11 implementation of std::is_same
+template<typename T1, typename T2>
 struct is_same
 {
     static const bool value = false;
 };
 
-template <typename T>
+template<typename T>
 struct is_same<T, T>
 {
     static const bool value = true;
 };
 
-template <typename T>
+/// @brief C++11 implementation of std::is_floating_point
+template<typename T>
 struct is_floating_point
 {
-    static const bool value = is_same<T,float>::value || is_same<T,double>::value;
+    static const bool value = is_same<T, float>::value || is_same<T, double>::value;
+};
+
+/// @brief Metafunction used to determine if the first template
+///        parameter is a specialization of the class template
+///        given in the second template parameter.
+///
+/// @details is_specialization<Vec3<float>, Vec3>::value == true;
+template<typename AnyType, template<typename...> class TemplateType>
+struct is_specialization
+{
+    static const bool value = false;
+};
+template<typename... Args, template<typename...> class TemplateType>
+struct is_specialization<TemplateType<Args...>, TemplateType>
+{
+    static const bool value = true;
 };
 
 // Dummy type for a voxel with a binary mask value, e.g. the active state
@@ -166,10 +224,12 @@
 
 /// @brief Grid flags which indicate what extra information is present in the grid buffer.
 enum class GridFlags : uint32_t {
-    HAS_MIN_MAX = 1 << 0,
-    HAS_BBOX = 1 << 1,
-    HAS_TRUNCATED_GRIDNAME = 1 << 2,
-    // bits # 8, 16, 32, 64, 128, 256, ...  1 << 32 are available
+    HasTruncatedGridname = 1 << 0,
+    HasBBox = 1 << 1,
+    HasMinMax = 1 << 2,
+    HasAverage = 1 << 3,
+    HasStdDeviation = 1 << 4,
+    End = 1 << 5,
 };
 
 /// @brief Blind-data Classes that are currently supported by NanoVDB
@@ -234,6 +294,11 @@
     __hostdev__ static int value() { return 2147483647; }
 };
 template<>
+struct Maximum<uint32_t>
+{
+    __hostdev__ static uint32_t value() { return 4294967295; }
+};
+template<>
 struct Maximum<float>
 {
     __hostdev__ static float value() { return 1e+38f; }
@@ -337,13 +402,13 @@
     return int32_t(ceil(x));
 }
 
-template <typename T>
+template<typename T>
 __hostdev__ inline T Pow2(T x)
 {
     return x * x;
 }
 
-template <typename T>
+template<typename T>
 __hostdev__ inline T Abs(T x)
 {
     return x < 0 ? -x : x;
@@ -410,9 +475,12 @@
     const int        hashKey = ((v[0] < v[1]) << 2) + ((v[0] < v[2]) << 1) + (v[1] < v[2]); // ?*4+?*2+?*1
     return hashTable[hashKey];
 #else
-    if (v[0] < v[1] && v[0] < v[2]) return 0;
-    if (v[1] < v[2]) return 1;
-    else return 2;
+    if (v[0] < v[1] && v[0] < v[2])
+        return 0;
+    if (v[1] < v[2])
+        return 1;
+    else
+        return 2;
 #endif
 }
 
@@ -424,9 +492,12 @@
     const int        hashKey = ((v[0] > v[1]) << 2) + ((v[0] > v[2]) << 1) + (v[1] > v[2]); // ?*4+?*2+?*1
     return hashTable[hashKey];
 #else
-    if (v[0] > v[1] && v[0] > v[2]) return 0;
-    if (v[1] > v[2]) return 1;
-    else return 2;
+    if (v[0] > v[1] && v[0] > v[2])
+        return 0;
+    if (v[1] > v[2])
+        return 1;
+    else
+        return 2;
 #endif
 }
 
@@ -466,6 +537,11 @@
     {
     }
 
+    __hostdev__ Coord(ValueType *ptr)
+        : mVec{ptr[0], ptr[1], ptr[2]}
+    {
+    }
+
     __hostdev__ int32_t x() const { return mVec[0]; }
     __hostdev__ int32_t y() const { return mVec[1]; }
     __hostdev__ int32_t z() const { return mVec[2]; }
@@ -476,7 +552,7 @@
 
     __hostdev__ static Coord max() { return Coord(int32_t((1u << 31) - 1)); }
 
-    __hostdev__ static Coord min() { return Coord(-int32_t((1u << 31) - 1)-1); }
+    __hostdev__ static Coord min() { return Coord(-int32_t((1u << 31) - 1) - 1); }
 
     __hostdev__ static size_t memUsage() { return sizeof(Coord); }
 
@@ -536,22 +612,35 @@
         mVec[2] += rhs[2];
         return *this;
     }
+    __hostdev__ Coord& operator-=(const Coord& rhs)
+    {
+        mVec[0] -= rhs[0];
+        mVec[1] -= rhs[1];
+        mVec[2] -= rhs[2];
+        return *this;
+    }
 
     /// @brief Perform a component-wise minimum with the other Coord.
     __hostdev__ Coord& minComponent(const Coord& other)
     {
-        if (other[0] < mVec[0]) mVec[0] = other[0];
-        if (other[1] < mVec[1]) mVec[1] = other[1];
-        if (other[2] < mVec[2]) mVec[2] = other[2];
+        if (other[0] < mVec[0])
+            mVec[0] = other[0];
+        if (other[1] < mVec[1])
+            mVec[1] = other[1];
+        if (other[2] < mVec[2])
+            mVec[2] = other[2];
         return *this;
     }
 
     /// @brief Perform a component-wise maximum with the other Coord.
     __hostdev__ Coord& maxComponent(const Coord& other)
     {
-        if (other[0] > mVec[0]) mVec[0] = other[0];
-        if (other[1] > mVec[1]) mVec[1] = other[1];
-        if (other[2] > mVec[2]) mVec[2] = other[2];
+        if (other[0] > mVec[0])
+            mVec[0] = other[0];
+        if (other[1] > mVec[1])
+            mVec[1] = other[1];
+        if (other[2] > mVec[2])
+            mVec[2] = other[2];
         return *this;
     }
 
@@ -579,13 +668,13 @@
                                                 (uint8_t(bool(mVec[2] & (1u << 31))) << 2); }
 }; // Coord class
 
-// ----------------------------> Vec3R <--------------------------------------
+// ----------------------------> Vec3 <--------------------------------------
 
-/// @brief A simple vector class with three double components, simular to openvdb::math::Vec3<double>
+/// @brief A simple vector class with three double components, simular to openvdb::math::Vec3
 template<typename T>
 class Vec3
 {
-    static_assert(is_floating_point<T>::value,"Vec3: expected a floating point value");
+    static_assert(is_floating_point<T>::value, "Vec3: expected a floating point value");
     T mVec[3];
 
 public:
@@ -641,7 +730,7 @@
     __hostdev__ Vec3 operator+(const Vec3& v) const { return Vec3(mVec[0] + v[0], mVec[1] + v[1], mVec[2] + v[2]); }
     __hostdev__ Vec3 operator-(const Vec3& v) const { return Vec3(mVec[0] - v[0], mVec[1] - v[1], mVec[2] - v[2]); }
     __hostdev__ Vec3 operator*(const T& s) const { return Vec3(s * mVec[0], s * mVec[1], s * mVec[2]); }
-    __hostdev__ Vec3 operator/(const T& s) const { return Vec3(mVec[0] / s, mVec[1] / s, mVec[2] / s); }
+    __hostdev__ Vec3 operator/(const T& s) const { return (T(1) / s) * (*this); }
     __hostdev__ Vec3& operator+=(const Vec3& v)
     {
         mVec[0] += v[0];
@@ -663,48 +752,42 @@
         mVec[2] *= s;
         return *this;
     }
-    __hostdev__ Vec3& operator/=(const T& s)
-    {
-        mVec[0] /= s;
-        mVec[1] /= s;
-        mVec[2] /= s;
-        return *this;
-    }
-    __hostdev__ Vec3& normalize()
-    {
-        (*this) *= T(1) / this->length();
-        return *this;
-    }
+    __hostdev__ Vec3& operator/=(const T& s) { return (*this) *= T(1) / s; }
+    __hostdev__ Vec3& normalize() { return (*this) /= this->length(); }
     /// @brief Perform a component-wise minimum with the other Coord.
     __hostdev__ void minComponent(const Vec3& other)
     {
-        if (other[0] < mVec[0]) mVec[0] = other[0];
-        if (other[1] < mVec[1]) mVec[1] = other[1];
-        if (other[2] < mVec[2]) mVec[2] = other[2];
+        if (other[0] < mVec[0])
+            mVec[0] = other[0];
+        if (other[1] < mVec[1])
+            mVec[1] = other[1];
+        if (other[2] < mVec[2])
+            mVec[2] = other[2];
     }
 
     /// @brief Perform a component-wise maximum with the other Coord.
     __hostdev__ void maxComponent(const Vec3& other)
     {
-        if (other[0] > mVec[0]) mVec[0] = other[0];
-        if (other[1] > mVec[1]) mVec[1] = other[1];
-        if (other[2] > mVec[2]) mVec[2] = other[2];
+        if (other[0] > mVec[0])
+            mVec[0] = other[0];
+        if (other[1] > mVec[1])
+            mVec[1] = other[1];
+        if (other[2] > mVec[2])
+            mVec[2] = other[2];
     }
     /// @brief Retun the smallest vector component
     __hostdev__ ValueType min() const
     {
-        return mVec[0] < mVec[1] ? (mVec[0] < mVec[2] ? mVec[0] : mVec[2]) :
-                                   (mVec[1] < mVec[2] ? mVec[1] : mVec[2]) ;
+        return mVec[0] < mVec[1] ? (mVec[0] < mVec[2] ? mVec[0] : mVec[2]) : (mVec[1] < mVec[2] ? mVec[1] : mVec[2]);
     }
     /// @brief Retun the largest vector component
     __hostdev__ ValueType max() const
     {
-        return mVec[0] > mVec[1] ? (mVec[0] > mVec[2] ? mVec[0] : mVec[2]) :
-                                   (mVec[1] > mVec[2] ? mVec[1] : mVec[2]) ;
+        return mVec[0] > mVec[1] ? (mVec[0] > mVec[2] ? mVec[0] : mVec[2]) : (mVec[1] > mVec[2] ? mVec[1] : mVec[2]);
     }
-    __hostdev__ Coord floor() const { return Coord(Floor(mVec[0]),Floor(mVec[1]),Floor(mVec[2])); }
-    __hostdev__ Coord  ceil() const { return Coord( Ceil(mVec[0]), Ceil(mVec[1]), Ceil(mVec[2])); }
-    __hostdev__ Coord round() const { return Coord(Floor(mVec[0]+0.5),Floor(mVec[1]+0.5),Floor(mVec[2]+0.5)); }
+    __hostdev__ Coord floor() const { return Coord(Floor(mVec[0]), Floor(mVec[1]), Floor(mVec[2])); }
+    __hostdev__ Coord ceil() const { return Coord(Ceil(mVec[0]), Ceil(mVec[1]), Ceil(mVec[2])); }
+    __hostdev__ Coord round() const { return Coord(Floor(mVec[0] + 0.5), Floor(mVec[1] + 0.5), Floor(mVec[2] + 0.5)); }
 }; // Vec3<T>
 
 template<typename T1, typename T2>
@@ -722,6 +805,171 @@
 using Vec3d = Vec3<double>;
 using Vec3f = Vec3<float>;
 
+// ----------------------------> Vec4 <--------------------------------------
+
+/// @brief A simple vector class with three double components, simular to openvdb::math::Vec4
+template<typename T>
+class Vec4
+{
+    static_assert(is_floating_point<T>::value, "Vec4: expected a floating point value");
+    T mVec[4];
+
+public:
+    static const int SIZE = 4;
+    using ValueType = T;
+    Vec4() = default;
+    __hostdev__ explicit Vec4(T x)
+        : mVec{x, x, x, x}
+    {
+    }
+    __hostdev__ Vec4(T x, T y, T z, T w)
+        : mVec{x, y, z, w}
+    {
+    }
+    template<typename T2>
+    __hostdev__ explicit Vec4(const Vec4<T2>& v)
+        : mVec{T(v[0]), T(v[1]), T(v[2]), T(v[3])}
+    {
+    }
+    __hostdev__ bool operator==(const Vec4& rhs) const { return mVec[0] == rhs[0] && mVec[1] == rhs[1] && mVec[2] == rhs[2] && mVec[3] == rhs[3]; }
+    __hostdev__ bool operator!=(const Vec4& rhs) const { return mVec[0] != rhs[0] || mVec[1] != rhs[1] || mVec[2] != rhs[2] != mVec[3] != rhs[3]; }
+    template<typename Vec4T>
+    __hostdev__ Vec4& operator=(const Vec4T& rhs)
+    {
+        mVec[0] = rhs[0];
+        mVec[1] = rhs[1];
+        mVec[2] = rhs[2];
+        mVec[3] = rhs[3];
+        return *this;
+    }
+    __hostdev__ const T& operator[](int i) const { return mVec[i]; }
+    __hostdev__ T& operator[](int i) { return mVec[i]; }
+    template<typename Vec4T>
+    __hostdev__ T dot(const Vec4T& v) const { return mVec[0] * v[0] + mVec[1] * v[1] + mVec[2] * v[2] + mVec[3] * v[3]; }
+    __hostdev__ T lengthSqr() const
+    {
+        return mVec[0] * mVec[0] + mVec[1] * mVec[1] + mVec[2] * mVec[2] + mVec[3] * mVec[3]; // 7 flops
+    }
+    __hostdev__ T    length() const { return Sqrt(this->lengthSqr()); }
+    __hostdev__ Vec4 operator-() const { return Vec4(-mVec[0], -mVec[1], -mVec[2], -mVec[3]); }
+    __hostdev__ Vec4 operator*(const Vec4& v) const { return Vec4(mVec[0] * v[0], mVec[1] * v[1], mVec[2] * v[2], mVec[3] * v[3]); }
+    __hostdev__ Vec4 operator/(const Vec4& v) const { return Vec4(mVec[0] / v[0], mVec[1] / v[1], mVec[2] / v[2], mVec[3] / v[3]); }
+    __hostdev__ Vec4 operator+(const Vec4& v) const { return Vec4(mVec[0] + v[0], mVec[1] + v[1], mVec[2] + v[2], mVec[3] + v[3]); }
+    __hostdev__ Vec4 operator-(const Vec4& v) const { return Vec4(mVec[0] - v[0], mVec[1] - v[1], mVec[2] - v[2], mVec[3] - v[3]); }
+    __hostdev__ Vec4 operator*(const T& s) const { return Vec4(s * mVec[0], s * mVec[1], s * mVec[2], s * mVec[3]); }
+    __hostdev__ Vec4 operator/(const T& s) const { return (T(1) / s) * (*this); }
+    __hostdev__ Vec4& operator+=(const Vec4& v)
+    {
+        mVec[0] += v[0];
+        mVec[1] += v[1];
+        mVec[2] += v[2];
+        mVec[3] += v[3];
+        return *this;
+    }
+    __hostdev__ Vec4& operator-=(const Vec4& v)
+    {
+        mVec[0] -= v[0];
+        mVec[1] -= v[1];
+        mVec[2] -= v[2];
+        mVec[3] -= v[3];
+        return *this;
+    }
+    __hostdev__ Vec4& operator*=(const T& s)
+    {
+        mVec[0] *= s;
+        mVec[1] *= s;
+        mVec[2] *= s;
+        mVec[3] *= s;
+        return *this;
+    }
+    __hostdev__ Vec4& operator/=(const T& s) { return (*this) *= T(1) / s; }
+    __hostdev__ Vec4& normalize() { return (*this) /= this->length(); }
+    /// @brief Perform a component-wise minimum with the other Coord.
+    __hostdev__ void minComponent(const Vec4& other)
+    {
+        if (other[0] < mVec[0])
+            mVec[0] = other[0];
+        if (other[1] < mVec[1])
+            mVec[1] = other[1];
+        if (other[2] < mVec[2])
+            mVec[2] = other[2];
+        if (other[3] < mVec[3])
+            mVec[3] = other[3];
+    }
+
+    /// @brief Perform a component-wise maximum with the other Coord.
+    __hostdev__ void maxComponent(const Vec4& other)
+    {
+        if (other[0] > mVec[0])
+            mVec[0] = other[0];
+        if (other[1] > mVec[1])
+            mVec[1] = other[1];
+        if (other[2] > mVec[2])
+            mVec[2] = other[2];
+        if (other[3] > mVec[3])
+            mVec[3] = other[3];
+    }
+}; // Vec4<T>
+
+template<typename T1, typename T2>
+inline __hostdev__ Vec4<T2> operator*(T1 scalar, const Vec4<T2>& vec)
+{
+    return Vec4<T2>(scalar * vec[0], scalar * vec[1], scalar * vec[2], scalar * vec[3]);
+}
+template<typename T1, typename T2>
+inline __hostdev__ Vec4<T2> operator/(T1 scalar, const Vec3<T2>& vec)
+{
+    return Vec4<T2>(scalar / vec[0], scalar / vec[1], scalar / vec[2], scalar / vec[3]);
+}
+
+using Vec4R = Vec4<double>;
+using Vec4d = Vec4<double>;
+using Vec4f = Vec4<float>;
+
+// ----------------------------> TensorTraits <--------------------------------------
+
+template<typename T, int Rank = (is_specialization<T, Vec3>::value || 
+                                 is_specialization<T, Vec4>::value) ? 1 : 0>
+struct TensorTraits;
+
+template<typename T>
+struct TensorTraits<T, 0>
+{
+    static const int  Rank = 0; // i.e. scalar
+    static const bool IsScalar = true;
+    static const bool IsVector = false;
+    static const int  Size = 1;
+    using ElementType = T;
+    static T scalar(const T& s) { return s; }
+};
+
+template<typename T>
+struct TensorTraits<T, 1>
+{
+    static const int  Rank = 1; // i.e. vector
+    static const bool IsScalar = false;
+    static const bool IsVector = true;
+    static const int  Size = T::SIZE;
+    using ElementType = typename T::ValueType;
+    static ElementType scalar(const T& v) { return v.length(); }
+};
+
+// ----------------------------> FloatTraits <--------------------------------------
+
+template<typename T, int = sizeof(typename TensorTraits<T>::ElementType)>
+struct FloatTraits
+{
+    using FloatType = float;
+};
+
+template<typename T>
+struct FloatTraits<T, 8>
+{
+    using FloatType = double;
+};
+
+// ----------------------------> mapping ValueType -> GridType <--------------------------------------
+
 /// @brief Maps from a templated value type to a GridType enum
 template<typename ValueT>
 __hostdev__ GridType mapToGridType()
@@ -816,14 +1064,13 @@
                  fma(static_cast<double>(xyz[0]), mat[2], fma(static_cast<double>(xyz[1]), mat[5], fma(static_cast<double>(xyz[2]), mat[8], vec[2])))); // 9 fma = 9 flops
 }
 
-
 // ----------------------------> BBox <-------------------------------------
 
 // Base-class for static polymorphism (cannot be constructed directly)
 template<typename Vec3T>
 struct BaseBBox
 {
-    Vec3T mCoord[2];
+    Vec3T             mCoord[2];
     __hostdev__ bool  operator==(const BaseBBox& rhs) const { return mCoord[0] == rhs.mCoord[0] && mCoord[1] == rhs.mCoord[1]; };
     __hostdev__ bool  operator!=(const BaseBBox& rhs) const { return mCoord[0] != rhs.mCoord[0] || mCoord[1] != rhs.mCoord[1]; };
     __hostdev__ const Vec3T& operator[](int i) const { return mCoord[i]; }
@@ -832,7 +1079,11 @@
     __hostdev__ Vec3T& max() { return mCoord[1]; }
     __hostdev__ const Vec3T& min() const { return mCoord[0]; }
     __hostdev__ const Vec3T& max() const { return mCoord[1]; }
-    __hostdev__ void translate(const Vec3T &xyz) { mCoord[0] += xyz; mCoord[1] += xyz; }
+    __hostdev__ void         translate(const Vec3T& xyz)
+    {
+        mCoord[0] += xyz;
+        mCoord[1] += xyz;
+    }
     // @brief Expand this bounding box to enclose point (i, j, k).
     __hostdev__ void expand(const Vec3T& xyz)
     {
@@ -847,10 +1098,14 @@
             return false;
         return true;
     }
+
 protected:
     __hostdev__ BaseBBox() {}
-    __hostdev__ BaseBBox(const Vec3T& min, const Vec3T& max) : mCoord{min, max} {}
-};// BaseBBox
+    __hostdev__ BaseBBox(const Vec3T& min, const Vec3T& max)
+        : mCoord{min, max}
+    {
+    }
+}; // BaseBBox
 
 template<typename Vec3T, bool = is_floating_point<typename Vec3T::ValueType>::value>
 struct BBox;
@@ -862,16 +1117,35 @@
 template<typename Vec3T>
 struct BBox<Vec3T, true> : public BaseBBox<Vec3T>
 {
+    using Vec3Type = Vec3T;
+    using ValueType = typename Vec3T::ValueType;
+    static_assert(is_floating_point<ValueType>::value, "Expected a floating point coordinate type");
     using BaseT = BaseBBox<Vec3T>;
     using BaseT::mCoord;
-    __hostdev__ BBox() : BaseT(Vec3T( Maximum<typename Vec3T::ValueType>::value()),
-                               Vec3T(-Maximum<typename Vec3T::ValueType>::value())) {}
-    __hostdev__ BBox(const Vec3T& min, const Vec3T& max) : BaseT(min, max) {}
-    __hostdev__ bool empty() const { return mCoord[0][0] >= mCoord[1][0] ||
-                                            mCoord[0][1] >= mCoord[1][1] ||
-                                            mCoord[0][2] >= mCoord[1][2]; }
+    __hostdev__ BBox()
+        : BaseT(Vec3T( Maximum<typename Vec3T::ValueType>::value()),
+                Vec3T(-Maximum<typename Vec3T::ValueType>::value()))
+    {
+    }
+    __hostdev__ BBox(const Vec3T& min, const Vec3T& max)
+        : BaseT(min, max)
+    {
+    }
+    __hostdev__ BBox(const Coord& min, const Coord& max)
+        : BaseT(Vec3T(ValueType(min[0]), ValueType(min[1]), ValueType(min[2])),
+                Vec3T(ValueType(max[0] + 1), ValueType(max[1] + 1), ValueType(max[2] + 1)))
+    {
+    }
+    __hostdev__ BBox(const BaseBBox<Coord>& bbox)
+        : BBox(bbox[0], bbox[1])
+    {
+    }
+    __hostdev__ bool  empty() const { return mCoord[0][0] >= mCoord[1][0] ||
+                                             mCoord[0][1] >= mCoord[1][1] ||
+                                             mCoord[0][2] >= mCoord[1][2]; }
     __hostdev__ Vec3T dim() const { return this->empty() ? Vec3T(0) : this->max() - this->min(); }
-    __hostdev__ bool isInside(const Vec3T &p) const {
+    __hostdev__ bool  isInside(const Vec3T& p) const
+    {
         return p[0] > mCoord[0][0] && p[1] > mCoord[0][1] && p[2] > mCoord[0][2] &&
                p[0] < mCoord[1][0] && p[1] < mCoord[1][1] && p[2] < mCoord[1][2];
     }
@@ -889,53 +1163,191 @@
     using BaseT::mCoord;
     /// @brief Iterator over the domain covered by a BBox
     /// @details z is the fastest-moving coordinate.
-    class Iterator {
-        const BBox &mBBox;
-        CoordT mPos;
+    class Iterator
+    {
+        const BBox& mBBox;
+        CoordT      mPos;
+
     public:
-        __hostdev__ Iterator(const BBox& b): mBBox(b), mPos(b.min()) {}
-        __hostdev__ Iterator& operator++() {
-            if (mPos[2] < mBBox[1][2]) { ++mPos[2]; } // this is the most common case
-            else if (mPos[1] <  mBBox[1][1]) { mPos[2] = mBBox[0][2]; ++mPos[1]; }
-            else if (mPos[0] <= mBBox[1][0]) { mPos[2] = mBBox[0][2]; mPos[1] = mBBox[0][1]; ++mPos[0]; }
+        __hostdev__ Iterator(const BBox& b)
+            : mBBox(b)
+            , mPos(b.min())
+        {
+        }
+        __hostdev__ Iterator& operator++()
+        {
+            if (mPos[2] < mBBox[1][2]) {
+                ++mPos[2];
+            } // this is the most common case
+            else if (mPos[1] < mBBox[1][1]) {
+                mPos[2] = mBBox[0][2];
+                ++mPos[1];
+            } else if (mPos[0] <= mBBox[1][0]) {
+                mPos[2] = mBBox[0][2];
+                mPos[1] = mBBox[0][1];
+                ++mPos[0];
+            }
             return *this;
         }
-        __hostdev__ Iterator operator++(int) {auto tmp = *this; ++(*this); return tmp; }
+        __hostdev__ Iterator operator++(int)
+        {
+            auto tmp = *this;
+            ++(*this);
+            return tmp;
+        }
         /// @brief Return @c true if the iterator still points to a valid coordinate.
-        __hostdev__ operator bool() const { return mPos[0] <= mBBox[1][0]; }
+        __hostdev__       operator bool() const { return mPos[0] <= mBBox[1][0]; }
         __hostdev__ const CoordT& operator*() const { return mPos; }
-    };// Iterator
+    }; // Iterator
     __hostdev__ Iterator begin() const { return Iterator{*this}; }
-    __hostdev__ BBox() : BaseT(CoordT::max(), CoordT::min()) {}
-    __hostdev__ BBox(const CoordT& min, const CoordT& max) : BaseT(min, max) {}
-    template <typename SplitT>
-    __hostdev__ BBox(BBox &other, const SplitT&) : BaseT(other.mCoord[0], other.mCoord[1]) {
+    __hostdev__          BBox()
+        : BaseT(CoordT::max(), CoordT::min())
+    {
+    }
+    __hostdev__ BBox(const CoordT& min, const CoordT& max)
+        : BaseT(min, max)
+    {
+    }
+    template<typename SplitT>
+    __hostdev__ BBox(BBox& other, const SplitT&)
+        : BaseT(other.mCoord[0], other.mCoord[1])
+    {
         assert(this->is_divisible());
         const int n = MaxIndex(this->dim());
         mCoord[1][n] = (mCoord[0][n] + mCoord[1][n]) >> 1;
         other.mCoord[0][n] = mCoord[1][n] + 1;
     }
-    __hostdev__ bool is_divisible() const { return mCoord[0][0] < mCoord[1][0] && 
-                                                   mCoord[0][1] < mCoord[1][1] && 
+    __hostdev__ bool is_divisible() const { return mCoord[0][0] < mCoord[1][0] &&
+                                                   mCoord[0][1] < mCoord[1][1] &&
                                                    mCoord[0][2] < mCoord[1][2]; }
-    __hostdev__ bool empty() const { return mCoord[0][0] > mCoord[1][0] ||
-                                            mCoord[0][1] > mCoord[1][1] ||
-                                            mCoord[0][2] > mCoord[1][2]; }
-    __hostdev__ CoordT dim() const {return this->empty() ? Coord(0) : this->max() - this->min() + Coord(1);}
-    __hostdev__ bool isInside(const CoordT &p) const { return !(CoordT::lessThan(p,this->min()) || CoordT::lessThan(this->max(),p)); }
-    __hostdev__ bool isInside(const BBox& b) const 
-    {
-        return !(CoordT::lessThan(b.min(),this->min()) || CoordT::lessThan(this->max(),b.max()));
-    }
-    template <typename RealT>
-    __hostdev__  BBox<Vec3<RealT>> asReal() const {
-        static_assert(is_floating_point<RealT>::value, "Expected a floating point coordinate");
-        return BBox<Vec3<RealT>>(Vec3<RealT>(RealT(mCoord[0][0]    ), RealT(mCoord[0][1]    ), RealT(mCoord[0][2])   ),
+    /// @brief Return true if this bounding box is empty, i.e. uninitialized
+    __hostdev__ bool   empty() const { return mCoord[0][0] > mCoord[1][0] ||
+                                              mCoord[0][1] > mCoord[1][1] ||
+                                              mCoord[0][2] > mCoord[1][2]; }
+    __hostdev__ CoordT dim() const { return this->empty() ? Coord(0) : this->max() - this->min() + Coord(1); }
+    __hostdev__ bool   isInside(const CoordT& p) const { return !(CoordT::lessThan(p, this->min()) || CoordT::lessThan(this->max(), p)); }
+    __hostdev__ bool   isInside(const BBox& b) const
+    {
+        return !(CoordT::lessThan(b.min(), this->min()) || CoordT::lessThan(this->max(), b.max()));
+    }
+
+    /// @warning This converts a CoordBBox into a floating-point bounding box which implies that max += 1 !
+    template<typename RealT>
+    __hostdev__ BBox<Vec3<RealT>> asReal() const
+    {
+        static_assert(is_floating_point<RealT>::value, "CoordBBox::asReal: Expected a floating point coordinate");
+        return BBox<Vec3<RealT>>(Vec3<RealT>(RealT(mCoord[0][0]), RealT(mCoord[0][1]), RealT(mCoord[0][2])),
                                  Vec3<RealT>(RealT(mCoord[1][0] + 1), RealT(mCoord[1][1] + 1), RealT(mCoord[1][2] + 1)));
     }
 };
 
 using CoordBBox = BBox<Coord>;
+using BBoxR = BBox<Vec3R>;
+
+// -------------------> Find lowest and highest bit in a word <----------------------------
+
+/// @brief Returns the index of the lowest, i.e. least significant, on bit in the specified 32 bit word
+///
+/// @warning Assumes that at least one bit is set in the word, i.e. @a v != uint32_t(0)!
+__hostdev__ static inline uint32_t FindLowestOn(uint32_t v)
+{
+    assert(v);
+#if defined(_MSC_VER) && defined(NANOVDB_USE_INTRINSICS)
+    unsigned long index;
+    _BitScanForward(&index, v);
+    return static_cast<uint32_t>(index);
+#elif (defined(__GNUC__) || defined(__clang__)) && defined(NANOVDB_USE_INTRINSICS)
+    return static_cast<uint32_t>(__builtin_ctzl(v));
+#else
+    static const unsigned char DeBruijn[32] = {
+        0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9};
+// disable unary minus on unsigned warning
+#if defined(_MSC_VER)
+#pragma warning(push)
+#pragma warning(disable : 4146)
+#endif
+    return DeBruijn[uint32_t((v & -v) * 0x077CB531U) >> 27];
+#if defined(_MSC_VER)
+#pragma warning(pop)
+#endif
+
+#endif
+}
+
+/// @brief Returns the index of the highest, i.e. most significant, on bit in the specified 32 bit word
+///
+/// @warning Assumes that at least one bit is set in the word, i.e. @a v != uint32_t(0)!
+__hostdev__ static inline uint32_t FindHighestOn(uint32_t v)
+{
+    assert(v);
+#if defined(_MSC_VER) && defined(NANOVDB_USE_INTRINSICS)
+    unsigned long index;
+    _BitScanReverse(&index, v);
+    return static_cast<uint32_t>(index);
+#elif (defined(__GNUC__) || defined(__clang__)) && defined(NANOVDB_USE_INTRINSICS)
+    return sizeof(unsigned long) * 8 - 1 - __builtin_clzl(v);
+
+#else
+    static const unsigned char DeBruijn[32] = {
+        0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30, 8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31};
+    v |= v >> 1; // first round down to one less than a power of 2
+    v |= v >> 2;
+    v |= v >> 4;
+    v |= v >> 8;
+    v |= v >> 16;
+    return DeBruijn[uint32_t(v * 0x07C4ACDDU) >> 27];
+#endif
+}
+
+/// @brief Returns the index of the lowest, i.e. least significant, on bit in the specified 64 bit word
+///
+/// @warning Assumes that at least one bit is set in the word, i.e. @a v != uint32_t(0)!
+__hostdev__ static inline uint32_t FindLowestOn(uint64_t v)
+{
+    assert(v);
+#if defined(_MSC_VER) && defined(NANOVDB_USE_INTRINSICS)
+    unsigned long index;
+    _BitScanForward64(&index, v);
+    return static_cast<uint32_t>(index);
+#elif (defined(__GNUC__) || defined(__clang__)) && defined(NANOVDB_USE_INTRINSICS)
+    return static_cast<uint32_t>(__builtin_ctzll(v));
+#else
+    static const unsigned char DeBruijn[64] = {
+        0,   1,  2, 53,  3,  7, 54, 27, 4,  38, 41,  8, 34, 55, 48, 28,
+        62,  5, 39, 46, 44, 42, 22,  9, 24, 35, 59, 56, 49, 18, 29, 11,
+        63, 52,  6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,
+        51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12,
+    };
+// disable unary minus on unsigned warning
+#if defined(_MSC_VER)
+#pragma warning(push)
+#pragma warning(disable : 4146)
+#endif
+    return DeBruijn[uint64_t((v & -v) * UINT64_C(0x022FDD63CC95386D)) >> 58];
+#if defined(_MSC_VER)
+#pragma warning(pop)
+#endif
+
+#endif
+}
+
+/// @brief Returns the index of the highest, i.e. most significant, on bit in the specified 64 bit word
+///
+/// @warning Assumes that at least one bit is set in the word, i.e. @a v != uint32_t(0)!
+__hostdev__ static inline uint32_t FindHighestOn(uint64_t v)
+{
+    assert(v);
+#if defined(_MSC_VER) && defined(NANOVDB_USE_INTRINSICS)
+    unsigned long index;
+    _BitScanReverse64(&index, v);
+    return static_cast<uint32_t>(index);
+#elif (defined(__GNUC__) || defined(__clang__)) && defined(NANOVDB_USE_INTRINSICS)
+    return sizeof(unsigned long) * 8 - 1 - __builtin_clzll(v);
+#else
+    const uint32_t* p = reinterpret_cast<const uint32_t*>(&v);
+    return p[1] ? 32u + FindHighestOn(p[1]) : FindHighestOn(p[0]);
+#endif
+}
 
 // ----------------------------> Mask <--------------------------------------
 
@@ -961,22 +1373,36 @@
     __hostdev__ uint32_t countOn() const
     {
         uint32_t sum = 0, n = WORD_COUNT;
-        for (const uint64_t* w = mWords; n--; ++w) sum += CountOn(*w);
+        for (const uint64_t* w = mWords; n--; ++w)
+            sum += CountOn(*w);
         return sum;
     }
 
     class Iterator
     {
     public:
-      __hostdev__ Iterator() : mPos(Mask::SIZE), mParent(nullptr) {}
-      __hostdev__ Iterator(uint32_t pos, const Mask* parent) : mPos(pos), mParent(parent) {}
-      Iterator& operator=(const Iterator&) = default;
-      __hostdev__ uint32_t operator*() const { return mPos; }
-      __hostdev__ operator bool() const { return mPos != Mask::SIZE;}
-      __hostdev__ Iterator& operator++() { mPos = mParent->findNextOn(mPos+1); return *this; }
+        __hostdev__ Iterator()
+            : mPos(Mask::SIZE)
+            , mParent(nullptr)
+        {
+        }
+        __hostdev__ Iterator(uint32_t pos, const Mask* parent)
+            : mPos(pos)
+            , mParent(parent)
+        {
+        }
+        Iterator&            operator=(const Iterator&) = default;
+        __hostdev__ uint32_t operator*() const { return mPos; }
+        __hostdev__          operator bool() const { return mPos != Mask::SIZE; }
+        __hostdev__ Iterator& operator++()
+        {
+            mPos = mParent->findNextOn(mPos + 1);
+            return *this;
+        }
+
     private:
-      uint32_t     mPos;
-      const Mask*  mParent;
+        uint32_t    mPos;
+        const Mask* mParent;
     }; // Memeber class MaskIterator
 
     /// @brief Initialize all bits to zero.
@@ -999,6 +1425,14 @@
             mWords[i] = other.mWords[i];
     }
 
+    /// @breif Return the <i>n</i>th word of the bit mask, for a word of arbitrary size.
+    template<typename WordT>
+    __hostdev__ WordT getWord(int n) const
+    {
+        assert(n * 8 * sizeof(WordT) < SIZE);
+        return reinterpret_cast<const WordT*>(mWords)[n];
+    }
+
     /// @brief Assignment operator from another Mask type
     __hostdev__ Mask& operator=(const Mask& other)
     {
@@ -1014,18 +1448,22 @@
 
     __hostdev__ bool isOn() const
     {
-        for (uint32_t i = 0; i < WORD_COUNT; ++i) if (mWords[i] != ~uint64_t(0)) return false;
+        for (uint32_t i = 0; i < WORD_COUNT; ++i)
+            if (mWords[i] != ~uint64_t(0))
+                return false;
         return true;
     }
 
     __hostdev__ bool isOff() const
     {
-        for (uint32_t i = 0; i < WORD_COUNT; ++i) if (mWords[i] != uint64_t(0)) return false;
+        for (uint32_t i = 0; i < WORD_COUNT; ++i)
+            if (mWords[i] != uint64_t(0))
+                return false;
         return true;
     }
 
     /// @brief Set the given bit on.
-    __hostdev__ void setOn( uint32_t n) { mWords[n >> 6] |=   uint64_t(1) << (n & 63);  }
+    __hostdev__ void setOn(uint32_t n) { mWords[n >> 6] |= uint64_t(1) << (n & 63); }
     __hostdev__ void setOff(uint32_t n) { mWords[n >> 6] &= ~(uint64_t(1) << (n & 63)); }
 
     __hostdev__ void set(uint32_t n, bool On) { On ? this->setOn(n) : this->setOff(n); }
@@ -1048,9 +1486,11 @@
     __hostdev__ void toggle()
     {
         uint32_t n = WORD_COUNT;
-        for (auto* w = mWords; n--; ++w) *w = ~*w;
+        for (auto* w = mWords; n--; ++w)
+            *w = ~*w;
     }
-    __hostdev__ void toggle(uint32_t n) { mWords[n >> 6] ^= uint64_t(1) << (n & 63);  }
+    __hostdev__ void toggle(uint32_t n) { mWords[n >> 6] ^= uint64_t(1) << (n & 63); }
+
 private:
     __hostdev__ static inline uint32_t CountOn(uint64_t v)
     {
@@ -1058,33 +1498,28 @@
         v = (v & uint64_t(0x3333333333333333)) + ((v >> 2) & uint64_t(0x3333333333333333));
         return (((v + (v >> 4)) & uint64_t(0xF0F0F0F0F0F0F0F)) * uint64_t(0x101010101010101)) >> 56;
     }
-    __hostdev__ static inline uint32_t FindLowestOn(uint64_t v)
-    {
-      static const unsigned char DeBruijn[64] = {
-          0,   1,  2, 53,  3,  7, 54, 27, 4,  38, 41,  8, 34, 55, 48, 28,
-          62,  5, 39, 46, 44, 42, 22,  9, 24, 35, 59, 56, 49, 18, 29, 11,
-          63, 52,  6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,
-          51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12,
-      };
-      return DeBruijn[uint64_t((v & -static_cast<int64_t>(v)) * uint64_t(0x022FDD63CC95386D)) >> 58];
-    }
+
     __hostdev__ uint32_t findFirstOn() const
     {
-        uint32_t n = 0;
+        uint32_t        n = 0;
         const uint64_t* w = mWords;
-        for (; n<WORD_COUNT && !*w; ++w, ++n) ;
-        return n==WORD_COUNT ? SIZE : (n << 6) + FindLowestOn(*w);
+        for (; n < WORD_COUNT && !*w; ++w, ++n)
+            ;
+        return n == WORD_COUNT ? SIZE : (n << 6) + FindLowestOn(*w);
     }
     __hostdev__ uint32_t findNextOn(uint32_t start) const
     {
-        uint32_t n = start >> 6;//initiate
-        if (n >= WORD_COUNT) return SIZE; // check for out of bounds
+        uint32_t n = start >> 6; // initiate
+        if (n >= WORD_COUNT)
+            return SIZE; // check for out of bounds
         uint32_t m = start & 63;
         uint64_t b = mWords[n];
-        if (b & (uint64_t(1) << m)) return start;//simpel case: start is on
-        b &= ~uint64_t(0) << m;// mask out lower bits
-        while(!b && ++n<WORD_COUNT) b = mWords[n];// find next none-zero word
-        return (!b ? SIZE : (n << 6) + FindLowestOn(b));//catch last word=0
+        if (b & (uint64_t(1) << m))
+            return start; //simple case: start is on
+        b &= ~uint64_t(0) << m; // mask out lower bits
+        while (!b && ++n < WORD_COUNT)
+            b = mWords[n]; // find next none-zero word
+        return (!b ? SIZE : (n << 6) + FindLowestOn(b)); // catch last word=0
     }
 }; // Mask class
 
@@ -1093,14 +1528,14 @@
 /// @brief Defined an affine transform and its inverse represented as a 3x3 matrix and a vec3 translation
 struct Map
 {
-    float  mMatF[9]; // 9*4B
-    float  mInvMatF[9]; // 9*4B
-    float  mVecF[3]; // 3*4B
-    float  mTaperF; // 4B, taper value
-    double mMatD[9]; // 9*8B
-    double mInvMatD[9]; // 9*8B
-    double mVecD[3]; // 3*8B
-    double mTaperD; // 8B
+    float  mMatF[9]; // 9*4B <- 3x3 matrix
+    float  mInvMatF[9]; // 9*4B <- 3x3 matrix
+    float  mVecF[3]; // 3*4B <- translation
+    float  mTaperF; // 4B, placeholder for taper value
+    double mMatD[9]; // 9*8B <- 3x3 matrix
+    double mInvMatD[9]; // 9*8B <- 3x3 matrix
+    double mVecD[3]; // 3*8B <- translation
+    double mTaperD; // 8B, placeholder for taper value
 
     // This method can only be called on the host to initialize the member data
     template<typename Mat4T>
@@ -1141,10 +1576,10 @@
 template<typename Mat4T>
 void Map::set(const Mat4T& mat, const Mat4T& invMat, double taper)
 {
-    float  *mf = mMatF, *vf = mVecF;
-    float  *mif = mInvMatF;
+    float * mf = mMatF, *vf = mVecF;
+    float*  mif = mInvMatF;
     double *md = mMatD, *vd = mVecD;
-    double *mid = mInvMatD;
+    double* mid = mInvMatD;
     mTaperF = static_cast<float>(taper);
     mTaperD = taper;
     for (int i = 0; i < 3; ++i) {
@@ -1211,7 +1646,7 @@
     static const int MaxNameSize = 256;
     uint64_t         mMagic; // 8B magic to validate it is valid grid data.
     uint64_t         mChecksum; // 8B. Checksum of grid buffer.
-    uint32_t         mMajor;// 4B. major version number
+    uint32_t         mMajor; // 4B. major version number
     uint32_t         mFlags; // 4B. flags for grid.
     uint64_t         mGridSize; // 8B. byte count of entire grid buffer.
     char             mGridName[MaxNameSize]; // 256B
@@ -1225,51 +1660,67 @@
 
     // Set and unset various bit flags
     __hostdev__ void setFlagsOff() { mFlags = uint32_t(0); }
-    __hostdev__ void setMinMax(bool on)
+    __hostdev__ void setMinMaxOn(bool on = true)
     {
         if (on) {
-            mFlags |= static_cast<uint32_t>(GridFlags::HAS_MIN_MAX);
+            mFlags |= static_cast<uint32_t>(GridFlags::HasMinMax);
         } else {
-            mFlags &= ~static_cast<uint32_t>(GridFlags::HAS_MIN_MAX);
+            mFlags &= ~static_cast<uint32_t>(GridFlags::HasMinMax);
         }
     }
-    __hostdev__ void setBBox(bool on)
+    __hostdev__ void setBBoxOn(bool on = true)
     {
         if (on) {
-            mFlags |= static_cast<uint32_t>(GridFlags::HAS_BBOX);
+            mFlags |= static_cast<uint32_t>(GridFlags::HasBBox);
         } else {
-            mFlags &= ~static_cast<uint32_t>(GridFlags::HAS_BBOX);
+            mFlags &= ~static_cast<uint32_t>(GridFlags::HasBBox);
         }
     }
-    __hostdev__ void setTrunctedGridName(bool on)
+    __hostdev__ void setTruncatedGridNameOn(bool on = true)
     {
         if (on) {
-            mFlags |= static_cast<uint32_t>(GridFlags::HAS_TRUNCATED_GRIDNAME);
+            mFlags |= static_cast<uint32_t>(GridFlags::HasTruncatedGridname);
         } else {
-            mFlags &= ~static_cast<uint32_t>(GridFlags::HAS_TRUNCATED_GRIDNAME);
+            mFlags &= ~static_cast<uint32_t>(GridFlags::HasTruncatedGridname);
         }
-     }
-    
+    }
+    __hostdev__ void setAverageOn(bool on = true)
+    {
+        if (on) {
+            mFlags |= static_cast<uint32_t>(GridFlags::HasAverage);
+        } else {
+            mFlags &= ~static_cast<uint32_t>(GridFlags::HasAverage);
+        }
+    }
+    __hostdev__ void setStdDeviationOn(bool on = true)
+    {
+        if (on) {
+            mFlags |= static_cast<uint32_t>(GridFlags::HasStdDeviation);
+        } else {
+            mFlags &= ~static_cast<uint32_t>(GridFlags::HasStdDeviation);
+        }
+    }
+
     // Affine transformations based on double precision
     template<typename Vec3T>
-    __hostdev__ Vec3T applyMap(const Vec3T& xyz) const { return mMap.applyMap(xyz); }
+    __hostdev__ Vec3T applyMap(const Vec3T& xyz) const { return mMap.applyMap(xyz); } // Pos: index -> world
     template<typename Vec3T>
-    __hostdev__ Vec3T applyInverseMap(const Vec3T& xyz) const { return mMap.applyInverseMap(xyz); }
+    __hostdev__ Vec3T applyInverseMap(const Vec3T& xyz) const { return mMap.applyInverseMap(xyz); } // Pos: world -> index
     template<typename Vec3T>
-    __hostdev__ Vec3T applyJacobian(const Vec3T& xyz) const { return mMap.applyJacobian(xyz); }
+    __hostdev__ Vec3T applyJacobian(const Vec3T& xyz) const { return mMap.applyJacobian(xyz); } // Dir: index -> world
     template<typename Vec3T>
-    __hostdev__ Vec3T applyInverseJacobian(const Vec3T& xyz) const { return mMap.applyInverseJacobian(xyz); }
+    __hostdev__ Vec3T applyInverseJacobian(const Vec3T& xyz) const { return mMap.applyInverseJacobian(xyz); } // Dir: world -> index
     template<typename Vec3T>
     __hostdev__ Vec3T applyIJT(const Vec3T& xyz) const { return mMap.applyIJT(xyz); }
     // Affine transformations based on single precision
     template<typename Vec3T>
-    __hostdev__ Vec3T applyMapF(const Vec3T& xyz) const { return mMap.applyMapF(xyz); }
+    __hostdev__ Vec3T applyMapF(const Vec3T& xyz) const { return mMap.applyMapF(xyz); } // Pos: index -> world
     template<typename Vec3T>
-    __hostdev__ Vec3T applyInverseMapF(const Vec3T& xyz) const { return mMap.applyInverseMapF(xyz); }
+    __hostdev__ Vec3T applyInverseMapF(const Vec3T& xyz) const { return mMap.applyInverseMapF(xyz); } // Pos: world -> index
     template<typename Vec3T>
-    __hostdev__ Vec3T applyJacobianF(const Vec3T& xyz) const { return mMap.applyJacobianF(xyz); }
+    __hostdev__ Vec3T applyJacobianF(const Vec3T& xyz) const { return mMap.applyJacobianF(xyz); } // Dir: index -> world
     template<typename Vec3T>
-    __hostdev__ Vec3T applyInverseJacobianF(const Vec3T& xyz) const { return mMap.applyInverseJacobianF(xyz); }
+    __hostdev__ Vec3T applyInverseJacobianF(const Vec3T& xyz) const { return mMap.applyInverseJacobianF(xyz); } // Dir: world -> index
     template<typename Vec3T>
     __hostdev__ Vec3T applyIJTF(const Vec3T& xyz) const { return mMap.applyIJTF(xyz); }
 
@@ -1297,9 +1748,12 @@
 }; // GridData
 
 // Forward decleration of accelerated random access class
-template<typename>
+template <typename ValueT, int LEVEL0 = -1, int LEVEL1 = -1, int LEVEL2 = -1>
 class ReadAccessor;
 
+template <typename ValueT>
+using DefaultReadAccessor = ReadAccessor<ValueT, 0, 1, 2>;
+
 /// @brief Highest level of the data structure. Contains a tree and a world->index
 ///        transform (that currenrtly only supports uniform scaling and translation).
 ///
@@ -1312,9 +1766,9 @@
     using DataType = GridData;
     using ValueType = typename TreeT::ValueType;
     using CoordType = typename TreeT::CoordType;
-    using AccessorType = ReadAccessor<typename TreeT::RootType>;
+    using AccessorType = DefaultReadAccessor<ValueType>;
 
-    static constexpr bool IgnoreValues = TreeT::IgnoreValues;
+    //static constexpr bool IgnoreValues = TreeT::IgnoreValues;
 
     /// @brief Disallow constructions, copy and assignment
     ///
@@ -1328,7 +1782,7 @@
     __hostdev__ const DataType* data() const { return reinterpret_cast<const DataType*>(this); }
 
     /// @brief return memory usage in bytes for the class (note this computes room for blindMetaData structures.)
-    __hostdev__ static uint64_t memUsage() {return sizeof(GridData);}
+    __hostdev__ static uint64_t memUsage() { return sizeof(GridData); }
 
     /// @brief return the memory footprint of the entire grid, i.e. including all nodes and blind data
     __hostdev__ uint64_t totalMemUsage() const { return DataType::mGridSize; }
@@ -1340,7 +1794,7 @@
     __hostdev__ TreeT& tree() { return *reinterpret_cast<TreeT*>(this->treePtr()); }
 
     /// @brief Return a new instance of a ReadAccessor used to access values in this grid
-    __hostdev__ AccessorType getAccessor() const { return ReadAccessor<typename TreeT::RootType>(this->tree().root()); }
+    __hostdev__ AccessorType getAccessor() const { return AccessorType(this->tree().root()); }
 
     /// @brief Return a const reference to the size of a voxel in world units
     __hostdev__ const Vec3R& voxelSize() const { return DataType::mVoxelSize; }
@@ -1359,16 +1813,17 @@
     /// @brief transformation from index space direction to world space direction
     /// @warning assumes dir to be normalized
     template<typename Vec3T>
-    __hostdev__ Vec3T indexToWorldDir(const Vec3T& dir) const { return this->applyInverseJacobian(dir); }
+    __hostdev__ Vec3T indexToWorldDir(const Vec3T& dir) const { return this->applyJacobian(dir); }
 
     /// @brief transformation from world space direction to index space direction
     /// @warning assumes dir to be normalized
     template<typename Vec3T>
-    __hostdev__ Vec3T worldToIndexDir(const Vec3T& dir) const { return this->applyJacobian(dir); }
+    __hostdev__ Vec3T worldToIndexDir(const Vec3T& dir) const { return this->applyInverseJacobian(dir); }
 
-    /// @brief Inverse jacobian map, suitable for gradients.
+    /// @brief Trnasform the gradient from index space to world space.
+    /// @details Applies the inverse jacobian transform map.
     template<typename Vec3T>
-    __hostdev__ Vec3T applyIJT(const Vec3T& dir) const { return this->applyIJT(dir); }
+    __hostdev__ Vec3T indexToWorldGrad(const Vec3T& grad) const { return this->applyIJT(grad); }
 
     /// @brief world to index space transformation
     template<typename Vec3T>
@@ -1381,40 +1836,45 @@
     /// @brief transformation from index space direction to world space direction
     /// @warning assumes dir to be normalized
     template<typename Vec3T>
-    __hostdev__ Vec3T indexToWorldDirF(const Vec3T& dir) const { return this->applyInverseJacobianF(dir); }
+    __hostdev__ Vec3T indexToWorldDirF(const Vec3T& dir) const { return this->applyJacobianF(dir); }
 
     /// @brief transformation from world space direction to index space direction
     /// @warning assumes dir to be normalized
     template<typename Vec3T>
-    __hostdev__ Vec3T worldToIndexDirF(const Vec3T& dir) const { return this->applyJacobianF(dir); }
+    __hostdev__ Vec3T worldToIndexDirF(const Vec3T& dir) const { return this->applyInverseJacobianF(dir); }
 
-    /// @brief Inverse jacobian map, suitable for gradients.
+    /// @brief Transforms the gradient from index space to world space.
+    /// @details Applies the inverse jacobian transform map.
     template<typename Vec3T>
-    __hostdev__ Vec3T applyIJTF(const Vec3T& dir) const { return this->applyIJTF(dir); }
-
+    __hostdev__ Vec3T indexToWorldGradF(const Vec3T& grad) const { return DataType::applyIJTF(grad); }
 
     /// @brief Computes a AABB of active values in world space
     __hostdev__ const BBox<Vec3R>& worldBBox() const { return DataType::mWorldBBox; }
 
     /// @brief Computes a AABB of active values in index space
+    ///
+    /// @note This method is returning a floating point bounding box and not a CoordBBox. This makes
+    ///       it more useful for clipping rays.
     __hostdev__ const BBox<CoordType>& indexBBox() const { return this->tree().bbox(); }
 
     /// @brief Return the total number of active voxels in this tree.
     __hostdev__ const uint64_t& activeVoxelCount() const { return this->tree().activeVoxelCount(); }
 
     /// @brief Methods related to the classification of this grid
-    __hostdev__ bool      isValid() const { return DataType::mMagic == NANOVDB_MAGIC_NUMBER; }
-    __hostdev__ const GridType&  gridType() const { return DataType::mGridType; }
+    __hostdev__ bool  isValid() const { return DataType::mMagic == NANOVDB_MAGIC_NUMBER; }
+    __hostdev__ const GridType& gridType() const { return DataType::mGridType; }
     __hostdev__ const GridClass& gridClass() const { return DataType::mGridClass; }
-    __hostdev__ bool      isLevelSet() const { return DataType::mGridClass == GridClass::LevelSet; }
-    __hostdev__ bool      isFogVolume() const { return DataType::mGridClass == GridClass::FogVolume; }
-    __hostdev__ bool      isStaggered() const { return DataType::mGridClass == GridClass::Staggered; }
-    __hostdev__ bool      isPointIndex() const { return DataType::mGridClass == GridClass::PointIndex; }
-    __hostdev__ bool      isPointData() const { return DataType::mGridClass == GridClass::PointData; }
-    __hostdev__ bool      isUnknown() const { return DataType::mGridClass == GridClass::Unknown; }
-    __hostdev__ bool      hasMinMax() const { return DataType::mFlags & static_cast<uint32_t>(GridFlags::HAS_MIN_MAX); }
-    __hostdev__ bool      hasBBox() const { return DataType::mFlags & static_cast<uint32_t>(GridFlags::HAS_BBOX); }
-    __hostdev__ bool      hasTrunctedGridName() const { return DataType::mFlags & static_cast<uint32_t>(GridFlags::HAS_TRUNCATED_GRIDNAME); }
+    __hostdev__ bool             isLevelSet() const { return DataType::mGridClass == GridClass::LevelSet; }
+    __hostdev__ bool             isFogVolume() const { return DataType::mGridClass == GridClass::FogVolume; }
+    __hostdev__ bool             isStaggered() const { return DataType::mGridClass == GridClass::Staggered; }
+    __hostdev__ bool             isPointIndex() const { return DataType::mGridClass == GridClass::PointIndex; }
+    __hostdev__ bool             isPointData() const { return DataType::mGridClass == GridClass::PointData; }
+    __hostdev__ bool             isUnknown() const { return DataType::mGridClass == GridClass::Unknown; }
+    __hostdev__ bool             hasMinMax() const { return DataType::mFlags & static_cast<uint32_t>(GridFlags::HasMinMax); }
+    __hostdev__ bool             hasBBox() const { return DataType::mFlags & static_cast<uint32_t>(GridFlags::HasBBox); }
+    __hostdev__ bool             hasTrunctedGridName() const { return DataType::mFlags & static_cast<uint32_t>(GridFlags::HasTruncatedGridname); }
+    __hostdev__ bool             hasAverage() const { return DataType::mFlags & static_cast<uint32_t>(GridFlags::HasAverage); }
+    __hostdev__ bool             hasStdDeviation() const { return DataType::mFlags & static_cast<uint32_t>(GridFlags::HasStdDeviation); }
 
     /// @brief Return a c-string with the name of this grid
     __hostdev__ const char* gridName() const { return DataType::mGridName; }
@@ -1463,34 +1923,39 @@
 struct NANOVDB_ALIGN(NANOVDB_DATA_ALIGNMENT) TreeData
 {
     static_assert(ROOT_LEVEL == 3, "Root level is a ssumed to be three");
-    uint64_t mBytes[ROOT_LEVEL+1]; // 32B. byte offsets to nodes of type: leaf, lower internal, upper internal, and root
-    uint32_t mCount[ROOT_LEVEL+1]; // 16B. total number of nodes of type: leaf, lower internal, upper internal, and root
+    uint64_t mBytes[ROOT_LEVEL + 1]; // 32B. byte offsets to nodes of type: leaf, lower internal, upper internal, and root
+    uint32_t mCount[ROOT_LEVEL + 1]; // 16B. total number of nodes of type: leaf, lower internal, upper internal, and root
+    uint32_t mPFSum[ROOT_LEVEL + 1]; // 16B. reversed prefix sum of mCount - useful for accessing blind data associated with nodes
 };
 
 /// @brief Struct to derive node type from its level in a given tree
 template<typename TreeT, int LEVEL>
-struct Node;
+struct TreeNode;
 
 // Partial template specialization of above Node struct
-template<typename T>
-struct Node<T, 0>
+template<typename TreeT>
+struct TreeNode<TreeT, 0>
 {
-    using type = typename T::LeafNodeType;
+    static_assert(TreeT::RootType::LEVEL == 3, "Tree depth is not supported");
+    using type = typename TreeT::LeafNodeType;
 };
-template<typename T>
-struct Node<T, 1>
+template<typename TreeT>
+struct TreeNode<TreeT, 1>
 {
-    using type = typename T::RootType::ChildNodeType::ChildNodeType;
+    static_assert(TreeT::RootType::LEVEL == 3, "Tree depth is not supported");
+    using type = typename TreeT::RootType::ChildNodeType::ChildNodeType;
 };
-template<typename T>
-struct Node<T, 2>
+template<typename TreeT>
+struct TreeNode<TreeT, 2>
 {
-    using type = typename T::RootType::ChildNodeType;
+    static_assert(TreeT::RootType::LEVEL == 3, "Tree depth is not supported");
+    using type = typename TreeT::RootType::ChildNodeType;
 };
-template<typename T>
-struct Node<T, 3>
+template<typename TreeT>
+struct TreeNode<TreeT, 3>
 {
-    using type = typename T::RootType;
+    static_assert(TreeT::RootType::LEVEL == 3, "Tree depth is not supported");
+    using type = typename TreeT::RootType;
 };
 
 /// @brief VDB Tree, which is a thin wrapper around a RootNode.
@@ -1501,19 +1966,28 @@
     static_assert(RootT::ChildNodeType::LOG2DIM == 5, "Tree configuration is not supported");
     static_assert(RootT::ChildNodeType::ChildNodeType::LOG2DIM == 4, "Tree configuration is not supported");
     static_assert(RootT::LeafNodeType::LOG2DIM == 3, "Tree configuration is not supported");
+
 public:
     using DataType = TreeData<RootT::LEVEL>;
     using RootType = RootT;
     using LeafNodeType = typename RootT::LeafNodeType;
     using ValueType = typename RootT::ValueType;
     using CoordType = typename RootT::CoordType;
-    using AccessorType = ReadAccessor<RootT>;
+    using AccessorType = DefaultReadAccessor<ValueType>;
+
+    using Node3 = RootT;
+    using Node2 = typename RootT::ChildNodeType;
+    using Node1 = typename Node2::ChildNodeType;
+    using Node0 = LeafNodeType;
+
     template<int LEVEL>
-    using NodeType = typename Node<Tree, LEVEL>::type;
+    using TreeNodeT = typename TreeNode<Tree, LEVEL>::type;
 
-    static constexpr bool IgnoreValues = RootT::IgnoreValues;
-    static_assert(is_same<NodeType<0>, LeafNodeType>::value, "NodeType<0> error");
-    static_assert(is_same<NodeType<3>, RootType>::value, "NodeType<3> error");
+    //static constexpr bool IgnoreValues = RootT::IgnoreValues;
+    static_assert(is_same<TreeNodeT<0>, Node0>::value, "TreeNodeT<0> error");
+    static_assert(is_same<TreeNodeT<1>, Node1>::value, "TreeNodeT<1> error");
+    static_assert(is_same<TreeNodeT<2>, Node2>::value, "TreeNodeT<2> error");
+    static_assert(is_same<TreeNodeT<3>, Node3>::value, "TreeNodeT<3> error");
 
     /// @brief This class cannot be constructed or deleted
     Tree() = delete;
@@ -1532,7 +2006,7 @@
 
     __hostdev__ const RootT& root() const { return *reinterpret_cast<const RootT*>(reinterpret_cast<const uint8_t*>(this) + DataType::mBytes[RootT::LEVEL]); }
 
-    __hostdev__ AccessorType getAccessor() const { return ReadAccessor<RootT>(this->root()); }
+    __hostdev__ AccessorType getAccessor() const { return AccessorType(this->root()); }
 
     /// @brief Return the value of the given voxel (regardless of state or location in the tree.)
     __hostdev__ const ValueType& getValue(const CoordType& ijk) const { return this->root().getValue(ijk); }
@@ -1567,13 +2041,25 @@
     __hostdev__ const NodeT* getNode(uint32_t i) const;
 
     template<int LEVEL>
-    __hostdev__ const NodeType<LEVEL>* getNode(uint32_t i) const;
+    __hostdev__ const TreeNodeT<LEVEL>* getNode(uint32_t i) const;
 
     template<typename NodeT>
     __hostdev__ NodeT* getNode(uint32_t i);
 
     template<int LEVEL>
-    __hostdev__ NodeType<LEVEL>* getNode(uint32_t i);
+    __hostdev__ TreeNodeT<LEVEL>* getNode(uint32_t i);
+
+    /// @brief Returns the linear index, i.e. 0 -> ( # of nodes of type NodeT - 1), of the specified node
+    template<typename NodeT>
+    __hostdev__ uint32_t getNodeID(const NodeT& node) const;
+
+    /// @brief Returns the linear index of the specified node. 0 corresponds to the root node, followed by all the upper
+    ///        internal nodes, then the lower internal nodes and finally the leaf nodes. So the highest linear index is
+    ///        is total number of tree nodes minus one.
+    ///
+    /// @details This is useful when accessing blind data associated with tree nodes, e.g. auxiliary value buffers
+    template<typename NodeT>
+    __hostdev__ uint32_t getLinearOffset(const NodeT& node) const;
 
 private:
     static_assert(sizeof(DataType) % NANOVDB_DATA_ALIGNMENT == 0, "sizeof(TreeData) is misaligned");
@@ -1591,34 +2077,51 @@
 template<typename NodeT>
 const NodeT* Tree<RootT>::getNode(uint32_t i) const
 {
-    static_assert(is_same<NodeType<NodeT::LEVEL>, NodeT>::value, "Tree::getNode: unvalid node type");
+    static_assert(is_same<TreeNodeT<NodeT::LEVEL>, NodeT>::value, "Tree::getNode: unvalid node type");
     assert(i < DataType::mCount[NodeT::LEVEL]);
     return reinterpret_cast<const NodeT*>(reinterpret_cast<const uint8_t*>(this) + DataType::mBytes[NodeT::LEVEL]) + i;
 }
 
 template<typename RootT>
 template<int LEVEL>
-const typename Node<Tree<RootT>, LEVEL>::type* Tree<RootT>::getNode(uint32_t i) const
+const typename TreeNode<Tree<RootT>, LEVEL>::type* Tree<RootT>::getNode(uint32_t i) const
 {
     assert(i < DataType::mCount[LEVEL]);
-    return reinterpret_cast<const NodeType<LEVEL>*>(reinterpret_cast<const uint8_t*>(this) + DataType::mBytes[LEVEL]) + i;
+    return reinterpret_cast<const TreeNodeT<LEVEL>*>(reinterpret_cast<const uint8_t*>(this) + DataType::mBytes[LEVEL]) + i;
 }
 
 template<typename RootT>
 template<typename NodeT>
 NodeT* Tree<RootT>::getNode(uint32_t i)
 {
-    static_assert(is_same<NodeType<NodeT::LEVEL>, NodeT>::value, "Tree::getNode: unvalid node type");
+    static_assert(is_same<TreeNodeT<NodeT::LEVEL>, NodeT>::value, "Tree::getNode: unvalid node type");
     assert(i < DataType::mCount[NodeT::LEVEL]);
     return reinterpret_cast<NodeT*>(reinterpret_cast<uint8_t*>(this) + DataType::mBytes[NodeT::LEVEL]) + i;
 }
 
 template<typename RootT>
 template<int LEVEL>
-typename Node<Tree<RootT>, LEVEL>::type* Tree<RootT>::getNode(uint32_t i)
+typename TreeNode<Tree<RootT>, LEVEL>::type* Tree<RootT>::getNode(uint32_t i)
 {
     assert(i < DataType::mCount[LEVEL]);
-    return reinterpret_cast<NodeType<LEVEL>*>(reinterpret_cast<uint8_t*>(this) + DataType::mBytes[LEVEL]) + i;
+    return reinterpret_cast<TreeNodeT<LEVEL>*>(reinterpret_cast<uint8_t*>(this) + DataType::mBytes[LEVEL]) + i;
+}
+
+template<typename RootT>
+template<typename NodeT>
+uint32_t Tree<RootT>::getNodeID(const NodeT& node) const
+{
+    static_assert(is_same<TreeNodeT<NodeT::LEVEL>, NodeT>::value, "Tree::getNodeID: unvalid node type");
+    const NodeT* first = reinterpret_cast<const NodeT*>(reinterpret_cast<const uint8_t*>(this) + DataType::mBytes[NodeT::LEVEL]);
+    assert(&node >= first);
+    return static_cast<uint32_t>(&node - first); //we know that there can never be more than 2^32 nodes of any type
+}
+
+template<typename RootT>
+template<typename NodeT>
+uint32_t Tree<RootT>::getLinearOffset(const NodeT& node) const
+{
+    return this->getNodeID(node) + DataType::mPFSum[NodeT::LEVEL];
 }
 
 // --------------------------> RootNode <------------------------------------
@@ -1631,6 +2134,7 @@
 {
     using ValueT = typename ChildT::ValueType;
     using CoordT = typename ChildT::CoordType;
+    using StatsT = typename ChildT::FloatType;
     /// @brief Return a key based on the coordinates of a voxel
 #ifdef USE_SINGLE_ROOT_KEY
     using KeyT = uint64_t;
@@ -1641,16 +2145,16 @@
                (KeyT(uint32_t(ijk[1]) >> ChildT::TOTAL) << 21) | // middle 21 bits
                (KeyT(uint32_t(ijk[0]) >> ChildT::TOTAL) << 42); // upper 21 bits
     }
-    __hostdev__ static CoordT KeyToCoord(const KeyT& key) 
-    { 
+    __hostdev__ static CoordT KeyToCoord(const KeyT& key)
+    {
         static constexpr uint64_t MASK = (1u << 21) - 1;
-        return Coord(( key        & MASK) << ChildT::TOTAL,
+        return Coord((key & MASK) << ChildT::TOTAL,
                      ((key >> 21) & MASK) << ChildT::TOTAL,
-                     ((key >> 42) & MASK) << ChildT::TOTAL); 
+                     ((key >> 42) & MASK) << ChildT::TOTAL);
     }
 #else
     using KeyT = CoordT;
-    __hostdev__ static KeyT CoordToKey(const CoordT& ijk) { return ijk & ~ChildT::MASK; }
+    __hostdev__ static KeyT   CoordToKey(const CoordT& ijk) { return ijk & ~ChildT::MASK; }
     __hostdev__ static CoordT KeyToCoord(const KeyT& key) { return key; }
 #endif
     BBox<CoordT> mBBox; // 24B. AABB if active values in index space.
@@ -1658,8 +2162,10 @@
     uint32_t     mTileCount; // 4B. number of tiles and child pointers in the root node
 
     ValueT mBackground; // background value, i.e. value of any unset voxel
-    ValueT mValueMin; // min value
-    ValueT mValueMax; // max value
+    ValueT mMinimum; // typically 4B, minmum of all the active values
+    ValueT mMaximum; // typically 4B, maximum of all the active values
+    StatsT mAverage; // typically 4B, average of all the active values in this node and its child nodes
+    StatsT mStdDevi; // typically 4B, standard deviation of all the active values in this node and its child nodes
 
     struct NANOVDB_ALIGN(NANOVDB_DATA_ALIGNMENT) Tile
     {
@@ -1675,12 +2181,12 @@
             value = v;
             childID = -1;
         }
-        __hostdev__ bool isChild() const { return childID >=0; }
+        __hostdev__ bool   isChild() const { return childID >= 0; }
         __hostdev__ CoordT origin() const { return KeyToCoord(key); }
-        KeyT     key; // (USE_SINGLE_ROOT_KEY)?8B:12B
-        int32_t  childID; // 4B. negative values indicate no child node, i.e. this is a value tile
-        uint32_t state; // 4B. state of tile value
-        ValueT   value; // value of tile (i.e. no child node)
+        KeyT               key; // (USE_SINGLE_ROOT_KEY)?8B:12B
+        int32_t            childID; // 4B. negative values indicate no child node, i.e. this is a value tile
+        uint32_t           state; // 4B. state of tile value
+        ValueT             value; // value of tile (i.e. no child node)
     }; // Tile
 
     /// @brief Returns a non-const reference to the tile at the specified linear offset.
@@ -1717,11 +2223,13 @@
     using LeafNodeType = typename ChildT::LeafNodeType;
     using ChildNodeType = ChildT;
     using ValueType = typename ChildT::ValueType;
+    using FloatType = typename ChildT::FloatType;
     using CoordType = typename ChildT::CoordType;
+    using AccessorType = DefaultReadAccessor<ValueType>;
     using Tile = typename DataType::Tile;
 
     static constexpr uint32_t LEVEL = 1 + ChildT::LEVEL; // level 0 = leaf
-    static constexpr bool IgnoreValues = ChildT::IgnoreValues;
+    //static constexpr bool     IgnoreValues = ChildT::IgnoreValues;
 
     /// @brief This class cannot be constructed or deleted
     RootNode() = delete;
@@ -1729,6 +2237,8 @@
     RootNode& operator=(const RootNode&) = delete;
     ~RootNode() = delete;
 
+    __hostdev__ AccessorType getAccessor() const { return AccessorType(*this); }
+
     __hostdev__ DataType* data() { return reinterpret_cast<DataType*>(this); }
 
     __hostdev__ const DataType* data() const { return reinterpret_cast<const DataType*>(this); }
@@ -1736,21 +2246,30 @@
     /// @brief Return a const reference to the index bounding box of all the active values in this tree, i.e. in all nodes of the tree
     __hostdev__ const BBox<CoordType>& bbox() const { return DataType::mBBox; }
 
-     /// @brief Return the total number of active voxels in the root and all its child nodes.
+    /// @brief Return the total number of active voxels in the root and all its child nodes.
     __hostdev__ const uint64_t& activeVoxelCount() const { return DataType::mActiveVoxelCount; }
 
     /// @brief Return a const reference to the background value, i.e. the value associated with
     ///        any coordinate location that has not been set explicitly.
     __hostdev__ const ValueType& background() const { return DataType::mBackground; }
 
+    /// @brief Return the number of tiles encoded in this root node
+    __hostdev__ const uint32_t& tileCount() const { return DataType::mTileCount; }
+
     /// @brief Return a const reference to the minimum active value encoded in this root node and any of its child nodes
-    __hostdev__ const ValueType& valueMin() const { return DataType::mValueMin; }
+    __hostdev__ const ValueType& valueMin() const { return DataType::mMinimum; }
 
     /// @brief Return a const reference to the maximum active value encoded in this root node and any of its child nodes
-    __hostdev__ const ValueType& valueMax() const { return DataType::mValueMax; }
+    __hostdev__ const ValueType& valueMax() const { return DataType::mMaximum; }
 
-    /// @brief Return the number of tiles encoded in this root node
-    __hostdev__ const uint32_t& tileCount() const { return DataType::mTileCount; }
+    /// @brief Return a const reference to the average of all the active values encoded in this root node and any of its child nodes
+    __hostdev__ const FloatType& average() const { return DataType::mAverage; }
+
+    /// @brief Return a const reference to the variance of all the active values encoded in this root node and any of its child nodes
+    __hostdev__ const FloatType& variance() const { return DataType::mStdDevi * DataType::mStdDevi; }
+
+    /// @brief Return a const reference to the standard deviation of all the active values encoded in this root node and any of its child nodes
+    __hostdev__ const FloatType& stdDeviation() const { return DataType::mStdDevi; }
 
     /// @brief Return the expected memory footprint in bytes with the specified number of tiles
     __hostdev__ static uint64_t memUsage(uint32_t _tileCount) { return sizeof(RootNode) + _tileCount * sizeof(Tile); }
@@ -1800,8 +2319,9 @@
     static_assert(sizeof(DataType) % NANOVDB_DATA_ALIGNMENT == 0, "sizeof(RootData) is misaligned");
     static_assert(sizeof(typename DataType::Tile) % NANOVDB_DATA_ALIGNMENT == 0, "sizeof(RootData::Tile) is misaligned");
 
-    template<typename>
+    template<typename, int, int, int>
     friend class ReadAccessor;
+
     template<typename>
     friend class Tree;
 
@@ -1812,10 +2332,10 @@
     __hostdev__ const Tile* findTile(const CoordType& ijk) const
     {
         // binary-search of pre-sorted elements
-        int32_t     low = 0, high = DataType::mTileCount; //low is inclusive and high is exclusive
+        int32_t     low = 0, high = DataType::mTileCount; // low is inclusive and high is exclusive
         const Tile* tiles = reinterpret_cast<const Tile*>(this + 1);
         const auto  key = DataType::CoordToKey(ijk);
-#if 1 //switch between linear and binary seach
+#if 1 // switch between linear and binary seach
         for (int i = low; i < high; i++) {
             const Tile* tile = &tiles[i];
             if (tile->key == key)
@@ -1837,7 +2357,25 @@
         return nullptr;
     }
 
-    /// @brief Private method to retun a voxel value and update a ReadAccessor
+    /// @brief Private method to return node information and update a ReadAccessor
+    template<typename AccT>
+    __hostdev__ typename AccT::NodeInfo getNodeInfoAndCache(const CoordType& ijk, const AccT& acc) const
+    {
+        using NodeInfoT = typename AccT::NodeInfo;
+        if (const Tile* tile = this->findTile(ijk)) {
+            if (tile->childID < 0) {
+                return NodeInfoT{LEVEL, ChildT::dim(), tile->value, tile->value, tile->value, 
+                                 0, tile->origin(), tile->origin() + CoordType(ChildT::DIM)};
+            }
+            const ChildT& child = this->child(*tile);
+            acc.insert(ijk, &child);
+            return child.getNodeInfoAndCache(ijk, acc);
+        }
+        return NodeInfoT{LEVEL, Maximum<uint32_t>::value(), this->valueMin(), this->valueMax(), 
+                         this->average(), this->stdDeviation(), this->bbox()[0], this->bbox()[1]};
+    }
+
+    /// @brief Private method to return a voxel value and update a ReadAccessor
     template<typename AccT>
     __hostdev__ const ValueType& getValueAndCache(const CoordType& ijk, const AccT& acc) const
     {
@@ -1917,6 +2455,7 @@
 struct NANOVDB_ALIGN(NANOVDB_DATA_ALIGNMENT) InternalData
 {
     using ValueT = typename ChildT::ValueType;
+    using StatsT = typename ChildT::FloatType;
     using CoordT = typename ChildT::CoordType;
     using MaskT = typename ChildT::template MaskType<LOG2DIM>;
 
@@ -1932,15 +2471,17 @@
         ~Tile() = delete;
     }; // if ValueType is a float this has a footprint of only 4 bytes!
 
-    BBox<CoordT> mBBox; // 24B. node bounding box.
-    int32_t      mOffset; // 4B. number of node offsets till first tile
-    uint32_t     mFlags; // 4B. node flags.
-    MaskT        mValueMask; // LOG2DIM(5): 4096B, LOG2DIM(4): 512B
-    MaskT        mChildMask; // LOG2DIM(5): 4096B, LOG2DIM(4): 512B
-
-    ValueT mValueMin;// sizeof(ValueT)
-    ValueT mValueMax;// sizeof(ValueT)
-    alignas(32) Tile mTable[1u << (3 * LOG2DIM)];// sizeof(ValueT) x (16*16*16 or 32*32*32)
+    BBox<CoordT> mBBox; // 24B. node bounding box.                       |
+    int32_t      mOffset; // 4B. number of node offsets till first child |  32B aligned
+    uint32_t     mFlags; // 4B. node flags.                              |
+    MaskT        mValueMask; // LOG2DIM(5): 4096B, LOG2DIM(4): 512B  | 32B aligned
+    MaskT        mChildMask; // LOG2DIM(5): 4096B, LOG2DIM(4): 512B  | 32B aligned
+
+    ValueT mMinimum; // typically 4B
+    ValueT mMaximum; // typically 4B
+    StatsT mAverage; // typically 4B,  average of all the active values in this node and its child nodes
+    StatsT mStdDevi; // typically 4B, standard deviation of all the active values in this node and its child nodes
+    alignas(32) Tile mTable[1u << (3 * LOG2DIM)]; // sizeof(ValueT) x (16*16*16 or 32*32*32)
 
     /// @brief Returns a const pointer to the child node at the specifed linear offset.
     __hostdev__ const ChildT* child(uint32_t n) const
@@ -1964,19 +2505,20 @@
     using LeafNodeType = typename ChildT::LeafNodeType;
     using ChildNodeType = ChildT;
     using ValueType = typename ChildT::ValueType;
+    using FloatType = typename ChildT::FloatType;
     using CoordType = typename ChildT::CoordType;
     template<uint32_t LOG2>
     using MaskType = typename ChildT::template MaskType<LOG2>;
     using DataType = InternalData<ChildT, Log2Dim>;
 
     static constexpr uint32_t LOG2DIM = Log2Dim;
-    static constexpr uint32_t TOTAL = LOG2DIM + ChildT::TOTAL; //dimension in index space
-    static constexpr uint32_t DIM = 1u << TOTAL;// number of voxels along each axis of this node
-    static constexpr uint32_t SIZE = 1u << (3 * LOG2DIM); //number of tile values (or child pointers)
+    static constexpr uint32_t TOTAL = LOG2DIM + ChildT::TOTAL; // dimension in index space
+    static constexpr uint32_t DIM = 1u << TOTAL; // number of voxels along each axis of this node
+    static constexpr uint32_t SIZE = 1u << (3 * LOG2DIM); // number of tile values (or child pointers)
     static constexpr uint32_t MASK = (1u << TOTAL) - 1u;
     static constexpr uint32_t LEVEL = 1 + ChildT::LEVEL; // level 0 = leaf
-    static constexpr uint64_t NUM_VALUES = uint64_t(1) << (3 * TOTAL);// total voxel count represented by this node
-    static constexpr bool IgnoreValues = ChildT::IgnoreValues;
+    static constexpr uint64_t NUM_VALUES = uint64_t(1) << (3 * TOTAL); // total voxel count represented by this node
+    //static constexpr bool     IgnoreValues = ChildT::IgnoreValues;
 
     /// @brief This class cannot be constructed or deleted
     InternalNode() = delete;
@@ -1988,10 +2530,10 @@
 
     __hostdev__ const DataType* data() const { return reinterpret_cast<const DataType*>(this); }
 
-    /// @brief Return the dimnetion, in voxel units, of this internal node (typically 8*16 or 8*16*32)
+    /// @brief Return the dimension, in voxel units, of this internal node (typically 8*16 or 8*16*32)
     __hostdev__ static uint32_t dim() { return 1u << TOTAL; }
 
-    /// @brief return memory usage in bytes for the class
+    /// @brief Return memory usage in bytes for the class
     __hostdev__ static size_t memUsage() { return sizeof(DataType); }
 
     /// @brief Return a const reference to the bit mask of active voxels in this internal node
@@ -2004,10 +2546,19 @@
     __hostdev__ CoordType origin() const { return DataType::mBBox.min() & ~MASK; }
 
     /// @brief Return a const reference to the minimum active value encoded in this internal node and any of its child nodes
-    __hostdev__ const ValueType& valueMin() const { return DataType::mValueMin; }
+    __hostdev__ const ValueType& valueMin() const { return DataType::mMinimum; }
 
     /// @brief Return a const reference to the maximum active value encoded in this internal node and any of its child nodes
-    __hostdev__ const ValueType& valueMax() const { return DataType::mValueMax; }
+    __hostdev__ const ValueType& valueMax() const { return DataType::mMaximum; }
+
+    /// @brief Return a const reference to the average of all the active values encoded in this internal node and any of its child nodes
+    __hostdev__ const FloatType& average() const { return DataType::mAverage; }
+
+    /// @brief Return a const reference to the variance of all the active values encoded in this internal node and any of its child nodes
+    __hostdev__ const FloatType& variance() const { return DataType::mStdDevi*DataType::mStdDevi; }
+
+    /// @brief Return a const reference to the standard deviation of all the active values encoded in this internal node and any of its child nodes
+    __hostdev__ const FloatType& stdDeviation() const { return DataType::mStdDevi; }
 
     /// @brief Return a const reference to the bounding box in index space of active values in this internal node and any of its child nodes
     __hostdev__ const BBox<CoordType>& bbox() const { return DataType::mBBox; }
@@ -2053,20 +2604,20 @@
     __hostdev__ static Coord OffsetToLocalCoord(uint32_t n)
     {
         assert(n < SIZE);
-        const uint32_t m = n & ((1<<2*LOG2DIM)-1);
-        return Coord(n >> 2*LOG2DIM, m >> LOG2DIM, m & ((1<<LOG2DIM)-1));
+        const uint32_t m = n & ((1 << 2 * LOG2DIM) - 1);
+        return Coord(n >> 2 * LOG2DIM, m >> LOG2DIM, m & ((1 << LOG2DIM) - 1));
     }
 
-    __hostdev__ void localToGlobalCoord(Coord &ijk) const
+    __hostdev__ void localToGlobalCoord(Coord& ijk) const
     {
         ijk <<= ChildT::TOTAL;
-        ijk  += this->origin();
+        ijk += this->origin();
     }
 
     __hostdev__ Coord offsetToGlobalCoord(uint32_t n) const
     {
         Coord ijk = InternalNode::OffsetToLocalCoord(n);
-        this->localToGlobalCoord(ijk); 
+        this->localToGlobalCoord(ijk);
         return ijk;
     }
 
@@ -2074,8 +2625,9 @@
     static_assert(sizeof(DataType) % NANOVDB_DATA_ALIGNMENT == 0, "sizeof(InternalData) is misaligned");
     //static_assert(offsetof(DataType, mTable) % 32 == 0, "InternalData::mTable is misaligned");
 
-    template<typename>
+    template<typename, int, int, int>
     friend class ReadAccessor;
+
     template<typename>
     friend class RootNode;
     template<typename, uint32_t>
@@ -2094,6 +2646,20 @@
     }
 
     template<typename AccT>
+    __hostdev__ typename AccT::NodeInfo getNodeInfoAndCache(const CoordType& ijk, const AccT& acc) const
+    {
+        using NodeInfoT = typename AccT::NodeInfo;
+        const uint32_t n = CoordToOffset(ijk);
+        if (!DataType::mChildMask.isOn(n)) {
+            return NodeInfoT{LEVEL, this->dim(), this->valueMin(), this->valueMax(), this->average(),
+                             this->stdDeviation(), this->bbox()[0], this->bbox()[1]};
+        }
+        const ChildT* child = this->child(n);
+        acc.insert(ijk, child);
+        return child->getNodeInfoAndCache(ijk, acc);
+    }
+
+    template<typename AccT>
     __hostdev__ bool isActiveAndCache(const CoordType& ijk, const AccT& acc) const
     {
         const uint32_t n = CoordToOffset(ijk);
@@ -2133,12 +2699,7 @@
     {
         if (DataType::mFlags & uint32_t(1))
             this->dim(); //ship this node if first bit is set
-        //if (DataType::mFlags) ChildNodeType::dim();
-        //if (DataType::mFlags || !ray.intersects( this->bbox() )) return 1<<TOTAL;
-        //auto bbox = this->bbox();
-        //bbox.min() += -1;
-        //bbox.max() += 1;
-        //if (!ray.intersects( bbox )) return 1<<TOTAL;
+        //if (!ray.intersects( this->bbox() )) return 1<<TOTAL;
 
         const uint32_t n = CoordToOffset(ijk);
         if (DataType::mChildMask.isOn(n)) {
@@ -2160,21 +2721,33 @@
 struct NANOVDB_ALIGN(NANOVDB_DATA_ALIGNMENT) LeafData
 {
     using ValueType = ValueT;
-    static constexpr bool IgnoreValues = false;
+    using FloatType = typename FloatTraits<ValueT>::FloatType;
+    //static constexpr bool IgnoreValues = false;
 
     CoordT         mBBoxMin; // 12B.
     uint8_t        mBBoxDif[3]; // 3B.
     uint8_t        mFlags; // 1B.
     MaskT<LOG2DIM> mValueMask; // LOG2DIM(3): 64B.
 
-    ValueType mValueMin;
-    ValueType mValueMax;
+    ValueType mMinimum; // typically 4B
+    ValueType mMaximum; // typically 4B
+    FloatType mAverage; // typically 4B, average of all the active values in this node and its child nodes
+    FloatType mStdDevi; //typically 4B, standard deviation of all the active values in this node and its child nodes
     alignas(32) ValueType mValues[1u << 3 * LOG2DIM];
 
     __hostdev__ const ValueType* values() const { return mValues; }
     __hostdev__ const ValueType& value(uint32_t i) const { return mValues[i]; }
-    __hostdev__ const ValueType& valueMin() const { return mValueMin; }
-    __hostdev__ const ValueType& valueMax() const { return mValueMax; }
+    __hostdev__ void             setValueOnly(uint32_t offset, const ValueType& value) { mValues[offset] = value; }
+    __hostdev__ void             setValue(uint32_t offset, const ValueType& value)
+    {
+        mValueMask.setOn(offset);
+        mValues[offset] = value;
+    }
+
+    __hostdev__ const ValueType& valueMin()     const { return mMinimum; }
+    __hostdev__ const ValueType& valueMax()     const { return mMaximum; }
+    __hostdev__ const FloatType& average()      const { return mAverage; }
+    __hostdev__ const FloatType& stdDeviation() const { return mStdDevi; }
 
     /// @brief This class cannot be constructed or deleted
     LeafData() = delete;
@@ -2187,8 +2760,9 @@
 template<typename CoordT, template<uint32_t> class MaskT, uint32_t LOG2DIM>
 struct NANOVDB_ALIGN(NANOVDB_DATA_ALIGNMENT) LeafData<ValueMask, CoordT, MaskT, LOG2DIM>
 {
-    using ValueType = uint32_t;// dummy value type
-    static constexpr bool IgnoreValues = true;
+    using ValueType = uint32_t; // dummy value type
+    using FloatType = uint32_t; // dummy value type
+    //static constexpr bool IgnoreValues = true;
     static const uint32_t mDummy;
 
     CoordT         mBBoxMin; // 12B.
@@ -2200,6 +2774,8 @@
     __hostdev__ const ValueType& value(uint32_t) const { return mDummy; }
     __hostdev__ const ValueType& valueMin() const { return mDummy; }
     __hostdev__ const ValueType& valueMax() const { return mDummy; }
+    __hostdev__ const FloatType& average() const { return mDummy; }
+    __hostdev__ const FloatType& stdDeviation() const { return mDummy; }
 
     /// @brief This class cannot be constructed or deleted
     LeafData() = delete;
@@ -2226,18 +2802,19 @@
     using LeafNodeType = LeafNode<ValueT, CoordT, MaskT, Log2Dim>;
     using DataType = LeafData<ValueT, CoordT, MaskT, Log2Dim>;
     using ValueType = typename DataType::ValueType;
+    using FloatType = typename DataType::FloatType;
     using CoordType = CoordT;
     template<uint32_t LOG2>
     using MaskType = MaskT<LOG2>;
 
     static constexpr uint32_t LOG2DIM = Log2Dim;
     static constexpr uint32_t TOTAL = LOG2DIM; // needed by parent nodes
-    static constexpr uint32_t DIM = 1u << TOTAL;// number of voxels along each axis of this node
+    static constexpr uint32_t DIM = 1u << TOTAL; // number of voxels along each axis of this node
     static constexpr uint32_t SIZE = 1u << 3 * LOG2DIM; // total number of voxels represented by this node
     static constexpr uint32_t MASK = (1u << LOG2DIM) - 1u; // mask for bit operations
     static constexpr uint32_t LEVEL = 0; // level 0 = leaf
-    static constexpr uint64_t NUM_VALUES = uint64_t(1) << (3 * TOTAL);// total voxel count represented by this node
-    static constexpr bool IgnoreValues = DataType::IgnoreValues;
+    static constexpr uint64_t NUM_VALUES = uint64_t(1) << (3 * TOTAL); // total voxel count represented by this node
+    //static constexpr bool     IgnoreValues = DataType::IgnoreValues;
 
     __hostdev__ DataType* data() { return reinterpret_cast<DataType*>(this); }
 
@@ -2255,6 +2832,15 @@
     /// @brief Return a const reference to the maximum active value encoded in this leaf node
     __hostdev__ const ValueType& valueMax() const { return DataType::valueMax(); }
 
+    /// @brief Return a const reference to the average of all the active values encoded in this leaf node
+    __hostdev__ const FloatType& average() const { return DataType::average(); }
+
+    /// @brief Return a const reference to the variance of all the active values encoded in this leaf node
+    __hostdev__ const FloatType& variance() const { return DataType::stdDeviation()*DataType::stdDeviation(); }
+
+    /// @brief Return a const reference to the standard deviation of all the active values encoded in this leaf node
+    __hostdev__ const FloatType& stdDeviation() const { return DataType::stdDeviation(); }
+
     __hostdev__ uint8_t flags() const { return DataType::mFlags; }
 
     /// @brief Return the origin in index space of this leaf node
@@ -2263,12 +2849,12 @@
     __hostdev__ static CoordT OffsetToLocalCoord(uint32_t n)
     {
         assert(n < SIZE);
-        const uint32_t m = n & ((1<<2*LOG2DIM)-1);
-        return CoordT(n >> 2*LOG2DIM, m >> LOG2DIM, m & MASK);
+        const uint32_t m = n & ((1 << 2 * LOG2DIM) - 1);
+        return CoordT(n >> 2 * LOG2DIM, m >> LOG2DIM, m & MASK);
     }
 
     /// @brief Converts (in place) a local index coordinate to a global index coordinate
-    __hostdev__ void localToGlobalCoord(Coord &ijk) const { ijk += this->origin(); }
+    __hostdev__ void localToGlobalCoord(Coord& ijk) const { ijk += this->origin(); }
 
     __hostdev__ CoordT offsetToGlobalCoord(uint32_t n) const
     {
@@ -2306,6 +2892,16 @@
     /// @brief Return the voxel value at the given coordinate.
     __hostdev__ const ValueType& getValue(const CoordT& ijk) const { return DataType::value(CoordToOffset(ijk)); }
 
+    /// @brief Sets the value at the specified location and activate its state.
+    ///
+    /// @note This is safe since it does not change the topology of the tree (unlike setValue methods on the other nodes)
+    __hostdev__ void setValue(const CoordT& ijk, const ValueType& v) { DataType::setValue(CoordToOffset(ijk), v); }
+
+    /// @brief Sets the value at the specified location but leaves its state unchanged.
+    ///
+    /// @note This is safe since it does not change the topology of the tree (unlike setValue methods on the other nodes)
+    __hostdev__ void setValueOnly(const CoordT& ijk, const ValueType& v) { DataType::setValueOnly(CoordToOffset(ijk), v); }
+
     /// @brief Return @c true if the voxel value at the given coordinate is active.
     __hostdev__ bool isActive(const CoordT& ijk) const { return DataType::mValueMask.isOn(CoordToOffset(ijk)); }
     __hostdev__ bool isActive(uint32_t n) const { return DataType::mValueMask.isOn(n); }
@@ -2326,12 +2922,22 @@
         return ((ijk[0] & MASK) << (2 * LOG2DIM)) + ((ijk[1] & MASK) << LOG2DIM) + (ijk[2] & MASK);
     }
 
+    /// @brief Updates the local bounding box of active voxels in this node.
+    ///
+    /// @warning It assumes that the origin and value mask have already been set.
+    ///
+    /// @details This method is based on few (intrinsic) bit operations and hence is relatively fast.
+    ///          However, it should only only be called of either the value mask has changed or if the
+    ///          active bounding box is still undefined. e.g. during constrution of this node.
+    __hostdev__ void updateBBox();
+
 private:
     static_assert(sizeof(DataType) % NANOVDB_DATA_ALIGNMENT == 0, "sizeof(LeafData) is misaligned");
     //static_assert(offsetof(DataType, mValues) % 32 == 0, "LeafData::mValues is misaligned");
 
-    template<typename>
+    template<typename, int, int, int>
     friend class ReadAccessor;
+
     template<typename>
     friend class RootNode;
     template<typename, uint32_t>
@@ -2341,6 +2947,14 @@
     template<typename AccT>
     __hostdev__ const ValueType& getValueAndCache(const CoordT& ijk, const AccT&) const { return this->getValue(ijk); }
 
+    /// @brief Return the node information.
+    template<typename AccT>
+    __hostdev__ typename AccT::NodeInfo getNodeInfoAndCache(const CoordType& /*ijk*/, const AccT& /*acc*/) const { 
+        using NodeInfoT = typename AccT::NodeInfo;
+        return NodeInfoT{LEVEL, this->dim(), this->valueMin(), this->valueMax(), 
+                         this->average(), this->stdDeviation(), this->bbox()[0], this->bbox()[1]}; 
+    }
+
     template<typename AccT>
     __hostdev__ bool isActiveAndCache(const CoordT& ijk, const AccT&) const { return this->isActive(ijk); }
 
@@ -2355,12 +2969,76 @@
     {
         if (DataType::mFlags & uint8_t(1))
             return this->dim(); // skip this node if first bit is set
-        //if (!ray.intersects( this->bbox() )) return 1<<TOTAL;
+        //if (!ray.intersects( this->bbox() )) return 1 << LOG2DIM;
         return ChildNodeType::dim();
     }
 
 }; // LeafNode class
 
+template<typename ValueT, typename CoordT, template<uint32_t> class MaskT, uint32_t LOG2DIM>
+inline void LeafNode<ValueT, CoordT, MaskT, LOG2DIM>::updateBBox()
+{
+    static_assert(LOG2DIM == 3, "LeafNode::updateBBox: only supports LOGDIM = 3!");
+    auto update = [&](uint32_t min, uint32_t max, int axis) {
+        assert(min <= max && max < 8);
+        DataType::mBBoxMin[axis] = (DataType::mBBoxMin[axis] & ~MASK) + int(min);
+        DataType::mBBoxDif[axis] = uint8_t(max - min);
+    };
+    uint64_t word64 = DataType::mValueMask.template getWord<uint64_t>(0);
+    uint32_t Xmin = word64 ? 0u : 8u, Xmax = Xmin;
+    for (int i = 1; i < 8; ++i) { // last loop over 8 64 words
+        if (uint64_t w = DataType::mValueMask.template getWord<uint64_t>(i)) { // skip if word has no set bits
+            word64 |= w; // union 8 x 64 bits words into one 64 bit word
+            if (Xmin == 8)
+                Xmin = i; // only set once
+            Xmax = i;
+        }
+    }
+    assert(word64); // we assume at least one active voxel in this node!
+    update(Xmin, Xmax, 0);
+    update(FindLowestOn(word64) >> 3, FindHighestOn(word64) >> 3, 1);
+    const uint32_t *p = reinterpret_cast<const uint32_t*>(&word64), word32 = p[0] | p[1];
+    const uint16_t *q = reinterpret_cast<const uint16_t*>(&word32), word16 = q[0] | q[1];
+    const uint8_t  *b = reinterpret_cast<const uint8_t* >(&word16), byte   = b[0] | b[1];
+    assert(byte);
+    update(FindLowestOn(static_cast<uint32_t>(byte)), FindHighestOn(static_cast<uint32_t>(byte)), 2);
+}
+
+// --------------------------> Template specializations and traits <------------------------------------
+
+/// @brief Template specializations to the default configuration used in OpenVDB:
+///        Root->32^3->16^3->8^3
+template<typename ValueT>
+using NanoLeaf = LeafNode<ValueT, Coord, Mask, 3>;
+template<typename ValueT>
+using NanoNode1 = InternalNode<NanoLeaf<ValueT>, 4>;
+template<typename ValueT>
+using NanoNode2 = InternalNode<NanoNode1<ValueT>, 5>;
+template<typename ValueT>
+using NanoRoot = RootNode<NanoNode2<ValueT>>;
+template<typename ValueT>
+using NanoTree = Tree<NanoRoot<ValueT>>;
+template<typename ValueT>
+using NanoGrid = Grid<NanoTree<ValueT>>;
+
+using FloatTree  = NanoTree<float>;
+using DoubleTree = NanoTree<double>;
+using Int32Tree  = NanoTree<int32_t>;
+using UInt32Tree = NanoTree<uint32_t>;
+using Int64Tree  = NanoTree<int64_t>;
+using Vec3fTree  = NanoTree<Vec3f>;
+using Vec3dTree  = NanoTree<Vec3d>;
+using MaskTree   = NanoTree<ValueMask>;
+
+using FloatGrid  = Grid<FloatTree>;
+using DoubleGrid = Grid<DoubleTree>;
+using Int32Grid  = Grid<Int32Tree>;
+using UInt32Grid = Grid<UInt32Tree>;
+using Int64Grid  = Grid<Int64Tree>;
+using Vec3fGrid  = Grid<Vec3fTree>;
+using Vec3dGrid  = Grid<Vec3dTree>;
+using MaskGrid   = Grid<MaskTree>;
+
 // --------------------------> ReadAccessor <------------------------------------
 
 /// @brief A read-only value acessor with three levels of node caching. This allows for
@@ -2378,37 +3056,473 @@
 ///          multiple threads on the same host or device. However, it's light-weight so simple
 ///          instantiate one per thread (on the host and/or device).
 ///
-/// @details Used to accelerated random access into a VDB tree. Provides on
-/// average O(1) random access operations by means of inverse tree traversal,
-/// which amortizes the non-const time complexity of the root node.
+/// @details Used to accelerated random access into a VDB tree. Provides on average
+///          O(1) random access operations by means of inverse tree traversal,
+///          which amortizes the non-const time complexity of the root node.
 
-template<typename RootT>
-class ReadAccessor
+template <typename ValueT>
+class ReadAccessor<ValueT, -1, -1, -1>
 {
+    using RootT  = NanoRoot<ValueT>; // root node
+    using FloatType = typename RootT::FloatType;
+    using CoordValueType = typename RootT::CoordType::ValueType;
+
+    mutable const RootT* mRoot; // 8 bytes (mutable to allow for access methods to be const)
 public:
-    using ValueType = typename RootT::ValueType;
+    using ValueType = ValueT;
     using CoordType = typename RootT::CoordType;
-    using CoordValueType = typename RootT::CoordType::ValueType;
-    using NodeT3 = const RootT; //                    root node
-    using NodeT2 = typename NodeT3::ChildNodeType; // upper internal node
-    using NodeT1 = typename NodeT2::ChildNodeType; // lower internal node
-    using NodeT0 = typename NodeT1::ChildNodeType; // Leaf node
+
+    static const int CacheLevels = 0;
+
+    struct NodeInfo {
+        uint32_t  mLevel; //   4B
+        uint32_t  mDim; //     4B
+        ValueType mMinimum; // typically 4B 
+        ValueType mMaximum; // typically 4B
+        FloatType mAverage; // typically 4B
+        FloatType mStdDevi; // typically 4B
+        CoordType mBBoxMin; // 3*4B
+        CoordType mBBoxMax; // 3*4B 
+    };
+
+    /// @brief Constructor from a root node
+    __hostdev__ ReadAccessor(const RootT& root) : mRoot{&root} {}
+
+    __hostdev__ const RootT& root() const { return *mRoot; }
+
+    /// @brief Defaults constructors
+    ReadAccessor(const ReadAccessor&) = default;
+    ~ReadAccessor() = default;
+    ReadAccessor& operator=(const ReadAccessor&) = default;
+
+    __hostdev__ const ValueType& getValue(const CoordType& ijk) const
+    {
+        return mRoot->getValueAndCache(ijk, *this);
+    }
+
+    __hostdev__ NodeInfo getNodeInfo(const CoordType& ijk) const
+    {
+        return mRoot->getNodeInfoAndCache(ijk, *this);
+    }
+
+    __hostdev__ bool isActive(const CoordType& ijk) const
+    {
+        return mRoot->isActiveAndCache(ijk, *this);
+    }
+
+    __hostdev__ bool probeValue(const CoordType& ijk, ValueType& v) const
+    {
+        return mRoot->probeValueAndCache(ijk, v, *this);
+    }
+
+    __hostdev__ const NanoLeaf<ValueT>* probeLeaf(const CoordType& ijk) const
+    {
+        return mRoot->probeLeafAndCache(ijk, *this);
+    }
+
+    template<typename RayT>
+    __hostdev__ uint32_t getDim(const CoordType& ijk, const RayT& ray) const
+    {        
+        return mRoot->getDimAndCache(ijk, ray, *this);
+    }
+
+private:
+    /// @brief Allow nodes to insert themselves into the cache.
+    template<typename>
+    friend class RootNode;
+    template<typename, uint32_t>
+    friend class InternalNode;
+    template<typename, typename, template<uint32_t> class, uint32_t>
+    friend class LeafNode;
+
+    /// @brief No-op
+    template<typename NodeT>
+    __hostdev__ void insert(const CoordType&, const NodeT*) const {}
+}; // ReadAccessor<ValueT, -1, -1, -1> class
+
+/// @brief Node caching at a single tree level
+template <typename ValueT, int LEVEL0>
+class ReadAccessor<ValueT, LEVEL0, -1, -1>// 0, 1, 2
+{
+    static_assert(LEVEL0 >= 0 && LEVEL0 <= 2, "LEVEL0 should be 0, 1, 2");
+
+    using TreeT  = NanoTree<ValueT>;
+    using RootT  = NanoRoot<ValueT>; //  root node
+    using LeafT  = NanoLeaf< ValueT>; // Leaf node
+    using NodeT  = typename TreeNode<TreeT, LEVEL0>::type;
+    using CoordT = typename RootT::CoordType;
+
+    using FloatType = typename RootT::FloatType;
+    using CoordValueType = typename RootT::CoordT::ValueType;
+
+    // All member data are mutable to allow for access methods to be const
+    mutable CoordT       mKey; // 3*4 = 12 bytes
+    mutable const RootT* mRoot; // 8 bytes
+    mutable const NodeT* mNode; // 8 bytes
+
+public:
+    using ValueType = ValueT;
+    using CoordType = CoordT;
+
+    static const int CacheLevels = 1;
+
+    using NodeInfo = typename ReadAccessor<ValueT, -1, -1, -1>::NodeInfo;
+
+    /// @brief Constructor from a root node
+    __hostdev__ ReadAccessor(const RootT& root)
+        : mKey(CoordType::max())
+        , mRoot(&root)
+        , mNode(nullptr)
+    {
+    }
+
+    __hostdev__ const RootT& root() const { return *mRoot; }
+
+    /// @brief Defaults constructors
+    ReadAccessor(const ReadAccessor&) = default;
+    ~ReadAccessor() = default;
+    ReadAccessor& operator=(const ReadAccessor&) = default;
+
+    __hostdev__ bool isCached(const CoordType& ijk) const
+    {
+        return (ijk[0] & int32_t(~NodeT::MASK)) == mKey[0] && 
+               (ijk[1] & int32_t(~NodeT::MASK)) == mKey[1] && 
+               (ijk[2] & int32_t(~NodeT::MASK)) == mKey[2];
+    }
+
+    __hostdev__ const ValueType& getValue(const CoordType& ijk) const
+    {
+        if (this->isCached(ijk)) {
+            return mNode->getValueAndCache(ijk, *this);
+        }
+        return mRoot->getValueAndCache(ijk, *this);
+    }
+
+    __hostdev__ NodeInfo getNodeInfo(const CoordType& ijk) const
+    {
+        if (this->isCached(ijk)) {
+            return mNode->getNodeInfoAndCache(ijk, *this);
+        }
+        return mRoot->getNodeInfoAndCache(ijk, *this);
+    }
+
+    __hostdev__ bool isActive(const CoordType& ijk) const
+    {
+        if (this->isCached(ijk)) {
+            return mNode->isActiveAndCache(ijk, *this);
+        }
+        return mRoot->isActiveAndCache(ijk, *this);
+    }
+
+    __hostdev__ bool probeValue(const CoordType& ijk, ValueType& v) const
+    {
+        if (this->isCached(ijk)) {
+            return mNode->probeValueAndCache(ijk, *this);
+        }
+        return mRoot->probeValueAndCache(ijk, *this);
+    }
+
+    __hostdev__ const LeafT* probeLeaf(const CoordType& ijk) const
+    {
+        if (this->isCached(ijk)) {
+            return mNode->probeLeafAndCache(ijk, *this);
+        }
+        return mRoot->probeLeafAndCache(ijk, *this);
+    }
+
+    template<typename RayT>
+    __hostdev__ uint32_t getDim(const CoordType& ijk, const RayT& ray) const
+    {
+        if (this->isCached(ijk)) {
+            return mNode->getDimAndCache(ijk, *this);
+        }
+        return mRoot->getDimAndCache(ijk, *this);
+    }
+
+private:
+    /// @brief Allow nodes to insert themselves into the cache.
+    template<typename>
+    friend class RootNode;
+    template<typename, uint32_t>
+    friend class InternalNode;
+    template<typename, typename, template<uint32_t> class, uint32_t>
+    friend class LeafNode;
+
+    /// @brief Inserts a leaf node and key pair into this ReadAccessor
+    __hostdev__ void insert(const CoordType& ijk, const NodeT* node) const
+    {
+        mKey = ijk & ~NodeT::MASK;
+        mNode = node;
+    }
+
+    // no-op
+    template<typename OtherNodeT>
+    __hostdev__ void insert(const CoordType&, const OtherNodeT*) const {}
+
+}; // ReadAccessor<ValueT, LEVEL0>
+
+template <typename ValueT, int LEVEL0, int LEVEL1>
+class ReadAccessor<ValueT, LEVEL0, LEVEL1, -1>// (0,1), (1,2), (0,2)
+{
+    static_assert(LEVEL0 >=0 && LEVEL0 <=2, "LEVEL0 must be 0, 1, 2");
+    static_assert(LEVEL1 >=0 && LEVEL1 <=2, "LEVEL1 must be 0, 1, 2");
+    static_assert(LEVEL0 < LEVEL1, "Level 0 must be lower than level 1");                              
+    using TreeT  = NanoTree<ValueT>;
+    using RootT  = NanoRoot<ValueT>;
+    using LeafT  = NanoLeaf<ValueT>;
+    using Node1T = typename TreeNode<TreeT, LEVEL0>::type;
+    using Node2T = typename TreeNode<TreeT, LEVEL1>::type;
+    using CoordT = typename RootT::CoordType;
+    
+    using FloatType = typename RootT::FloatType;
+    using CoordValueType = typename RootT::CoordT::ValueType;
+
+    // All member data are mutable to allow for access methods to be const
+#ifdef USE_SINGLE_ACCESSOR_KEY // 44 bytes total
+    mutable CoordT mKey; // 3*4 = 12 bytes
+#else // 68 bytes total
+    mutable CoordT mKeys[2]; // 2*3*4 = 24 bytes
+#endif
+    mutable const RootT*  mRoot;
+    mutable const Node1T* mNode1;
+    mutable const Node2T* mNode2;
+
+public:
+    using ValueType = ValueT;
+    using CoordType = CoordT;
+
+    static const int CacheLevels = 2;
+
+    using NodeInfo = typename ReadAccessor<ValueT,-1,-1,-1>::NodeInfo;
 
     /// @brief Constructor from a root node
     __hostdev__ ReadAccessor(const RootT& root)
 #ifdef USE_SINGLE_ACCESSOR_KEY
         : mKey(CoordType::max())
 #else
-        : mKeys
+        : mKeys{CoordType::max(), CoordType::max()}
+#endif
+        , mRoot(&root)
+        , mNode1(nullptr)
+        , mNode2(nullptr)
     {
-        CoordType::max(), CoordType::max(), CoordType::max()
     }
+
+    __hostdev__ const RootT& root() const { return *mRoot; }
+
+    /// @brief Defaults constructors
+    ReadAccessor(const ReadAccessor&) = default;
+    ~ReadAccessor() = default;
+    ReadAccessor& operator=(const ReadAccessor&) = default;
+
+#ifdef USE_SINGLE_ACCESSOR_KEY
+    __hostdev__ bool isCached1(CoordValueType dirty) const
+    {
+        if (!mNode1)
+            return false;
+        if (dirty & int32_t(~Node1T::MASK)) {
+            mNode1 = nullptr;
+            return false;
+        }
+        return true;
+    }
+    __hostdev__ bool isCached2(CoordValueType dirty) const
+    {
+        if (!mNode2)
+            return false;
+        if (dirty & int32_t(~Node2T::MASK)) {
+            mNode2 = nullptr;
+            return false;
+        }
+        return true;
+    }
+    __hostdev__ CoordValueType computeDirty(const CoordType& ijk) const
+    {
+        return (ijk[0] ^ mKey[0]) | (ijk[1] ^ mKey[1]) | (ijk[2] ^ mKey[2]);
+    }
+#else
+    __hostdev__ bool isCached1(const CoordType& ijk) const
+    {
+        return (ijk[0] & int32_t(~Node1T::MASK)) == mKeys[0][0] && 
+               (ijk[1] & int32_t(~Node1T::MASK)) == mKeys[0][1] && 
+               (ijk[2] & int32_t(~Node1T::MASK)) == mKeys[0][2];
+    }
+    __hostdev__ bool isCached2(const CoordType& ijk) const
+    {
+        return (ijk[0] & int32_t(~Node2T::MASK)) == mKeys[1][0] && 
+               (ijk[1] & int32_t(~Node2T::MASK)) == mKeys[1][1] && 
+               (ijk[2] & int32_t(~Node2T::MASK)) == mKeys[1][2];
+    }
+#endif
+
+    __hostdev__ const ValueType& getValue(const CoordType& ijk) const
+    {
+#ifdef USE_SINGLE_ACCESSOR_KEY
+        const CoordValueType dirty = this->computeDirty(ijk);
+#else
+        auto&& dirty = ijk;
+#endif
+        if (this->isCached1(dirty)) {
+            return mNode1->getValueAndCache(ijk, *this);
+        } else if (this->isCached2(dirty)) {
+            return mNode2->getValueAndCache(ijk, *this);
+        }
+        return mRoot->getValueAndCache(ijk, *this);
+    }
+
+    __hostdev__ NodeInfo getNodeInfo(const CoordType& ijk) const
+    {
+#ifdef USE_SINGLE_ACCESSOR_KEY
+        const CoordValueType dirty = this->computeDirty(ijk);
+#else
+        auto&& dirty = ijk;
+#endif
+        if (this->isCached1(dirty)) {
+            return mNode1->getNodeInfoAndCache(ijk, *this);
+        } else if (this->isCached2(dirty)) {
+            return mNode2->getNodeInfoAndCache(ijk, *this);
+        }
+        return mRoot->getNodeInfoAndCache(ijk, *this);
+    }
+
+    __hostdev__ bool isActive(const CoordType& ijk) const
+    {
+#ifdef USE_SINGLE_ACCESSOR_KEY
+        const CoordValueType dirty = this->computeDirty(ijk);
+#else
+        auto&& dirty = ijk;
+#endif
+        if (this->isCached1(dirty)) {
+            return mNode1->isActiveAndCache(ijk, *this);
+        } else if (this->isCached2(dirty)) {
+            return mNode2->isActiveAndCache(ijk, *this);
+        }
+        return mRoot->isActiveAndCache(ijk, *this);
+    }
+
+    __hostdev__ bool probeValue(const CoordType& ijk, ValueType& v) const
+    {
+#ifdef USE_SINGLE_ACCESSOR_KEY
+        const CoordValueType dirty = this->computeDirty(ijk);
+#else
+        auto&& dirty = ijk;
+#endif
+        if (this->isCached1(dirty)) {
+            return mNode1->probeValueAndCache(ijk, *this);
+        } else if (this->isCached2(dirty)) {
+            return mNode2->probeValueAndCache(ijk, *this);
+        }
+        return mRoot->probeValueAndCache(ijk, *this);
+    }
+
+    __hostdev__ const LeafT* probeLeaf(const CoordType& ijk) const
+    {
+#ifdef USE_SINGLE_ACCESSOR_KEY
+        const CoordValueType dirty = this->computeDirty(ijk);
+#else
+        auto&& dirty = ijk;
+#endif
+        if (this->isCached1(dirty)) {
+            return mNode1->probeLeafAndCache(ijk, *this);
+        } else if (this->isCached2(dirty)) {
+            return mNode2->probeLeafAndCache(ijk, *this);
+        }
+        return mRoot->probeLeafAndCache(ijk, *this);
+    }
+
+    template<typename RayT>
+    __hostdev__ uint32_t getDim(const CoordType& ijk, const RayT& ray) const
+    {
+#ifdef USE_SINGLE_ACCESSOR_KEY
+        const CoordValueType dirty = this->computeDirty(ijk);
+#else
+        auto&& dirty = ijk;
+#endif
+        if (this->isCached1(dirty)) {
+            return mNode1->getDimAndCache(ijk, *this);
+        } else if (this->isCached2(dirty)) {
+            return mNode2->getDimAndCache(ijk, *this);
+        }
+        return mRoot->getDimAndCache(ijk, *this);
+    }
+
+private:
+    /// @brief Allow nodes to insert themselves into the cache.
+    template<typename>
+    friend class RootNode;
+    template<typename, uint32_t>
+    friend class InternalNode;
+    template<typename, typename, template<uint32_t> class, uint32_t>
+    friend class LeafNode;
+
+    /// @brief Inserts a leaf node and key pair into this ReadAccessor
+    __hostdev__ void insert(const CoordType& ijk, const Node1T* node) const
+    {
+#ifdef USE_SINGLE_ACCESSOR_KEY
+        mKey = ijk;
+#else
+        mKeys[0] = ijk & ~NodeT::MASK;
+#endif
+        mNode1 = node;
+    }
+    __hostdev__ void insert(const CoordType& ijk, const Node2T* node) const
+    {
+#ifdef USE_SINGLE_ACCESSOR_KEY
+        mKey = ijk;
+#else
+        mKeys[1] = ijk & ~NodeT::MASK;
+#endif
+        mNode2 = node;
+    }
+    template <typename OtherNodeT>
+    __hostdev__ void insert(const CoordType&, const OtherNodeT*) const {}
+}; // ReadAccessor<ValueT, LEVEL0, LEVEL1>
+
+
+/// @brief Node caching at all (three) tree levels
+template <typename ValueT>
+class ReadAccessor<ValueT, 0, 1, 2>
+{
+    using TreeT  = NanoTree<ValueT>;
+    using RootT  = NanoRoot<ValueT>; //  root node
+    using NodeT2 = NanoNode2<ValueT>; // upper internal node
+    using NodeT1 = NanoNode1<ValueT>; // lower internal node
+    using LeafT  = NanoLeaf< ValueT>; // Leaf node
+    using CoordT = typename RootT::CoordType;
+
+    using FloatType = typename RootT::FloatType;
+    using CoordValueType = typename RootT::CoordT::ValueType;
+
+    // All member data are mutable to allow for access methods to be const
+#ifdef USE_SINGLE_ACCESSOR_KEY // 44 bytes total
+    mutable CoordT mKey; // 3*4 = 12 bytes
+#else // 68 bytes total
+    mutable CoordT mKeys[3]; // 3*3*4 = 36 bytes
+#endif
+    mutable const RootT* mRoot;
+    mutable const void* mNode[3]; // 4*8 = 32 bytes
+
+public:
+    using ValueType = ValueT;
+    using CoordType = CoordT;
+
+    static const int CacheLevels = 3;
+
+    using NodeInfo = typename ReadAccessor<ValueT, -1, -1, -1>::NodeInfo;
+
+    /// @brief Constructor from a root node
+    __hostdev__ ReadAccessor(const RootT& root)
+#ifdef USE_SINGLE_ACCESSOR_KEY
+        : mKey(CoordType::max())
+#else
+        : mKeys{CoordType::max(), CoordType::max(), CoordType::max()}
 #endif
-        , mNode{nullptr, nullptr, nullptr, &root}
+        , mRoot(&root)  
+        , mNode{nullptr, nullptr, nullptr}
     {
     }
 
-    __hostdev__ const RootT& root() const { return *(NodeT3*)mNode[3]; }
+    __hostdev__ const RootT& root() const { return *mRoot; }
 
     /// @brief Defaults constructors
     ReadAccessor(const ReadAccessor&) = default;
@@ -2421,7 +3535,7 @@
     template<typename NodeT>
     __hostdev__ const NodeT* getNode() const
     {
-        using T = typename Node<Tree<RootT>, NodeT::LEVEL>::type;
+        using T = typename TreeNode<TreeT, NodeT::LEVEL>::type;
         static_assert(is_same<T, NodeT>::value, "ReadAccessor::getNode: Invalid node type");
         return reinterpret_cast<const T*>(mNode[NodeT::LEVEL]);
     }
@@ -2458,14 +3572,31 @@
 #else
         auto&& dirty = ijk;
 #endif
-        if (this->isCached<NodeT0>(dirty)) {
-            return ((NodeT0*)mNode[0])->getValue(ijk);
+        if (this->isCached<LeafT>(dirty)) {
+            return ((LeafT*)mNode[0])->getValue(ijk);
         } else if (this->isCached<NodeT1>(dirty)) {
             return ((NodeT1*)mNode[1])->getValueAndCache(ijk, *this);
         } else if (this->isCached<NodeT2>(dirty)) {
             return ((NodeT2*)mNode[2])->getValueAndCache(ijk, *this);
         }
-        return ((NodeT3*)mNode[3])->getValueAndCache(ijk, *this);
+        return mRoot->getValueAndCache(ijk, *this);
+    }
+
+    __hostdev__ NodeInfo getNodeInfo(const CoordType& ijk) const
+    {
+#ifdef USE_SINGLE_ACCESSOR_KEY
+        const CoordValueType dirty = this->computeDirty(ijk);
+#else
+        auto&& dirty = ijk;
+#endif
+        if (this->isCached<LeafT>(dirty)) {
+            return ((LeafT*)mNode[0])->getNodeInfoAndCache(ijk, *this);
+        } else if (this->isCached<NodeT1>(dirty)) {
+            return ((NodeT1*)mNode[1])->getNodeInfoAndCache(ijk, *this);
+        } else if (this->isCached<NodeT2>(dirty)) {
+            return ((NodeT2*)mNode[2])->getNodeInfoAndCache(ijk, *this);
+        }
+        return mRoot->getNodeInfoAndCache(ijk, *this);
     }
 
     __hostdev__ bool isActive(const CoordType& ijk) const
@@ -2475,14 +3606,14 @@
 #else
         auto&& dirty = ijk;
 #endif
-        if (this->isCached<NodeT0>(dirty)) {
-            return ((NodeT0*)mNode[0])->isActive(ijk);
+        if (this->isCached<LeafT>(dirty)) {
+            return ((LeafT*)mNode[0])->isActive(ijk);
         } else if (this->isCached<NodeT1>(dirty)) {
             return ((NodeT1*)mNode[1])->isActiveAndCache(ijk, *this);
         } else if (this->isCached<NodeT2>(dirty)) {
             return ((NodeT2*)mNode[2])->isActiveAndCache(ijk, *this);
         }
-        return ((NodeT3*)mNode[3])->isActiveAndCache(ijk, *this);
+        return mRoot->isActiveAndCache(ijk, *this);
     }
 
     __hostdev__ bool probeValue(const CoordType& ijk, ValueType& v) const
@@ -2492,31 +3623,31 @@
 #else
         auto&& dirty = ijk;
 #endif
-        if (this->isCached<NodeT0>(dirty)) {
-            return ((NodeT0*)mNode[0])->probeValue(ijk, v);
+        if (this->isCached<LeafT>(dirty)) {
+            return ((LeafT*)mNode[0])->probeValue(ijk, v);
         } else if (this->isCached<NodeT1>(dirty)) {
             return ((NodeT1*)mNode[1])->probeValueAndCache(ijk, v, *this);
         } else if (this->isCached<NodeT2>(dirty)) {
             return ((NodeT2*)mNode[2])->probeValueAndCache(ijk, v, *this);
         }
-        return ((NodeT3*)mNode[3])->probeValueAndCache(ijk, v, *this);
+        return mRoot->probeValueAndCache(ijk, v, *this);
     }
 
-    __hostdev__ const NodeT0* probeLeaf(const CoordType& ijk) const
+    __hostdev__ const LeafT* probeLeaf(const CoordType& ijk) const
     {
 #ifdef USE_SINGLE_ACCESSOR_KEY
         const CoordValueType dirty = this->computeDirty(ijk);
 #else
         auto&& dirty = ijk;
 #endif
-        if (this->isCached<NodeT0>(dirty)) {
-            return ((NodeT0*)mNode[0]);
+        if (this->isCached<LeafT>(dirty)) {
+            return ((LeafT*)mNode[0]);
         } else if (this->isCached<NodeT1>(dirty)) {
             return ((NodeT1*)mNode[1])->probeLeafAndCache(ijk, *this);
         } else if (this->isCached<NodeT2>(dirty)) {
             return ((NodeT2*)mNode[2])->probeLeafAndCache(ijk, *this);
         }
-        return ((NodeT3*)mNode[3])->probeLeafAndCache(ijk, *this);
+        return mRoot->probeLeafAndCache(ijk, *this);
     }
 
     template<typename RayT>
@@ -2527,14 +3658,14 @@
 #else
         auto&& dirty = ijk;
 #endif
-        if (this->isCached<NodeT0>(dirty)) {
-            return ((NodeT0*)mNode[0])->getDimAndCache(ijk, ray, *this);
+        if (this->isCached<LeafT>(dirty)) {
+            return ((LeafT*)mNode[0])->getDimAndCache(ijk, ray, *this);
         } else if (this->isCached<NodeT1>(dirty)) {
             return ((NodeT1*)mNode[1])->getDimAndCache(ijk, ray, *this);
         } else if (this->isCached<NodeT2>(dirty)) {
             return ((NodeT2*)mNode[2])->getDimAndCache(ijk, ray, *this);
         }
-        return ((NodeT3*)mNode[3])->getDimAndCache(ijk, ray, *this);
+        return mRoot->getDimAndCache(ijk, ray, *this);
     }
 
 private:
@@ -2557,47 +3688,41 @@
 #endif
         mNode[NodeT::LEVEL] = node;
     }
+}; // ReadAccessor<ValueT, 0, 1, 2>
 
-    // All member data are mutable to allow for access methods to be const
-#ifdef USE_SINGLE_ACCESSOR_KEY // 44 bytes total
-    mutable CoordType mKey; // 3*4 = 12 bytes
-#else // 68 bytes total
-    mutable CoordType mKeys[3]; // 3*3*4 = 36 bytes
-#endif
-    mutable const void* mNode[4]; // 4*8 = 32 bytes
-}; // ReadAccessor class
+//////////////////////////////////////////////////
 
-/// @brief Default configuration used in OpenVDB: Root->32^3->16^3->8^3
-template<typename ValueT>
-using NanoLeaf = LeafNode<ValueT, Coord, Mask, 3>;
-template<typename ValueT>
-using NanoNode1 = InternalNode<NanoLeaf<ValueT>, 4>;
-template<typename ValueT>
-using NanoNode2 = InternalNode<NanoNode1<ValueT>, 5>;
-template<typename ValueT>
-using NanoRoot = RootNode<NanoNode2<ValueT>>;
-template<typename ValueT>
-using NanoTree = Tree<NanoRoot<ValueT>>;
-template<typename ValueT>
-using NanoGrid = Grid<NanoTree<ValueT>>;
-
-using FloatTree = NanoTree<float>;
-using DoubleTree = NanoTree<double>;
-using Int32Tree = NanoTree<int32_t>;
-using UInt32Tree = NanoTree<uint32_t>;
-using Int64Tree = NanoTree<int64_t>;
-using Vec3fTree = NanoTree<Vec3f>;
-using Vec3dTree = NanoTree<Vec3d>;
-using MaskTree = NanoTree<ValueMask>;
+/// @brief Free-standing function for convenient creation of a ReadAccessor with
+///        optional and customizable node caching.
+///
+/// @details createAccessor<>(grid):  No caching of nodes and hence it's thread-safe but slow
+///          createAccessor<0>(grid): Caching of leaf nodes only
+///          createAccessor<1>(grid): Caching of lower internal nodes only
+///          createAccessor<2>(grid): Caching of upper internal nodes only
+///          createAccessor<0,1>(grid): Caching of leaf and lower internal nodes
+///          createAccessor<0,2>(grid): Caching of leaf and upper internal nodes
+///          createAccessor<1,2>(grid): Caching of lower and upper internal nodes
+///          createAccessor<0,1,0>(grid): Caching of all nodes at all tree levels
+
+template <int LEVEL0 = -1, int LEVEL1 = -1, int LEVEL2 = -1, typename ValueT = float>
+ReadAccessor<ValueT, LEVEL0, LEVEL1, LEVEL2> createAccessor(const NanoGrid<ValueT> &grid)
+{ 
+    return ReadAccessor<ValueT, LEVEL0, LEVEL1, LEVEL2>(grid.tree().root());
+}
+
+template <int LEVEL0 = -1, int LEVEL1 = -1, int LEVEL2 = -1, typename ValueT = float>
+ReadAccessor<ValueT, LEVEL0, LEVEL1, LEVEL2> createAccessor(const NanoTree<ValueT> &tree)
+{ 
+    return ReadAccessor<ValueT, LEVEL0, LEVEL1, LEVEL2>(tree().root());
+}
+
+template <int LEVEL0 = -1, int LEVEL1 = -1, int LEVEL2 = -1, typename ValueT = float>
+ReadAccessor<ValueT, LEVEL0, LEVEL1, LEVEL2> createAccessor(const NanoRoot<ValueT> &root)
+{ 
+    return ReadAccessor<ValueT, LEVEL0, LEVEL1, LEVEL2>(root);
+}
 
-using FloatGrid = Grid<FloatTree>;
-using DoubleGrid = Grid<DoubleTree>;
-using Int32Grid = Grid<Int32Tree>;
-using UInt32Grid = Grid<UInt32Tree>;
-using Int64Grid = Grid<Int64Tree>;
-using Vec3fGrid = Grid<Vec3fTree>;
-using Vec3dGrid = Grid<Vec3dTree>;
-using MaskGrid = Grid<MaskTree>;
+//////////////////////////////////////////////////
 
 /// @brief This is a convenient class that allows for access to grid meta-data
 ///        that are independent of the value type of a grid. That is, this calls
@@ -2611,39 +3736,42 @@
     // memory-layout of the data structure and the reasons for why certain methods are safe
     // to call and others are not!
     using GridT = NanoGrid<int>;
-    __hostdev__ const GridT& grid() const { return *reinterpret_cast<const GridT*>( this ); }
+    __hostdev__ const GridT& grid() const { return *reinterpret_cast<const GridT*>(this); }
+
 public:
-    __hostdev__ bool isValid() const { return this->grid().isValid(); }
+    __hostdev__ bool        isValid() const { return this->grid().isValid(); }
     __hostdev__ const char* gridName() const { return this->grid().gridName(); }
-    __hostdev__ GridType gridType() const { return this->grid().gridType(); }
-    __hostdev__ GridClass gridClass() const { return this->grid().gridClass(); }
-    __hostdev__ bool isLevelSet() const { return this->grid().isLevelSet(); }
-    __hostdev__ bool isFogVolume() const { return this->grid().isFogVolume(); }
-    __hostdev__ bool isPointIndex() const { return this->grid().isPointIndex(); }
-    __hostdev__ bool isPointData() const { return this->grid().isPointData(); }
-    __hostdev__ bool isStaggered() const { return this->grid().isStaggered(); }
-    __hostdev__ bool isUnknown() const { return this->grid().isUnknown(); }
+    __hostdev__ GridType    gridType() const { return this->grid().gridType(); }
+    __hostdev__ GridClass   gridClass() const { return this->grid().gridClass(); }
+    __hostdev__ bool        isLevelSet() const { return this->grid().isLevelSet(); }
+    __hostdev__ bool        isFogVolume() const { return this->grid().isFogVolume(); }
+    __hostdev__ bool        isPointIndex() const { return this->grid().isPointIndex(); }
+    __hostdev__ bool        isPointData() const { return this->grid().isPointData(); }
+    __hostdev__ bool        isStaggered() const { return this->grid().isStaggered(); }
+    __hostdev__ bool        isUnknown() const { return this->grid().isUnknown(); }
     __hostdev__ const Map& map() const { return this->grid().map(); }
-    __hostdev__ const BBox<Vec3R> worldBBox() const { return this->grid().worldBBox(); }
+    __hostdev__ const BBox<Vec3R>& worldBBox() const { return this->grid().worldBBox(); }
     __hostdev__ const BBox<Coord>& indexBBox() const { return this->grid().indexBBox(); }
-    __hostdev__ Vec3R voxelSize() const { return this->grid().voxelSize(); }
-    __hostdev__ int blindDataCount() const { return this->grid().blindDataCount(); }
+    __hostdev__ Vec3R              voxelSize() const { return this->grid().voxelSize(); }
+    __hostdev__ int                blindDataCount() const { return this->grid().blindDataCount(); }
     __hostdev__ const GridBlindMetaData& blindMetaData(int n) const { return this->grid().blindMetaData(n); }
-    __hostdev__ uint64_t activeVoxelCount() const { return this->grid().activeVoxelCount(); }
-    __hostdev__ uint32_t nodeCount(uint32_t level) const { return this->grid().tree().nodeCount(level);}
-    __hostdev__ uint64_t checksum() const { return this->grid().checksum(); }
-    __hostdev__ bool isEmpty() const { return this->grid().isEmpty(); }
-};// GridMetaData
+    __hostdev__ uint64_t                 activeVoxelCount() const { return this->grid().activeVoxelCount(); }
+    __hostdev__ uint32_t                 nodeCount(uint32_t level) const { return this->grid().tree().nodeCount(level); }
+    __hostdev__ uint64_t                 checksum() const { return this->grid().checksum(); }
+    __hostdev__ bool                     isEmpty() const { return this->grid().isEmpty(); }
+}; // GridMetaData
 
 /// @brief Class to access points at a specefic voxel location
 template<typename AttT>
-class PointAccessor : public ReadAccessor<NanoRoot<uint32_t>>
+class PointAccessor : public DefaultReadAccessor<uint32_t>
 {
-    using AccT = ReadAccessor<NanoRoot<uint32_t>>;
+    using AccT = DefaultReadAccessor<uint32_t>;
     const UInt32Grid* mGrid;
     const AttT*       mData;
 
 public:
+    using LeafNodeType = typename NanoRoot<uint32_t>::LeafNodeType;
+
     PointAccessor(const UInt32Grid& grid)
         : AccT(grid.tree().root())
         , mGrid(&grid)
@@ -2662,12 +3790,15 @@
         end = begin + count;
         return count;
     }
-    /// @brief Return the number of point in the leaf node containing
+    /// @brief Return the number of points in the leaf node containing the coordinate @a ijk.
+    ///        If this return value is larger than zero then the iterators @a begin and @end
+    ///        will point to all the attributes contained within that leaf node.
     __hostdev__ uint64_t leafPoints(const Coord& ijk, const AttT*& begin, const AttT*& end) const
     {
         auto* leaf = this->probeLeaf(ijk);
-        if (leaf == nullptr)
+        if (leaf == nullptr) {
             return 0;
+        }
         begin = mData + leaf->valueMin();
         end = begin + leaf->valueMax();
         return leaf->valueMax();
@@ -2679,7 +3810,7 @@
         auto* leaf = this->probeLeaf(ijk);
         if (leaf == nullptr)
             return 0;
-        const uint32_t offset = NodeT0::CoordToOffset(ijk);
+        const uint32_t offset = LeafNodeType::CoordToOffset(ijk);
         if (leaf->isActive(offset)) {
             auto* p = mData + leaf->valueMin();
             begin = p + (offset == 0 ? 0 : leaf->getValue(offset - 1));
diff -aur nanovdb-20200925/nanovdb/nanovdb/util/GridBuilder.h nanovdb-20201022/nanovdb/nanovdb/util/GridBuilder.h
--- nanovdb-20200925/nanovdb/nanovdb/util/GridBuilder.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/nanovdb/util/GridBuilder.h	2020-10-22 03:52:50.000000000 +0200
@@ -18,6 +18,7 @@
 #define NANOVDB_GRIDBUILDER_H_HAS_BEEN_INCLUDED
 
 #include "GridHandle.h"
+#include "GridStats.h"
 #include "GridChecksum.h"
 #include "Range.h"
 #include "Invoke.h"
@@ -26,9 +27,9 @@
 #include <map>
 #include <limits>
 #include <atomic>
-#include <sstream>// for stringstream
+#include <sstream> // for stringstream
 #include <vector>
-#include <cstring>// for memcpy
+#include <cstring> // for memcpy
 
 namespace nanovdb {
 
@@ -40,25 +41,27 @@
 /// @param halfWidth Half-width of narrow band in voxel units
 /// @param origin    Origin of grid in world units
 /// @param name      Name of the grid
-/// @param mode      Mode of computation for the checksum.
+/// @param sMode     Mode of computation for the statistics.
+/// @param cMode     Mode of computation for the checksum.
 /// @param buffer    Buffer used for memory allocation by the handle
-template <typename ValueT = float, typename BufferT = HostBuffer>
+template<typename ValueT = float, typename BufferT = HostBuffer>
 GridHandle<BufferT>
-createLevelSetSphere(ValueT radius = 100, 
-                     const Vec3d& center = Vec3d(0),
-                     ValueT voxelSize = 1.0,
-                     ValueT halfWidth = 3.0,
-                     const Vec3d &origin = Vec3d(0),
-                     const std::string &name = "sphere_ls",
-                     ChecksumMode mode = ChecksumMode::Default,
-                     const BufferT& buffer = BufferT());
+createLevelSetSphere(ValueT             radius = 100,
+                     const Vec3d&       center = Vec3d(0),
+                     ValueT             voxelSize = 1.0,
+                     ValueT             halfWidth = 3.0,
+                     const Vec3d&       origin = Vec3d(0),
+                     const std::string& name = "sphere_ls",
+                     StatsMode          sMode = StatsMode::Default,
+                     ChecksumMode       cMode = ChecksumMode::Default,
+                     const BufferT&     buffer = BufferT());
 
 //================================================================================================
 
 /// @brief Returns a handle to a sparse fog volume of a sphere such
 ///        that the eterior is 0 and inactive, the interior is active
-///        with values varying smoothly from 0 at the surface of the 
-///        sphere to 1 at the halfWidth and interior of the sphere. 
+///        with values varying smoothly from 0 at the surface of the
+///        sphere to 1 at the halfWidth and interior of the sphere.
 ///
 /// @param radius    Radius of sphere in world units
 /// @param center    Center of sphere in world units
@@ -66,7 +69,8 @@
 /// @param halfWidth Half-width of narrow band in voxel units
 /// @param origin    Origin of grid in world units
 /// @param name      Name of the grid
-/// @param mode      Mode of computation for the checksum.
+/// @param sMode     Mode of computation for the statistics.
+/// @param cMode     Mode of computation for the checksum.
 /// @param buffer    Buffer used for memory allocation by the handle
 template<typename ValueT = float, typename BufferT = HostBuffer>
 GridHandle<BufferT>
@@ -76,13 +80,14 @@
                       ValueT             halfWidth = 3.0,
                       const Vec3d&       origin = Vec3d(0),
                       const std::string& name = "sphere_fog",
-                      ChecksumMode mode = ChecksumMode::Default,
-                      const BufferT& buffer = BufferT());
+                      StatsMode          sMode = StatsMode::Default,
+                      ChecksumMode       cMode = ChecksumMode::Default,
+                      const BufferT&     buffer = BufferT());
 
 //================================================================================================
 
-/// @brief Returns a handle to a PointDataGrid containing points scattered 
-///        on the surface of a sphere. 
+/// @brief Returns a handle to a PointDataGrid containing points scattered
+///        on the surface of a sphere.
 ///
 /// @param pointsPerVoxel Number of point per voxel on on the surface
 /// @param radius         Radius of sphere in world units
@@ -92,16 +97,16 @@
 /// @param name           Name of the grid
 /// @param mode           Mode of computation for the checksum.
 /// @param buffer         Buffer used for memory allocation by the handle
-template <typename ValueT = float, typename BufferT = HostBuffer>
+template<typename ValueT = float, typename BufferT = HostBuffer>
 inline GridHandle<BufferT>
-createPointSphere(int pointsPerVoxel = 1,
-                  ValueT radius = 100,
-                  const Vec3d& center = Vec3d(0),
-                  ValueT voxelSize = 1.0,
-                  const Vec3d &origin = Vec3d(0),
-                  const std::string &name = "sphere_points",
-                  ChecksumMode mode = ChecksumMode::Default,
-                  const BufferT& buffer = BufferT());
+createPointSphere(int                pointsPerVoxel = 1,
+                  ValueT             radius = 100,
+                  const Vec3d&       center = Vec3d(0),
+                  ValueT             voxelSize = 1.0,
+                  const Vec3d&       origin = Vec3d(0),
+                  const std::string& name = "sphere_points",
+                  ChecksumMode       mode = ChecksumMode::Default,
+                  const BufferT&     buffer = BufferT());
 
 //================================================================================================
 
@@ -114,26 +119,28 @@
 /// @param halfWidth   Half-width of narrow band in voxel units
 /// @param origin      Origin of grid in world units
 /// @param name        Name of the grid
-/// @param mode        Mode of computation for the checksum.
+/// @param sMode     Mode of computation for the statistics.
+/// @param cMode     Mode of computation for the checksum.
 /// @param buffer      Buffer used for memory allocation by the handle
-template <typename ValueT = float, typename BufferT = HostBuffer>
+template<typename ValueT = float, typename BufferT = HostBuffer>
 GridHandle<BufferT>
-createLevelSetTorus(ValueT majorRadius = 100, 
-                    ValueT minorRadius = 50,
-                    const Vec3d& center = Vec3d(0),
-                    ValueT voxelSize = 1.0,
-                    ValueT halfWidth = 3.0,
-                    const Vec3d &origin = Vec3d(0), 
-                    const std::string &name = "torus_ls",
-                    ChecksumMode mode = ChecksumMode::Default,
-                    const BufferT& buffer = BufferT());
+createLevelSetTorus(ValueT             majorRadius = 100,
+                    ValueT             minorRadius = 50,
+                    const Vec3d&       center = Vec3d(0),
+                    ValueT             voxelSize = 1.0,
+                    ValueT             halfWidth = 3.0,
+                    const Vec3d&       origin = Vec3d(0),
+                    const std::string& name = "torus_ls",
+                    StatsMode          sMode = StatsMode::Default,
+                    ChecksumMode       cMode = ChecksumMode::Default,
+                    const BufferT&     buffer = BufferT());
 
 //================================================================================================
 
 /// @brief Returns a handle to a sparse fog volume of a torus in the xz-plane such
 ///        that the exterior is 0 and inactive, the interior is active
-///        with values varying smoothly from 0 at the surface of the 
-///        torus to 1 at the halfWidth and interior of the sphere. 
+///        with values varying smoothly from 0 at the surface of the
+///        torus to 1 at the halfWidth and interior of the sphere.
 ///
 /// @param majorRadius Major radius of torus in world units
 /// @param minorRadius Minor radius of torus in world units
@@ -142,24 +149,26 @@
 /// @param halfWidth   Half-width of narrow band in voxel units
 /// @param origin      Origin of grid in world units
 /// @param name        Name of the grid
-/// @param mode        Mode of computation for the checksum.
+/// @param sMode     Mode of computation for the statistics.
+/// @param cMode     Mode of computation for the checksum.
 /// @param buffer      Buffer used for memory allocation by the handle
-template <typename ValueT = float, typename BufferT = HostBuffer>
+template<typename ValueT = float, typename BufferT = HostBuffer>
 GridHandle<BufferT>
-createFogVolumeTorus(ValueT majorRadius = 100, 
-                     ValueT minorRadius = 50,
-                     const Vec3d& center = Vec3d(0),
-                     ValueT voxelSize = 1.0,
-                     ValueT halfWidth = 3.0,
-                     const Vec3d &origin = Vec3d(0),
-                     const std::string &name = "torus_fog",
-                     ChecksumMode mode = ChecksumMode::Default,
-                     const BufferT& buffer = BufferT());
+createFogVolumeTorus(ValueT             majorRadius = 100,
+                     ValueT             minorRadius = 50,
+                     const Vec3d&       center = Vec3d(0),
+                     ValueT             voxelSize = 1.0,
+                     ValueT             halfWidth = 3.0,
+                     const Vec3d&       origin = Vec3d(0),
+                     const std::string& name = "torus_fog",
+                     StatsMode          sMode = StatsMode::Default,
+                     ChecksumMode       cMode = ChecksumMode::Default,
+                     const BufferT&     buffer = BufferT());
 
 //================================================================================================
 
-/// @brief Returns a handle to a PointDataGrid containing points scattered 
-///        on the surface of a torus. 
+/// @brief Returns a handle to a PointDataGrid containing points scattered
+///        on the surface of a torus.
 ///
 /// @param pointsPerVoxel Number of point per voxel on on the surface
 /// @param majorRadius    Major radius of torus in world units
@@ -170,17 +179,17 @@
 /// @param name           Name of the grid
 /// @param mode           Mode of computation for the checksum.
 /// @param buffer         Buffer used for memory allocation by the handle
-template <typename ValueT = float, typename BufferT = HostBuffer>
+template<typename ValueT = float, typename BufferT = HostBuffer>
 inline GridHandle<BufferT>
-createPointTorus(int pointsPerVoxel = 1,// half-width of narrow band in voxel units
-                 ValueT majorRadius = 100,// major radius of torus in world units
-                 ValueT minorRadius = 50,// minor radius of torus in world units
-                 const Vec3d& center = Vec3d(0), //center of sphere in world units
-                 ValueT voxelSize = 1.0, // size of a voxel in world units 
-                 const Vec3d& origin = Vec3d(0), // origin of grid in world units
-                 const std::string& name = "torus_points",// name of grid
-                 ChecksumMode mode = ChecksumMode::Default,// mode of computation for the checksum
-                 const BufferT& buffer = BufferT());
+createPointTorus(int                pointsPerVoxel = 1, // half-width of narrow band in voxel units
+                 ValueT             majorRadius = 100, // major radius of torus in world units
+                 ValueT             minorRadius = 50, // minor radius of torus in world units
+                 const Vec3d&       center = Vec3d(0), //center of sphere in world units
+                 ValueT             voxelSize = 1.0, // size of a voxel in world units
+                 const Vec3d&       origin = Vec3d(0), // origin of grid in world units
+                 const std::string& name = "torus_points", // name of grid
+                 ChecksumMode       cMode = ChecksumMode::Default,
+                 const BufferT&     buffer = BufferT());
 
 //================================================================================================
 
@@ -194,20 +203,22 @@
 /// @param halfWidth Half-width of narrow band in voxel units
 /// @param origin    Origin of grid in world units
 /// @param name      Name of the grid
-/// @param mode      Mode of computation for the checksum.
+/// @param sMode     Mode of computation for the statistics.
+/// @param cMode     Mode of computation for the checksum.
 /// @param buffer    Buffer used for memory allocation by the handle
-template <typename ValueT = float, typename BufferT = HostBuffer>
+template<typename ValueT = float, typename BufferT = HostBuffer>
 GridHandle<BufferT>
-createLevelSetBox(ValueT width = 40,
-                  ValueT height = 60,
-                  ValueT depth = 100,
-                  const Vec3d& center = Vec3d(0),
-                  ValueT voxelSize = 1.0,
-                  ValueT halfWidth = 3.0, 
-                  const Vec3d &origin = Vec3d(0),
-                  const std::string &name = "box_ls",
-                  ChecksumMode mode = ChecksumMode::Default,
-                  const BufferT& buffer = BufferT());
+createLevelSetBox(ValueT             width = 40,
+                  ValueT             height = 60,
+                  ValueT             depth = 100,
+                  const Vec3d&       center = Vec3d(0),
+                  ValueT             voxelSize = 1.0,
+                  ValueT             halfWidth = 3.0,
+                  const Vec3d&       origin = Vec3d(0),
+                  const std::string& name = "box_ls",
+                  StatsMode          sMode = StatsMode::Default,
+                  ChecksumMode       cMode = ChecksumMode::Default,
+                  const BufferT&     buffer = BufferT());
 
 //================================================================================================
 
@@ -222,28 +233,30 @@
 /// @param halfWidth Half-width of narrow band in voxel units
 /// @param origin    Origin of grid in world units
 /// @param name      Name of the grid
-/// @param mode      Mode of computation for the checksum.
+/// @param sMode     Mode of computation for the statistics.
+/// @param cMode     Mode of computation for the checksum.
 /// @param buffer    Buffer used for memory allocation by the handle
-template <typename ValueT = float, typename BufferT = HostBuffer>
+template<typename ValueT = float, typename BufferT = HostBuffer>
 GridHandle<BufferT>
-createLevelSetBBox(ValueT width = 40,
-                   ValueT height = 60,
-                   ValueT depth = 100,
-                   ValueT thickness = 10,
-                   const Vec3d& center = Vec3d(0),
-                   ValueT voxelSize = 1.0,
-                   ValueT halfWidth = 3.0, 
-                   const Vec3d &origin = Vec3d(0),
-                   const std::string &name = "bbox_ls",
-                   ChecksumMode mode = ChecksumMode::Default,
-                   const BufferT& buffer = BufferT());
+createLevelSetBBox(ValueT             width = 40,
+                   ValueT             height = 60,
+                   ValueT             depth = 100,
+                   ValueT             thickness = 10,
+                   const Vec3d&       center = Vec3d(0),
+                   ValueT             voxelSize = 1.0,
+                   ValueT             halfWidth = 3.0,
+                   const Vec3d&       origin = Vec3d(0),
+                   const std::string& name = "bbox_ls",
+                   StatsMode          sMode = StatsMode::Default,
+                   ChecksumMode       cMode = ChecksumMode::Default,
+                   const BufferT&     buffer = BufferT());
 
 //================================================================================================
 
 /// @brief Returns a handle to a sparse fog volume of a box such
 ///        that the exterior is 0 and inactive, the interior is active
-///        with values varying smoothly from 0 at the surface of the 
-///        box to 1 at the halfWidth and interior of the sphere. 
+///        with values varying smoothly from 0 at the surface of the
+///        box to 1 at the halfWidth and interior of the sphere.
 ///
 /// @param width     Width of box in world units
 /// @param height    Height of box in world units
@@ -253,25 +266,27 @@
 /// @param halfWidth Half-width of narrow band in voxel units
 /// @param origin    Origin of grid in world units
 /// @param name      Name of the grid
-/// @param mode      Mode of computation for the checksum.
+/// @param sMode     Mode of computation for the statistics.
+/// @param cMode     Mode of computation for the checksum.
 /// @param buffer    Buffer used for memory allocation by the handle
-template <typename ValueT = float, typename BufferT = HostBuffer>
+template<typename ValueT = float, typename BufferT = HostBuffer>
 GridHandle<BufferT>
-createFogVolumeBox(ValueT width = 40,
-                   ValueT height = 60,
-                   ValueT depth = 100,
-                   const Vec3d& center = Vec3d(0),
-                   ValueT voxelSize = 1.0,
-                   ValueT halfWidth = 3.0, 
-                   const Vec3d &origin = Vec3d(0),
-                   const std::string &name = "box_ls",
-                   ChecksumMode mode = ChecksumMode::Default,
-                   const BufferT& buffer = BufferT());
+createFogVolumeBox(ValueT             width = 40,
+                   ValueT             height = 60,
+                   ValueT             depth = 100,
+                   const Vec3d&       center = Vec3d(0),
+                   ValueT             voxelSize = 1.0,
+                   ValueT             halfWidth = 3.0,
+                   const Vec3d&       origin = Vec3d(0),
+                   const std::string& name = "box_ls",
+                   StatsMode          sMode = StatsMode::Default,
+                   ChecksumMode       cMode = ChecksumMode::Default,
+                   const BufferT&     buffer = BufferT());
 
 //================================================================================================
 
-/// @brief Returns a handle to a PointDataGrid containing points scattered 
-///        on the surface of a box. 
+/// @brief Returns a handle to a PointDataGrid containing points scattered
+///        on the surface of a box.
 ///
 /// @param pointsPerVoxel Number of point per voxel on on the surface
 /// @param width     Width of box in world units
@@ -283,91 +298,39 @@
 /// @param name      Name of the grid
 /// @param mode      Mode of computation for the checksum.
 /// @param buffer    Buffer used for memory allocation by the handle
-template <typename ValueT = float, typename BufferT = HostBuffer>
+template<typename ValueT = float, typename BufferT = HostBuffer>
 inline GridHandle<BufferT>
-createPointBox(int pointsPerVoxel = 1,// half-width of narrow band in voxel units
-               ValueT width = 40,// width of box in world units
-               ValueT height = 60,// height of box in world units
-               ValueT depth = 100,// depth of box in world units
-               const Vec3d& center = Vec3d(0),//center of sphere in world units
-               ValueT voxelSize = 1.0,// size of a voxel in world units
-               const Vec3d &origin = Vec3d(0),// origin of grid in world units
-               const std::string& name = "box_points",// name of grid
-               ChecksumMode mode = ChecksumMode::Default,
-               const BufferT& buffer = BufferT());
+createPointBox(int                pointsPerVoxel = 1, // half-width of narrow band in voxel units
+               ValueT             width = 40, // width of box in world units
+               ValueT             height = 60, // height of box in world units
+               ValueT             depth = 100, // depth of box in world units
+               const Vec3d&       center = Vec3d(0), //center of sphere in world units
+               ValueT             voxelSize = 1.0, // size of a voxel in world units
+               const Vec3d&       origin = Vec3d(0), // origin of grid in world units
+               const std::string& name = "box_points", // name of grid
+               ChecksumMode       mode = ChecksumMode::Default,
+               const BufferT&     buffer = BufferT());
 
 //================================================================================================
 
 /// @brief Given an input NanoVDB voxel grid this methods returns a GridHandle to another NanoVDB
 ///        PointDataGrid with points scattered in the active leaf voxels of in input grid.
 ///
-/// @param srcGrid        Const input grid used to determine the active voxels to scatter point intp 
+/// @param srcGrid        Const input grid used to determine the active voxels to scatter point intp
 /// @param pointsPerVoxel Number of point per voxel on on the surface
 /// @param name           Name of the grid
 /// @param mode           Mode of computation for the checksum.
 /// @param buffer         Buffer used for memory allocation by the handle
-template <typename ValueT = float, typename BufferT = HostBuffer>
+template<typename ValueT = float, typename BufferT = HostBuffer>
 inline GridHandle<BufferT>
-createPointScatter(const NanoGrid<ValueT> &srcGrid,// origin of grid in world units
-                   int pointsPerVoxel = 1,// half-width of narrow band in voxel units
-                   const std::string &name = "point_scatter",// name of grid
-                   ChecksumMode mode = ChecksumMode::Default,
-                   const BufferT& buffer = BufferT());
-
-//================================================================================================
-
-template<typename T>
-class Extrema
-{
-    T mMin, mMax;
-public:
-    Extrema() : mMin(std::numeric_limits<T>::max()), mMax(std::numeric_limits<T>::min()) {}
-    Extrema(const T &v) : mMin(v), mMax(v) {}
-    Extrema(const T &a, const T &b) : mMin(a), mMax(b) {}
-    Extrema& operator=(const Extrema&) = default;
-    void min(const T &v) { if (v < mMin) mMin = v; }
-    void max(const T &v) { if (v > mMax) mMax = v; }
-    void operator()(const T &v) {
-        if (v < mMin) {
-            mMin = v;
-        } else if (v > mMax) {
-            mMax = v;
-        }
-    }
-    const T& min() const { return mMin; }
-    const T& max() const { return mMax; }
-    operator bool() const { return mMin <= mMax; }
-};// Extrema
-
-// Template specialization
-template<typename T>
-class Extrema<Vec3<T>>
-{
-    Vec3<T> mMin, mMax;
-public:
-    Extrema() : mMin(std::numeric_limits<T>::max()), mMax(std::numeric_limits<T>::min()) {}
-    Extrema(const Vec3<T> &v) : mMin(v), mMax(v) {}
-    Extrema(const Vec3<T> &a, const Vec3<T> &b) : mMin(a), mMax(b) {}
-    Extrema& operator=(const Extrema&) = default;
-    void min(const Vec3<T> &v) { for (int i=0; i<3; ++i) if (v[i] < mMin[i]) mMin[i] = v[i]; }
-    void max(const Vec3<T> &v) { for (int i=0; i<3; ++i) if (v[i] > mMax[i]) mMax[i] = v[i]; }
-    void operator()(const Vec3<T> &v) {
-        for (int i=0; i<3; ++i) {
-            if (v[i] < mMin[i]) {
-                mMin[i] = v[i];
-            } else if (v[i] > mMax[i]) {
-                mMax[i] = v[i];
-            }
-        }
-    }
-    const Vec3<T>& min() const { return mMin; }
-    const Vec3<T>& max() const { return mMax; }
-    operator bool() const { return mMin[0] <= mMax[0] && mMin[1] <= mMax[1] && mMin[2] <= mMax[2]; }
-};// Extrema
-
+createPointScatter(const NanoGrid<ValueT>& srcGrid, // origin of grid in world units
+                   int                     pointsPerVoxel = 1, // half-width of narrow band in voxel units
+                   const std::string&      name = "point_scatter", // name of grid
+                   ChecksumMode            mode = ChecksumMode::Default,
+                   const BufferT&          buffer = BufferT());
 
 /// @brief Allows for the construction of NanoVDB grids without any dependecy
-template <typename ValueT, typename ExtremaOp = Extrema<ValueT> >
+template<typename ValueT, typename StatsT = Stats<ValueT>>
 class GridBuilder
 {
     struct Leaf;
@@ -388,35 +351,36 @@
     using DstRootT = nanovdb::RootNode<DstNode2>;
     using DstTreeT = nanovdb::Tree<DstRootT>;
     using DstGridT = nanovdb::Grid<DstTreeT>;
-    
-    ValueT   mDelta;// skip node if: node.max < -mDelta || node.min > mDelta
-    SrcRootT mRoot;
-    uint8_t* mData;
-    uint64_t mBytes[8]; // Byte offsets to from mData to: tree, blindmetadata, root, node2, node1, leafs, blinddata, (total size)
-    std::atomic<uint64_t> mActiveVoxelCount;
+
+    ValueT                 mDelta; // skip node if: node.max < -mDelta || node.min > mDelta
+    SrcRootT               mRoot;
+    uint8_t*               mData;
+    uint64_t               mBytes[8]; // Byte offsets to from mData to: tree, blindmetadata, root, node2, node1, leafs, blinddata, (total size)
     std::vector<SrcNode0*> mArray0; // leaf nodes
     std::vector<SrcNode1*> mArray1; // lower internal nodes
     std::vector<SrcNode2*> mArray2; // upper internal nodes
-    uint64_t mBlindDataSize;
+    uint64_t               mBlindDataSize;
+
+    template<typename DstNodeT>
+    DstNodeT* node() const { return reinterpret_cast<DstNodeT*>(mData + mBytes[5 - DstNodeT::LEVEL]); }
 
     template<typename DstNodeT>
     typename DstNodeT::DataType* nodeData() const { return reinterpret_cast<typename DstNodeT::DataType*>(mData + mBytes[5 - DstNodeT::LEVEL]); }
     typename DstTreeT::DataType* treeData() const { return reinterpret_cast<typename DstTreeT::DataType*>(mData + mBytes[0]); }
     typename DstGridT::DataType* gridData() const { return reinterpret_cast<typename DstGridT::DataType*>(mData); }
-    uint64_t gridSize() const { return mBytes[7]; }
-    nanovdb::GridBlindMetaData* blindMetaData() const { return reinterpret_cast<nanovdb::GridBlindMetaData*>(mData + mBytes[1]); }
-    uint8_t* blindData() const { return reinterpret_cast<uint8_t*>(mData + mBytes[6]); }
-    
+    uint64_t                     gridSize() const { return mBytes[7]; }
+    nanovdb::GridBlindMetaData*  blindMetaData() const { return reinterpret_cast<nanovdb::GridBlindMetaData*>(mData + mBytes[1]); }
+    uint8_t*                     blindData() const { return reinterpret_cast<uint8_t*>(mData + mBytes[6]); }
+
     // Below are private methods use to serialize nodes into NanoVDB
-    void processLeafs();   
-    template <typename SrcNodeT, typename DstNodeT>
+    void processLeafs();
+    template<typename SrcNodeT, typename DstNodeT>
     void processNodes(std::vector<SrcNodeT*>&);
     void processRoot();
     void processTree();
     void processGrid(const Map&, const std::string&, GridClass);
-    void postProcessGrid(ChecksumMode mode);
-    
-    template <typename SrcNodeT>
+
+    template<typename SrcNodeT>
     void update(std::vector<SrcNodeT*>&);
 
     template<typename T, typename FlagT>
@@ -428,8 +392,13 @@
     setFlag(const T& min, const T& max, FlagT& flag) const;
 
 public:
-    GridBuilder(ValueT background, uint64_t blindDataSize = 0) 
-        : mDelta(0), mRoot(background), mData(nullptr), mBlindDataSize(blindDataSize) {}
+    GridBuilder(ValueT background, uint64_t blindDataSize = 0)
+        : mDelta(0)
+        , mRoot(background)
+        , mData(nullptr)
+        , mBlindDataSize(blindDataSize)
+    {
+    }
 
     ValueAccessor getAccessor() { return ValueAccessor(mRoot); }
 
@@ -437,83 +406,90 @@
 
     void sdfToFog();
 
-    template <typename BufferT = HostBuffer>
-    GridHandle<BufferT> getHandle(double voxelSize = 1.0, const Vec3d &gridOrigin = Vec3d(0), const std::string &name = "", GridClass gridClass = GridClass::Unknown, ChecksumMode mode = ChecksumMode::Default, const BufferT& buffer = BufferT());
-
-    template <typename BufferT = HostBuffer>
-    GridHandle<BufferT> getHandle(const Map &map, const std::string &name = "", GridClass gridClass = GridClass::Unknown, ChecksumMode mode = ChecksumMode::Default, const BufferT& buffer = BufferT());
+    template<typename BufferT = HostBuffer>
+    GridHandle<BufferT> getHandle(double voxelSize = 1.0,
+                                  const Vec3d& gridOrigin = Vec3d(0),
+                                  const std::string& name = "",
+                                  GridClass gridClass = GridClass::Unknown,
+                                  StatsMode sMode = StatsMode::Default,
+                                  ChecksumMode mode = ChecksumMode::Default,
+                                  const BufferT& buffer = BufferT());
+
+    template<typename BufferT = HostBuffer>
+    GridHandle<BufferT> getHandle(const Map& map,
+                                  const std::string& name = "",
+                                  GridClass gridClass = GridClass::Unknown,
+                                  StatsMode sMode = StatsMode::Default,
+                                  ChecksumMode cMode = ChecksumMode::Default,
+                                  const BufferT& buffer = BufferT());
 
-    /// @brief Sets grids values in domain of the @a bbox to those returned by the specified @a func with the 
+    /// @brief Sets grids values in domain of the @a bbox to those returned by the specified @a func with the
     ///        expected signature [](const Coord&)->ValueT.
     ///
-    /// @note If @a func returns a value equal to the brackground value (specified in the constructor) at a 
+    /// @note If @a func returns a value equal to the brackground value (specified in the constructor) at a
     ///       specefic voxel coordinate, then the active state of that coordinate is left off! Else the value
     ///       value is set and the active state is on. This is done to allow for sparse grids to be generated.
     ///
-    /// @param func  Functor used to evaluate the grid values in the @a bbox 
+    /// @param func  Functor used to evaluate the grid values in the @a bbox
     /// @param bbox  Coordinate bounding-box over which the grid values will be set.
     /// @param delta Specifies a lower threshold value for rendering (optiona). Typically equals the voxel size
     ///              for level sets and otherwise it's zero.
-    template <typename Func>
-    void operator()(const Func &func, const CoordBBox &bbox, ValueT delta = ValueT(0));
+    template<typename Func>
+    void operator()(const Func& func, const CoordBBox& bbox, ValueT delta = ValueT(0));
 
-};// GridBuilder
+}; // GridBuilder
 
 //================================================================================================
 
-template <typename ValueT, typename ExtremaOp>
-template <typename Func>
-void GridBuilder<ValueT, ExtremaOp>::
-operator()(const Func &func, const CoordBBox &voxelBBox, ValueT delta)
+template<typename ValueT, typename StatsT>
+template<typename Func>
+void GridBuilder<ValueT, StatsT>::
+operator()(const Func& func, const CoordBBox& voxelBBox, ValueT delta)
 {
     static_assert(is_same<ValueT, typename std::result_of<Func(const Coord&)>::type>::value, "GridBuilder: mismatched ValueType");
-    mDelta = delta;// delta = voxel size for level sets, else 0
-    mActiveVoxelCount = 0;
+    mDelta = delta; // delta = voxel size for level sets, else 0
 
     using NodeT = Leaf;
-    //using NodeT = Node<Leaf>;
     const CoordBBox nodeBBox(voxelBBox[0] >> NodeT::TOTAL, voxelBBox[1] >> NodeT::TOTAL);
-    std::mutex mutex;
-    auto kernel = [&](const CoordBBox &b)
-    {
-        uint64_t sum = 0;
-        NodeT *node = nullptr;
+    std::mutex      mutex;
+    auto            kernel = [&](const CoordBBox& b) {
+        NodeT* node = nullptr;
         for (auto it = b.begin(); it; ++it) {
-            Coord min(*it << NodeT::TOTAL), max(min + Coord(NodeT::DIM - 1));
-            const CoordBBox bbox( min.maxComponent(voxelBBox.min()), 
-                                  max.minComponent(voxelBBox.max()) );
+            Coord           min(*it << NodeT::TOTAL), max(min + Coord(NodeT::DIM - 1));
+            const CoordBBox bbox(min.maxComponent(voxelBBox.min()),
+                                 max.minComponent(voxelBBox.max()));
             if (node == nullptr) {
-                node = new NodeT( bbox[0], mRoot.mBackground, false );
+                node = new NodeT(bbox[0], mRoot.mBackground, false);
             } else {
                 node->mOrigin = bbox[0] & ~NodeT::MASK;
             }
             uint64_t count = 0;
             for (auto ijk = bbox.begin(); ijk; ++ijk) {
-                const auto v = func( *ijk );
-                if ( v == mRoot.mBackground ) continue;
+                const auto v = func(*ijk);
+                if (v == mRoot.mBackground)
+                    continue;
                 ++count;
-                node->setValue( *ijk, v );
+                node->setValue(*ijk, v);
             }
-            if (count>0) {
-                sum += count;
+            if (count > 0) {
                 std::lock_guard<std::mutex> guard(mutex);
                 assert(node != nullptr);
-                mRoot.addNode(node); 
+                mRoot.addNode(node);
                 assert(node == nullptr);
             }
         }
-        if (node) delete node;
-        mActiveVoxelCount += sum;
-    };// kernel
+        if (node)
+            delete node;
+    }; // kernel
     forEach(nodeBBox, kernel);
 }
 
 //================================================================================================
 
-template <typename ValueT, typename ExtremaOp>
-template <typename SrcNodeT>
-void GridBuilder<ValueT, ExtremaOp>::
-update(std::vector<SrcNodeT*> &array)
+template<typename ValueT, typename StatsT>
+template<typename SrcNodeT>
+void GridBuilder<ValueT, StatsT>::
+    update(std::vector<SrcNodeT*>& array)
 {
     const uint32_t nodeCount = mRoot.template nodeCount<SrcNodeT>();
     if (nodeCount != uint32_t(array.size())) {
@@ -521,83 +497,88 @@
         array.reserve(nodeCount);
         mRoot.getNodes(array);
     }
-}// GridBuilder::update
+} // GridBuilder::update
 
 //================================================================================================
 
-template <typename ValueT, typename ExtremaOp>
-void GridBuilder<ValueT, ExtremaOp>::
-sdfToLevelSet()
+template<typename ValueT, typename StatsT>
+void GridBuilder<ValueT, StatsT>::
+    sdfToLevelSet()
 {
     const ValueT outside = mRoot.mBackground;
     // Note that the bottum-up flood filling is essential
-    invoke([&](){this->update(mArray0);}, [&](){this->update(mArray1);}, [&](){this->update(mArray2);});
-    forEach(0, mArray0.size(), 8, [&](const Range1D &r){
-        for (auto i = r.begin(); i != r.end(); ++i) mArray0[i]->signedFloodFill(outside);
+    invoke([&]() { this->update(mArray0); }, [&]() { this->update(mArray1); }, [&]() { this->update(mArray2); });
+    forEach(0, mArray0.size(), 8, [&](const Range1D& r) {
+        for (auto i = r.begin(); i != r.end(); ++i)
+            mArray0[i]->signedFloodFill(outside);
     });
-    forEach(0, mArray1.size(), 1, [&](const Range1D &r){
-        for (auto i = r.begin(); i != r.end(); ++i) mArray1[i]->signedFloodFill(outside);
+    forEach(0, mArray1.size(), 1, [&](const Range1D& r) {
+        for (auto i = r.begin(); i != r.end(); ++i)
+            mArray1[i]->signedFloodFill(outside);
     });
-    forEach(0, mArray2.size(), 1, [&](const Range1D &r){
-        for (auto i = r.begin(); i != r.end(); ++i) mArray2[i]->signedFloodFill(outside);
+    forEach(0, mArray2.size(), 1, [&](const Range1D& r) {
+        for (auto i = r.begin(); i != r.end(); ++i)
+            mArray2[i]->signedFloodFill(outside);
     });
     mRoot.signedFloodFill(outside);
-}// GridBuilder::sdfToLevelSet
+} // GridBuilder::sdfToLevelSet
 
 //================================================================================================
 
-template <typename ValueT, typename ExtremaOp>
-template <typename BufferT>
-GridHandle<BufferT> GridBuilder<ValueT, ExtremaOp>::
-getHandle(double dx,//voxel size
-          const Vec3d &p0,// origin
-          const std::string &name,
-          GridClass gridClass,
-          ChecksumMode mode,
-          const BufferT& buffer)
-{ 
+template<typename ValueT, typename StatsT>
+template<typename BufferT>
+GridHandle<BufferT> GridBuilder<ValueT, StatsT>::
+    getHandle(double             dx, //voxel size
+              const Vec3d&       p0, // origin
+              const std::string& name,
+              GridClass          gridClass,
+              StatsMode          sMode, // mode of comutation for the statistics
+              ChecksumMode       cMode, // mode of comutation for the checksum
+              const BufferT&     buffer)
+{
     if (dx <= 0) {
         throw std::runtime_error("GridBuilder: voxel size is zero or negative");
     }
-    Map map;// affine map
+    Map          map; // affine map
     const double Tx = p0[0], Ty = p0[1], Tz = p0[2];
     const double mat[4][4] = {
-        {dx,  0.0, 0.0, 0.0},// row 0
-        {0.0,  dx, 0.0, 0.0},// row 1
-        {0.0, 0.0,  dx, 0.0},// row 2
-        { Tx,  Ty,  Tz, 1.0},// row 3
+        {dx, 0.0, 0.0, 0.0}, // row 0
+        {0.0, dx, 0.0, 0.0}, // row 1
+        {0.0, 0.0, dx, 0.0}, // row 2
+        {Tx, Ty, Tz, 1.0}, // row 3
     };
     const double invMat[4][4] = {
-        {1/dx, 0.0, 0.0, 0.0},// row 0
-        {0.0, 1/dx, 0.0, 0.0},// row 1
-        {0.0, 0.0, 1/dx, 0.0},// row 2
-        {-Tx, -Ty,  -Tz, 1.0},// row 3
+        {1 / dx, 0.0, 0.0, 0.0}, // row 0
+        {0.0, 1 / dx, 0.0, 0.0}, // row 1
+        {0.0, 0.0, 1 / dx, 0.0}, // row 2
+        {-Tx, -Ty, -Tz, 1.0}, // row 3
     };
     map.set(mat, invMat, 1.0);
-    return this->getHandle(map, name, gridClass, mode, buffer);
-}// GridBuilder::getHandle
+    return this->getHandle(map, name, gridClass, sMode, cMode, buffer);
+} // GridBuilder::getHandle
 
 //================================================================================================
 
-template <typename ValueT, typename ExtremaOp>
-template <typename BufferT>
-GridHandle<BufferT> GridBuilder<ValueT, ExtremaOp>::
-getHandle(const Map &map,
-          const std::string &name,
-          GridClass gridClass,
-          ChecksumMode mode,
-          const BufferT& buffer)
-{ 
+template<typename ValueT, typename StatsT>
+template<typename BufferT>
+GridHandle<BufferT> GridBuilder<ValueT, StatsT>::
+    getHandle(const Map&         map,
+              const std::string& name,
+              GridClass          gridClass,
+              StatsMode          sMode,
+              ChecksumMode       cMode,
+              const BufferT&     buffer)
+{
     if (gridClass == GridClass::LevelSet && !is_floating_point<ValueT>::value)
         throw std::runtime_error("Level sets are expected to be floating point types");
     if (gridClass == GridClass::FogVolume && !is_floating_point<ValueT>::value)
         throw std::runtime_error("Fog volumes are expected to be floating point types");
-    
-    invoke([&](){this->update(mArray0);}, [&](){this->update(mArray1);}, [&](){this->update(mArray2);});
+
+    invoke([&]() { this->update(mArray0); }, [&]() { this->update(mArray1); }, [&]() { this->update(mArray2); });
 
     mBytes[0] = DstGridT::memUsage(); // grid
     mBytes[1] = DstTreeT::memUsage(); // tree
-    mBytes[2] = nanovdb::GridBlindMetaData::memUsage(mBlindDataSize>0 ? 1 : 0); // blind meta data
+    mBytes[2] = nanovdb::GridBlindMetaData::memUsage(mBlindDataSize > 0 ? 1 : 0); // blind meta data
     mBytes[3] = DstRootT::memUsage(uint32_t(mRoot.mTable.size())); // root
     mBytes[4] = mArray2.size() * DstNode2::memUsage(); // upper internal nodes
     mBytes[5] = mArray1.size() * DstNode1::memUsage(); // lower internal nodes
@@ -610,25 +591,34 @@
 
     GridHandle<BufferT> handle(BufferT::create(this->gridSize(), &buffer));
     mData = handle.data();
+    auto *grid = reinterpret_cast<NanoGrid<ValueT>*>(mData);
 
     this->processLeafs();
+
     this->template processNodes<SrcNode1, DstNode1>(mArray1);
+
     this->template processNodes<SrcNode2, DstNode2>(mArray2);
+
     this->processRoot();
+
     this->processTree();
+
     this->processGrid(map, name, gridClass);
-    this->postProcessGrid( mode );
-    
-    return handle; 
-}// GridBuilder::getHandle
+
+    gridStats<ValueT>(*grid, sMode);
+
+    updateChecksum(*grid, cMode);
+
+    return handle;
+} // GridBuilder::getHandle
 
 //================================================================================================
 
-template<typename ValueT, typename ExtremaOp>
+template<typename ValueT, typename StatsT>
 template<typename T, typename FlagT>
 inline typename std::enable_if<std::is_floating_point<T>::value>::type
-GridBuilder<ValueT, ExtremaOp>::
-setFlag(const T& min, const T& max, FlagT& flag) const
+GridBuilder<ValueT, StatsT>::
+    setFlag(const T& min, const T& max, FlagT& flag) const
 {
     if (mDelta > 0 && (min > mDelta || max < -mDelta)) {
         flag |= FlagT(1); // set first bit
@@ -639,34 +629,34 @@
 
 //================================================================================================
 
-template<typename ValueT, typename ExtremaOp>
-inline void GridBuilder<ValueT, ExtremaOp>::
-sdfToFog()
-{
-    this->sdfToLevelSet();// performs signed flood fill
-
-    const ValueT d = -mRoot.mBackground, w = 1.0f/d;
-    auto op = [&](ValueT &v)->bool
-    {
-        if (v>ValueT(0)) {
+template<typename ValueT, typename StatsT>
+inline void GridBuilder<ValueT, StatsT>::
+    sdfToFog()
+{
+    this->sdfToLevelSet(); // performs signed flood fill
+
+    const ValueT d = -mRoot.mBackground, w = 1.0f / d;
+    auto         op = [&](ValueT& v) -> bool {
+        if (v > ValueT(0)) {
             v = ValueT(0);
             return false;
         }
-        v = v>d ? v*w : ValueT(1);
-        return true; 
+        v = v > d ? v * w : ValueT(1);
+        return true;
     };
-    auto kernel0 = [&](const Range1D &r) {
+    auto kernel0 = [&](const Range1D& r) {
         for (auto i = r.begin(); i != r.end(); ++i) {
             SrcNode0* node = mArray0[i];
-            for (uint32_t i=0; i<SrcNode0::SIZE; ++i) node->mValueMask.set(i, op(node->mValues[i]));
+            for (uint32_t i = 0; i < SrcNode0::SIZE; ++i)
+                node->mValueMask.set(i, op(node->mValues[i]));
         }
     };
-    auto kernel1 = [&](const Range1D &r) {
+    auto kernel1 = [&](const Range1D& r) {
         for (auto i = r.begin(); i != r.end(); ++i) {
             SrcNode1* node = mArray1[i];
-            for (uint32_t i=0; i<SrcNode1::SIZE; ++i) {
+            for (uint32_t i = 0; i < SrcNode1::SIZE; ++i) {
                 if (node->mChildMask.isOn(i)) {
-                    SrcNode0 *leaf = node->mTable[i].child;
+                    SrcNode0* leaf = node->mTable[i].child;
                     if (leaf->mValueMask.isOff()) {
                         node->mTable[i].value = leaf->getFirstValue();
                         node->mChildMask.setOff(i);
@@ -678,12 +668,12 @@
             }
         }
     };
-    auto kernel2 = [&](const Range1D &r) {
+    auto kernel2 = [&](const Range1D& r) {
         for (auto i = r.begin(); i != r.end(); ++i) {
             SrcNode2* node = mArray2[i];
-            for (uint32_t i=0; i<SrcNode2::SIZE; ++i) {
+            for (uint32_t i = 0; i < SrcNode2::SIZE; ++i) {
                 if (node->mChildMask.isOn(i)) {
-                    SrcNode1 *child = node->mTable[i].child;
+                    SrcNode1* child = node->mTable[i].child;
                     if (child->mChildMask.isOff() && child->mValueMask.isOff()) {
                         node->mTable[i].value = child->getFirstValue();
                         node->mChildMask.setOff(i);
@@ -700,7 +690,7 @@
     forEach(0, mArray2.size(), 1, kernel2);
 
     for (auto it = mRoot.mTable.begin(); it != mRoot.mTable.end(); ++it) {
-        SrcNode2 *child = it->second.child;
+        SrcNode2* child = it->second.child;
         if (child == nullptr) {
             it->second.state = op(it->second.value);
         } else if (child->mChildMask.isOff() && child->mValueMask.isOff()) {
@@ -710,215 +700,129 @@
             delete child;
         }
     }
-}// GridBuilder::sdfToFog
+} // GridBuilder::sdfToFog
 
 //================================================================================================
 
-template<typename ValueT, typename ExtremaOp>
-void GridBuilder<ValueT, ExtremaOp>::
-processLeafs()
+template<typename ValueT, typename StatsT>
+void GridBuilder<ValueT, StatsT>::
+    processLeafs()
 {
-    mActiveVoxelCount = 0;
-    auto* start = this->template nodeData<DstNode0>(); // address of first leaf node
-    auto kernel = [&](const Range1D &r) {
-        uint64_t sum = 0;
-        auto* data = start + r.begin();
-        for (auto i = r.begin(); i != r.end(); ++i, ++data) {
-            SrcNode0& srcLeaf = *mArray0[i];
+    DstNode0* firstLeaf = this->template node<DstNode0>(); // address of first leaf node
+    auto      kernel = [&](const Range1D& r) {
+        auto* dstLeaf = firstLeaf + r.begin();
+        for (auto i = r.begin(); i != r.end(); ++i, ++dstLeaf) {
+            const SrcNode0& srcLeaf = *mArray0[i];
+            auto*           data = dstLeaf->data();
             assert(size_t(srcLeaf.mID) == i);
-            sum += srcLeaf.mValueMask.countOn();
-            data->mValueMask = srcLeaf.mValueMask;
+            data->mValueMask = srcLeaf.mValueMask; // copy value mask
+            data->mBBoxMin = srcLeaf.mOrigin; // copy origin of node
             const ValueT* src = srcLeaf.mValues;
-            for (ValueT *dst = data->mValues, *n = dst + SrcNode0::SIZE; dst != n; dst += 4, src += 4) {
-                dst[0] = src[0];
+            for (ValueT *dst = data->mValues, *end = dst + SrcNode0::SIZE; dst != end; dst += 4, src += 4) {
+                dst[0] = src[0]; // copy *all* voxel values in sets of four, i.e. loop-unrolling
                 dst[1] = src[1];
                 dst[2] = src[2];
                 dst[3] = src[3];
             }
-            auto iter = srcLeaf.mValueMask.beginOn();
-            if (!iter) throw std::runtime_error("Expected at least one active voxel in every leaf node! Hint: try pruneInactive.");
-            src = srcLeaf.mValues;
-            ExtremaOp extrema( src[*iter] );
-            CoordBBox bbox;// empty
-            bbox.expand(SrcNode0::OffsetToLocalCoord(*iter));// initially use local coord for speed
-            for (++iter; iter; ++iter) {
-                bbox.expand(SrcNode0::OffsetToLocalCoord(*iter));
-                extrema( src[*iter] );
-            }
-            assert(!bbox.empty());
-            srcLeaf.localToGlobalCoord(bbox[0]);
-            srcLeaf.localToGlobalCoord(bbox[1]);
-            data->mBBoxDif[0] = uint8_t(bbox[1][0] - bbox[0][0]);
-            data->mBBoxDif[1] = uint8_t(bbox[1][1] - bbox[0][1]);
-            data->mBBoxDif[2] = uint8_t(bbox[1][2] - bbox[0][2]);
-            data->mBBoxMin = bbox[0];
-            data->mValueMin = extrema.min();
-            data->mValueMax = extrema.max();
-            this->setFlag(data->mValueMin, data->mValueMax, data->mFlags);
         }
-        mActiveVoxelCount += sum;
     };
     forEach(0, mArray0.size(), 8, kernel);
 } // GridBuilder::processLeafs
 
 //================================================================================================
 
-template<typename ValueT, typename ExtremaOp>
+template<typename ValueT, typename StatsT>
 template<typename SrcNodeT, typename DstNodeT>
-void GridBuilder<ValueT, ExtremaOp>::
-processNodes(std::vector<SrcNodeT*>& array)
+void GridBuilder<ValueT, StatsT>::
+    processNodes(std::vector<SrcNodeT*>& array)
 {
-    using SrcChildT = typename SrcNodeT::ChildType;
     auto* start = this->template nodeData<DstNodeT>();
-    auto  kernel = [&](const Range1D &r) 
-    {
+    auto  kernel = [&](const Range1D& r) {
         auto* data = start + r.begin();
-        uint64_t sum = 0;
         for (auto i = r.begin(); i != r.end(); ++i, ++data) {
             SrcNodeT& srcNode = *array[i];
             assert(srcNode.mID == i);
-            sum += SrcChildT::NUM_VALUES * srcNode.mValueMask.countOn();// active tiles
-            data->mValueMask = srcNode.mValueMask;
-            data->mChildMask = srcNode.mChildMask;
+            data->mBBox[0] = srcNode.mOrigin; // copy origin of node
+            data->mValueMask = srcNode.mValueMask; // copy value mask
+            data->mChildMask = srcNode.mChildMask; // copy child mask
             data->mOffset = array.size() - i;
-            auto noneChildMask = srcNode.mChildMask;//copy
-            noneChildMask.toggle();// bits are on for values vs child nodes
+            auto noneChildMask = srcNode.mChildMask; //copy
+            noneChildMask.toggle(); // bits are on for values vs child nodes
             for (auto iter = noneChildMask.beginOn(); iter; ++iter) {
                 data->mTable[*iter].value = srcNode.mTable[*iter].value;
             }
-            auto onValIter = srcNode.mValueMask.beginOn();
-            auto childIter = srcNode.mChildMask.beginOn();
-            ExtremaOp extrema;
-            if (onValIter) {
-                extrema = ExtremaOp(srcNode.mTable[*onValIter].value);
-                const Coord ijk = srcNode.offsetToGlobalCoord(*onValIter);
-                data->mBBox[0] = ijk;
-                data->mBBox[1] = ijk + Coord(int32_t(SrcChildT::DIM) - 1);
-                ++onValIter;
-            } else if (childIter) {
-                data->mTable[*childIter].childID = srcNode.mTable[*childIter].child->mID;
-                auto* dstChild = data->child(*childIter);
-                extrema = ExtremaOp(dstChild->valueMin(), dstChild->valueMax());
-                data->mBBox = dstChild->bbox();
-                ++childIter;
-            } else {
-                throw std::runtime_error("Internal node with no children or active values! Hint: try pruneInactive.");
-            }
-            for (; onValIter; ++onValIter) { // typically there are few active tiles
-                extrema( srcNode.mTable[*onValIter].value );
-                const Coord ijk = srcNode.offsetToGlobalCoord(*onValIter);
-                data->mBBox[0].minComponent(ijk);
-                data->mBBox[1].maxComponent(ijk + Coord(int32_t(SrcChildT::DIM) - 1));
+            for (auto iter = srcNode.mChildMask.beginOn(); iter; ++iter) {
+                data->mTable[*iter].childID = srcNode.mTable[*iter].child->mID;
             }
-            for (; childIter; ++childIter) {
-                data->mTable[*childIter].childID = srcNode.mTable[*childIter].child->mID;
-                auto* dstChild = data->child(*childIter);
-                extrema.min( dstChild->valueMin() );
-                extrema.max( dstChild->valueMax() );
-                const auto& bbox = dstChild->bbox();
-                data->mBBox[0].minComponent(bbox[0]);
-                data->mBBox[1].maxComponent(bbox[1]);
-            }
-            data->mValueMin = extrema.min();
-            data->mValueMax = extrema.max();
-            this->setFlag(data->mValueMin, data->mValueMax, data->mFlags);
         }
-        mActiveVoxelCount += sum;
     };
     forEach(0, array.size(), 4, kernel);
 } // GridBuilder::processNodes
 
 //================================================================================================
 
-template<typename ValueT, typename ExtremaOp>
-void GridBuilder<ValueT, ExtremaOp>::
-processRoot()
+template<typename ValueT, typename StatsT>
+void GridBuilder<ValueT, StatsT>::
+    processRoot()
 {
-    using SrcChildT = SrcNode2;
     auto& data = *(this->template nodeData<DstRootT>());
     data.mBackground = mRoot.mBackground;
     data.mTileCount = uint32_t(mRoot.mTable.size());
+    data.mMinimum = data.mMaximum = data.mBackground;
+    data.mBBox = CoordBBox(); // // set to an empty bounding box
+    data.mActiveVoxelCount = 0;
+
     // since openvdb::RootNode internally uses a std::map for child nodes its iterator
     // visits elements in the stored order required by the nanovdb::RootNode
-    if (data.mTileCount == 0) { // empty root node
-        data.mValueMin = data.mValueMax = data.mBackground;
-        data.mBBox[0] = Coord::max(); // set to an empty bounding box
-        data.mBBox[1] = Coord::min();
-        data.mActiveVoxelCount = 0;
-    } else {
-        ExtremaOp extrema;// invalid
+    if (data.mTileCount > 0) {
         uint32_t tileID = 0;
         for (auto iter = mRoot.mTable.begin(); iter != mRoot.mTable.end(); ++iter, ++tileID) {
             auto& dstTile = data.tile(tileID);
-            if (auto *srcChild = iter->second.child) {
+            if (auto* srcChild = iter->second.child) {
                 dstTile.setChild(srcChild->mOrigin, srcChild->mID);
-                auto& dstChild = data.child(dstTile);
-                if (!extrema) {
-                    extrema = ExtremaOp( dstChild.valueMin(), dstChild.valueMax() );
-                    assert(extrema);
-                    data.mBBox = dstChild.bbox();
-                } else {
-                    extrema.min( dstChild.valueMin() );
-                    extrema.max( dstChild.valueMax() );
-                    data.mBBox[0].minComponent(dstChild.bbox()[0]);
-                    data.mBBox[1].maxComponent(dstChild.bbox()[1]);
-                }
             } else {
                 dstTile.setValue(iter->first, iter->second.state, iter->second.value);
-                if (iter->second.state) {// active tile
-                    mActiveVoxelCount += SrcChildT::NUM_VALUES;
-                    if (!extrema) {
-                        extrema = ExtremaOp(iter->second.value);
-                        assert(extrema);
-                        data.mBBox[0] = iter->first;
-                        data.mBBox[1] = iter->first + Coord(SrcChildT::DIM - 1);
-                    } else {
-                        extrema( dstTile.value );
-                        data.mBBox[0].minComponent(iter->first);
-                        data.mBBox[1].maxComponent(iter->first + Coord(SrcChildT::DIM - 1)); 
-                    }
-                }
             }
         }
-        data.mValueMin = extrema.min();
-        data.mValueMax = extrema.max();
-        data.mActiveVoxelCount = mActiveVoxelCount;
-        if (!extrema) std::cerr << "\nWarning: input tree only contained inactive root tiles! While not strictly an error it's suspecious." << std::endl;
     }
-}// GridBuilder::processRoot
+} // GridBuilder::processRoot
 
 //================================================================================================
 
-template<typename ValueT, typename ExtremaOp>
-void GridBuilder<ValueT, ExtremaOp>::
-processTree()
+template<typename ValueT, typename StatsT>
+void GridBuilder<ValueT, StatsT>::
+    processTree()
 {
     const uint64_t count[4] = {mArray0.size(), mArray1.size(), mArray2.size(), 1};
-    auto& data = *this->treeData(); // data for the tree
+    auto&          data = *this->treeData(); // data for the tree
     for (int i = 0; i < 4; ++i) {
-        if (count[i] > std::numeric_limits<uint32_t>::max()) throw std::runtime_error("Node count exceeds 32 bit range");
+        if (count[i] > std::numeric_limits<uint32_t>::max())
+            throw std::runtime_error("Node count exceeds 32 bit range");
         data.mCount[i] = static_cast<uint32_t>(count[i]);
         data.mBytes[i] = mBytes[5 - i] - mBytes[0]; // offset from the tree to the first node at each tree level
     }
-}// GridBuilder::processTree
+    data.mPFSum[3] = 0;
+    for (int i = 2; i >= 0; --i)
+        data.mPFSum[i] = data.mPFSum[i + 1] + data.mCount[i + 1]; // reverse prefix sum
+} // GridBuilder::processTree
 
 //================================================================================================
 
-template<typename ValueT, typename ExtremaOp>
-void GridBuilder<ValueT, ExtremaOp>::
-processGrid(const Map &map, 
-            const std::string &name, 
-            GridClass gridClass)
+template<typename ValueT, typename StatsT>
+void GridBuilder<ValueT, StatsT>::
+    processGrid(const Map&         map,
+                const std::string& name,
+                GridClass          gridClass)
 {
     auto& data = *this->gridData();
     data.mMagic = NANOVDB_MAGIC_NUMBER;
+    data.mChecksum = 0u;
     data.mMajor = NANOVDB_MAJOR_VERSION_NUMBER;
+    data.mFlags = 0u;
     data.mGridSize = this->gridSize();
-    data.setFlagsOff();
-    data.setBBox(true);
-    data.setMinMax(true);
-    data.mBlindMetadataOffset = mBlindDataSize>0?mBytes[1]:0;
-    data.mBlindMetadataCount = mBlindDataSize>0 ? 1u : 0u;
+    data.mWorldBBox = BBox<Vec3R>();
+    data.mBlindMetadataOffset = mBlindDataSize > 0 ? mBytes[1] : 0;
+    data.mBlindMetadataCount = mBlindDataSize > 0 ? 1u : 0u;
     data.mGridClass = gridClass;
     if (std::is_same<ValueT, float>::value) { // resolved at compiletime
         data.mGridType = GridType::Float;
@@ -945,43 +849,31 @@
         }
         memcpy(data.mGridName, name.c_str(), name.size() + 1);
     }
-    data.mVoxelSize = map.applyMap(Vec3d(1))-map.applyMap(Vec3d(0));
+    data.mVoxelSize = map.applyMap(Vec3d(1)) - map.applyMap(Vec3d(0));
     data.mMap = map;
-    { // set world space AABB
-        const auto& indexBBox = this->template nodeData<DstRootT>()->mBBox;
-        auto &worldBBox = data.mWorldBBox;
-        worldBBox[0] = worldBBox[1] = map.applyMap(Vec3d(indexBBox[0][0], indexBBox[0][1], indexBBox[0][2]));
-        worldBBox.expand(map.applyMap(Vec3d(indexBBox[0][0], indexBBox[0][1], indexBBox[1][2])));
-        worldBBox.expand(map.applyMap(Vec3d(indexBBox[0][0], indexBBox[1][1], indexBBox[0][2])));
-        worldBBox.expand(map.applyMap(Vec3d(indexBBox[1][0], indexBBox[0][1], indexBBox[0][2])));
-        worldBBox.expand(map.applyMap(Vec3d(indexBBox[1][0], indexBBox[1][1], indexBBox[0][2])));
-        worldBBox.expand(map.applyMap(Vec3d(indexBBox[1][0], indexBBox[0][1], indexBBox[1][2])));
-        worldBBox.expand(map.applyMap(Vec3d(indexBBox[0][0], indexBBox[1][1], indexBBox[1][2])));
-        worldBBox.expand(map.applyMap(Vec3d(indexBBox[1][0], indexBBox[1][1], indexBBox[1][2])));
-    }
-}// GridBuilder::processGrid
+} // GridBuilder::processGrid
 
 //================================================================================================
 
-template<typename ValueT, typename ExtremaOp>
-inline void GridBuilder<ValueT, ExtremaOp>::postProcessGrid(ChecksumMode mode)
-{
-    auto& data = *this->gridData();
-    data.mChecksum = checksum( *reinterpret_cast<const NanoGrid<ValueT>*>(mData), mode );
-}
-
-//================================================================================================
-
-template <typename ValueT, typename ExtremaOp>
-template <typename ChildT>
-struct GridBuilder<ValueT, ExtremaOp>::Root
+template<typename ValueT, typename StatsT>
+template<typename ChildT>
+struct GridBuilder<ValueT, StatsT>::Root
 {
     using ValueType = typename ChildT::ValueType;
     using ChildType = ChildT;
     static constexpr uint32_t LEVEL = 1 + ChildT::LEVEL; // level 0 = leaf
-    struct Tile {
-        Tile(ChildT* c = nullptr) : child(c) {}
-        Tile(const ValueT& v, bool s) : child(nullptr), value(v), state(s) {}
+    struct Tile
+    {
+        Tile(ChildT* c = nullptr)
+            : child(c)
+        {
+        }
+        Tile(const ValueT& v, bool s)
+            : child(nullptr)
+            , value(v)
+            , state(s)
+        {
+        }
         ChildT* child;
         ValueT  value;
         bool    state;
@@ -990,29 +882,34 @@
     MapT   mTable;
     ValueT mBackground;
 
-    Root(const ValueT& background) : mBackground(background) {}
-    Root(const Root&) = delete;// disallow copy-construction
-    Root(Root&&) = default;// allow move construction
-    Root& operator=(const Root&) = delete;// disallow copy assignment
-    Root& operator=(Root&&) = default;// allow move assignment
+    Root(const ValueT& background)
+        : mBackground(background)
+    {
+    }
+    Root(const Root&) = delete; // disallow copy-construction
+    Root(Root&&) = default; // allow move construction
+    Root& operator=(const Root&) = delete; // disallow copy assignment
+    Root& operator=(Root&&) = default; // allow move assignment
 
     ~Root() { this->clear(); }
 
-    bool empty() const {return mTable.empty();}
+    bool empty() const { return mTable.empty(); }
 
-    void clear() 
+    void clear()
     {
-        for (auto iter = mTable.begin(); iter != mTable.end(); ++iter) delete iter->second.child;
-        mTable.clear();   
+        for (auto iter = mTable.begin(); iter != mTable.end(); ++iter)
+            delete iter->second.child;
+        mTable.clear();
     }
 
     static Coord CoordToKey(const Coord& ijk) { return ijk & ~ChildT::MASK; }
 
-    template <typename AccT>
+    template<typename AccT>
     bool isActiveAndCache(const Coord& ijk, AccT& acc) const
     {
         auto iter = mTable.find(CoordToKey(ijk));
-        if (iter == mTable.end()) return false;
+        if (iter == mTable.end())
+            return false;
         if (iter->second.child) {
             acc.insert(ijk, iter->second.child);
             return iter->second.child->isActiveAndCache(ijk, acc);
@@ -1032,11 +929,12 @@
         }
     }
 
-    template <typename AccT>
+    template<typename AccT>
     const ValueT& getValueAndCache(const Coord& ijk, AccT& acc) const
     {
         auto iter = mTable.find(CoordToKey(ijk));
-        if (iter == mTable.end()) return mBackground;
+        if (iter == mTable.end())
+            return mBackground;
         if (iter->second.child) {
             acc.insert(ijk, iter->second.child);
             return iter->second.child->getValueAndCache(ijk, acc);
@@ -1044,12 +942,12 @@
         return iter->second.value;
     }
 
-    template <typename AccT>
+    template<typename AccT>
     void setValueAndCache(const Coord& ijk, const ValueT& value, AccT& acc)
     {
-        ChildT* child = nullptr;
+        ChildT*     child = nullptr;
         const Coord key = CoordToKey(ijk);
-        auto iter = mTable.find(key);
+        auto        iter = mTable.find(key);
         if (iter == mTable.end()) {
             child = new ChildT(ijk, mBackground, false);
             mTable[key] = Tile(child);
@@ -1065,15 +963,16 @@
         }
     }
 
-    template <typename NodeT>
+    template<typename NodeT>
     uint32_t nodeCount() const
     {
         static_assert(is_same<ValueT, typename NodeT::ValueType>::value, "Root::getNodes: Invalid type");
         static_assert(NodeT::LEVEL < LEVEL, "Root::getNodes: LEVEL error");
         uint32_t sum = 0;
         for (auto iter = mTable.begin(); iter != mTable.end(); ++iter) {
-            if (iter->second.child == nullptr) continue;// skip tiles
-            if (is_same<NodeT,ChildT>::value) {//resolved at compile-time
+            if (iter->second.child == nullptr)
+                continue; // skip tiles
+            if (is_same<NodeT, ChildT>::value) { //resolved at compile-time
                 ++sum;
             } else {
                 sum += iter->second.child->template nodeCount<NodeT>();
@@ -1082,14 +981,15 @@
         return sum;
     }
 
-    template <typename NodeT>
-    void getNodes(std::vector<NodeT*> &array)
+    template<typename NodeT>
+    void getNodes(std::vector<NodeT*>& array)
     {
         static_assert(is_same<ValueT, typename NodeT::ValueType>::value, "Root::getNodes: Invalid type");
         static_assert(NodeT::LEVEL < LEVEL, "Root::getNodes: LEVEL error");
         for (auto iter = mTable.begin(); iter != mTable.end(); ++iter) {
-            if (iter->second.child == nullptr) continue;
-            if (is_same<NodeT,ChildT>::value) {//resolved at compile-time
+            if (iter->second.child == nullptr)
+                continue;
+            if (is_same<NodeT, ChildT>::value) { //resolved at compile-time
                 iter->second.child->mID = static_cast<uint32_t>(array.size());
                 array.push_back(reinterpret_cast<NodeT*>(iter->second.child));
             } else {
@@ -1102,8 +1002,8 @@
     {
         assert(child);
         const Coord key = CoordToKey(child->mOrigin);
-        auto iter = mTable.find(key);
-        if (iter != mTable.end() && iter->second.child != nullptr) {// existing child node
+        auto        iter = mTable.find(key);
+        if (iter != mTable.end() && iter->second.child != nullptr) { // existing child node
             delete iter->second.child;
             iter->second.child = child;
         } else {
@@ -1112,15 +1012,15 @@
         child = nullptr;
     }
 
-    template <typename NodeT>
+    template<typename NodeT>
     void addNode(NodeT*& node)
     {
-        if (is_same<NodeT, ChildT>::value) {//resolved at compile-time
+        if (is_same<NodeT, ChildT>::value) { //resolved at compile-time
             this->addChild(reinterpret_cast<ChildT*&>(node));
         } else {
-            ChildT* child = nullptr;
+            ChildT*     child = nullptr;
             const Coord key = CoordToKey(node->mOrigin);
-            auto iter = mTable.find(key);
+            auto        iter = mTable.find(key);
             if (iter == mTable.end()) {
                 child = new ChildT(node->mOrigin, mBackground, false);
                 mTable[key] = Tile(child);
@@ -1134,53 +1034,56 @@
         }
     }
 
-    template <typename T>
+    template<typename T>
     typename std::enable_if<std::is_floating_point<T>::value>::type
     signedFloodFill(T outside);
-    template <typename T>
+    template<typename T>
     typename std::enable_if<!std::is_floating_point<T>::value>::type
-    signedFloodFill(T) {}// no-op for none floating point values
-};// GridBuilder::Root
+        signedFloodFill(T) {} // no-op for none floating point values
+}; // GridBuilder::Root
 
 //================================================================================================
 
-template <typename ValueT, typename ExtremaOp>
-template <typename ChildT>
-template <typename T>
+template<typename ValueT, typename StatsT>
+template<typename ChildT>
+template<typename T>
 inline typename std::enable_if<std::is_floating_point<T>::value>::type
-GridBuilder<ValueT, ExtremaOp>::Root<ChildT>::
-signedFloodFill(T outside)
+GridBuilder<ValueT, StatsT>::Root<ChildT>::
+    signedFloodFill(T outside)
 {
     std::map<Coord, ChildT*> nodeKeys;
     for (auto iter = mTable.begin(); iter != mTable.end(); ++iter) {
-        if (iter->second.child == nullptr) continue;
+        if (iter->second.child == nullptr)
+            continue;
         nodeKeys.insert(std::pair<Coord, ChildT*>(iter->first, iter->second.child));
     }
 
     // We employ a simple z-scanline algorithm that inserts inactive tiles with
     // the inside value if they are sandwiched between inside child nodes only!
     auto b = nodeKeys.begin(), e = nodeKeys.end();
-    if ( b == e ) return;
-    //const ValueT inside = -mRoot.mBackground;
+    if (b == e)
+        return;
     for (auto a = b++; b != e; ++a, ++b) {
         Coord d = b->first - a->first; // delta of neighboring coordinates
-        if (d[0]!=0 || d[1]!=0 || d[2]==int(ChildT::DIM)) continue;// not same z-scanline or neighbors
-        const ValueT fill[] = { a->second->getLastValue(), b->second->getFirstValue() };
-        if (!(fill[0] < 0) || !(fill[1] < 0)) continue; // scanline isn't inside
+        if (d[0] != 0 || d[1] != 0 || d[2] == int(ChildT::DIM))
+            continue; // not same z-scanline or neighbors
+        const ValueT fill[] = {a->second->getLastValue(), b->second->getFirstValue()};
+        if (!(fill[0] < 0) || !(fill[1] < 0))
+            continue; // scanline isn't inside
         Coord c = a->first + Coord(0u, 0u, ChildT::DIM);
         for (; c[2] != b->first[2]; c[2] += ChildT::DIM) {
             const Coord key = SrcRootT::CoordToKey(c);
-            mTable[key] = typename SrcRootT::Tile(-outside, false);// inactive tile
+            mTable[key] = typename SrcRootT::Tile(-outside, false); // inactive tile
         }
     }
-}// Root::signedFloodFill
+} // Root::signedFloodFill
 
 //================================================================================================
 
-template <typename ValueT, typename ExtremaOp>
-template <typename ChildT>
-struct GridBuilder<ValueT, ExtremaOp>::
-Node
+template<typename ValueT, typename StatsT>
+template<typename ChildT>
+struct GridBuilder<ValueT, StatsT>::
+    Node
 {
     using ValueType = typename ChildT::ValueType;
     using ChildType = ChildT;
@@ -1188,56 +1091,71 @@
     static constexpr uint32_t TOTAL = LOG2DIM + ChildT::TOTAL; //dimension in index space
     static constexpr uint32_t DIM = 1u << TOTAL;
     static constexpr uint32_t SIZE = 1u << (3 * LOG2DIM); //number of tile values (or child pointers)
-    static constexpr uint32_t MASK = DIM - 1u;
+    static constexpr int32_t  MASK = DIM - 1;
     static constexpr uint32_t LEVEL = 1 + ChildT::LEVEL; // level 0 = leaf
-    static constexpr uint64_t NUM_VALUES = uint64_t(1) << (3 * TOTAL);// total voxel count represented by this node
+    static constexpr uint64_t NUM_VALUES = uint64_t(1) << (3 * TOTAL); // total voxel count represented by this node
     using MaskT = Mask<LOG2DIM>;
 
-    struct Tile {
-        Tile(ChildT* c = nullptr) : child(c) {}
-        union { ChildT* child; ValueT value; };
+    struct Tile
+    {
+        Tile(ChildT* c = nullptr)
+            : child(c)
+        {
+        }
+        union
+        {
+            ChildT* child;
+            ValueT  value;
+        };
     };
-    Coord mOrigin;
-    MaskT mValueMask;
-    MaskT mChildMask;
-    Tile  mTable[SIZE];
+    Coord    mOrigin;
+    MaskT    mValueMask;
+    MaskT    mChildMask;
+    Tile     mTable[SIZE];
     uint32_t mID;
 
     Node(const Coord& origin, const ValueT& value, bool state)
-        : mOrigin(origin & ~MASK), mValueMask(state), mChildMask()
+        : mOrigin(origin & ~MASK)
+        , mValueMask(state)
+        , mChildMask()
+    {
+        for (uint32_t i = 0; i < SIZE; ++i)
+            mTable[i].value = value;
+    }
+    Node(const Node&) = delete; // disallow copy-construction
+    Node(Node&&) = delete; // disallow move construction
+    Node& operator=(const Node&) = delete; // disallow copy assignment
+    Node& operator=(Node&&) = delete; // disallow move assignment
+    ~Node()
     {
-        for (uint32_t i = 0; i < SIZE; ++i) mTable[i].value = value;
+        for (auto iter = mChildMask.beginOn(); iter; ++iter)
+            delete mTable[*iter].child;
     }
-    Node(const Node&) = delete;// disallow copy-construction
-    Node(Node&&) = delete;// disallow move construction
-    Node& operator=(const Node&) = delete;// disallow copy assignment
-    Node& operator=(Node&&) = delete;// disallow move assignment
-    ~Node() {for (auto iter = mChildMask.beginOn(); iter; ++iter) delete mTable[*iter].child;}
 
     static uint32_t CoordToOffset(const Coord& ijk)
     {
         return (((ijk[0] & MASK) >> ChildT::TOTAL) << (2 * LOG2DIM)) +
                (((ijk[1] & MASK) >> ChildT::TOTAL) << (LOG2DIM)) +
-               (( ijk[2] & MASK) >> ChildT::TOTAL);
+               ((ijk[2] & MASK) >> ChildT::TOTAL);
     }
 
     static Coord OffsetToLocalCoord(uint32_t n)
     {
         assert(n < SIZE);
-        const uint32_t m = n & ((1<<2*LOG2DIM)-1);
-        return Coord(n >> 2*LOG2DIM, m >> LOG2DIM, m & ((1<<LOG2DIM)-1));
+        const uint32_t m = n & ((1 << 2 * LOG2DIM) - 1);
+        return Coord(n >> 2 * LOG2DIM, m >> LOG2DIM, m & ((1 << LOG2DIM) - 1));
     }
 
-    void localToGlobalCoord(Coord &ijk) const
+    void localToGlobalCoord(Coord& ijk) const
     {
         ijk <<= ChildT::TOTAL;
-        ijk  += mOrigin;
+        ijk += mOrigin;
     }
 
     Coord offsetToGlobalCoord(uint32_t n) const
     {
         Coord ijk = Node::OffsetToLocalCoord(n);
-        this->localToGlobalCoord(ijk); 
+        this->localToGlobalCoord(ijk);
         return ijk;
     }
 
@@ -1252,8 +1170,8 @@
         return mValueMask.isOn(n);
     }
 
-    ValueT getFirstValue() const {return mChildMask.isOn(0) ? mTable[0].child->getFirstValue() : mTable[0].value;}
-    ValueT getLastValue() const {return mChildMask.isOn(SIZE-1) ? mTable[SIZE-1].child->getLastValue() : mTable[SIZE-1].value;}
+    ValueT getFirstValue() const { return mChildMask.isOn(0) ? mTable[0].child->getFirstValue() : mTable[0].value; }
+    ValueT getLastValue() const { return mChildMask.isOn(SIZE - 1) ? mTable[SIZE - 1].child->getLastValue() : mTable[SIZE - 1].value; }
 
     const ValueT& getValue(const Coord& ijk) const
     {
@@ -1278,7 +1196,7 @@
     void setValue(const Coord& ijk, const ValueT& value)
     {
         const uint32_t n = CoordToOffset(ijk);
-        ChildT* child = nullptr;
+        ChildT*        child = nullptr;
         if (mChildMask.isOn(n)) {
             child = mTable[n].child;
         } else {
@@ -1293,7 +1211,7 @@
     void setValueAndCache(const Coord& ijk, const ValueT& value, AccT& acc)
     {
         const uint32_t n = CoordToOffset(ijk);
-        ChildT* child = nullptr;
+        ChildT*        child = nullptr;
         if (mChildMask.isOn(n)) {
             child = mTable[n].child;
         } else {
@@ -1305,13 +1223,13 @@
         child->setValueAndCache(ijk, value, acc);
     }
 
-    template <typename NodeT>
+    template<typename NodeT>
     uint32_t nodeCount() const
     {
         static_assert(is_same<ValueT, typename NodeT::ValueType>::value, "Node::getNodes: Invalid type");
         assert(NodeT::LEVEL < LEVEL);
         uint32_t sum = 0;
-        if (is_same<NodeT,ChildT>::value) {//resolved at compile-time
+        if (is_same<NodeT, ChildT>::value) { //resolved at compile-time
             sum += mChildMask.countOn();
         } else {
             for (auto iter = mChildMask.beginOn(); iter; ++iter) {
@@ -1321,13 +1239,13 @@
         return sum;
     }
 
-    template <typename NodeT>
-    void getNodes(std::vector<NodeT*> &array)
+    template<typename NodeT>
+    void getNodes(std::vector<NodeT*>& array)
     {
         static_assert(is_same<ValueT, typename NodeT::ValueType>::value, "Node::getNodes: Invalid type");
         assert(NodeT::LEVEL < LEVEL);
         for (auto iter = mChildMask.beginOn(); iter; ++iter) {
-            if (is_same<NodeT,ChildT>::value) {//resolved at compile-time
+            if (is_same<NodeT, ChildT>::value) { //resolved at compile-time
                 mTable[*iter].child->mID = static_cast<uint32_t>(array.size());
                 array.push_back(reinterpret_cast<NodeT*>(mTable[*iter].child));
             } else {
@@ -1349,14 +1267,14 @@
         child = nullptr;
     }
 
-    template <typename NodeT>
+    template<typename NodeT>
     void addNode(NodeT*& node)
     {
-        if (is_same<NodeT, ChildT>::value) {//resolved at compile-time
+        if (is_same<NodeT, ChildT>::value) { //resolved at compile-time
             this->addChild(reinterpret_cast<ChildT*&>(node));
         } else {
             const uint32_t n = CoordToOffset(node->mOrigin);
-            ChildT* child = nullptr;
+            ChildT*        child = nullptr;
             if (mChildMask.isOn(n)) {
                 child = mTable[n].child;
             } else {
@@ -1368,39 +1286,41 @@
         }
     }
 
-    template <typename T>
+    template<typename T>
     typename std::enable_if<std::is_floating_point<T>::value>::type
     signedFloodFill(T outside);
-    template <typename T>
+    template<typename T>
     typename std::enable_if<!std::is_floating_point<T>::value>::type
-    signedFloodFill(T) {}// no-op for none floating point values
-};// GridBuilder::Node
+        signedFloodFill(T) {} // no-op for none floating point values
+}; // GridBuilder::Node
 
 //================================================================================================
 
-template<typename ValueT, typename ExtremaOp>
+template<typename ValueT, typename StatsT>
 template<typename ChildT>
 template<typename T>
 inline typename std::enable_if<std::is_floating_point<T>::value>::type
-GridBuilder<ValueT, ExtremaOp>::Node<ChildT>::
-signedFloodFill(T outside)
+GridBuilder<ValueT, StatsT>::Node<ChildT>::
+    signedFloodFill(T outside)
 {
     const uint32_t first = *mChildMask.beginOn();
     if (first < NUM_VALUES) {
-        bool xInside = mTable[first].child->getFirstValue()<0;
+        bool xInside = mTable[first].child->getFirstValue() < 0;
         bool yInside = xInside, zInside = xInside;
         for (uint32_t x = 0; x != (1 << LOG2DIM); ++x) {
             const uint32_t x00 = x << (2 * LOG2DIM); // offset for block(x, 0, 0)
-            if (mChildMask.isOn(x00)) xInside = mTable[x00].child->getLastValue()<0;
+            if (mChildMask.isOn(x00))
+                xInside = mTable[x00].child->getLastValue() < 0;
             yInside = xInside;
             for (uint32_t y = 0; y != (1u << LOG2DIM); ++y) {
                 const uint32_t xy0 = x00 + (y << LOG2DIM); // offset for block(x, y, 0)
-                if (mChildMask.isOn(xy0)) yInside = mTable[xy0].child->getLastValue()<0;
+                if (mChildMask.isOn(xy0))
+                    yInside = mTable[xy0].child->getLastValue() < 0;
                 zInside = yInside;
                 for (uint32_t z = 0; z != (1 << LOG2DIM); ++z) {
                     const uint32_t xyz = xy0 + z; // offset for block(x, y, z)
                     if (mChildMask.isOn(xyz)) {
-                        zInside = mTable[xyz].child->getLastValue()<0;
+                        zInside = mTable[xyz].child->getLastValue() < 0;
                     } else {
                         mTable[xyz].value = zInside ? -outside : outside;
                     }
@@ -1408,38 +1328,41 @@
             }
         }
     }
-}// Node::signedFloodFill
+} // Node::signedFloodFill
 
 //================================================================================================
 
-template <typename ValueT, typename ExtremaOp>
-struct GridBuilder<ValueT, ExtremaOp>::
-Leaf
+template<typename ValueT, typename StatsT>
+struct GridBuilder<ValueT, StatsT>::
+    Leaf
 {
     using ValueType = ValueT;
     static constexpr uint32_t LOG2DIM = 3;
     static constexpr uint32_t TOTAL = LOG2DIM; // needed by parent nodes
     static constexpr uint32_t DIM = 1u << TOTAL;
     static constexpr uint32_t SIZE = 1u << 3 * LOG2DIM; // total number of voxels represented by this node
-    static constexpr uint32_t MASK = DIM - 1u; // mask for bit operations
+    static constexpr int32_t  MASK = DIM - 1; // mask for bit operations
     static constexpr uint32_t LEVEL = 0; // level 0 = leaf
-    static constexpr uint64_t NUM_VALUES = uint64_t(1) << (3 * TOTAL);// total voxel count represented by this node
+    static constexpr uint64_t NUM_VALUES = uint64_t(1) << (3 * TOTAL); // total voxel count represented by this node
     using NodeMaskType = Mask<LOG2DIM>;
-    Coord mOrigin;
-    Mask<LOG2DIM>  mValueMask;
-    ValueT mValues[SIZE];
-    uint32_t mID;
-
-    Leaf(const Coord& ijk, const ValueT& value, bool state) : mOrigin(ijk & ~MASK), mValueMask(state)//invalid
-    {
-      ValueT* target = mValues;
-      uint32_t n = SIZE;
-      while (n--) *target++ = value;
-    }
-    Leaf(const Leaf&) = delete;// disallow copy-construction
-    Leaf(Leaf&&) = delete;// disallow move construction
-    Leaf& operator=(const Leaf&) = delete;// disallow copy assignment
-    Leaf& operator=(Leaf&&) = delete;// disallow move assignment
+    Coord         mOrigin;
+    Mask<LOG2DIM> mValueMask;
+    ValueT        mValues[SIZE];
+    uint32_t      mID;
+
+    Leaf(const Coord& ijk, const ValueT& value, bool state)
+        : mOrigin(ijk & ~MASK)
+        , mValueMask(state) //invalid
+    {
+        ValueT*  target = mValues;
+        uint32_t n = SIZE;
+        while (n--)
+            *target++ = value;
+    }
+    Leaf(const Leaf&) = delete; // disallow copy-construction
+    Leaf(Leaf&&) = delete; // disallow move construction
+    Leaf& operator=(const Leaf&) = delete; // disallow copy assignment
+    Leaf& operator=(Leaf&&) = delete; // disallow move assignment
     ~Leaf() = default;
 
     /// @brief Return the linear offset corresponding to the given coordinate
@@ -1451,11 +1374,11 @@
     static Coord OffsetToLocalCoord(uint32_t n)
     {
         assert(n < SIZE);
-        const uint32_t m = n & ((1<<2*LOG2DIM)-1);
-        return Coord(n >> 2*LOG2DIM, m >> LOG2DIM, m & MASK);
+        const int32_t m = n & ((1 << 2 * LOG2DIM) - 1);
+        return Coord(n >> 2 * LOG2DIM, m >> LOG2DIM, m & MASK);
     }
 
-    void localToGlobalCoord(Coord &ijk) const
+    void localToGlobalCoord(Coord& ijk) const
     {
         ijk += mOrigin;
     }
@@ -1470,11 +1393,11 @@
     template<typename AccT>
     bool isActiveAndCache(const Coord& ijk, const AccT&) const
     {
-      return mValueMask.isOn(CoordToOffset(ijk));
+        return mValueMask.isOn(CoordToOffset(ijk));
     }
 
-    ValueT getFirstValue() const {return mValues[0];}
-    ValueT getLastValue() const {return mValues[SIZE-1];}
+    ValueT getFirstValue() const { return mValues[0]; }
+    ValueT getLastValue() const { return mValues[SIZE - 1]; }
 
     const ValueT& getValue(const Coord& ijk) const
     {
@@ -1489,54 +1412,60 @@
 
     template<typename AccT>
     void setValueAndCache(const Coord& ijk, const ValueT& value, const AccT&)
-    {   
+    {
         const uint32_t n = CoordToOffset(ijk);
         mValueMask.setOn(n);
         mValues[n] = value;
     }
 
     void setValue(const Coord& ijk, const ValueT& value)
-    {   
+    {
         const uint32_t n = CoordToOffset(ijk);
         mValueMask.setOn(n);
         mValues[n] = value;
     }
 
-    template <typename NodeT>
+    template<typename NodeT>
     void getNodes(std::vector<NodeT*>&) { assert(false); }
 
-    template <typename NodeT>
+    template<typename NodeT>
     void addNode(NodeT*&) {}
 
-    template <typename NodeT>
-    uint32_t nodeCount() const { assert(false); return 1;}
+    template<typename NodeT>
+    uint32_t nodeCount() const
+    {
+        assert(false);
+        return 1;
+    }
 
-    template <typename T>
+    template<typename T>
     typename std::enable_if<std::is_floating_point<T>::value>::type
     signedFloodFill(T outside);
-    template <typename T>
+    template<typename T>
     typename std::enable_if<!std::is_floating_point<T>::value>::type
-    signedFloodFill(T) {}// no-op for none floating point values
-};// Leaf
+        signedFloodFill(T) {} // no-op for none floating point values
+}; // Leaf
 
 //================================================================================================
 
-template<typename ValueT, typename ExtremaOp>
+template<typename ValueT, typename StatsT>
 template<typename T>
 inline typename std::enable_if<std::is_floating_point<T>::value>::type
-GridBuilder<ValueT, ExtremaOp>::Leaf::
-signedFloodFill(T outside)
+GridBuilder<ValueT, StatsT>::Leaf::
+    signedFloodFill(T outside)
 {
     const uint32_t first = *mValueMask.beginOn();
     if (first < SIZE) {
-        bool xInside = mValues[first]<0, yInside = xInside, zInside = xInside;
+        bool xInside = mValues[first] < 0, yInside = xInside, zInside = xInside;
         for (uint32_t x = 0; x != DIM; ++x) {
             const uint32_t x00 = x << (2 * LOG2DIM);
-            if (mValueMask.isOn(x00)) xInside = mValues[x00] < 0; // element(x, 0, 0)
+            if (mValueMask.isOn(x00))
+                xInside = mValues[x00] < 0; // element(x, 0, 0)
             yInside = xInside;
             for (uint32_t y = 0; y != DIM; ++y) {
                 const uint32_t xy0 = x00 + (y << LOG2DIM);
-                if (mValueMask.isOn(xy0)) yInside = mValues[xy0] < 0; // element(x, y, 0)
+                if (mValueMask.isOn(xy0))
+                    yInside = mValues[xy0] < 0; // element(x, y, 0)
                 zInside = yInside;
                 for (uint32_t z = 0; z != (1 << LOG2DIM); ++z) {
                     const uint32_t xyz = xy0 + z; // element(x, y, z)
@@ -1549,65 +1478,66 @@
             }
         }
     }
-}// Leaf::signedFloodFill
+} // Leaf::signedFloodFill
 
 //================================================================================================
-template <typename ValueT, typename ExtremaOp>
-struct GridBuilder<ValueT, ExtremaOp>::
-ValueAccessor
+template<typename ValueT, typename StatsT>
+struct GridBuilder<ValueT, StatsT>::
+    ValueAccessor
 {
-    ValueAccessor(SrcRootT& root) : mKeys{Coord(Maximum<int>::value()),Coord(Maximum<int>::value()), Coord(Maximum<int>::value())}
-                                  , mNode{nullptr, nullptr, nullptr, &root}
+    ValueAccessor(SrcRootT& root)
+        : mKeys{Coord(Maximum<int>::value()), Coord(Maximum<int>::value()), Coord(Maximum<int>::value())}
+        , mNode{nullptr, nullptr, nullptr, &root}
     {
     }
     template<typename NodeT>
     bool isCached(const Coord& ijk) const
     {
-        return (ijk[0] & int32_t(~NodeT::MASK)) == mKeys[NodeT::LEVEL][0] && 
-               (ijk[1] & int32_t(~NodeT::MASK)) == mKeys[NodeT::LEVEL][1] && 
-               (ijk[2] & int32_t(~NodeT::MASK)) == mKeys[NodeT::LEVEL][2];
+        return (ijk[0] & ~NodeT::MASK) == mKeys[NodeT::LEVEL][0] &&
+               (ijk[1] & ~NodeT::MASK) == mKeys[NodeT::LEVEL][1] &&
+               (ijk[2] & ~NodeT::MASK) == mKeys[NodeT::LEVEL][2];
     }
     bool isActive(const Coord& ijk)
     {
-      if (this->isCached<SrcNode0>(ijk)) {
-          return ((SrcNode0*)mNode[0])->isActiveAndCache(ijk, *this);
-      } else if (this->isCached<SrcNode1>(ijk)) {
-          return ((SrcNode1*)mNode[1])->isActiveAndCache(ijk, *this);
-      } else if (this->isCached<SrcNode2>(ijk)) {
-          return ((SrcNode2*)mNode[2])->isActiveAndCache(ijk, *this);
-      }
-      return ((SrcRootT*)mNode[3])->isActiveAndCache(ijk, *this);
+        if (this->isCached<SrcNode0>(ijk)) {
+            return ((SrcNode0*)mNode[0])->isActiveAndCache(ijk, *this);
+        } else if (this->isCached<SrcNode1>(ijk)) {
+            return ((SrcNode1*)mNode[1])->isActiveAndCache(ijk, *this);
+        } else if (this->isCached<SrcNode2>(ijk)) {
+            return ((SrcNode2*)mNode[2])->isActiveAndCache(ijk, *this);
+        }
+        return ((SrcRootT*)mNode[3])->isActiveAndCache(ijk, *this);
     }
     const ValueT& getValue(const Coord& ijk)
     {
-      if (this->isCached<SrcNode0>(ijk)) {
-          return ((SrcNode0*)mNode[0])->getValueAndCache(ijk, *this);
-      } else if (this->isCached<SrcNode1>(ijk)) {
-          return ((SrcNode1*)mNode[1])->getValueAndCache(ijk, *this);
-      } else if (this->isCached<SrcNode2>(ijk)) {
-          return ((SrcNode2*)mNode[2])->getValueAndCache(ijk, *this);
-      }
-      return ((SrcRootT*)mNode[3])->getValueAndCache(ijk, *this);
+        if (this->isCached<SrcNode0>(ijk)) {
+            return ((SrcNode0*)mNode[0])->getValueAndCache(ijk, *this);
+        } else if (this->isCached<SrcNode1>(ijk)) {
+            return ((SrcNode1*)mNode[1])->getValueAndCache(ijk, *this);
+        } else if (this->isCached<SrcNode2>(ijk)) {
+            return ((SrcNode2*)mNode[2])->getValueAndCache(ijk, *this);
+        }
+        return ((SrcRootT*)mNode[3])->getValueAndCache(ijk, *this);
     }
     /// @brief Sets value in a leaf node and returns it.
     SrcNode0* setValue(const Coord& ijk, const ValueT& value)
     {
         if (this->isCached<SrcNode0>(ijk)) {
-           ((SrcNode0*)mNode[0])->setValueAndCache(ijk, value, *this);
+            ((SrcNode0*)mNode[0])->setValueAndCache(ijk, value, *this);
         } else if (this->isCached<SrcNode1>(ijk)) {
-           ((SrcNode1*)mNode[1])->setValueAndCache(ijk, value, *this);
+            ((SrcNode1*)mNode[1])->setValueAndCache(ijk, value, *this);
         } else if (this->isCached<SrcNode2>(ijk)) {
-           ((SrcNode2*)mNode[2])->setValueAndCache(ijk, value, *this);
+            ((SrcNode2*)mNode[2])->setValueAndCache(ijk, value, *this);
         } else {
-           ((SrcRootT*)mNode[3])->setValueAndCache(ijk, value, *this);
+            ((SrcRootT*)mNode[3])->setValueAndCache(ijk, value, *this);
         }
         assert(this->isCached<SrcNode0>(ijk));
         return (SrcNode0*)mNode[0];
     }
-    template <typename NodeT>
+    template<typename NodeT>
     void insert(const Coord& ijk, NodeT* node)
     {
-        mKeys[NodeT::LEVEL] = ijk & int(~NodeT::MASK);
+        mKeys[NodeT::LEVEL] = ijk & ~NodeT::MASK;
         mNode[NodeT::LEVEL] = node;
     }
     Coord mKeys[3];
@@ -1623,40 +1553,44 @@
 /// @brief Note, this is not (yet) a valid level set SDF field since values inside sphere (and outside
 ///        the narrow band) are still undefined. Call GridBuilder::sdfToLevelSet() to set those
 ///        values or alternatively call GridBuilder::sdfToFog to generate a FOG volume.
-template <typename ValueT>
+template<typename ValueT>
 std::shared_ptr<GridBuilder<ValueT>>
-initSphere(ValueT radius,// radius of sphere in world units 
-           const Vec3d& center,//center of sphere in world units
-           ValueT voxelSize,// size of a voxel in world units
-           ValueT halfWidth,// half-width of narrow band in voxel units 
-           const Vec3d &origin)// origin of grid in world units
-{
-    static_assert(is_floating_point<ValueT>::value,"Sphere: expect floating point");
-    if (!(radius > 0)) throw std::runtime_error("Sphere: radius must be positive!");
-    if (!(voxelSize > 0)) throw std::runtime_error("Sphere: voxelSize must be positive!");
-    if (!(halfWidth > 0)) throw std::runtime_error("Sphere: halfWidth must be positive!");
+initSphere(ValueT       radius, // radius of sphere in world units
+           const Vec3d& center, //center of sphere in world units
+           ValueT       voxelSize, // size of a voxel in world units
+           ValueT       halfWidth, // half-width of narrow band in voxel units
+           const Vec3d& origin) // origin of grid in world units
+{
+    static_assert(is_floating_point<ValueT>::value, "Sphere: expect floating point");
+    if (!(radius > 0))
+        throw std::runtime_error("Sphere: radius must be positive!");
+    if (!(voxelSize > 0))
+        throw std::runtime_error("Sphere: voxelSize must be positive!");
+    if (!(halfWidth > 0))
+        throw std::runtime_error("Sphere: halfWidth must be positive!");
 
-    auto builder = std::make_shared<GridBuilder<ValueT>>(halfWidth*voxelSize);
+    auto builder = std::make_shared<GridBuilder<ValueT>>(halfWidth * voxelSize);
     auto acc = builder->getAccessor();
 
     // Define radius of sphere and narrow-band in voxel units
-    const ValueT r0 = radius/voxelSize, rmax = r0 + halfWidth;
+    const ValueT r0 = radius / voxelSize, rmax = r0 + halfWidth;
 
     // Radius below the Nyquist frequency
-    if (r0 < ValueT(1.5)) return builder;
+    if (r0 < ValueT(1.5))
+        return builder;
 
     // Define center of sphere in voxel units
-    const Vec3<ValueT> c(ValueT(center[0]-origin[0])/voxelSize,
-                         ValueT(center[1]-origin[1])/voxelSize,
-                         ValueT(center[2]-origin[2])/voxelSize);
+    const Vec3<ValueT> c(ValueT(center[0] - origin[0]) / voxelSize,
+                         ValueT(center[1] - origin[1]) / voxelSize,
+                         ValueT(center[2] - origin[2]) / voxelSize);
 
     // Define bounds of the voxel coordinates
-    const int imin = Floor(c[0]-rmax), imax = Ceil(c[0]+rmax);
-    const int jmin = Floor(c[1]-rmax), jmax = Ceil(c[1]+rmax);
-    const int kmin = Floor(c[2]-rmax), kmax = Ceil(c[2]+rmax);
+    const int imin = Floor(c[0] - rmax), imax = Ceil(c[0] + rmax);
+    const int jmin = Floor(c[1] - rmax), jmax = Ceil(c[1] + rmax);
+    const int kmin = Floor(c[2] - rmax), kmax = Ceil(c[2] + rmax);
 
     Coord ijk;
-    int &i = ijk[0], &j = ijk[1], &k = ijk[2], m=1;
+    int & i = ijk[0], &j = ijk[1], &k = ijk[2], m = 1;
     // Compute signed distances to sphere using leapfrogging in k
     for (i = imin; i <= imax; ++i) {
         const auto x2 = Pow2(ValueT(i) - c[0]);
@@ -1664,56 +1598,61 @@
             const auto x2y2 = Pow2(ValueT(j) - c[1]) + x2;
             for (k = kmin; k <= kmax; k += m) {
                 m = 1;
-                const auto v = Sqrt(x2y2 + Pow2(ValueT(k)-c[2]))-r0;// Distance in voxel units
-                const auto d = v<0 ? -v : v;
+                const auto v = Sqrt(x2y2 + Pow2(ValueT(k) - c[2])) - r0; // Distance in voxel units
+                const auto d = v < 0 ? -v : v;
                 if (d < halfWidth) { // inside narrow band
-                    acc.setValue(ijk, voxelSize*v);// distance in world units
+                    acc.setValue(ijk, voxelSize * v); // distance in world units
                 } else { // outside narrow band
-                    m += Floor(d-halfWidth);// leapfrog
+                    m += Floor(d - halfWidth); // leapfrog
                 }
-            }//end leapfrog over k
-        }//end loop over j
-    }//end loop over i
+            } //end leapfrog over k
+        } //end loop over j
+    } //end loop over i
 
     return builder;
-}// initSphere
+} // initSphere
 
-template <typename ValueT>
+template<typename ValueT>
 std::shared_ptr<GridBuilder<ValueT>>
-initTorus(ValueT radius1,// major radius of torus in world units 
-          ValueT radius2,// minor radius of torus in world units 
-          const Vec3d& center,//center of sphere in world units
-          ValueT voxelSize,// size of a voxel in world units
-          ValueT halfWidth,// half-width of narrow band in voxel units 
-          const Vec3d &origin)// origin of grid in world units
-{
-    static_assert(is_floating_point<ValueT>::value,"Torus: expect floating point");
-    if (!(radius2 > 0)) throw std::runtime_error("Torus: radius2 must be positive!");
-    if (!(radius1 > radius2)) throw std::runtime_error("Torus: radius1 must be larger than radius2!");
-    if (!(voxelSize > 0)) throw std::runtime_error("Torus: voxelSize must be positive!");
-    if (!(halfWidth > 0)) throw std::runtime_error("Torus: halfWidth must be positive!");
+initTorus(ValueT       radius1, // major radius of torus in world units
+          ValueT       radius2, // minor radius of torus in world units
+          const Vec3d& center, //center of sphere in world units
+          ValueT       voxelSize, // size of a voxel in world units
+          ValueT       halfWidth, // half-width of narrow band in voxel units
+          const Vec3d& origin) // origin of grid in world units
+{
+    static_assert(is_floating_point<ValueT>::value, "Torus: expect floating point");
+    if (!(radius2 > 0))
+        throw std::runtime_error("Torus: radius2 must be positive!");
+    if (!(radius1 > radius2))
+        throw std::runtime_error("Torus: radius1 must be larger than radius2!");
+    if (!(voxelSize > 0))
+        throw std::runtime_error("Torus: voxelSize must be positive!");
+    if (!(halfWidth > 0))
+        throw std::runtime_error("Torus: halfWidth must be positive!");
 
-    auto builder = std::make_shared<GridBuilder<ValueT>>(halfWidth*voxelSize);
+    auto builder = std::make_shared<GridBuilder<ValueT>>(halfWidth * voxelSize);
     auto acc = builder->getAccessor();
 
     // Define radius of sphere and narrow-band in voxel units
-    const ValueT r1 = radius1/voxelSize, r2 = radius2/voxelSize, rmax1 = r1 + r2 + halfWidth, rmax2 = r2 + halfWidth;
+    const ValueT r1 = radius1 / voxelSize, r2 = radius2 / voxelSize, rmax1 = r1 + r2 + halfWidth, rmax2 = r2 + halfWidth;
 
     // Radius below the Nyquist frequency
-    if (r2 < ValueT(1.5)) return builder;
+    if (r2 < ValueT(1.5))
+        return builder;
 
     // Define center of sphere in voxel units
-    const Vec3<ValueT> c(ValueT(center[0]-origin[0])/voxelSize,
-                         ValueT(center[1]-origin[1])/voxelSize,
-                         ValueT(center[2]-origin[2])/voxelSize);
+    const Vec3<ValueT> c(ValueT(center[0] - origin[0]) / voxelSize,
+                         ValueT(center[1] - origin[1]) / voxelSize,
+                         ValueT(center[2] - origin[2]) / voxelSize);
 
     // Define bounds of the voxel coordinates
-    const int imin = Floor(c[0]-rmax1), imax = Ceil(c[0]+rmax1);
-    const int jmin = Floor(c[1]-rmax2), jmax = Ceil(c[1]+rmax2);
-    const int kmin = Floor(c[2]-rmax1), kmax = Ceil(c[2]+rmax1);
+    const int imin = Floor(c[0] - rmax1), imax = Ceil(c[0] + rmax1);
+    const int jmin = Floor(c[1] - rmax2), jmax = Ceil(c[1] + rmax2);
+    const int kmin = Floor(c[2] - rmax1), kmax = Ceil(c[2] + rmax1);
 
     Coord ijk;
-    int &i = ijk[0], &j = ijk[1], &k = ijk[2], m=1;
+    int & i = ijk[0], &j = ijk[1], &k = ijk[2], m = 1;
     // Compute signed distances to sphere using leapfrogging in k
     for (i = imin; i <= imax; ++i) {
         const auto x2 = Pow2(ValueT(i) - c[0]);
@@ -1721,147 +1660,160 @@
             const auto x2z2 = Pow2(Sqrt(Pow2(ValueT(k) - c[2]) + x2) - r1);
             for (j = jmin; j <= jmax; j += m) {
                 m = 1;
-                const auto v = Sqrt(x2z2 + Pow2(ValueT(j)-c[1])) - r2; // Distance in voxel units
-                const auto d = v<0 ? -v : v;
+                const auto v = Sqrt(x2z2 + Pow2(ValueT(j) - c[1])) - r2; // Distance in voxel units
+                const auto d = v < 0 ? -v : v;
                 if (d < halfWidth) { // inside narrow band
-                    acc.setValue(ijk, voxelSize*v);// distance in world units
+                    acc.setValue(ijk, voxelSize * v); // distance in world units
                 } else { // outside narrow band
-                    m += Floor(d-halfWidth);// leapfrog
+                    m += Floor(d - halfWidth); // leapfrog
                 }
-            }//end leapfrog over k
-        }//end loop over j
-    }//end loop over i
+            } //end leapfrog over k
+        } //end loop over j
+    } //end loop over i
 
     return builder;
-}// initTorus
+} // initTorus
 
-template <typename ValueT>
+template<typename ValueT>
 std::shared_ptr<GridBuilder<ValueT>>
-initBox(ValueT width,// major radius of torus in world units 
-        ValueT height,// minor radius of torus in world units
-        ValueT depth, 
-        const Vec3d& center,//center of sphere in world units
-        ValueT voxelSize,// size of a voxel in world units
-        ValueT halfWidth,// half-width of narrow band in voxel units 
-        const Vec3d &origin)// origin of grid in world units
+initBox(ValueT       width, // major radius of torus in world units
+        ValueT       height, // minor radius of torus in world units
+        ValueT       depth,
+        const Vec3d& center, //center of sphere in world units
+        ValueT       voxelSize, // size of a voxel in world units
+        ValueT       halfWidth, // half-width of narrow band in voxel units
+        const Vec3d& origin) // origin of grid in world units
 {
     using Vec3T = Vec3<ValueT>;
-    static_assert(is_floating_point<ValueT>::value,"Box: expect floating point");
-    if (!(width > 0))  throw std::runtime_error("Box: width must be positive!");
-    if (!(height > 0)) throw std::runtime_error("Box: height must be positive!");
-    if (!(depth > 0))  throw std::runtime_error("Box: depth must be positive!");
-
-    if (!(voxelSize > 0)) throw std::runtime_error("Box: voxelSize must be positive!");
-    if (!(halfWidth > 0)) throw std::runtime_error("Box: halfWidth must be positive!");
+    static_assert(is_floating_point<ValueT>::value, "Box: expect floating point");
+    if (!(width > 0))
+        throw std::runtime_error("Box: width must be positive!");
+    if (!(height > 0))
+        throw std::runtime_error("Box: height must be positive!");
+    if (!(depth > 0))
+        throw std::runtime_error("Box: depth must be positive!");
+
+    if (!(voxelSize > 0))
+        throw std::runtime_error("Box: voxelSize must be positive!");
+    if (!(halfWidth > 0))
+        throw std::runtime_error("Box: halfWidth must be positive!");
 
-    auto builder = std::make_shared<GridBuilder<ValueT>>(halfWidth*voxelSize);
+    auto builder = std::make_shared<GridBuilder<ValueT>>(halfWidth * voxelSize);
     auto acc = builder->getAccessor();
 
     // Define radius of sphere and narrow-band in voxel units
-    const Vec3T r(width/(2*voxelSize), height/(2*voxelSize), depth/(2*voxelSize));
-                      
+    const Vec3T r(width / (2 * voxelSize), height / (2 * voxelSize), depth / (2 * voxelSize));
+
     // Below the Nyquist frequency
-    if (r.min() < ValueT(1.5)) return builder;
+    if (r.min() < ValueT(1.5))
+        return builder;
 
     // Define center of sphere in voxel units
-    const Vec3T c(ValueT(center[0]-origin[0])/voxelSize,
-                  ValueT(center[1]-origin[1])/voxelSize,
-                  ValueT(center[2]-origin[2])/voxelSize);
+    const Vec3T c(ValueT(center[0] - origin[0]) / voxelSize,
+                  ValueT(center[1] - origin[1]) / voxelSize,
+                  ValueT(center[2] - origin[2]) / voxelSize);
 
     // Define utinity functions
-    auto Pos = [](ValueT x){return x>0 ?  x : 0;};
-    auto Neg = [](ValueT x){return x<0 ?  x : 0;};
+    auto Pos = [](ValueT x) { return x > 0 ? x : 0; };
+    auto Neg = [](ValueT x) { return x < 0 ? x : 0; };
 
     // Define bounds of the voxel coordinates
     const BBox<Vec3T> b(c - r - Vec3T(halfWidth), c + r + Vec3T(halfWidth));
-    const CoordBBox bbox(Coord(Floor(b[0][0]), Floor(b[0][1]),Floor(b[0][2])), 
-                         Coord( Ceil(b[1][0]),  Ceil(b[1][1]), Ceil(b[1][2])));
+    const CoordBBox   bbox(Coord(Floor(b[0][0]), Floor(b[0][1]), Floor(b[0][2])),
+                         Coord(Ceil(b[1][0]), Ceil(b[1][1]), Ceil(b[1][2])));
 
     // Compute signed distances to sphere using leapfrogging in k
     int m = 1;
-    for (Coord p = bbox[0]; p[0]<=bbox[1][0]; ++p[0]) {
+    for (Coord p = bbox[0]; p[0] <= bbox[1][0]; ++p[0]) {
         const auto q1 = Abs(ValueT(p[0]) - c[0]) - r[0];
         const auto x2 = Pow2(Pos(q1));
-        for (p[1] = bbox[0][1]; p[1]<=bbox[1][1]; ++p[1]) {
+        for (p[1] = bbox[0][1]; p[1] <= bbox[1][1]; ++p[1]) {
             const auto q2 = Abs(ValueT(p[1]) - c[1]) - r[1];
             const auto q0 = Max(q1, q2);
             const auto x2y2 = x2 + Pow2(Pos(q2));
-            for (p[2] = bbox[0][2]; p[2]<=bbox[1][2]; p[2] += m) {
+            for (p[2] = bbox[0][2]; p[2] <= bbox[1][2]; p[2] += m) {
                 m = 1;
                 const auto q3 = Abs(ValueT(p[2]) - c[2]) - r[2];
-                const auto v = Sqrt(x2y2 + Pow2(Pos(q3))) + Neg(Max(q0, q3));// Distance in voxel units
+                const auto v = Sqrt(x2y2 + Pow2(Pos(q3))) + Neg(Max(q0, q3)); // Distance in voxel units
                 const auto d = Abs(v);
                 if (d < halfWidth) { // inside narrow band
-                    acc.setValue(p, voxelSize*v);// distance in world units
+                    acc.setValue(p, voxelSize * v); // distance in world units
                 } else { // outside narrow band
-                    m += Floor(d-halfWidth);// leapfrog
+                    m += Floor(d - halfWidth); // leapfrog
                 }
-            }//end leapfrog over k
-        }//end loop over j
-    }//end loop over i
+            } //end leapfrog over k
+        } //end loop over j
+    } //end loop over i
 
     return builder;
-}// initBox
+} // initBox
 
-template <typename ValueT>
+template<typename ValueT>
 std::shared_ptr<GridBuilder<ValueT>>
-initBBox(ValueT width,// width of the box in world units 
-         ValueT height,// height of the box in world units
-         ValueT depth, // depth of th ebox in world units
-         ValueT thickness,// thickness of the wire in world units
-         const Vec3d& center,//center of sphere in world units
-         ValueT voxelSize,// size of a voxel in world units
-         ValueT halfWidth,// half-width of narrow band in voxel units 
-         const Vec3d &origin)// origin of grid in world units
+initBBox(ValueT       width, // width of the box in world units
+         ValueT       height, // height of the box in world units
+         ValueT       depth, // depth of th ebox in world units
+         ValueT       thickness, // thickness of the wire in world units
+         const Vec3d& center, //center of sphere in world units
+         ValueT       voxelSize, // size of a voxel in world units
+         ValueT       halfWidth, // half-width of narrow band in voxel units
+         const Vec3d& origin) // origin of grid in world units
 {
     using Vec3T = Vec3<ValueT>;
-    static_assert(is_floating_point<ValueT>::value,"BBox: expect floating point");
-    if (!(width > 0))  throw std::runtime_error("BBox: width must be positive!");
-    if (!(height > 0)) throw std::runtime_error("BBox: height must be positive!");
-    if (!(depth > 0))  throw std::runtime_error("BBox: depth must be positive!");
-    if (!(thickness > 0)) throw std::runtime_error("BBox: thickness must be positive!");
-    if (!(voxelSize > 0)) throw std::runtime_error("BBox: voxelSize must be positive!");
+    static_assert(is_floating_point<ValueT>::value, "BBox: expect floating point");
+    if (!(width > 0))
+        throw std::runtime_error("BBox: width must be positive!");
+    if (!(height > 0))
+        throw std::runtime_error("BBox: height must be positive!");
+    if (!(depth > 0))
+        throw std::runtime_error("BBox: depth must be positive!");
+    if (!(thickness > 0))
+        throw std::runtime_error("BBox: thickness must be positive!");
+    if (!(voxelSize > 0))
+        throw std::runtime_error("BBox: voxelSize must be positive!");
 
-    auto builder = std::make_shared<GridBuilder<ValueT>>(halfWidth*voxelSize);
+    auto builder = std::make_shared<GridBuilder<ValueT>>(halfWidth * voxelSize);
     auto acc = builder->getAccessor();
 
     // Define radius of sphere and narrow-band in voxel units
-    const Vec3T r(width/(2*voxelSize), height/(2*voxelSize), depth/(2*voxelSize));
-    const ValueT e = thickness/voxelSize;
-                      
+    const Vec3T  r(width / (2 * voxelSize), height / (2 * voxelSize), depth / (2 * voxelSize));
+    const ValueT e = thickness / voxelSize;
+
     // Below the Nyquist frequency
-    if (r.min() < ValueT(1.5) || e < ValueT(1.5) ) return builder;
+    if (r.min() < ValueT(1.5) || e < ValueT(1.5))
+        return builder;
 
     // Define center of sphere in voxel units
-    const Vec3T c(ValueT(center[0]-origin[0])/voxelSize,
-                  ValueT(center[1]-origin[1])/voxelSize,
-                  ValueT(center[2]-origin[2])/voxelSize);
+    const Vec3T c(ValueT(center[0] - origin[0]) / voxelSize,
+                  ValueT(center[1] - origin[1]) / voxelSize,
+                  ValueT(center[2] - origin[2]) / voxelSize);
 
     // Define utinity functions
-    auto Pos = [](ValueT x){return x>0 ?  x : 0;};
-    auto Neg = [](ValueT x){return x<0 ?  x : 0;};
+    auto Pos = [](ValueT x) { return x > 0 ? x : 0; };
+    auto Neg = [](ValueT x) { return x < 0 ? x : 0; };
 
     // Define bounds of the voxel coordinates
     const BBox<Vec3T> b(c - r - Vec3T(e + halfWidth), c + r + Vec3T(e + halfWidth));
-    const CoordBBox bbox(Coord(Floor(b[0][0]), Floor(b[0][1]),Floor(b[0][2])), 
-                         Coord( Ceil(b[1][0]),  Ceil(b[1][1]), Ceil(b[1][2])));
+    const CoordBBox   bbox(Coord(Floor(b[0][0]), Floor(b[0][1]), Floor(b[0][2])),
+                         Coord(Ceil(b[1][0]), Ceil(b[1][1]), Ceil(b[1][2])));
 
     // Compute signed distances to sphere using leapfrogging in k
     int m = 1;
-    for (Coord p = bbox[0]; p[0]<=bbox[1][0]; ++p[0]) {
+    for (Coord p = bbox[0]; p[0] <= bbox[1][0]; ++p[0]) {
         const ValueT px = Abs(ValueT(p[0]) - c[0]) - r[0];
         const ValueT qx = Abs(ValueT(px) + e) - e;
         const ValueT px2 = Pow2(Pos(px));
         const ValueT qx2 = Pow2(Pos(qx));
-        for (p[1] = bbox[0][1]; p[1]<=bbox[1][1]; ++p[1]) {
+        for (p[1] = bbox[0][1]; p[1] <= bbox[1][1]; ++p[1]) {
             const ValueT py = Abs(ValueT(p[1]) - c[1]) - r[1];
             const ValueT qy = Abs(ValueT(py) + e) - e;
-            const ValueT qy2 = Pow2(Pos(qy));;
+            const ValueT qy2 = Pow2(Pos(qy));
+            ;
             const ValueT px2qy2 = px2 + qy2;
             const ValueT qx2py2 = qx2 + Pow2(Pos(py));
             const ValueT qx2qy2 = qx2 + qy2;
             const ValueT a[3] = {Max(px, qy), Max(qx, py), Max(qx, qy)};
-            for (p[2] = bbox[0][2]; p[2]<=bbox[1][2]; p[2] += m) {
+            for (p[2] = bbox[0][2]; p[2] <= bbox[1][2]; p[2] += m) {
                 m = 1;
                 const ValueT pz = Abs(ValueT(p[2]) - c[2]) - r[2];
                 const ValueT qz = Abs(ValueT(pz) + e) - e;
@@ -1869,41 +1821,42 @@
                 const ValueT s1 = Sqrt(px2qy2 + qz2) + Neg(Max(a[0], qz));
                 const ValueT s2 = Sqrt(qx2py2 + qz2) + Neg(Max(a[1], qz));
                 const ValueT s3 = Sqrt(qx2qy2 + Pow2(Pos(pz))) + Neg(Max(a[2], pz));
-                const ValueT v = Min(s1, Min(s2, s3));// Distance in voxel units
+                const ValueT v = Min(s1, Min(s2, s3)); // Distance in voxel units
                 const ValueT d = Abs(v);
                 if (d < halfWidth) { // inside narrow band
-                    acc.setValue(p, voxelSize*v);// distance in world units
+                    acc.setValue(p, voxelSize * v); // distance in world units
                 } else { // outside narrow band
-                    m += Floor(d-halfWidth);// leapfrog
+                    m += Floor(d - halfWidth); // leapfrog
                 }
-            }//end leapfrog over k
-        }//end loop over j
-    }//end loop over i
+            } //end leapfrog over k
+        } //end loop over j
+    } //end loop over i
 
     return builder;
-}// initBBox
+} // initBBox
 
-}// unnamed namespace
+} // unnamed namespace
 
 //================================================================================================
 
-template <typename ValueT, typename BufferT>
+template<typename ValueT, typename BufferT>
 inline GridHandle<BufferT>
-createLevelSetSphere(ValueT radius,// radius of sphere in world units 
-                     const Vec3d& center,//center of sphere in world units
-                     ValueT voxelSize,// size of a voxel in world units
-                     ValueT halfWidth,// half-width of narrow band in voxel units 
-                     const Vec3d &origin,// origin of grid in world units
-                     const std::string &name,// name of grid
-                     ChecksumMode mode,// mode of comutation for the checksum
-                     const BufferT& buffer)
+createLevelSetSphere(ValueT             radius, // radius of sphere in world units
+                     const Vec3d&       center, //center of sphere in world units
+                     ValueT             voxelSize, // size of a voxel in world units
+                     ValueT             halfWidth, // half-width of narrow band in voxel units
+                     const Vec3d&       origin, // origin of grid in world units
+                     const std::string& name, // name of grid
+                     StatsMode          sMode, // mode of comutation for the statistics
+                     ChecksumMode       cMode, // mode of comutation for the checksum
+                     const BufferT&     buffer)
 {
     auto builder = initSphere(radius, center, voxelSize, halfWidth, origin);
     builder->sdfToLevelSet();
-    auto handle = builder->template getHandle<BufferT>(double(voxelSize), origin, name, GridClass::LevelSet, mode, buffer);
+    auto handle = builder->template getHandle<BufferT>(double(voxelSize), origin, name, GridClass::LevelSet, sMode, cMode, buffer);
     assert(handle);
     return handle;
-}// createLevelSetSphere
+} // createLevelSetSphere
 
 //================================================================================================
 
@@ -1912,261 +1865,278 @@
 createFogVolumeSphere(ValueT             radius, // radius of sphere in world units
                       const Vec3d&       center, //center of sphere in world units
                       ValueT             voxelSize, // size of a voxel in world units
-                      ValueT             halfWidth,// half-width of narrow band in voxel units 
+                      ValueT             halfWidth, // half-width of narrow band in voxel units
                       const Vec3d&       origin, // origin of grid in world units
-                      const std::string& name,// name of grid
-                      ChecksumMode mode,// mode of comutation for the checksum
-                      const BufferT& buffer)
+                      const std::string& name, // name of grid
+                      StatsMode          sMode, // mode of comutation for the statistics
+                      ChecksumMode       cMode, // mode of comutation for the checksum
+                      const BufferT&     buffer)
 {
     auto builder = initSphere(radius, center, voxelSize, halfWidth, origin);
     builder->sdfToFog();
-    auto handle = builder->template getHandle<BufferT>(double(voxelSize), origin, name, GridClass::FogVolume, mode, buffer);
+    auto handle = builder->template getHandle<BufferT>(double(voxelSize), origin, name, GridClass::FogVolume, sMode, cMode, buffer);
     assert(handle);
     return handle;
 } // createFogVolumeSphere
 
 //================================================================================================
 
-template <typename ValueT, typename BufferT>
+template<typename ValueT, typename BufferT>
 inline GridHandle<BufferT>
-createPointSphere(int pointsPerVoxel,// half-width of narrow band in voxel units
-                  ValueT radius,// radius of sphere in world units 
-                  const Vec3d& center,//center of sphere in world units
-                  ValueT voxelSize,// size of a voxel in world units 
-                  const Vec3d &origin,// origin of grid in world units
-                  const std::string &name,// name of grid
-                  ChecksumMode mode,// mode of comutation for the checksum
-                  const BufferT& buffer)
+createPointSphere(int                pointsPerVoxel, // half-width of narrow band in voxel units
+                  ValueT             radius, // radius of sphere in world units
+                  const Vec3d&       center, //center of sphere in world units
+                  ValueT             voxelSize, // size of a voxel in world units
+                  const Vec3d&       origin, // origin of grid in world units
+                  const std::string& name, // name of grid
+                  ChecksumMode       cMode, // mode of comutation for the checksum
+                  const BufferT&     buffer)
 {
-    auto sphereHandle = createLevelSetSphere(radius, center, voxelSize, 0.5f, origin,  "dummy", ChecksumMode::Disable, buffer);
+    auto sphereHandle = createLevelSetSphere(radius, center, voxelSize, 0.5f, origin, "dummy", StatsMode::BBox, ChecksumMode::Disable, buffer);
     assert(sphereHandle);
-    auto *sphereGrid = sphereHandle.template grid<ValueT>();
+    auto* sphereGrid = sphereHandle.template grid<ValueT>();
     assert(sphereGrid);
-    auto pointHandle = createPointScatter(*sphereGrid, pointsPerVoxel, name, mode, buffer);
+    auto pointHandle = createPointScatter(*sphereGrid, pointsPerVoxel, name, cMode, buffer);
     assert(pointHandle);
     return pointHandle;
-}// createPointSphere
+} // createPointSphere
 
 //================================================================================================
 
-template <typename ValueT, typename BufferT>
+template<typename ValueT, typename BufferT>
 inline GridHandle<BufferT>
-createLevelSetTorus(ValueT majorRadius,// major radius of torus in world units
-                    ValueT minorRadius,// minor radius of torus in world units 
-                    const Vec3d& center,//center of sphere in world units
-                    ValueT voxelSize,// size of a voxel in world units
-                    ValueT halfWidth,// half-width of narrow band in voxel units 
-                    const Vec3d &origin,// origin of grid in world units
-                    const std::string& name,// name of grid
-                    ChecksumMode mode,// mode of comutation for the checksum
-                    const BufferT& buffer)
+createLevelSetTorus(ValueT             majorRadius, // major radius of torus in world units
+                    ValueT             minorRadius, // minor radius of torus in world units
+                    const Vec3d&       center, //center of sphere in world units
+                    ValueT             voxelSize, // size of a voxel in world units
+                    ValueT             halfWidth, // half-width of narrow band in voxel units
+                    const Vec3d&       origin, // origin of grid in world units
+                    const std::string& name, // name of grid
+                    StatsMode          sMode, // mode of comutation for the statistics
+                    ChecksumMode       cMode, // mode of comutation for the checksum
+                    const BufferT&     buffer)
 {
     auto builder = initTorus(majorRadius, minorRadius, center, voxelSize, halfWidth, origin);
     builder->sdfToLevelSet();
-    auto handle = builder->template getHandle<BufferT>(double(voxelSize), origin, name, GridClass::LevelSet, mode, buffer);
+    auto handle = builder->template getHandle<BufferT>(double(voxelSize), origin, name, GridClass::LevelSet, sMode, cMode, buffer);
     assert(handle);
     return handle;
-}// createLevelSetTorus
+} // createLevelSetTorus
 
 //================================================================================================
 
 template<typename ValueT, typename BufferT>
 inline GridHandle<BufferT>
-createFogVolumeTorus(ValueT majorRadius,// major radius of torus in world units
-                     ValueT minorRadius,// minor radius of torus in world units
-                     const Vec3d& center, //center of sphere in world units
-                     ValueT voxelSize, // size of a voxel in world units
-                     ValueT halfWidth,// half-width of narrow band in voxel units 
-                     const Vec3d& origin, // origin of grid in world units
-                     const std::string& name,// name of grid
-                     ChecksumMode mode,// mode of comutation for the checksum
-                     const BufferT& buffer)
+createFogVolumeTorus(ValueT             majorRadius, // major radius of torus in world units
+                     ValueT             minorRadius, // minor radius of torus in world units
+                     const Vec3d&       center, //center of sphere in world units
+                     ValueT             voxelSize, // size of a voxel in world units
+                     ValueT             halfWidth, // half-width of narrow band in voxel units
+                     const Vec3d&       origin, // origin of grid in world units
+                     const std::string& name, // name of grid
+                     StatsMode          sMode, // mode of comutation for the statistics
+                     ChecksumMode       cMode, // mode of comutation for the checksum
+                     const BufferT&     buffer)
 {
     auto builder = initTorus(majorRadius, minorRadius, center, voxelSize, halfWidth, origin);
     builder->sdfToFog();
-    auto handle = builder->template getHandle<BufferT>(double(voxelSize), origin, name, GridClass::FogVolume, mode, buffer);
+    auto handle = builder->template getHandle<BufferT>(double(voxelSize), origin, name, GridClass::FogVolume, sMode, cMode, buffer);
     assert(handle);
     return handle;
 } // createFogVolumeTorus
 
 //================================================================================================
 
-template <typename ValueT, typename BufferT>
+template<typename ValueT, typename BufferT>
 inline GridHandle<BufferT>
-createPointTorus(int pointsPerVoxel,// half-width of narrow band in voxel units
-                 ValueT majorRadius,// major radius of torus in world units
-                 ValueT minorRadius,// minor radius of torus in world units
-                 const Vec3d& center, //center of sphere in world units
-                 ValueT voxelSize, // size of a voxel in world units 
-                 const Vec3d& origin, // origin of grid in world units
-                 const std::string& name,// name of grid
-                 ChecksumMode mode,// mode of comutation for the checksum
-                 const BufferT& buffer)
+createPointTorus(int                pointsPerVoxel, // half-width of narrow band in voxel units
+                 ValueT             majorRadius, // major radius of torus in world units
+                 ValueT             minorRadius, // minor radius of torus in world units
+                 const Vec3d&       center, //center of sphere in world units
+                 ValueT             voxelSize, // size of a voxel in world units
+                 const Vec3d&       origin, // origin of grid in world units
+                 const std::string& name, // name of grid
+                 ChecksumMode       cMode, // mode of comutation for the checksum
+                 const BufferT&     buffer)
 {
-    auto torusHandle = createLevelSetTorus(majorRadius, minorRadius, center, voxelSize, 0.5f, origin, "dummy", ChecksumMode::Disable, buffer);
+    auto torusHandle = createLevelSetTorus(majorRadius, minorRadius, center, voxelSize, 0.5f, origin, "dummy", StatsMode::BBox, ChecksumMode::Disable, buffer);
     assert(torusHandle);
-    auto *torusGrid = torusHandle.template grid<ValueT>();
+    auto* torusGrid = torusHandle.template grid<ValueT>();
     assert(torusGrid);
-    auto pointHandle = createPointScatter(*torusGrid, pointsPerVoxel, name, mode, buffer);
+    auto pointHandle = createPointScatter(*torusGrid, pointsPerVoxel, name, cMode, buffer);
     assert(pointHandle);
     return pointHandle;
-}// createPointTorus
+} // createPointTorus
 
 //================================================================================================
 
-template <typename ValueT, typename BufferT>
+template<typename ValueT, typename BufferT>
 inline GridHandle<BufferT>
-createLevelSetBox(ValueT width,// width of box in world units
-                  ValueT height,// height of box in world units
-                  ValueT depth,// depth of box in world units
-                  const Vec3d& center,//center of sphere in world units
-                  ValueT voxelSize,// size of a voxel in world units
-                  ValueT halfWidth,// half-width of narrow band in voxel units 
-                  const Vec3d &origin,// origin of grid in world units
-                  const std::string& name,// name of grid
-                  ChecksumMode mode,// mode of comutation for the checksum
-                  const BufferT& buffer)
+createLevelSetBox(ValueT             width, // width of box in world units
+                  ValueT             height, // height of box in world units
+                  ValueT             depth, // depth of box in world units
+                  const Vec3d&       center, //center of sphere in world units
+                  ValueT             voxelSize, // size of a voxel in world units
+                  ValueT             halfWidth, // half-width of narrow band in voxel units
+                  const Vec3d&       origin, // origin of grid in world units
+                  const std::string& name, // name of grid
+                  StatsMode          sMode, // mode of comutation for the statistics
+                  ChecksumMode       cMode, // mode of comutation for the checksum
+                  const BufferT&     buffer)
 {
     auto builder = initBox(width, height, depth, center, voxelSize, halfWidth, origin);
     builder->sdfToLevelSet();
-    auto handle = builder->template getHandle<BufferT>(double(voxelSize), origin, name, GridClass::LevelSet, mode, buffer);
+    auto handle = builder->template getHandle<BufferT>(double(voxelSize), origin, name, GridClass::LevelSet, sMode, cMode, buffer);
     assert(handle);
     return handle;
-}// createLevelSetBox
+} // createLevelSetBox
 
 //================================================================================================
 
-template <typename ValueT, typename BufferT>
+template<typename ValueT, typename BufferT>
 inline GridHandle<BufferT>
-createLevelSetBBox(ValueT width,// width of box in world units
-                   ValueT height,// height of box in world units
-                   ValueT depth,// depth of box in world units
-                   ValueT thickness,// thickness of the wire in world units
-                   const Vec3d& center,//center of sphere in world units
-                   ValueT voxelSize,// size of a voxel in world units
-                   ValueT halfWidth,// half-width of narrow band in voxel units 
-                   const Vec3d &origin,// origin of grid in world units
-                   const std::string& name,// name of grid
-                   ChecksumMode mode,// mode of comutation for the checksum
-                   const BufferT& buffer)
+createLevelSetBBox(ValueT             width, // width of box in world units
+                   ValueT             height, // height of box in world units
+                   ValueT             depth, // depth of box in world units
+                   ValueT             thickness, // thickness of the wire in world units
+                   const Vec3d&       center, //center of sphere in world units
+                   ValueT             voxelSize, // size of a voxel in world units
+                   ValueT             halfWidth, // half-width of narrow band in voxel units
+                   const Vec3d&       origin, // origin of grid in world units
+                   const std::string& name, // name of grid
+                   StatsMode          sMode, // mode of comutation for the statistics
+                   ChecksumMode       cMode, // mode of comutation for the checksum
+                   const BufferT&     buffer)
 {
     auto builder = initBBox(width, height, depth, thickness, center, voxelSize, halfWidth, origin);
     builder->sdfToLevelSet();
-    auto handle = builder->template getHandle<BufferT>(double(voxelSize), origin, name, GridClass::LevelSet, mode, buffer);
+    auto handle = builder->template getHandle<BufferT>(double(voxelSize), origin, name, GridClass::LevelSet, sMode, cMode, buffer);
     assert(handle);
     return handle;
-}// createLevelSetBBox
+} // createLevelSetBBox
 
 //================================================================================================
 
 template<typename ValueT, typename BufferT>
 inline GridHandle<BufferT>
-createFogVolumeBox(ValueT width,// width of box in world units
-                   ValueT height,// height of box in world units
-                   ValueT depth,// depth of box in world units
+createFogVolumeBox(ValueT             width, // width of box in world units
+                   ValueT             height, // height of box in world units
+                   ValueT             depth, // depth of box in world units
                    const Vec3d&       center, //center of sphere in world units
                    ValueT             voxelSize, // size of a voxel in world units
-                   ValueT             halfWidth,// half-width of narrow band in voxel units 
+                   ValueT             halfWidth, // half-width of narrow band in voxel units
                    const Vec3d&       origin, // origin of grid in world units
-                   const std::string& name,// name of grid
-                   ChecksumMode mode,// mode of comutation for the checksum
-                   const BufferT& buffer)
+                   const std::string& name, // name of grid
+                   StatsMode          sMode, // mode of comutation for the statistics
+                   ChecksumMode       cMode, // mode of comutation for the checksum
+                   const BufferT&     buffer)
 {
     auto builder = initBox(width, height, depth, center, voxelSize, halfWidth, origin);
     builder->sdfToFog();
-    auto handle = builder->template getHandle<BufferT>(double(voxelSize), origin, name, GridClass::FogVolume, mode, buffer);
+    auto handle = builder->template getHandle<BufferT>(double(voxelSize), origin, name, GridClass::FogVolume, sMode, cMode, buffer);
     assert(handle);
     return handle;
 } // createFogVolumeBox
 
 //================================================================================================
 
-template <typename ValueT, typename BufferT>
+template<typename ValueT, typename BufferT>
 inline GridHandle<BufferT>
-createPointBox(int pointsPerVoxel,// half-width of narrow band in voxel units
-               ValueT width,// width of box in world units
-               ValueT height,// height of box in world units
-               ValueT depth,// depth of box in world units
-               const Vec3d& center,//center of sphere in world units
-               ValueT voxelSize,// size of a voxel in world units
-               const Vec3d &origin,// origin of grid in world units
-               const std::string& name,// name of grid
-               ChecksumMode mode,// mode of comutation for the checksum
-               const BufferT& buffer)
+createPointBox(int                pointsPerVoxel, // half-width of narrow band in voxel units
+               ValueT             width, // width of box in world units
+               ValueT             height, // height of box in world units
+               ValueT             depth, // depth of box in world units
+               const Vec3d&       center, //center of sphere in world units
+               ValueT             voxelSize, // size of a voxel in world units
+               const Vec3d&       origin, // origin of grid in world units
+               const std::string& name, // name of grid
+               ChecksumMode       cMode, // mode of comutation for the checksum
+               const BufferT&     buffer)
 {
-    auto boxHandle = createLevelSetBox(width, height, depth, center, voxelSize, 0.5f, origin, "dummy", ChecksumMode::Disable, buffer);
+    auto boxHandle = createLevelSetBox(width, height, depth, center, voxelSize, 0.5f, origin, "dummy", StatsMode::BBox, ChecksumMode::Disable, buffer);
     assert(boxHandle);
-    auto *boxGrid = boxHandle.template grid<ValueT>();
+    auto* boxGrid = boxHandle.template grid<ValueT>();
     assert(boxGrid);
-    auto pointHandle = createPointScatter(*boxGrid, pointsPerVoxel, name, mode, buffer);
+    auto pointHandle = createPointScatter(*boxGrid, pointsPerVoxel, name, cMode, buffer);
     assert(pointHandle);
     return pointHandle;
-    
-}// createPointBox
+
+} // createPointBox
 
 //================================================================================================
 
-template <typename ValueT, typename BufferT>
+template<typename ValueT, typename BufferT>
 inline GridHandle<BufferT>
-createPointScatter(const NanoGrid<ValueT> &srcGrid,// origin of grid in world units
-                   int pointsPerVoxel,// half-width of narrow band in voxel units
-                   const std::string &name,// name of grid
-                   ChecksumMode mode,// mode of comutation for the checksum
-                   const BufferT& buffer)
+createPointScatter(const NanoGrid<ValueT>& srcGrid, // origin of grid in world units
+                   int                     pointsPerVoxel, // half-width of narrow band in voxel units
+                   const std::string&      name, // name of grid
+                   ChecksumMode            cMode, // mode of comutation for the checksum
+                   const BufferT&          buffer)
 {
-    static_assert(is_floating_point<ValueT>::value,"Sphere: expect floating point");
+    static_assert(is_floating_point<ValueT>::value, "createPointScatter: expect floating point");
     using Vec3T = Vec3<ValueT>;
-    if (pointsPerVoxel < 1) throw std::runtime_error("Expected at least one point per voxel");
-    if (!srcGrid.isLevelSet()) throw std::runtime_error("Expected a level set grid");
-    
+    if (pointsPerVoxel < 1) {
+        throw std::runtime_error("createPointScatter: Expected at least one point per voxel");
+    }
+    if (!srcGrid.isLevelSet()) {
+        throw std::runtime_error("createPointScatter: Expected a level set grid");
+    }
+    if (!srcGrid.hasBBox()) {
+        throw std::runtime_error("createPointScatter: ActiveVoxelCount is required");
+    }
     const uint64_t pointCount = pointsPerVoxel * srcGrid.activeVoxelCount();
     const uint64_t pointSize = AlignUp<NANOVDB_DATA_ALIGNMENT>(pointCount * sizeof(Vec3T));
-    if (pointCount == 0) throw std::runtime_error("No particles to scatter");
+    if (pointCount == 0) {
+        throw std::runtime_error("createPointScatter: No particles to scatter");
+    }
     std::vector<Vec3T> xyz;
     xyz.reserve(pointCount);
     GridBuilder<uint32_t> builder(std::numeric_limits<uint32_t>::max(), pointSize);
-    auto dstAcc = builder.getAccessor();
+    auto                  dstAcc = builder.getAccessor();
     std::srand(1234);
-    const ValueT s = 1/(1+ValueT(RAND_MAX));
-    auto op = [&](const Coord &p){
+    const ValueT s = 1 / (1 + ValueT(RAND_MAX));
+    auto         op = [&](const Coord& p) {
         //return Vec3T(p[0] + s*rand(), p[1] + s*rand(), p[2] + s*rand());
-        return Vec3T(p[0] + s*rand() - 0.5, p[1] + s*rand() - 0.5, p[2] + s*rand() - 0.5);
+        return Vec3T(p[0] + s * rand() - 0.5, p[1] + s * rand() - 0.5, p[2] + s * rand() - 0.5);
         //return srcGrid.indexToWorld(Vec3T(p[0] + s*rand(), p[1] + s*rand(), p[2] + s*rand()));
     };
-    const auto &srcTree = srcGrid.tree();
-    for (uint32_t i=0, end = srcTree.nodeCount(0); i<end; ++i) {
-        auto *srcLeaf = srcTree.template getNode<0>(i);
-        auto *dstLeaf = dstAcc.setValue(srcLeaf->origin(), pointsPerVoxel);// allocates leaf node
+    const auto& srcTree = srcGrid.tree();
+    for (uint32_t i = 0, end = srcTree.nodeCount(0); i < end; ++i) {
+        auto* srcLeaf = srcTree.template getNode<0>(i);
+        auto* dstLeaf = dstAcc.setValue(srcLeaf->origin(), pointsPerVoxel); // allocates leaf node
         dstLeaf->mValueMask = srcLeaf->valueMask();
-        for (uint32_t j=0, m=0; j<512; ++j) {
+        for (uint32_t j = 0, m = 0; j < 512; ++j) {
             if (dstLeaf->mValueMask.isOn(j)) {
                 const auto ijk = srcLeaf->offsetToGlobalCoord(j);
-                for (int n=0; n<pointsPerVoxel; ++n, ++m) xyz.push_back(op(ijk));
+                for (int n = 0; n < pointsPerVoxel; ++n, ++m)
+                    xyz.push_back(op(ijk));
             }
             dstLeaf->mValues[j] = m;
         }
     }
     assert(pointCount == xyz.size());
-    auto handle = builder.template getHandle<BufferT>(srcGrid.map(), name, GridClass::PointData, ChecksumMode::Disable, buffer);
+    auto handle = builder.template getHandle<BufferT>(srcGrid.map(), name, GridClass::PointData, StatsMode::MinMax, ChecksumMode::Disable, buffer);
     assert(handle);
-    auto *dstGrid = handle.template grid<uint32_t>();
+    auto* dstGrid = handle.template grid<uint32_t>();
     assert(dstGrid);
-    auto &dstTree = dstGrid->tree();
-    if (dstTree.nodeCount(0) == 0) throw std::runtime_error("Expect leaf nodes!");
-    auto *leafData = const_cast<typename NanoLeaf<uint32_t>::DataType*>(dstTree.template getNode<0>(0u)->data());
-    leafData[0].mValueMin = 0; // start of prefix sum
+    auto& dstTree = dstGrid->tree();
+    if (dstTree.nodeCount(0) == 0) {
+        throw std::runtime_error("Expect leaf nodes!");
+    }
+    auto* leafData = const_cast<typename NanoLeaf<uint32_t>::DataType*>(dstTree.template getNode<0>(0u)->data());
+    leafData[0].mMinimum = 0; // start of prefix sum
     for (uint32_t i = 1, n = dstTree.nodeCount(0); i < n; ++i) {
-        leafData[i].mValueMin = leafData[i - 1].mValueMin + leafData[i - 1].mValueMax;
+        leafData[i].mMinimum = leafData[i - 1].mMinimum + leafData[i - 1].mMaximum;
     }
-    auto &meta = const_cast<GridBlindMetaData&>(dstGrid->blindMetaData(0u));
-    meta.mByteOffset = handle.size() - pointSize;// offset from Grid to blind data
+    auto& meta = const_cast<GridBlindMetaData&>(dstGrid->blindMetaData(0u));
+    meta.mByteOffset = handle.size() - pointSize; // offset from Grid to blind data
     meta.mElementCount = xyz.size();
     meta.mFlags = 0;
     meta.mDataClass = GridBlindDataClass::AttributeArray;
     meta.mSemantic = GridBlindDataSemantic::PointPosition;
     if (name.length() + 1 > GridBlindMetaData::MaxNameSize) {
         std::stringstream ss;
-        ss << "Point attribute name \"" << name << "\" is more then " 
+        ss << "Point attribute name \"" << name << "\" is more then "
            << nanovdb::GridBlindMetaData::MaxNameSize << " characters";
         throw std::runtime_error(ss.str());
     }
@@ -2179,9 +2149,9 @@
         throw std::runtime_error("Unsupported value type");
     }
     memcpy(handle.data() + meta.mByteOffset, xyz.data(), xyz.size() * sizeof(Vec3T));
-    updateChecksum( *dstGrid, mode);
+    updateChecksum(*dstGrid, cMode);
     return handle;
-}// createPointScatter
+} // createPointScatter
 
 } // namespace nanovdb
 
diff -aur nanovdb-20200925/nanovdb/nanovdb/util/GridChecksum.h nanovdb-20201022/nanovdb/nanovdb/util/GridChecksum.h
--- nanovdb-20200925/nanovdb/nanovdb/util/GridChecksum.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/nanovdb/util/GridChecksum.h	2020-10-22 03:52:50.000000000 +0200
@@ -163,7 +163,7 @@
 
     GridChecksum() : mCRC{CRC32::EMPTY, CRC32::EMPTY} {}
 
-    GridChecksum(uint32_t crc1, uint32_t crc2) : mCRC{crc1, crc2} {}
+    GridChecksum(uint32_t head, uint32_t tail) :  mCRC{head, tail} {}
 
     GridChecksum(uint64_t checksum, ChecksumMode mode = ChecksumMode::Full) : mChecksum{mode == ChecksumMode::Disable ? EMPTY : checksum}
     {
@@ -177,6 +177,12 @@
     bool isFull() const { return mCRC[0] != CRC32::EMPTY && mCRC[1] != CRC32::EMPTY; }
 
     bool isEmpty() const { return mChecksum == EMPTY; }
+
+    ChecksumMode mode() const
+    { 
+        return mChecksum == EMPTY ? ChecksumMode::Disable :
+               mCRC[1] == CRC32::EMPTY ? ChecksumMode::Partial : ChecksumMode::Full; 
+    }
     
     template <typename ValueT>
     void operator()(const NanoGrid<ValueT> &grid, ChecksumMode mode = ChecksumMode::Full);
@@ -270,7 +276,7 @@
 bool validateChecksum(const NanoGrid<ValueT> &grid, ChecksumMode mode)
 {
     GridChecksum cs1(grid.checksum(), mode), cs2;
-    cs2(grid, mode);
+    cs2(grid, cs1.mode() );
     return cs1 == cs2;
 }
 
diff -aur nanovdb-20200925/nanovdb/nanovdb/util/GridStats.h nanovdb-20201022/nanovdb/nanovdb/util/GridStats.h
--- nanovdb-20200925/nanovdb/nanovdb/util/GridStats.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/nanovdb/util/GridStats.h	2020-10-22 03:52:50.000000000 +0200
@@ -8,7 +8,8 @@
 
     \date August 29, 2020
 
-    \brief Re-computes min/max/bbox information for each node in a pre-existing NanoVDB grid.
+    \brief Re-computes min/max/avg/var/bbox information for each node in a 
+           pre-existing NanoVDB grid.
 */
 
 #ifndef NANOVDB_GRIDSTATS_H_HAS_BEEN_INCLUDED
@@ -17,22 +18,403 @@
 #include "../NanoVDB.h"
 #include "Range.h"
 #include "ForEach.h"
-#include "GridBuilder.h"// for Extrema
-#include "GridChecksum.h"
 
 #include <atomic>
 
 namespace nanovdb {
 
+/// @brief Grid flags which indicate what extra information is present in the grid buffer.
+enum class StatsMode : uint32_t {
+    Disable = 0,// disable the computation of any type of statistics (obviously the FASTEST!)
+    BBox = 1,// only compute the bbox of active values per node and total activeVoxelCount
+    MinMax = 2,// additionally compute extrema values
+    All = 3,// compute all of the statics, i.e. bbox, min/max, averager and standard deviation
+    Default = 3,
+    End = 4,
+};
+
 /// @brief Re-computes the min/max and bbox information for an existing NaoVDB Grid
 ///
 /// @param grid  Grid whoes stats to update
-/// @param mode  Mode of computation for the checksum.
-template <typename ValueT = float>
-void gridStats(NanoGrid<ValueT> &grid, ChecksumMode mode = ChecksumMode::Default);
+/// @param mode  Mode of computation for the statistics.
+template<typename ValueT>
+void gridStats(NanoGrid<ValueT>& grid, StatsMode mode = StatsMode::Default);
+
+//================================================================================================
+
+template<typename ValueT, int Rank = TensorTraits<ValueT>::Rank>
+class Extrema;
+
+/// @brief Template specialization of Extrema on scalar value types, i.e. rank = 0
+template<typename ValueT>
+class Extrema<ValueT, 0>
+{
+protected:
+    ValueT mMin, mMax;
+
+public:
+    Extrema()
+        : mMin(std::numeric_limits<ValueT>::max())
+        , mMax(std::numeric_limits<ValueT>::lowest())
+    {
+    }
+    Extrema(const ValueT& v)
+        : mMin(v)
+        , mMax(v)
+    {
+    }
+    Extrema(const ValueT& a, const ValueT& b)
+        : mMin(a)
+        , mMax(b)
+    {
+    }
+    Extrema& operator=(const Extrema&) = default;
+    void min(const ValueT& v)
+    {
+        if (v < mMin) {
+            mMin = v;
+        }
+    }
+    void max(const ValueT& v)
+    {
+        if (v > mMax) {
+            mMax = v;
+        }
+    }
+    void add(const ValueT& v)
+    {
+        this->min(v);
+        this->max(v);
+    }
+    void add(const ValueT& v, uint64_t) { this->add(v); }
+    void add(const Extrema& other)
+    {
+        this->min(other.mMin);
+        this->max(other.mMax);
+    }
+    const ValueT& min() const { return mMin; }
+    const ValueT& max() const { return mMax; }
+    operator bool() const { return mMin <= mMax; }
+    static constexpr bool hasMinMax() { return true; }
+    static constexpr bool hasAverage() { return false; }
+    static constexpr bool hasStdDeviation() { return false; }
+}; // Extrema<T, 0>
+
+/// @brief Template specialization of Extrema on vector value types, i.e. rank = 1
+template<typename VecT>
+class Extrema<VecT, 1>
+{
+protected:
+    using Real = typename VecT::ValueType; // this works with both nanovdb and openvdb vectors
+    struct Pair
+    {
+        Real scalar;
+        VecT vector;
+        Pair(Real s)
+            : scalar(s)
+            , vector(s)
+        {
+        } // is only used by Extrema() default c-tor
+        Pair(const VecT& v)
+            : scalar(v.lengthSqr())
+            , vector(v)
+        {
+        }
+        Pair& operator=(const Pair&) = default;
+        bool  operator<(const Pair& rhs) const { return scalar < rhs.scalar; }
+        bool  operator>(const Pair& rhs) const { return scalar > rhs.scalar; }
+        bool  operator<=(const Pair& rhs) const { return scalar <= rhs.scalar; }
+    } mMin, mMax;
+    void add(const Pair& p)
+    {
+        if (p < mMin) {
+            mMin = p;
+        }
+        if (p > mMax) {
+            mMax = p;
+        }
+    }
+
+public:
+    Extrema()
+        : mMin(std::numeric_limits<Real>::max())
+        , mMax(std::numeric_limits<Real>::lowest())
+    {
+    }
+    Extrema(const VecT& v)
+        : mMin(v)
+        , mMax(v)
+    {
+    }
+    Extrema(const VecT& a, const VecT& b)
+        : mMin(a)
+        , mMax(b)
+    {
+    }
+    Extrema& operator=(const Extrema&) = default;
+    void     min(const VecT& v)
+    {
+        Pair tmp(v);
+        if (tmp < mMin) {
+            mMin = tmp;
+        }
+    }
+    void max(const VecT& v)
+    {
+        Pair tmp(v);
+        if (tmp > mMax) {
+            mMax = tmp;
+        }
+    }
+    void add(const VecT& v) { this->add(Pair(v)); }
+    void add(const VecT& v, uint64_t) { this->add(Pair(v)); }
+    void add(const Extrema& other)
+    {
+        if (other.mMin < mMin)
+            mMin = other.mMin;
+        if (other.mMax > mMax)
+            mMax = other.mMax;
+    }
+    const VecT& min() const { return mMin.vector; }
+    const VecT& max() const { return mMax.vector; }
+    operator bool() const { return mMin <= mMax; }
+    static constexpr bool hasMinMax() { return true; }
+    static constexpr bool hasAverage() { return false; }
+    static constexpr bool hasStdDeviation() { return false; }
+}; // Extrema<T, 1>
+
+//================================================================================================
+
+template<typename ValueT, int Rank = TensorTraits<ValueT>::Rank>
+class Stats;
+
+/// @brief This class computes statistics (minimum value, maximum
+/// value, mean, variance and standard deviation) of a population
+/// of floating-point values.
+///
+/// @details variance = Mean[ (X-Mean[X])^2 ] = Mean[X^2] - Mean[X]^2,
+///          standard deviation = sqrt(variance)
+///
+/// @note This class employs incremental computation and double precision.
+template<typename ValueT>
+class Stats<ValueT, 0> : public Extrema<ValueT, 0>
+{
+protected:
+    using BaseT = Extrema<ValueT, 0>;
+    using RealT = double; // for accuracy the internal precission must be 64 bit floats
+    size_t mSize;
+    double mAvg, mAux;
+
+public:
+    Stats()
+        : BaseT()
+        , mSize(0)
+        , mAvg(0.0)
+        , mAux(0.0)
+    {
+    }
+    Stats(const ValueT& val)
+        : BaseT(val)
+        , mSize(1)
+        , mAvg(RealT(val))
+        , mAux(0.0)
+    {
+    }
+    /// @brief Add a single sample
+    void add(const ValueT& val)
+    {
+        BaseT::add(val);
+        mSize += 1;
+        const double delta = double(val) - mAvg;
+        mAvg += delta / double(mSize);
+        mAux += delta * (double(val) - mAvg);
+    }
+    /// @brief Add @a n samples with constant value @a val.
+    void add(const ValueT& val, uint64_t n)
+    {
+        const double denom = 1.0 / double(mSize + n);
+        const double delta = double(val) - mAvg;
+        mAvg += denom * delta * double(n);
+        mAux += denom * delta * delta * double(mSize) * double(n);
+        BaseT::add(val);
+        mSize += n;
+    }
+
+    /// Add the samples from the other Stats instance.
+    void add(const Stats& other)
+    {
+        if (other.mSize > 0) {
+            const double denom = 1.0 / double(mSize + other.mSize);
+            const double delta = other.mAvg - mAvg;
+            mAvg += denom * delta * double(other.mSize);
+            mAux += other.mAux + denom * delta * delta * double(mSize) * double(other.mSize);
+            BaseT::add(other);
+            mSize += other.mSize;
+        }
+    }
+
+    static constexpr bool hasMinMax() { return true; }
+    static constexpr bool hasAverage() { return true; }
+    static constexpr bool hasStdDeviation() { return true; }
+
+    size_t size() const { return mSize; }
+
+    //@{
+    /// Return the  arithmetic mean, i.e. average, value.
+    double avg() const { return mAvg; }
+    double mean() const { return mAvg; }
+    //@}
+
+    //@{
+    /// @brief Return the population variance.
+    ///
+    /// @note The unbiased sample variance = population variance * num/(num-1)
+    double var() const { return mSize < 2 ? 0.0 : mAux / double(mSize); }
+    double variance() const { return this->var(); }
+    //@}
+
+    //@{
+    /// @brief Return the standard deviation (=Sqrt(variance)) as
+    ///        defined from the (biased) population variance.
+    double std() const { return sqrt(this->var()); }
+    double stdDev() const { return this->std(); }
+    //@}
+}; // end Stats<T, 0>
+
+/// @brief This class computes statistics (minimum value, maximum
+/// value, mean, variance and standard deviation) of a population
+/// of floating-point values.
+///
+/// @details variance = Mean[ (X-Mean[X])^2 ] = Mean[X^2] - Mean[X]^2,
+///          standard deviation = sqrt(variance)
+///
+/// @note This class employs incremental computation and double precision.
+template<typename ValueT>
+class Stats<ValueT, 1> : public Extrema<ValueT, 1>
+{
+protected:
+    using BaseT = Extrema<ValueT, 1>;
+    using RealT = double; // for accuracy the internal precission must be 64 bit floats
+    size_t mSize;
+    double mAvg, mAux;
+
+public:
+    Stats()
+        : BaseT()
+        , mSize(0)
+        , mAvg(0.0)
+        , mAux(0.0)
+    {
+    }
+    /// @brief Add a single sample
+    void add(const ValueT& val)
+    {
+        typename BaseT::Pair tmp(val);
+        BaseT::add(tmp);
+        mSize += 1;
+        const double delta = tmp.scalar - mAvg;
+        mAvg += delta / double(mSize);
+        mAux += delta * (tmp.scalar - mAvg);
+    }
+    /// @brief Add @a n samples with constant value @a val.
+    void add(const ValueT& val, uint64_t n)
+    {
+        typename BaseT::Pair tmp(val);
+        const double         denom = 1.0 / double(mSize + n);
+        const double         delta = tmp.scalar - mAvg;
+        mAvg += denom * delta * double(n);
+        mAux += denom * delta * delta * double(mSize) * double(n);
+        BaseT::add(tmp);
+        mSize += n;
+    }
+
+    /// Add the samples from the other Stats instance.
+    void add(const Stats& other)
+    {
+        if (other.mSize > 0) {
+            const double denom = 1.0 / double(mSize + other.mSize);
+            const double delta = other.mAvg - mAvg;
+            mAvg += denom * delta * double(other.mSize);
+            mAux += other.mAux + denom * delta * delta * double(mSize) * double(other.mSize);
+            BaseT::add(other);
+            mSize += other.mSize;
+        }
+    }
+
+    static constexpr bool hasMinMax() { return true; }
+    static constexpr bool hasAverage() { return true; }
+    static constexpr bool hasStdDeviation() { return true; }
+
+    size_t size() const { return mSize; }
+
+    //@{
+    /// Return the  arithmetic mean, i.e. average, value.
+    double avg() const { return mAvg; }
+    double mean() const { return mAvg; }
+    //@}
+
+    //@{
+    /// @brief Return the population variance.
+    ///
+    /// @note The unbiased sample variance = population variance * num/(num-1)
+    double var() const { return mSize < 2 ? 0.0 : mAux / double(mSize); }
+    double variance() const { return this->var(); }
+    //@}
+
+    //@{
+    /// @brief Return the standard deviation (=Sqrt(variance)) as
+    ///        defined from the (biased) population variance.
+    double std() const { return sqrt(this->var()); }
+    double stdDev() const { return this->std(); }
+    //@}
+}; // end Stats<T, 1>
+
+template<typename ValueT>
+struct NoopStats
+{
+    int i;
+    NoopStats() {}
+    NoopStats(const ValueT&) {}
+    /// @brief Add a single sample
+    void add(const ValueT&) {}
+    /// @brief Add @a n samples with constant value @a val.
+    void add(const ValueT&, uint64_t) {}
+
+    /// Add the samples from the other Stats instance.
+    void add(const NoopStats&) {}
+
+    static constexpr bool hasMinMax() { return false; }
+    static constexpr bool hasAverage() { return false; }
+    static constexpr bool hasStdDeviation() { return false; }
+
+    static size_t size() { return 0; }
+
+    //@{
+    /// Return the  arithmetic mean, i.e. average, value.
+    static double avg() { return 0.0; }
+    static double mean() { return 0.0; }
+    //@}
+
+    //@{
+    /// @brief Return the population variance.
+    ///
+    /// @note The unbiased sample variance = population variance * num/(num-1)
+    static double var() { return 0.0; }
+    static double variance() { return 0.0; }
+    //@}
+
+    //@{
+    /// @brief Return the standard deviation (=Sqrt(variance)) as
+    ///        defined from the (biased) population variance.
+    static double std() { return 0.0; }
+    static double stdDev() { return 0.0; }
+    //@}
+}; // end NoopStats<T>
+
+//================================================================================================
 
 /// @brief Allows for the construction of NanoVDB grids without any dependecy
-template <typename ValueT, typename ExtremaOp = Extrema<ValueT> >
+template<typename ValueT, typename StatsT = Stats<ValueT>>
 class GridStats
 {
     using Node0 = LeafNode<ValueT>; // leaf
@@ -40,17 +422,25 @@
     using Node2 = InternalNode<Node1>; // upper
     using RootT = RootNode<Node2>;
 
+    static constexpr bool DO_STATS = StatsT::hasMinMax() || StatsT::hasAverage() || StatsT::hasStdDeviation();
+
     NanoGrid<ValueT>*     mGrid;
-    ValueT                mDelta;// skip node if: node.max < -mDelta || node.min > mDelta
+    ValueT                mDelta; // skip node if: node.max < -mDelta || node.min > mDelta
     std::atomic<uint64_t> mActiveVoxelCount;
-    
+
     // Below are private methods use to serialize nodes into NanoVDB
-    void processLeafs();   
-    template <typename NodeT>
-    void processNodes();
-    void processRoot();
+    void processLeafs(std::vector<StatsT>&);
+    template<typename NodeT>
+    void processNodes(std::vector<StatsT>&, std::vector<StatsT>&);
+    void processRoot(std::vector<StatsT>&);
     void processGrid();
-    void postProcessGrid(ChecksumMode mode);
+
+    template<typename DataT, int Rank>
+    void setStats(DataT*, const Extrema<ValueT, Rank>&);
+    template<typename DataT, int Rank>
+    void setStats(DataT*, const Stats<ValueT, Rank>&);
+    template<typename DataT>
+    void setStats(DataT*, const NoopStats<ValueT>&) {}
 
     template<typename T, typename FlagT>
     typename std::enable_if<!std::is_floating_point<T>::value>::type
@@ -61,35 +451,75 @@
     setFlag(const T& min, const T& max, FlagT& flag) const;
 
 public:
-    GridStats() : mGrid(nullptr) {}
+    GridStats()
+        : mGrid(nullptr)
+    {
+    }
 
-    void operator()(NanoGrid<ValueT> &grid, ChecksumMode mode = ChecksumMode::Default, ValueT delta = ValueT(0));
+    void operator()(NanoGrid<ValueT>& grid, ValueT delta = ValueT(0));
 
-};// GridStats
+}; // GridStats
 
 //================================================================================================
 
-template <typename ValueT, typename ExtremaOp>
-void GridStats<ValueT, ExtremaOp>::operator()(NanoGrid<ValueT> &grid, ChecksumMode mode, ValueT delta)
+template<typename ValueT, typename StatsT>
+void GridStats<ValueT, StatsT>::operator()(NanoGrid<ValueT>& grid, ValueT delta)
 {
     mGrid = &grid;
-    mDelta = delta;// delta = voxel size for level sets, else 0
+    mDelta = delta; // delta = voxel size for level sets, else 0
     mActiveVoxelCount = 0;
-    this->processLeafs();
-    this->template processNodes<Node1>();
-    this->template processNodes<Node2>();
-    this->processRoot();
+
+    std::vector<StatsT> stats0;
+    std::vector<StatsT> stats1;
+
+    if (DO_STATS) { // resolved at compiletime
+        stats0.resize(mGrid->tree().nodeCount(0));
+        stats1.resize(mGrid->tree().nodeCount(1));
+    }
+
+    this->processLeafs(stats0);
+
+    this->template processNodes<Node1>(stats1, stats0);
+
+    if (DO_STATS) { // resolved at compiletime
+        stats0.resize(mGrid->tree().nodeCount(2));
+    }
+    this->template processNodes<Node2>(stats0, stats1);
+
+    this->processRoot(stats0);
+
     this->processGrid();
-    this->postProcessGrid( mode );
 }
 
 //================================================================================================
 
-template<typename ValueT, typename ExtremaOp>
+template<typename ValueT, typename StatsT>
+template<typename DataT, int Rank>
+inline void GridStats<ValueT, StatsT>::
+    setStats(DataT* data, const Extrema<ValueT, Rank>& e)
+{
+    data->mMinimum = e.min();
+    data->mMaximum = e.max();
+}
+
+template<typename ValueT, typename StatsT>
+template<typename DataT, int Rank>
+inline void GridStats<ValueT, StatsT>::
+    setStats(DataT* data, const Stats<ValueT, Rank>& s)
+{
+    data->mMinimum = s.min();
+    data->mMaximum = s.max();
+    data->mAverage = s.avg();
+    data->mStdDevi = s.std();
+}
+
+//================================================================================================
+
+template<typename ValueT, typename StatsT>
 template<typename T, typename FlagT>
 inline typename std::enable_if<std::is_floating_point<T>::value>::type
-GridStats<ValueT, ExtremaOp>::
-setFlag(const T& min, const T& max, FlagT& flag) const
+GridStats<ValueT, StatsT>::
+    setFlag(const T& min, const T& max, FlagT& flag) const
 {
     if (mDelta > 0 && (min > mDelta || max < -mDelta)) {
         flag |= FlagT(1); // set first bit
@@ -100,37 +530,30 @@
 
 //================================================================================================
 
-template<typename ValueT, typename ExtremaOp>
-void GridStats<ValueT, ExtremaOp>::
-processLeafs()
+template<typename ValueT, typename StatsT>
+void GridStats<ValueT, StatsT>::
+    processLeafs(std::vector<StatsT>& stats)
 {
-    auto &tree = mGrid->tree();
-    auto kernel = [&](const Range1D &r) {
+    auto& tree = mGrid->tree();
+    auto  kernel = [&](const Range1D& r) {
         uint64_t sum = 0;
         for (auto i = r.begin(); i != r.end(); ++i) {
-            Node0 *leaf = tree.template getNode<Node0>(i);
-            auto *data = leaf->data();
-            auto iter = data->mValueMask.beginOn();
-            if (!iter) throw std::runtime_error("Expected at least one active voxel in every leaf node!");
-            sum += data->mValueMask.countOn();
-            const ValueT* src = data->mValues;
-            ExtremaOp extrema( src[*iter] );
-            CoordBBox bbox;// empty
-            bbox.expand(Node0::OffsetToLocalCoord(*iter));// initially use local coord for speed
-            for (++iter; iter; ++iter) {
-                bbox.expand(Node0::OffsetToLocalCoord(*iter));
-                extrema( src[*iter] );
+            Node0* leaf = tree.template getNode<Node0>(i);
+            auto*  data = leaf->data();
+            if (auto n = data->mValueMask.countOn()) {
+                sum += n;
+                leaf->updateBBox(); // optionally update active bounding box
+                if (DO_STATS) { // resolved at compiletime
+                    const ValueT* v = data->mValues;
+                    StatsT&       s = stats[i];
+                    for (auto it = data->mValueMask.beginOn(); it; ++it)
+                        s.add(v[*it]);
+                    this->setStats(data, s);
+                    this->setFlag(data->mMinimum, data->mMaximum, data->mFlags);
+                }
+            } else {
+                throw std::runtime_error("Expected at least one active voxel per leaf node.");
             }
-            assert(!bbox.empty());
-            leaf->localToGlobalCoord(bbox[0]);
-            leaf->localToGlobalCoord(bbox[1]);
-            data->mBBoxDif[0] = uint8_t(bbox[1][0] - bbox[0][0]);
-            data->mBBoxDif[1] = uint8_t(bbox[1][1] - bbox[0][1]);
-            data->mBBoxDif[2] = uint8_t(bbox[1][2] - bbox[0][2]);
-            data->mBBoxMin = bbox[0];
-            data->mValueMin = extrema.min();
-            data->mValueMax = extrema.max();
-            this->setFlag(data->mValueMin, data->mValueMax, data->mFlags);
         }
         mActiveVoxelCount += sum;
     };
@@ -138,54 +561,43 @@
 } // GridStats::processLeafs
 
 //================================================================================================
-template<typename ValueT, typename ExtremaOp>
+template<typename ValueT, typename StatsT>
 template<typename NodeT>
-void GridStats<ValueT, ExtremaOp>::
-processNodes()
+void GridStats<ValueT, StatsT>::
+    processNodes(std::vector<StatsT>& stats, std::vector<StatsT>& childStats)
 {
     using ChildT = typename NodeT::ChildNodeType;
-    auto &tree = mGrid->tree();
-    auto kernel = [&](const Range1D &r) 
-    {
+    auto& tree = mGrid->tree();
+    auto  kernel = [&](const Range1D& r) {
         uint64_t sum = 0;
         for (auto i = r.begin(); i != r.end(); ++i) {
-            NodeT *node = tree.template getNode<NodeT>(i);
-            auto *data = node->data();
-            sum += ChildT::NUM_VALUES * data->mValueMask.countOn();// active tiles
-            auto onValIter = data->mValueMask.beginOn();
-            auto childIter = data->mChildMask.beginOn();
-            ExtremaOp extrema;
-            if (onValIter) {
-                extrema = ExtremaOp(data->mTable[*onValIter].value);
-                const Coord ijk = node->offsetToGlobalCoord(*onValIter);
-                data->mBBox[0] = ijk;
-                data->mBBox[1] = ijk + Coord(int32_t(ChildT::DIM) - 1);
-                ++onValIter;
-            } else if (childIter) {
-                auto* child = data->child(*childIter);
-                extrema = ExtremaOp(child->valueMin(), child->valueMax());
-                data->mBBox = child->bbox();
-                ++childIter;
-            } else {
-                throw std::runtime_error("Internal node with no children or active values! Hint: try pruneInactive.");
+            NodeT* node = tree.template getNode<NodeT>(i);
+            auto*  data = node->data();
+            sum += ChildT::NUM_VALUES * data->mValueMask.countOn(); // active tiles
+            CoordBBox bbox; // empty
+            for (auto iter = data->mValueMask.beginOn(); iter; ++iter) {
+                if (DO_STATS) { // resolved at compiletime
+                    stats[i].add(data->mTable[*iter].value, ChildT::NUM_VALUES);
+                }
+                const Coord ijk = node->offsetToGlobalCoord(*iter);
+                bbox[0].minComponent(ijk);
+                bbox[1].maxComponent(ijk + Coord(int32_t(ChildT::DIM) - 1));
             }
-            for (; onValIter; ++onValIter) { // typically there are few active tiles
-                extrema( data->mTable[*onValIter].value );
-                const Coord ijk = node->offsetToGlobalCoord(*onValIter);
-                data->mBBox[0].minComponent(ijk);
-                data->mBBox[1].maxComponent(ijk + Coord(int32_t(ChildT::DIM) - 1));
+            for (auto iter = data->mChildMask.beginOn(); iter; ++iter) {
+                if (DO_STATS) { // resolved at compiletime
+                    stats[i].add(childStats[data->mTable[*iter].childID]);
+                }
+                const auto& childBBox = data->child(*iter)->bbox();
+                bbox[0].minComponent(childBBox[0]);
+                bbox[1].maxComponent(childBBox[1]);
             }
-            for (; childIter; ++childIter) {
-                auto* child = data->child(*childIter);
-                extrema.min( child->valueMin() );
-                extrema.max( child->valueMax() );
-                const auto& bbox = child->bbox();
-                data->mBBox[0].minComponent(bbox[0]);
-                data->mBBox[1].maxComponent(bbox[1]);
+            if (bbox.empty())
+                throw std::runtime_error("Internal node with no children or active values! Hint: try pruneInactive.");
+            data->mBBox = bbox;
+            if (DO_STATS) { // resolved at compiletime
+                this->setStats(data, stats[i]);
+                this->setFlag(data->mMinimum, data->mMaximum, data->mFlags);
             }
-            data->mValueMin = extrema.min();
-            data->mValueMax = extrema.max();
-            this->setFlag(data->mValueMin, data->mValueMax, data->mFlags);
         }
         mActiveVoxelCount += sum;
     };
@@ -193,101 +605,108 @@
 } // GridStats::processNodes
 
 //================================================================================================
-template<typename ValueT, typename ExtremaOp>
-void GridStats<ValueT, ExtremaOp>::
-processRoot()
+template<typename ValueT, typename StatsT>
+void GridStats<ValueT, StatsT>::
+    processRoot(std::vector<StatsT>& childStats)
 {
     using ChildT = Node2;
-    RootT &root = mGrid->tree().root();
-    //auto &root = const_cast<RootT&>(mGrid->tree().root());
-    auto &data = *root.data();
+    RootT&    root = mGrid->tree().root();
+    auto&     data = *root.data();
+    CoordBBox bbox; // set to an empty bounding box
     if (data.mTileCount == 0) { // empty root node
-        data.mValueMin = data.mValueMax = data.mBackground;
-        data.mBBox[0] = Coord::max(); // set to an empty bounding box
-        data.mBBox[1] = Coord::min();
+        data.mMinimum = data.mMaximum = data.mBackground;
+        data.mAverage = data.mStdDevi = 0;
         data.mActiveVoxelCount = 0;
     } else {
-        ExtremaOp extrema;// invalid
-        for (uint32_t i = 0; i<data.mTileCount; ++i) {
+        StatsT s; // invalid
+        for (uint32_t i = 0; i < data.mTileCount; ++i) {
             auto& tile = data.tile(i);
-            if (tile.isChild()) {// process child node
-                auto& child = data.child(tile);
-                if (!extrema) {
-                    extrema = ExtremaOp( child.valueMin(), child.valueMax() );
-                    assert(extrema);
-                    data.mBBox = child.bbox();
-                } else {
-                    extrema.min( child.valueMin() );
-                    extrema.max( child.valueMax() );
-                    data.mBBox[0].minComponent(child.bbox()[0]);
-                    data.mBBox[1].maxComponent(child.bbox()[1]);
-                }
-            } else {// process tile
-                if (tile.state) {// active tile
-                    mActiveVoxelCount += ChildT::NUM_VALUES;
-                    const Coord ijk = tile.origin();
-                    if (!extrema) {
-                        extrema = ExtremaOp(tile.value);
-                        assert(extrema);
-                        data.mBBox[0] = ijk;
-                        data.mBBox[1] = ijk + Coord(ChildT::DIM - 1);
-                    } else {
-                        extrema( tile.value );
-                        data.mBBox[0].minComponent(ijk);
-                        data.mBBox[1].maxComponent(ijk + Coord(ChildT::DIM - 1)); 
-                    }
-                }
+            if (tile.isChild()) { // process child node
+                auto& childBBox = data.child(tile).bbox();
+                bbox[0].minComponent(childBBox[0]);
+                bbox[1].maxComponent(childBBox[1]);
+                if (DO_STATS)
+                    s.add(childStats[tile.childID]); // resolved at compiletime
+            } else if (tile.state) { // active tile
+                mActiveVoxelCount += ChildT::NUM_VALUES;
+                const Coord ijk = tile.origin();
+                bbox[0].minComponent(ijk);
+                bbox[1].maxComponent(ijk + Coord(ChildT::DIM - 1));
+                if (DO_STATS)
+                    s.add(tile.value, ChildT::NUM_VALUES); // resolved at compiletime
             }
         }
-        data.mValueMin = extrema.min();
-        data.mValueMax = extrema.max();
+        this->setStats(&data, s);
         data.mActiveVoxelCount = mActiveVoxelCount;
-        if (!extrema) std::cerr << "\nWarning: input tree only contained inactive root tiles! While not strictly an error it's suspecious." << std::endl;
+        if (bbox.empty()) {
+            std::cerr << "\nWarning: input tree only contained inactive root tiles! While not strictly an error it's suspecious." << std::endl;
+        }
     }
-}// GridStats::processRoot
+    data.mBBox = bbox;
+} // GridStats::processRoot
 
 //================================================================================================
 
-template<typename ValueT, typename ExtremaOp>
-void GridStats<ValueT, ExtremaOp>::
-processGrid()
+template<typename ValueT, typename StatsT>
+void GridStats<ValueT, StatsT>::
+    processGrid()
 {
     // set world space AABB
+    auto&       data = *mGrid->data();
     const auto& indexBBox = mGrid->tree().root().bbox();
-    const auto &map = mGrid->map();
-    auto &data = *mGrid->data();
-    auto &worldBBox = data.mWorldBBox;
-    worldBBox[0] = worldBBox[1] = map.applyMap(Vec3d(indexBBox[0][0], indexBBox[0][1], indexBBox[0][2]));
-    worldBBox.expand(map.applyMap(Vec3d(indexBBox[0][0], indexBBox[0][1], indexBBox[1][2])));
-    worldBBox.expand(map.applyMap(Vec3d(indexBBox[0][0], indexBBox[1][1], indexBBox[0][2])));
-    worldBBox.expand(map.applyMap(Vec3d(indexBBox[1][0], indexBBox[0][1], indexBBox[0][2])));
-    worldBBox.expand(map.applyMap(Vec3d(indexBBox[1][0], indexBBox[1][1], indexBBox[0][2])));
-    worldBBox.expand(map.applyMap(Vec3d(indexBBox[1][0], indexBBox[0][1], indexBBox[1][2])));
-    worldBBox.expand(map.applyMap(Vec3d(indexBBox[0][0], indexBBox[1][1], indexBBox[1][2])));
-    worldBBox.expand(map.applyMap(Vec3d(indexBBox[1][0], indexBBox[1][1], indexBBox[1][2])));
-    
-    // set bit flags
-    data.setMinMax(true);
-    data.setBBox(true);
-}// GridStats::processGrid
-
-//================================================================================================
+    if (indexBBox.empty()) {
+        data.mWorldBBox = BBox<Vec3R>();
+        data.setBBoxOn(false);
+    } else {
+        // Note that below max is offset by one since CoordBBox.max is inclusive
+        // while bbox<Vec3R>.max is exclusive. However, min is inclusive in both
+        // CoordBBox and BBox<Vec3R>. This also guarantees that a grid with a single
+        // active voxel, does not have an empty world bbox! E.g. if a grid with a
+        // unit index-to-world transformation only contains the active voxel (0,0,0)
+        // then indeBBox = (0,0,0) -> (0,0,0) and then worldBBox = (0.0, 0.0, 0.0)
+        // -> (1.0, 1.0, 1.0). This is a consequence of the different definitions
+        // of index and world bounding boxes inherited from OpenVDB!
+        const Coord min = indexBBox[0];
+        const Coord max = indexBBox[1] + Coord(1);
+        
+        auto& worldBBox = data.mWorldBBox;
+        const auto& map = mGrid->map();
+        worldBBox[0] = worldBBox[1] = map.applyMap(Vec3d(min[0], min[1], min[2]));
+        worldBBox.expand(map.applyMap(Vec3d(min[0], min[1], max[2])));
+        worldBBox.expand(map.applyMap(Vec3d(min[0], max[1], min[2])));
+        worldBBox.expand(map.applyMap(Vec3d(max[0], min[1], min[2])));
+        worldBBox.expand(map.applyMap(Vec3d(max[0], max[1], min[2])));
+        worldBBox.expand(map.applyMap(Vec3d(max[0], min[1], max[2])));
+        worldBBox.expand(map.applyMap(Vec3d(min[0], max[1], max[2])));
+        worldBBox.expand(map.applyMap(Vec3d(max[0], max[1], max[2])));
+        data.setBBoxOn(true);
+    }
 
-template<typename ValueT, typename ExtremaOp>
-void GridStats<ValueT, ExtremaOp>::
-postProcessGrid(ChecksumMode mode)
-{
-    auto &data = *mGrid->data();
-    data.mChecksum = checksum(*mGrid, mode);
-}// GridStats::postProcessGrid
+    // set bit flags
+    data.setMinMaxOn(StatsT::hasMinMax());
+    data.setAverageOn(StatsT::hasAverage());
+    data.setStdDeviationOn(StatsT::hasStdDeviation());
+} // GridStats::processGrid
 
 //================================================================================================
 
-template <typename ValueT>
-void gridStats(NanoGrid<ValueT> &grid, ChecksumMode mode)
+template<typename ValueT>
+void gridStats(NanoGrid<ValueT>& grid, StatsMode mode)
 {
-    GridStats<ValueT> stats;
-    stats( grid, mode );
+    if (mode == StatsMode::Disable) {
+        return;
+    } else if (mode == StatsMode::BBox) {
+        GridStats<ValueT, NoopStats<ValueT> > stats;
+        stats(grid);
+    } else if (mode == StatsMode::MinMax) {
+        GridStats<ValueT, Extrema<ValueT> > stats;
+        stats(grid);
+    } else if (mode == StatsMode::All) {
+        GridStats<ValueT, Stats<ValueT> > stats;
+        stats(grid); 
+    } else {
+        throw std::runtime_error("gridStats: Unsupported statistics mode.");
+    }
 }
 
 } // namespace nanovdb
diff -aur nanovdb-20200925/nanovdb/nanovdb/util/HDDA.h nanovdb-20201022/nanovdb/nanovdb/util/HDDA.h
--- nanovdb-20200925/nanovdb/nanovdb/util/HDDA.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/nanovdb/util/HDDA.h	2020-10-22 03:52:50.000000000 +0200
@@ -143,8 +143,15 @@
     template<int axis>
     __hostdev__ bool step()
     {
+#if 0
         mT0 = mNext[axis];
         mNext[axis] += mDim * mDelta[axis];
+#else
+        //if (mNext[axis] <= mT0) mNext[axis] += mT0 - mNext[axis] + fmaxf(mNext[axis]*1.0e-6f, 1.0e-6f);
+        if (mNext[axis] <= mT0) mNext[axis] += mT0 - mNext[axis] + (mNext[axis] + 1.0f)*1.0e-6f;
+        mT0 = mNext[axis];
+        mNext[axis] += mDim * mDelta[axis];
+#endif
         mVoxel[axis] += mDim * mStep[axis];
         return mT0 <= mT1;
     }
@@ -158,14 +165,14 @@
 /////////////////////////////////////////// ZeroCrossing ////////////////////////////////////////////
 
 template<typename RayT, typename AccT>
-inline __hostdev__ bool ZeroCrossing(RayT& ray, AccT& acc, Coord& ijk, float& v, float& t)
+inline __hostdev__ bool ZeroCrossing(RayT& ray, AccT& acc, Coord& ijk, typename AccT::ValueType& v, float& t)
 {
     if (!ray.clip(acc.root().bbox()) || ray.t1() > 1e20)
         return false; // clip ray to bbox
     static const float Delta = 1.0001f;
     ijk = RoundDown<Coord>(ray.start()); // first hit of bbox
     HDDA<RayT, Coord> hdda(ray, acc.getDim(ijk, ray));
-    const float       v0 = acc.getValue(ijk);
+    const auto       v0 = acc.getValue(ijk);
     while (hdda.step()) {
         ijk = RoundDown<Coord>(ray(hdda.time() + Delta));
         hdda.update(ray, acc.getDim(ijk, ray));
diff -aur nanovdb-20200925/nanovdb/nanovdb/util/IO.h nanovdb-20201022/nanovdb/nanovdb/util/IO.h
--- nanovdb-20200925/nanovdb/nanovdb/util/IO.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/nanovdb/util/IO.h	2020-10-22 03:52:50.000000000 +0200
@@ -9,7 +9,7 @@
     \date May 1, 2020
 
     \brief Implements I/O for NanoVDB grids. Features optional BLOSC and ZIP
-           file compression, support for multiple grids per file as well as 
+           file compression, support for multiple grids per file as well as
            multiple grid types.
 
     \note  This file does NOT depend on OpenVDB, but optioanlly on ZIP and BLOSC
@@ -25,7 +25,7 @@
 #include <string> // for std::string
 #include <sstream> // for std::stringstream
 #include <cstring> // for std::strcmp
-#include <memory>// for std::unique_ptr
+#include <memory> // for std::unique_ptr
 #include <vector> // for std::vector
 #ifdef NANOVDB_USE_ZIP
 #include <zlib.h> // for ZIP compression
@@ -89,9 +89,9 @@
 inline uint64_t reverseEndianness(uint64_t val)
 {
     return (((val) >> 56) & 0x00000000000000FF) | (((val) >> 40) & 0x000000000000FF00) |
-	       (((val) >> 24) & 0x0000000000FF0000) | (((val) >>  8) & 0x00000000FF000000) |
-	       (((val) <<  8) & 0x000000FF00000000) | (((val) << 24) & 0x0000FF0000000000) |
-    	   (((val) << 40) & 0x00FF000000000000) | (((val) << 56) & 0xFF00000000000000) ;
+           (((val) >> 24) & 0x0000000000FF0000) | (((val) >> 8) & 0x00000000FF000000) |
+           (((val) << 8) & 0x000000FF00000000) | (((val) << 24) & 0x0000FF0000000000) |
+           (((val) << 40) & 0x00FF000000000000) | (((val) << 56) & 0xFF00000000000000);
 }
 
 /// @brief Data encoded at the head of each segment of a file or stream.
@@ -102,7 +102,7 @@
 // Major number of the file format (uint16_t) |
 // Minor number of the file format (uint16_t) | one header for each segment
 // Compression mode                (uint16_t) |
-// Number of grid in the file      (uint16_t) |
+// Number of grids in this segment (uint16_t) |
 struct Header
 {
     uint64_t magic; // 8 bytes
@@ -110,8 +110,8 @@
     Codec    codec; // 2 bytes
     Header(Codec c = Codec::NONE)
         : magic(NANOVDB_MAGIC_NUMBER) // Magic number: "NanoVDB" in hex
-        , major(19) // incremented for incompatible changes to the file format.
-        , minor(0) // incremented for backwards-compatible changes to the file format.
+        , major(NANOVDB_MAJOR_VERSION_NUMBER) // incremented for incompatible changes to the file format.
+        , minor(NANOVDB_MINOR_VERSION_NUMBER) // incremented for backwards-compatible changes to the file format.
         , gridCount(0)
         , codec(c)
     {
@@ -139,7 +139,8 @@
     Vec3R       voxelSize; // 24B.
     uint32_t    nameSize; // 4B.
     uint32_t    nodeCount[4]; //4 x 4 = 16B
-    uint32_t    _padding; // 4B.
+    Codec       codec; // 2B
+    uint16_t    major; // 2B
 }; // MetaData ( 160B )
 
 struct GridMetaData : public MetaData
@@ -149,7 +150,7 @@
     void        write(std::ostream& os) const;
     GridMetaData() {}
     template<typename ValueT>
-    GridMetaData(uint64_t size, const NanoGrid<ValueT>& grid);
+    GridMetaData(uint64_t size, Codec c, const NanoGrid<ValueT>& grid);
     uint64_t memUsage() const { return sizeof(MetaData) + nameSize; }
 }; // GridMetaData
 
@@ -285,8 +286,9 @@
         os.write(data, residual);
         total += residual;
     }
-    if (!os)
+    if (!os) {
         throw std::runtime_error("Failed to write Tree to file");
+    }
     return total;
 } // Internal::write
 
@@ -339,30 +341,45 @@
     default:
         is.read(data, residual);
     }
-    if (!is)
+    if (!is) {
         throw std::runtime_error("Failed to read Tree from file");
+    }
 } // Internal::read
 
 // --------------------------> Implementations for GridMetaData <------------------------------------
 
 template<typename ValueT>
-inline GridMetaData::GridMetaData(uint64_t size, const NanoGrid<ValueT>& grid)
-    : MetaData{size, 0, 0, grid.activeVoxelCount(), grid.gridType(), grid.gridClass(), grid.worldBBox(), grid.indexBBox(), grid.voxelSize(), 0, {0, 0, 0, 0}, 0}
+inline GridMetaData::GridMetaData(uint64_t size, Codec c, const NanoGrid<ValueT>& grid)
+    : MetaData{size, // gridSize
+               0, // fileSize
+               0, // nameKey
+               grid.activeVoxelCount(), // voxelCount
+               grid.gridType(), // gridType
+               grid.gridClass(), // gridClass
+               grid.worldBBox(), // worldBBox
+               grid.tree().bbox(), // indexBBox
+               grid.voxelSize(), // voxelSize
+               0, // nameSize
+               {0, 0, 0, 0}, // nodeCount[4]
+               c, // codec
+               NANOVDB_MAJOR_VERSION_NUMBER} // major
     , gridName(grid.gridName())
 {
     nameKey = stringHash(gridName);
     nameSize = static_cast<uint32_t>(gridName.size() + 1); // include '\0'
     const uint32_t* ptr = reinterpret_cast<const TreeData<3>*>(&grid.tree())->mCount;
-    for (int i = 0; i < 4; ++i)
+    for (int i = 0; i < 4; ++i) {
         MetaData::nodeCount[i] = *ptr++;
+    }
 }
 
 inline void GridMetaData::write(std::ostream& os) const
 {
     os.write(reinterpret_cast<const char*>(this), sizeof(MetaData));
     os.write(gridName.c_str(), nameSize);
-    if (!os)
+    if (!os) {
         throw std::runtime_error("Failed writing GridMetaData");
+    }
 }
 
 inline void GridMetaData::read(std::istream& is)
@@ -371,8 +388,9 @@
     std::unique_ptr<char[]> tmp(new char[nameSize]);
     is.read(reinterpret_cast<char*>(tmp.get()), nameSize);
     gridName.assign(tmp.get());
-    if (!is)
+    if (!is) {
         throw std::runtime_error("Failed reading GridMetaData");
+    }
 }
 
 // --------------------------> Implementations for Segment <------------------------------------
@@ -380,8 +398,9 @@
 inline uint64_t Segment::memUsage() const
 {
     uint64_t sum = sizeof(Header);
-    for (auto& m : meta)
+    for (auto& m : meta) {
         sum += m.memUsage();
+    }
     return sum;
 }
 
@@ -389,21 +408,21 @@
 inline void Segment::add(const GridHandle<BufferT>& h)
 {
     if (auto* grid = h.template grid<float>()) { // most common
-        meta.emplace_back(h.size(), *grid);
+        meta.emplace_back(h.size(), header.codec, *grid);
     } else if (auto* grid = h.template grid<Vec3f>()) {
-        meta.emplace_back(h.size(), *grid);
+        meta.emplace_back(h.size(), header.codec, *grid);
     } else if (auto* grid = h.template grid<double>()) {
-        meta.emplace_back(h.size(), *grid);
+        meta.emplace_back(h.size(), header.codec, *grid);
     } else if (auto* grid = h.template grid<int32_t>()) {
-        meta.emplace_back(h.size(), *grid);
+        meta.emplace_back(h.size(), header.codec, *grid);
     } else if (auto* grid = h.template grid<uint32_t>()) {
-        meta.emplace_back(h.size(), *grid);
+        meta.emplace_back(h.size(), header.codec, *grid);
     } else if (auto* grid = h.template grid<int64_t>()) {
-        meta.emplace_back(h.size(), *grid);
+        meta.emplace_back(h.size(), header.codec, *grid);
     } else if (auto* grid = h.template grid<int16_t>()) {
-        meta.emplace_back(h.size(), *grid);
+        meta.emplace_back(h.size(), header.codec, *grid);
     } else if (auto* grid = h.template grid<Vec3d>()) {
-        meta.emplace_back(h.size(), *grid);
+        meta.emplace_back(h.size(), header.codec, *grid);
     } else {
         throw std::runtime_error("Cannot write empty or unknown grids to file");
     }
@@ -412,35 +431,42 @@
 
 inline void Segment::write(std::ostream& os) const
 {
-    if (header.gridCount == 0)
+    if (header.gridCount == 0) {
         throw std::runtime_error("Segment contains no grids");
-    if (!os.write(reinterpret_cast<const char*>(&header), sizeof(Header)))
-        throw std::runtime_error("Failed writing Header");
-    for (auto& m : meta)
+    } else if (!os.write(reinterpret_cast<const char*>(&header), sizeof(Header))) {
+        throw std::runtime_error("Failed to write Header of Segment");
+    }
+    for (auto& m : meta) {
         m.write(os);
+    }
 }
 
 inline bool Segment::read(std::istream& is)
 {
     is.read(reinterpret_cast<char*>(&header), sizeof(Header));
-    if (is.eof())
+    if (is.eof()) {
         return false;
-    Header h;
+    }
     if (!is || header.magic != NANOVDB_MAGIC_NUMBER) {
         // first check for byte-swapped header magic.
         if (header.magic == reverseEndianness(NANOVDB_MAGIC_NUMBER))
-            throw std::runtime_error("This nvdb file has opposite endianness");
+            throw std::runtime_error("This nvdb file has reversed endianness");
         throw std::runtime_error("Magic number error: This is not a valid nvdb file");
-    }
-    if (header.major != h.major) {
+    } else if (header.major != NANOVDB_MAJOR_VERSION_NUMBER) {
         std::stringstream ss;
-        ss << "Read version " << header.major << "." << header.minor
-           << " but expected version " << h.major << ".x" << std::endl;
-        throw std::runtime_error("Incompatible file format: " + ss.str());
+        if (header.major < NANOVDB_MAJOR_VERSION_NUMBER) {
+            ss << "The file is written in an older version of NanoVDB: " << header.major << "." << header.minor << ".X!\n\t"
+               << "Recommendation: Re-generate this NanoVDB file with the never version " << NANOVDB_MAJOR_VERSION_NUMBER << ".X of NanoVDB";
+        } else {
+            ss << "This tool was compiled against an older version of NanoVDB: " << NANOVDB_MAJOR_VERSION_NUMBER << ".X!\n\t"
+               << "Recommendation: Re-compile this tool against version " << header.major << ".X of NanoVDB";
+        }
+        throw std::runtime_error("An unrecoverable error in nanaovdb::Segment::read:\n\tIncompatible file format: " + ss.str());
     }
     meta.resize(header.gridCount);
-    for (auto& m : meta)
+    for (auto& m : meta) {
         m.read(is);
+    }
     return true;
 }
 
@@ -450,11 +476,13 @@
 void writeGrid(const std::string& fileName, const GridHandle<BufferT>& handle, Codec codec, int verbose)
 {
     std::ofstream os(fileName, std::ios::out | std::ios::binary | std::ios::trunc);
-    if (!os.is_open())
+    if (!os.is_open()) {
         throw std::runtime_error("Unable to open file named \"" + fileName + "\" for output");
+    }
     writeGrid<BufferT>(os, handle, codec);
-    if (verbose)
+    if (verbose) {
         std::cout << "Wrote nanovdb::Grid to file named \"" << fileName << "\"" << std::endl;
+    }
 }
 
 template<typename BufferT>
@@ -476,19 +504,22 @@
 void writeGrids(const std::string& fileName, const VecT<GridHandle<BufferT>>& handles, Codec codec, int verbose)
 {
     std::ofstream os(fileName, std::ios::out | std::ios::binary | std::ios::trunc);
-    if (!os.is_open())
+    if (!os.is_open()) {
         throw std::runtime_error("Unable to open file named \"" + fileName + "\" for output");
+    }
     writeGrids<BufferT, VecT>(os, handles, codec);
-    if (verbose)
+    if (verbose) {
         std::cout << "Wrote " << handles.size() << " nanovdb::Grid(s) to file named \"" << fileName << "\"" << std::endl;
+    }
 }
 
 template<typename BufferT, template<typename...> class VecT>
 void writeGrids(std::ostream& os, const VecT<GridHandle<BufferT>>& handles, Codec codec)
 {
     Segment s(codec);
-    for (auto& h : handles)
+    for (auto& h : handles) {
         s.add(h);
+    }
     const uint64_t headerSize = s.memUsage();
     std::streamoff seek = headerSize;
     os.seekp(seek, std::ios_base::cur); // skip forward from the current position
@@ -506,12 +537,14 @@
 GridHandle<BufferT> readGrid(const std::string& fileName, uint64_t n, int verbose, const BufferT& buffer)
 {
     std::ifstream is(fileName, std::ios::in | std::ios::binary);
-    if (!is.is_open())
+    if (!is.is_open()) {
         throw std::runtime_error("Unable to open file named \"" + fileName + "\" for input");
+    }
     auto handle = readGrid<BufferT>(is, n, buffer);
-    if (verbose)
+    if (verbose) {
         std::cout << "Read NanoGrid # " << n << " from the file named \"" << fileName << "\"" << std::endl;
-    return handle;// is converted to r-value and return value is move constructed.
+    }
+    return handle; // is converted to r-value and return value is move constructed.
 }
 
 template<typename BufferT>
@@ -526,7 +559,7 @@
                 GridHandle<BufferT> handle(BufferT::create(m.gridSize, &buffer));
                 is.seekg(seek, std::ios_base::cur); // skip forward from the current position
                 Internal::read(is, handle, s.header.codec);
-                return handle;// is converted to r-value and return value is move constructed.
+                return handle; // is converted to r-value and return value is move constructed.
             } else {
                 seek += m.fileSize;
             }
@@ -542,8 +575,9 @@
 GridHandle<BufferT> readGrid(const std::string& fileName, const std::string& gridName, int verbose, const BufferT& buffer)
 {
     std::ifstream is(fileName, std::ios::in | std::ios::binary);
-    if (!is.is_open())
+    if (!is.is_open()) {
         throw std::runtime_error("Unable to open file named \"" + fileName + "\" for input");
+    }
     auto handle = readGrid<BufferT>(is, gridName, buffer);
     if (verbose) {
         if (handle) {
@@ -552,7 +586,7 @@
             std::cout << "File named \"" << fileName << "\" does not contain a grid named \"" + gridName + "\"" << std::endl;
         }
     }
-    return handle;// is converted to r-value and return value is move constructed.
+    return handle; // is converted to r-value and return value is move constructed.
 }
 
 template<typename BufferT>
@@ -567,14 +601,14 @@
                 GridHandle<BufferT> handle(BufferT::create(m.gridSize, &buffer));
                 is.seekg(seek, std::ios_base::cur); // rewind
                 Internal::read(is, handle, s.header.codec);
-                return handle;// is converted to r-value and return value is move constructed.
+                return handle; // is converted to r-value and return value is move constructed.
             } else {
                 seek += m.fileSize;
             }
         }
         is.seekg(seek, std::ios_base::cur); // skip forward from the current position
     }
-    return GridHandle<BufferT>();// empty handle
+    return GridHandle<BufferT>(); // empty handle
 }
 
 /// @brief Read all the grids
@@ -582,41 +616,44 @@
 VecT<GridHandle<BufferT>> readGrids(const std::string& fileName, int verbose, const BufferT& buffer)
 {
     std::ifstream is(fileName, std::ios::in | std::ios::binary);
-    if (!is.is_open())
+    if (!is.is_open()) {
         throw std::runtime_error("Unable to open file named \"" + fileName + "\" for input");
+    }
     auto handles = readGrids<BufferT, VecT>(is, buffer);
-    if (verbose)
+    if (verbose) {
         std::cout << "Read " << handles.size() << " NanoGrid(s) from the file named \"" << fileName << "\"" << std::endl;
-    return handles;// is converted to r-value and return value is move constructed.
+    }
+    return handles; // is converted to r-value and return value is move constructed.
 }
 
 template<typename BufferT, template<typename...> class VecT>
 VecT<GridHandle<BufferT>> readGrids(std::istream& is, const BufferT& buffer)
 {
     VecT<GridHandle<BufferT>> handles;
-    Segment seg;
+    Segment                   seg;
     while (seg.read(is)) {
         for (auto& m : seg.meta) {
             GridHandle<BufferT> handle(BufferT::create(m.gridSize, &buffer));
             Internal::read(is, handle, seg.header.codec);
-            handles.push_back(std::move(handle));// force move copy assignment
+            handles.push_back(std::move(handle)); // force move copy assignment
         }
     }
-    return handles;// is converted to r-value and return value is move constructed.
+    return handles; // is converted to r-value and return value is move constructed.
 }
 
 inline std::vector<GridMetaData> readGridMetaData(const std::string& fileName)
 {
     std::ifstream is(fileName, std::ios::in | std::ios::binary);
-    if (!is.is_open())
+    if (!is.is_open()) {
         throw std::runtime_error("Unable to open file named \"" + fileName + "\" for input");
-    return readGridMetaData(is);// is converted to r-value and return value is move constructed.
+    }
+    return readGridMetaData(is); // is converted to r-value and return value is move constructed.
 }
 
 inline std::vector<GridMetaData> readGridMetaData(std::istream& is)
 {
     std::vector<GridMetaData> meta;
-    Segment seg;
+    Segment                   seg;
     while (seg.read(is)) {
         std::streamoff seek = 0;
         for (auto& m : seg.meta) {
@@ -625,14 +662,15 @@
         }
         is.seekg(seek, std::ios_base::cur);
     }
-    return meta;// is converted to r-value and return value is move constructed.
+    return meta; // is converted to r-value and return value is move constructed.
 }
 
 inline bool hasGrid(const std::string& fileName, const std::string& gridName)
 {
     std::ifstream is(fileName, std::ios::in | std::ios::binary);
-    if (!is.is_open())
+    if (!is.is_open()) {
         throw std::runtime_error("Unable to open file named \"" + fileName + "\" for input");
+    }
     return hasGrid(is, gridName);
 }
 
@@ -643,8 +681,9 @@
     while (s.read(is)) {
         std::streamoff seek = 0;
         for (auto& m : s.meta) {
-            if (m.nameKey == key && m.gridName == gridName)
+            if (m.nameKey == key && m.gridName == gridName) {
                 return true; // check for hask key collision
+            }
             seek += m.fileSize;
         }
         is.seekg(seek, std::ios_base::cur);
@@ -655,8 +694,9 @@
 inline uint64_t stringHash(const char* cstr)
 {
     uint64_t hash = 0;
-    if (!cstr)
+    if (!cstr) {
         return hash;
+    }
     for (auto* str = reinterpret_cast<const unsigned char*>(cstr); *str; ++str) {
         uint64_t overflow = hash >> (64 - 8);
         hash *= 67; // Next-ish prime after 26 + 26 + 10
@@ -693,7 +733,17 @@
     }
 }
 
-} // namespace io
-} // namespace nanovdb
+inline std::string getStringForCodec(nanovdb::io::Codec c)
+{
+    switch (c) {
+    case Codec::NONE: return "None"; break;
+    case Codec::ZIP: return "Zip"; break;
+    case Codec::BLOSC: return "Blosc"; break;
+    default: return "?";
+    }
+}
+
+}
+} // namespace nanovdb::io
 
 #endif // NANOVDB_IO_H_HAS_BEEN_INCLUDED
diff -aur nanovdb-20200925/nanovdb/nanovdb/util/OpenToNanoVDB.h nanovdb-20201022/nanovdb/nanovdb/util/OpenToNanoVDB.h
--- nanovdb-20200925/nanovdb/nanovdb/util/OpenToNanoVDB.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/nanovdb/util/OpenToNanoVDB.h	2020-10-22 03:52:50.000000000 +0200
@@ -11,13 +11,14 @@
     \brief This class will serialize an OpenVDB grid into a NanoVDB grid.
 */
 
-#include <nanovdb/util/GridHandle.h> // manages and streams the raw memory buffer of a NanoVDB grid.
-#include <nanovdb/util/GridChecksum.h>
-
 #include <openvdb/openvdb.h>
 #include <openvdb/points/PointDataGrid.h>
 #include <openvdb/util/CpuTimer.h>
 
+#include "GridHandle.h" // manages and streams the raw memory buffer of a NanoVDB grid.
+#include "GridChecksum.h" // for checksum
+#include "GridStats.h" // for Extrema
+
 #include <tbb/parallel_for.h>
 #include <tbb/parallel_invoke.h>
 #include <tbb/parallel_sort.h>
@@ -33,17 +34,63 @@
 /// @brief Forward declaration of free-standing function that converts an OpenVDB GridBase into a NanoVDB GridHandle
 template<typename BufferT = HostBuffer>
 GridHandle<BufferT>
-openToNanoVDB(const openvdb::GridBase::Ptr& base, bool mortonSort = false, int verbose = 0, ChecksumMode mode = ChecksumMode::Default);
+openToNanoVDB(const openvdb::GridBase::Ptr& base,
+              StatsMode                     sMode = StatsMode::Default,
+              ChecksumMode                  cMode = ChecksumMode::Default,
+              bool                          mortonSort = false,
+              int                           verbose = 0);
 
 /// @brief Forward declaration of free-standing function that converts a typed OpenVDB Grid into a NanoVDB GridHandle
 template<typename BufferT = HostBuffer, typename SrcTreeT = openvdb::FloatTree>
 GridHandle<BufferT>
-openToNanoVDB(const openvdb::Grid<SrcTreeT>& grid, bool mortonSort = false, int verbose = 0, ChecksumMode mode = ChecksumMode::Default);
+openToNanoVDB(const openvdb::Grid<SrcTreeT>& grid,
+              StatsMode                      sMode = StatsMode::Default,
+              ChecksumMode                   cMode = ChecksumMode::Default,
+              bool                           mortonSort = false,
+              int                            verbose = 0);
+
+/// @brief Converts OpenVDB types to NanoVDB types
+template<typename T>
+struct TypeConverter
+{
+    using Type = T;
+};
+
+template<>
+struct TypeConverter<openvdb::math::Coord>
+{
+    using Type = nanovdb::Coord;
+};
+
+template<>
+struct TypeConverter<openvdb::math::CoordBBox>
+{
+    using Type = nanovdb::CoordBBox;
+};
+
+template<typename T>
+struct TypeConverter<openvdb::math::BBox<T>>
+{
+    using Type = nanovdb::BBox<T>;
+};
+
+template<typename T>
+struct TypeConverter<openvdb::math::Vec3<T>>
+{
+    using Type = nanovdb::Vec3<T>;
+};
+
+template<typename T>
+struct TypeConverter<openvdb::math::Vec4<T>>
+{
+    using Type = nanovdb::Vec4<T>;
+};
 
 namespace { // unnamed namespace
 
 /// @brief This class will openToNanoVDB an OpenVDB grid into a NanoVDB grid managed by a GridHandle.
 template<typename SrcTreeT, typename BufferT = HostBuffer>
+//typename StatsT = Extrema<typename SrcTreeT::ValueType, openvdb::VecTraits<typename SrcTreeT::ValueType>::IsVec ? 1 : 0> >
 class OpenToNanoVDB
 {
     struct BlindMetaData; // forward decleration
@@ -51,17 +98,22 @@
     ValueT                  mDelta; // skip node if: node.max < -mDelta || node.min > mDelta
     uint8_t*                mData;
     uint64_t                mBytes[8]; // Byte offsets to from mData to: tree, blindmetadata, root, node2, node1, leafs, blinddata, (total size)
-    tbb::atomic<uint64_t>   mActiveVoxelCount;
     std::set<BlindMetaData> mBlindMetaData; // sorted accoring to index
 
 public:
     /// @brief Construction from an existing const OpenVDB Grid.
-    OpenToNanoVDB() : mData(nullptr)
+    OpenToNanoVDB()
+        : mData(nullptr)
     {
     }
 
     /// @brief Return a shared pointer to a NanoVDB grid constructed from the specified OpneVDB grid
-    GridHandle<BufferT> operator()(const openvdb::Grid<SrcTreeT>& grid, bool fullChecksum = false, int verbose = 0, ChecksumMode mode = ChecksumMode::Default, const BufferT& allocator = BufferT());
+    GridHandle<BufferT> operator()(const openvdb::Grid<SrcTreeT>& grid,
+                                   StatsMode                      sMode = StatsMode::Default,
+                                   ChecksumMode                   mode = ChecksumMode::Default,
+                                   bool                           mortonSort = false,
+                                   int                            verbose = 0,
+                                   const BufferT&                 allocator = BufferT());
 
 private:
     static_assert(SrcTreeT::DEPTH == 4, "Converter assumes an OpenVDB tree of depth 4 (which is the default configuration)");
@@ -97,9 +149,6 @@
     /// @brief Private method to process the grid
     void processGrid(const SrcGridT& srcGrid);
 
-    /// @brief Private method to post-process the grid
-    void postProcessGrid(ChecksumMode mode);
-
     template<typename LeafT>
     uint64_t pointCount(std::vector<const LeafT*>&);
 
@@ -131,12 +180,15 @@
 
     /// @brief Private methods to access points to data
     template<typename DstNodeT>
+    DstNodeT* node() const { return reinterpret_cast<DstNodeT*>(mData + mBytes[5 - DstNodeT::LEVEL]); }
+
+    template<typename DstNodeT>
     typename DstNodeT::DataType* nodeData() const { return reinterpret_cast<typename DstNodeT::DataType*>(mData + mBytes[5 - DstNodeT::LEVEL]); }
     typename DstTreeT::DataType* treeData() const { return reinterpret_cast<typename DstTreeT::DataType*>(mData + mBytes[0]); }
     typename DstGridT::DataType* gridData() const { return reinterpret_cast<typename DstGridT::DataType*>(mData); }
-    uint64_t gridSize() const { return mBytes[7]; }
-    nanovdb::GridBlindMetaData* blindMetaData() const { return reinterpret_cast<nanovdb::GridBlindMetaData*>(mData + mBytes[1]); }
-    uint8_t* blindData() const { return reinterpret_cast<uint8_t*>(mData + mBytes[6]); }
+    uint64_t                     gridSize() const { return mBytes[7]; }
+    nanovdb::GridBlindMetaData*  blindMetaData() const { return reinterpret_cast<nanovdb::GridBlindMetaData*>(mData + mBytes[1]); }
+    uint8_t*                     blindData() const { return reinterpret_cast<uint8_t*>(mData + mBytes[6]); }
 
     /// @brief Private method used to cache the x compoment of a Coord into x and
     //         encode uint32_t id into the x component despite it being of type const int32_t.
@@ -168,8 +220,9 @@
     tbb::parallel_for(tbb::blocked_range<uint64_t>(0, array.size(), 16),
                       [&](const tbb::blocked_range<uint64_t>& r) {
                           uint64_t sum = 0;
-                          for (auto i = r.begin(); i != r.end(); ++i)
+                          for (auto i = r.begin(); i != r.end(); ++i) {
                               sum += array[i]->getLastValue();
+                          }
                           pointCount += sum;
                       });
     return pointCount;
@@ -223,14 +276,6 @@
 }
 
 template<typename SrcTreeT, typename BufferT>
-inline void
-OpenToNanoVDB<SrcTreeT, BufferT>::postProcessGrid(ChecksumMode mode)
-{
-    auto& data = *this->gridData();
-    data.mChecksum = nanovdb::checksum( *reinterpret_cast<const NanoGrid<ValueT>*>(mData), mode );
-}
-
-template<typename SrcTreeT, typename BufferT>
 template<typename LeafT>
 inline typename std::enable_if<std::is_same<typename LeafT::ValueType, openvdb::PointIndex32>::value>::type
 OpenToNanoVDB<SrcTreeT, BufferT>::postProcessPoints(std::vector<const LeafT*>& array)
@@ -242,13 +287,16 @@
     const uint32_t leafCount = static_cast<uint32_t>(array.size());
     auto*          data = this->template nodeData<DstNode0>();
 
-    data[0].mValueMin = 0; // start of prefix sum
-    for (uint32_t i = 1; i < leafCount; ++i)
-        data[i].mValueMin = data[i - 1].mValueMin + data[i - 1].mValueMax;
+    data[0].mMinimum = 0; // start of prefix sum
+    data[0].mMaximum = data[0].mValues[DstNode0::SIZE - 1u];
+    for (uint32_t i = 1; i < leafCount; ++i) {
+        data[i].mMinimum = data[i - 1].mMinimum + data[i - 1].mMaximum;
+        data[i].mMaximum = data[i].mValues[DstNode0::SIZE - 1u];
+    }
 
     // write point offsets as blind meta data
     auto b = *mBlindMetaData.cbegin();
-    assert(b.count == data[leafCount - 1].mValueMin + data[leafCount - 1].mValueMax);
+    assert(b.count == data[leafCount - 1].mMinimum + data[leafCount - 1].mMaximum);
     assert(b.name == "index" && b.typeName == "uint32");
     auto& meta = const_cast<nanovdb::GridBlindMetaData&>(this->gridData()->blindMetaData(0));
     meta.mByteOffset = uintptr_t(this->blindData()) - uintptr_t(this->gridData()); // offset from Grid to blind data;
@@ -268,7 +316,7 @@
     tbb::parallel_for(tbb::blocked_range<uint32_t>(0, array.size(), 16),
                       [&](const tbb::blocked_range<uint32_t>& r) {
                           for (auto i = r.begin(); i != r.end(); ++i) {
-                              uint32_t* p = points + data[i].mValueMin;
+                              uint32_t* p = points + data[i].mMinimum;
                               for (uint32_t idx : array[i]->indices())
                                   *p++ = idx;
                           }
@@ -285,14 +333,17 @@
     const uint32_t leafCount = array.size();
     auto*          data = this->template nodeData<DstNode0>();
 
-    data[0].mValueMin = 0; // start of prefix sum
-    for (uint32_t i = 1; i < leafCount; ++i)
-        data[i].mValueMin = data[i - 1].mValueMin + data[i - 1].mValueMax;
+    data[0].mMinimum = 0; // start of prefix sum
+    data[0].mMaximum = data[0].mValues[LeafT::SIZE - 1];
+    for (uint32_t i = 1; i < leafCount; ++i) {
+        data[i].mMinimum = data[i - 1].mMinimum + data[i - 1].mMaximum;
+        data[i].mMaximum = data[i].mValues[LeafT::SIZE - 1];
+    }
 
     // write point coordinates as blind meta data
     size_t byteOffset = uintptr_t(this->blindData()) - uintptr_t(this->gridData()); // offset from Grid to blind data;
     for (auto& b : mBlindMetaData) {
-        assert(b.count == data[leafCount - 1].mValueMin + data[leafCount - 1].mValueMax);
+        assert(b.count == data[leafCount - 1].mMinimum + data[leafCount - 1].mMaximum);
         auto& meta = const_cast<nanovdb::GridBlindMetaData&>(this->gridData()->blindMetaData(static_cast<uint32_t>(b.index)));
         meta.mByteOffset = byteOffset; // offset from Grid to blind data
         byteOffset += b.size;
@@ -316,7 +367,7 @@
                                       for (auto i = r.begin(); i != r.end(); ++i) {
                                           auto*                               leaf = array[i];
                                           openvdb::points::AttributeHandle<T> posHandle(leaf->constAttributeArray(b.index));
-                                          T*                                  p = ptr + data[i].mValueMin;
+                                          T*                                  p = ptr + data[i].mMinimum;
                                           for (auto iter = leaf->beginIndexOn(); iter; ++iter) {
                                               const auto ijk = iter.getCoord();
                                               assert(leaf->isValueOn(ijk));
@@ -339,7 +390,7 @@
                                       for (auto i = r.begin(); i != r.end(); ++i) {
                                           auto*                               leaf = array[i];
                                           openvdb::points::AttributeHandle<T> posHandle(leaf->constAttributeArray(b.index));
-                                          T*                                  p = ptr + data[i].mValueMin;
+                                          T*                                  p = ptr + data[i].mMinimum;
                                           for (auto iter = leaf->beginIndexOn(); iter; ++iter)
                                               *p++ = posHandle.get(*iter);
                                       }
@@ -359,7 +410,42 @@
                                   for (auto i = r.begin(); i != r.end(); ++i) {
                                       auto*                               leaf = array[i];
                                       openvdb::points::AttributeHandle<T> posHandle(leaf->constAttributeArray(b.index));
-                                      T*                                  p = ptr + data[i].mValueMin;
+                                      T*                                  p = ptr + data[i].mMinimum;
+                                      for (auto iter = leaf->beginIndexOn(); iter; ++iter)
+                                          *p++ = posHandle.get(*iter);
+                                  }
+                              });
+        } else if (b.typeName == "int64") {
+            meta.mDataType = GridType::Int64;
+            if (b.name == "id") {
+                meta.mSemantic = GridBlindDataSemantic::PointId;
+            } else {
+                meta.mSemantic = GridBlindDataSemantic::Unknown;
+            }
+            using T = int64_t;
+            T* ptr = reinterpret_cast<T*>(mData + meta.mByteOffset);
+            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, array.size(), 16),
+                              [&](const tbb::blocked_range<uint64_t>& r) {
+                                  for (auto i = r.begin(); i != r.end(); ++i) {
+                                      auto*                               leaf = array[i];
+                                      openvdb::points::AttributeHandle<T> posHandle(leaf->constAttributeArray(b.index));
+                                      T*                                  p = ptr + data[i].mMinimum;
+                                      for (auto iter = leaf->beginIndexOn(); iter; ++iter)
+                                          *p++ = posHandle.get(*iter);
+                                  }
+                              });
+        } else if (b.typeName == "float") {
+            meta.mDataType = GridType::Float;
+            meta.mSemantic = GridBlindDataSemantic::Unknown;
+
+            using T = float;
+            T* ptr = reinterpret_cast<T*>(mData + meta.mByteOffset);
+            tbb::parallel_for(tbb::blocked_range<uint64_t>(0, array.size(), 16),
+                              [&](const tbb::blocked_range<uint64_t>& r) {
+                                  for (auto i = r.begin(); i != r.end(); ++i) {
+                                      auto*                               leaf = array[i];
+                                      openvdb::points::AttributeHandle<T> posHandle(leaf->constAttributeArray(b.index));
+                                      T*                                  p = ptr + data[i].mMinimum;
                                       for (auto iter = leaf->beginIndexOn(); iter; ++iter)
                                           *p++ = posHandle.get(*iter);
                                   }
@@ -386,15 +472,29 @@
 
 template<typename SrcTreeT, typename BufferT>
 GridHandle<BufferT>
-OpenToNanoVDB<SrcTreeT, BufferT>::operator()(const openvdb::Grid<SrcTreeT>& srcGrid, bool mortonSort, int verbose, ChecksumMode mode, const BufferT& allocator)
+OpenToNanoVDB<SrcTreeT, BufferT>::operator()(const openvdb::Grid<SrcTreeT>& srcGrid,
+                                             StatsMode                      sMode,
+                                             ChecksumMode                   cMode,
+                                             bool                           mortonSort,
+                                             int                            verbose,
+                                             const BufferT&                 allocator)
 {
     openvdb::util::CpuTimer timer;
+    auto                    startTimer = [&](const std::string& s) {
+        if (verbose > 1) {
+            timer.start(s);
+        }
+    };
+    auto stopTimer = [&]() {
+        if (verbose > 1) {
+            timer.stop();
+        }
+    };
 
     const SrcTreeT& srcTree = srcGrid.tree();
     const SrcRootT& srcRoot = srcTree.root();
 
-    if (verbose > 1)
-        timer.start("Extracting nodes from openvdb grid");
+    startTimer("Extracting nodes from openvdb grid");
     std::vector<const SrcNode2*> array2; // upper OpenVDB internal nodes
     std::vector<const SrcNode1*> array1; // lower OpenVDB internal nodes
     std::vector<const SrcNode0*> array0; // OpenVDB leaf nodes
@@ -402,27 +502,22 @@
     tbb::parallel_invoke([&]() { srcTree.getNodes(array0); }, // multi-threaded population of node arrays from OpenVDB tree
                          [&]() { srcTree.getNodes(array1); },
                          [&]() { srcTree.getNodes(array2); });
-    if (verbose > 1)
-        timer.stop();
+    stopTimer();
 
     if (srcRoot.getTableSize() != array2.size())
         OPENVDB_THROW(openvdb::RuntimeError, "Tiles at the root level are not supported yet!");
 
     auto key = [](const CoordT& p) { return DstRootT::DataType::CoordToKey(p); };
 #ifdef USE_SINGLE_ROOT_KEY
-    if (verbose > 1)
-        timer.start("Sorting " + std::to_string(array2.size()) + " child nodes of the root node");
+    startTimer("Sorting " + std::to_string(array2.size()) + " child nodes of the root node");
     this->sortNodes(array2, key);
-    if (verbose > 1)
-        timer.stop();
+    stopTimer();
 #endif
     assert(std::is_sorted(array2.begin(), array2.end(), [&key](const SrcNode2* a, const SrcNode2* b) { return key(a->origin()) < key(b->origin()); }));
 
-    if (verbose > 1)
-        timer.start("Pre-processing points");
+    startTimer("Pre-processing points");
     this->preProcessPoints(array0);
-    if (verbose > 1)
-        timer.stop();
+    stopTimer();
 
     mBytes[0] = DstGridT::memUsage(); // grid + blind meta data
     mBytes[1] = DstTreeT::memUsage(); // tree
@@ -439,8 +534,7 @@
         mBytes[i] += mBytes[i - 1]; // Byte offsets to: tree, blindmetadata, root, node2, node1, leafs, blinddata, total
 
     if (mortonSort) { // Morton sorting of the leaf nodes is disabled by default since it has not been performance tested yet
-        if (verbose > 1)
-            timer.start("Morton sorting of " + std::to_string(array0.size()) + " leaf nodes");
+        startTimer("Morton sorting of " + std::to_string(array0.size()) + " leaf nodes");
         auto splitBy3 = [](int32_t i) {
             uint64_t x = uint32_t(i + 1000000000) & 0x1fffff; // offset to positive int and extract the first 21 bits
             x = (x | x << 32) & 0x1f00000000ffff;
@@ -452,19 +546,16 @@
         };
         auto key = [&splitBy3](const CoordT& p) { return splitBy3(p[0]) | splitBy3(p[1]) << 1 | splitBy3(p[2]) << 2; };
         this->sortNodes(array0, key);
-        if (verbose > 1)
-            timer.stop();
+        stopTimer();
     }
 
-    if (verbose > 1)
-        timer.start("Allocating memory for the NanoVDB");
+    startTimer("Allocating memory for the NanoVDB");
     GridHandle<BufferT> handle(allocator.create(this->gridSize()));
     mData = handle.data();
-    if (verbose > 1)
-        timer.stop();
+    stopTimer();
 
     if (verbose)
-        openvdb::util::printBytes(std::cerr, this->gridSize(), "Allocated", " for the NanoVDB\n");
+        openvdb::util::printBytes(std::cerr, this->gridSize(), "Allocated", " for the NanoVDB grid\n");
 
     if (srcGrid.getGridClass() == openvdb::GRID_LEVEL_SET) {
         mDelta = ValueT(srcGrid.voxelSize()[0]); // skip a node if max < -mDelta || min > mDelta
@@ -474,115 +565,86 @@
 
     std::unique_ptr<int32_t[]> cache0(new int32_t[array0.size()]); // cache for byte offsets to leaf nodes
 
-    if (verbose > 1)
-        timer.start("Processing leaf nodes");
+    startTimer("Processing leaf nodes");
     this->processLeafs(array0, cache0.get());
-    if (verbose > 1)
-        timer.stop();
+    stopTimer();
 
     std::unique_ptr<int32_t[]> cache1(new int32_t[array1.size()]); // cache for byte offsets to lower internal nodes
 
-    if (verbose > 1)
-        timer.start("Processing lower internal nodes");
+    startTimer("Processing lower internal nodes");
     this->processInternals<SrcNode1, DstNode1>(array1, cache1.get(), cache0.get());
-    if (verbose > 1)
-        timer.stop();
+    stopTimer();
 
     cache0.reset();
     std::unique_ptr<int32_t[]> cache2(new int32_t[array2.size()]); // cache for byte offsets to upper internal nodes
 
-    if (verbose > 1)
-        timer.start("Processing upper internal nodes");
+    startTimer("Processing upper internal nodes");
     this->processInternals<SrcNode2, DstNode2>(array2, cache2.get(), cache1.get());
-    if (verbose > 1)
-        timer.stop();
+    stopTimer();
 
     cache1.reset();
 
-    if (verbose > 1)
-        timer.start("Processing Root node");
+    startTimer("Processing Root node");
     this->processRoot(srcTree.root(), array2, cache2.get());
-    if (verbose > 1)
-        timer.stop();
+    stopTimer();
 
     cache2.reset();
 
-    if (verbose > 1)
-        timer.start("Processing Tree");
+    startTimer("Processing Tree");
     const uint64_t nodeCount[4] = {array0.size(), array1.size(), array2.size(), 1};
     this->processTree(nodeCount);
-    if (verbose > 1)
-        timer.stop();
+    stopTimer();
 
-    if (verbose > 1)
-        timer.start("Processing Grid");
+    startTimer("Processing Grid");
     this->processGrid(srcGrid);
-    if (verbose > 1)
-        timer.stop();
+    stopTimer();
 
-    if (verbose > 1)
-        timer.start("Post-processing points");
+    startTimer("Post-processing points");
     this->postProcessPoints(array0);
-    if (verbose > 1)
-        timer.stop();
+    stopTimer();
+
+    using NanoValueT = typename TypeConverter<ValueT>::Type;
+    auto* nanoGrid = reinterpret_cast<NanoGrid<NanoValueT>*>(mData);
 
-    if (verbose > 1)
-        timer.start("Post-processing Grid");
-    this->postProcessGrid(mode);
-    if (verbose > 1)
-        timer.stop();
+    // Since point grids already mde use of min/max we should not re-compute them
+    if (std::is_same<ValueT, openvdb::PointIndex32>::value ||
+        std::is_same<ValueT, openvdb::PointDataIndex32>::value)
+        sMode = StatsMode::BBox;
+
+    startTimer("GridStats");
+    gridStats(*nanoGrid, sMode);
+    stopTimer();
+
+    startTimer("Checksum");
+    updateChecksum(*nanoGrid, cMode);
+    stopTimer();
 
     mData = nullptr;
-    return handle;// envokes mode constructor
+    return handle; // envokes move constructor
 } // operator()
 
 template<typename SrcTreeT, typename BufferT>
 void OpenToNanoVDB<SrcTreeT, BufferT>::
     processLeafs(std::vector<const SrcNode0*>& array, int32_t* x0)
 {
-    mActiveVoxelCount = 0;
-    auto* start = this->template nodeData<DstNode0>(); // address of first leaf node
-    auto  op = [&](const tbb::blocked_range<uint32_t>& r) {
+    DstNode0* firstLeaf = this->template node<DstNode0>(); // address of first leaf node
+    auto      op = [&](const tbb::blocked_range<uint32_t>& r) {
         int32_t* x = x0 + r.begin();
-        uint64_t sum = 0;
-        auto*    data = start + r.begin();
-        for (auto i = r.begin(); i != r.end(); ++i, ++data) {
+        auto*    dstLeaf = firstLeaf + r.begin();
+        for (auto i = r.begin(); i != r.end(); ++i, ++dstLeaf) {
             const SrcNode0* srcLeaf = array[i];
-            sum += srcLeaf->onVoxelCount();
-            data->mValueMask = srcLeaf->valueMask();
+            auto*           data = dstLeaf->data();
+            data->mValueMask = srcLeaf->valueMask(); // copy value mask
+            data->mBBoxMin = srcLeaf->origin(); // copy origin of node
             const ValueT* src = srcLeaf->buffer().data();
             for (ValueT *dst = data->mValues, *end = dst + SrcNode0::size(); dst != end; dst += 4, src += 4) {
-                dst[0] = src[0];
+                dst[0] = src[0]; // copy *all* voxel values in sets of four, i.e. loop-unrolling
                 dst[1] = src[1];
                 dst[2] = src[2];
                 dst[3] = src[3];
             }
-            auto iter = srcLeaf->cbeginValueOn();
-            // Since min, max and bbox are derived from active values they are required at the leaf level!
-            if (!iter) {
-                OPENVDB_THROW(openvdb::RuntimeError, "Expected at least one active voxel in every leaf node! Hint: try pruneInactive.");
-            }
-            data->mValueMin = *iter, data->mValueMax = data->mValueMin;
-            openvdb::CoordBBox bbox;
-            bbox.expand(srcLeaf->offsetToLocalCoord(iter.pos()));
-            for (++iter; iter; ++iter) {
-                bbox.expand(srcLeaf->offsetToLocalCoord(iter.pos()));
-                const ValueT& v = *iter;
-                if (v < data->mValueMin) {
-                    data->mValueMin = v;
-                } else if (v > data->mValueMax) {
-                    data->mValueMax = v;
-                }
-            }
-            this->setFlag(data->mValueMin, data->mValueMax, data->mFlags);
-            bbox.translate(srcLeaf->origin());
-            data->mBBoxMin = bbox.min();
-            data->mBBoxDif[0] = uint8_t(bbox.max()[0] - bbox.min()[0]);
-            data->mBBoxDif[1] = uint8_t(bbox.max()[1] - bbox.min()[1]);
-            data->mBBoxDif[2] = uint8_t(bbox.max()[2] - bbox.min()[2]);
             cache(*x++, srcLeaf->origin(), i);
         }
-        mActiveVoxelCount += sum;
     };
     tbb::parallel_for(tbb::blocked_range<uint32_t>(0, static_cast<uint32_t>(array.size()), 8), op);
 } // processLeafs
@@ -592,16 +654,14 @@
 void OpenToNanoVDB<SrcTreeT, BufferT>::
     processInternals(std::vector<const SrcNode*>& array, int32_t* x0, const int32_t* childX)
 {
-    using SrcChildT = typename SrcNode::ChildNodeType;
     const uint32_t size = static_cast<uint32_t>(array.size());
     auto*          start = this->template nodeData<DstNode>();
     auto           op = [&](const tbb::blocked_range<size_t>& r) {
         int32_t* x = x0 + r.begin();
         auto*    data = start + r.begin();
-        uint64_t sum = 0;
         for (auto i = r.begin(); i != r.end(); ++i, ++data) {
             const SrcNode* srcNode = array[i];
-            sum += SrcChildT::NUM_VOXELS * srcNode->getValueMask().countOn();
+            data->mBBox.min() = srcNode->origin();
             cache(*x++, srcNode->origin(), i);
             data->mOffset = size - i;
             data->mValueMask = srcNode->getValueMask();
@@ -609,55 +669,12 @@
             for (auto iter = srcNode->cbeginValueAll(); iter; ++iter) {
                 data->mTable[iter.pos()].value = *iter;
             }
-            auto onValIter = srcNode->cbeginValueOn();
-            auto childIter = srcNode->cbeginChildOn();
-            if (onValIter) {
-                data->mValueMin = *onValIter;
-                data->mValueMax = data->mValueMin;
-                const CoordT &ijk = onValIter.getCoord();
-                data->mBBox[0] = ijk;
-                data->mBBox[1] = ijk.offsetBy(SrcChildT::DIM - 1);
-                ++onValIter;
-            } else if (childIter) {
+            for (auto childIter = srcNode->cbeginChildOn(); childIter; ++childIter) {
                 const auto childID = static_cast<uint32_t>(childIter->origin()[0]);
                 data->mTable[childIter.pos()].childID = childID;
-                const_cast<CoordT&>(childIter->origin())[0] = childX[childID];
-                auto* dstChild = data->child(childIter.pos());
-                data->mValueMin = dstChild->valueMin();
-                data->mValueMax = dstChild->valueMax();
-                data->mBBox = dstChild->bbox();
-                ++childIter;
-            } else {
-                OPENVDB_THROW(openvdb::RuntimeError, "Internal node with no children or active values! Hint: try pruneInactive.");
-            }
-            for (; onValIter; ++onValIter) { // typically there are few active tiles
-                const auto& value = *onValIter;
-                if (value < data->mValueMin) {
-                    data->mValueMin = value;
-                } else if (value > data->mValueMax) {
-                    data->mValueMax = value;
-                }
-                const CoordT &ijk = onValIter.getCoord();
-                data->mBBox.min().minComponent(ijk);
-                data->mBBox.max().maxComponent(ijk.offsetBy(SrcChildT::DIM - 1));
+                const_cast<CoordT&>(childIter->origin())[0] = childX[childID]; // restore origin
             }
-            for (; childIter; ++childIter) {
-                const auto n = childIter.pos();
-                const auto childID = static_cast<uint32_t>(childIter->origin()[0]);
-                data->mTable[n].childID = childID;
-                const_cast<CoordT&>(childIter->origin())[0] = childX[childID];
-                auto* dstChild = data->child(n);
-                if (dstChild->valueMin() < data->mValueMin)
-                    data->mValueMin = dstChild->valueMin();
-                if (dstChild->valueMax() > data->mValueMax)
-                    data->mValueMax = dstChild->valueMax();
-                const auto& bbox = dstChild->bbox();
-                data->mBBox.min().minComponent(bbox.min());
-                data->mBBox.max().maxComponent(bbox.max());
-            }
-            this->setFlag(data->mValueMin, data->mValueMax, data->mFlags);
         }
-        mActiveVoxelCount += sum;
     };
     tbb::parallel_for(tbb::blocked_range<size_t>(0, array.size(), 4), op);
 } // processInternals
@@ -666,59 +683,36 @@
 void OpenToNanoVDB<SrcTreeT, BufferT>::
     processRoot(const SrcRootT& srcRoot, std::vector<const SrcNode2*>& array, const int32_t* childX)
 {
-    using SrcChildT = typename SrcRootT::ChildNodeType;
     auto& data = *(this->template nodeData<DstRootT>());
     data.mBackground = srcRoot.background();
     data.mTileCount = srcRoot.getTableSize();
+    data.mMinimum = data.mMaximum = data.mBackground;
+    data.mBBox.min() = openvdb::Coord::max(); // set to an empty bounding box
+    data.mBBox.max() = openvdb::Coord::min();
+    data.mActiveVoxelCount = 0;
+
     // since openvdb::RootNode internally uses a std::map for child nodes its iterator
     // visits elements in the stored order required by the nanovdb::RootNode
-    if (data.mTileCount == 0) { // empty root node
-        data.mValueMin = data.mValueMax = data.mBackground;
-        data.mBBox.min() = openvdb::Coord::max(); // set to an empty bounding box
-        data.mBBox.max() = openvdb::Coord::min();
-        data.mActiveVoxelCount = 0;
-    } else {
+    if (data.mTileCount > 0) {
         auto*      node = array[0];
         auto&      tile = data.tile(0);
         const auto childID = static_cast<uint32_t>(node->origin()[0]);
         const_cast<CoordT&>(node->origin())[0] = childX[childID]; // restore cached coordinate
         tile.setChild(node->origin(), childID);
-        auto& dstChild = data.child(tile);
-        data.mValueMin = dstChild.valueMin();
-        data.mValueMax = dstChild.valueMax();
-        data.mBBox = dstChild.bbox();
         for (uint32_t i = 1, n = static_cast<uint32_t>(array.size()); i < n; ++i) {
             node = array[i];
             auto&      tile = data.tile(i);
             const auto childID = static_cast<uint32_t>(node->origin()[0]);
             const_cast<openvdb::Coord&>(node->origin())[0] = childX[childID]; // restore cached coordinate
             tile.setChild(node->origin(), childID);
-            auto& dstChild = data.child(tile);
-            if (dstChild.valueMin() < data.mValueMin)
-                data.mValueMin = dstChild.valueMin();
-            if (dstChild.valueMax() > data.mValueMax)
-                data.mValueMax = dstChild.valueMax();
-            data.mBBox.min().minComponent(dstChild.bbox().min());
-            data.mBBox.max().maxComponent(dstChild.bbox().max());
         }
         for (auto iter = srcRoot.cbeginValueAll(); iter; ++iter) {
-            OPENVDB_THROW(openvdb::RuntimeError, "Tiles at the root node is broken and need to be fixed!");
+            OPENVDB_THROW(openvdb::RuntimeError, "Tiles at the root node is broken and needs to be fixed!");
             auto& tile = data.tile(iter.pos());
             tile.setValue(iter.getCoord(), iter.isValueOn(), *iter);
-            if (iter.isValueOn()) {
-                if (tile.value < data.mValueMin) {
-                    data.mValueMin = tile.value;
-                } else if (tile.value > data.mValueMax) {
-                    data.mValueMax = tile.value;
-                }
-                mActiveVoxelCount += SrcChildT::NUM_VOXELS;
-                data.mBBox.min().minComponent(iter.getCoord());
-                data.mBBox.max().maxComponent(iter.getCoord().offsetBy(SrcNode2::DIM - 1));
-            }
         }
-        data.mActiveVoxelCount = mActiveVoxelCount;
     }
-}// processRoot
+} // processRoot
 
 template<typename SrcTreeT, typename BufferT>
 void OpenToNanoVDB<SrcTreeT, BufferT>::
@@ -731,6 +725,9 @@
         data.mCount[i] = static_cast<uint32_t>(count[i]);
         data.mBytes[i] = mBytes[5 - i] - mBytes[0]; // offset from the tree to the first node at each tree level
     }
+    data.mPFSum[3] = 0;
+    for (int i = 2; i >= 0; --i)
+        data.mPFSum[i] = data.mPFSum[i + 1] + data.mCount[i + 1]; // reverse prefix sum
 }
 
 template<typename SrcTreeT, typename BufferT>
@@ -742,14 +739,14 @@
     auto  affineMap = srcGrid.transform().baseMap()->getAffineMap();
     auto& data = *this->gridData();
     data.mMagic = NANOVDB_MAGIC_NUMBER;
+    data.mChecksum = 0u;
     data.mMajor = NANOVDB_MAJOR_VERSION_NUMBER;
+    data.mFlags = 0u;
     data.mGridSize = this->gridSize();
-    data.setFlagsOff();
-    data.setMinMax(true);
-    data.setBBox(true);
-    data.mBlindMetadataOffset = mBlindMetaData.size()?mBytes[1]:0;
+    data.mWorldBBox = BBox<Vec3R>();
+    data.mBlindMetadataOffset = mBlindMetaData.size() ? mBytes[1] : 0;
     data.mBlindMetadataCount = static_cast<uint32_t>(mBlindMetaData.size());
-    { // set grid name
+    { /// @todo allow long loger grid names by encoding it as blind meta data!
         const std::string name = srcGrid.getName();
         if (name.length() + 1 > nanovdb::GridData::MaxNameSize) {
             std::stringstream ss;
@@ -797,23 +794,15 @@
         OPENVDB_THROW(openvdb::ValueError, "Unsupported value type");
     }
     { // set affine map
-        if (srcGrid.hasUniformVoxels())
+        if (srcGrid.hasUniformVoxels()) {
             data.mVoxelSize = nanovdb::Vec3R(affineMap->voxelSize()[0]);
-        else
+        } else {
             data.mVoxelSize = affineMap->voxelSize();
+        }
         const auto mat = affineMap->getMat4();
         // Only support non-tapered at the moment:
         data.mMap.set(mat, mat.inverse(), 1.0);
     }
-    { // set world space AABB
-        auto& rootData = *(this->template nodeData<DstRootT>()); 
-        const openvdb::Vec3R                      min(&(rootData.mBBox.min()[0]));
-        const openvdb::Vec3R                      max(&(rootData.mBBox.max()[0]));
-        const openvdb::math::BBox<openvdb::Vec3R> bboxIndex(min, max);
-        const auto                                bboxWorld = bboxIndex.applyMap(*srcGrid.transform().baseMap());
-        data.mWorldBBox.min() = bboxWorld.min();
-        data.mWorldBBox.max() = bboxWorld.max();
-    }
 }
 
 template<typename SrcTreeT, typename BufferT>
@@ -850,32 +839,40 @@
 
 template<typename BufferT, typename SrcTreeT>
 GridHandle<BufferT>
-openToNanoVDB(const openvdb::Grid<SrcTreeT>& grid, bool mortonSort, int verbose, ChecksumMode mode)
+openToNanoVDB(const openvdb::Grid<SrcTreeT>& grid,
+              StatsMode                      sMode,
+              ChecksumMode                   cMode,
+              bool                           mortonSort,
+              int                            verbose)
 {
     OpenToNanoVDB<SrcTreeT, BufferT> s;
-    return s(grid, mortonSort, verbose, mode);
+    return s(grid, sMode, cMode, mortonSort, verbose);
 }
 
 template<typename BufferT>
 GridHandle<BufferT>
-openToNanoVDB(const openvdb::GridBase::Ptr& base, bool mortonSort, int verbose, ChecksumMode mode)
+openToNanoVDB(const openvdb::GridBase::Ptr& base,
+              StatsMode                     sMode,
+              ChecksumMode                  cMode,
+              bool                          mortonSort,
+              int                           verbose)
 {
     if (auto grid = openvdb::GridBase::grid<openvdb::FloatGrid>(base)) {
-        return openToNanoVDB<BufferT, openvdb::FloatTree>(*grid, mortonSort, verbose, mode);
+        return openToNanoVDB<BufferT, openvdb::FloatTree>(*grid, sMode, cMode, mortonSort, verbose);
     } else if (auto grid = openvdb::GridBase::grid<openvdb::DoubleGrid>(base)) {
-        return nanovdb::openToNanoVDB<BufferT, openvdb::DoubleTree>(*grid, mortonSort, verbose, mode);
+        return nanovdb::openToNanoVDB<BufferT, openvdb::DoubleTree>(*grid, sMode, cMode, mortonSort, verbose);
     } else if (auto grid = openvdb::GridBase::grid<openvdb::Int32Grid>(base)) {
-        return nanovdb::openToNanoVDB<BufferT, openvdb::Int32Tree>(*grid, mortonSort, verbose, mode);
+        return nanovdb::openToNanoVDB<BufferT, openvdb::Int32Tree>(*grid, sMode, cMode, mortonSort, verbose);
     } else if (auto grid = openvdb::GridBase::grid<openvdb::Int64Grid>(base)) {
-        return nanovdb::openToNanoVDB<BufferT, openvdb::Int64Tree>(*grid, mortonSort, verbose, mode);
-     } else if (auto grid = openvdb::GridBase::grid<openvdb::Grid<openvdb::UInt32Tree>>(base)) {
-        return nanovdb::openToNanoVDB<BufferT, openvdb::UInt32Tree>(*grid, mortonSort, verbose, mode);
+        return nanovdb::openToNanoVDB<BufferT, openvdb::Int64Tree>(*grid, sMode, cMode, mortonSort, verbose);
+    } else if (auto grid = openvdb::GridBase::grid<openvdb::Grid<openvdb::UInt32Tree>>(base)) {
+        return nanovdb::openToNanoVDB<BufferT, openvdb::UInt32Tree>(*grid, sMode, cMode, mortonSort, verbose);
     } else if (auto grid = openvdb::GridBase::grid<openvdb::Vec3fGrid>(base)) {
-        return nanovdb::openToNanoVDB<BufferT, openvdb::Vec3fTree>(*grid, mortonSort, verbose, mode);
+        return nanovdb::openToNanoVDB<BufferT, openvdb::Vec3fTree>(*grid, sMode, cMode, mortonSort, verbose);
     } else if (auto grid = openvdb::GridBase::grid<openvdb::Vec3dGrid>(base)) {
-        return nanovdb::openToNanoVDB<BufferT, openvdb::Vec3dTree>(*grid, mortonSort, verbose, mode);
+        return nanovdb::openToNanoVDB<BufferT, openvdb::Vec3dTree>(*grid, sMode, cMode, mortonSort, verbose);
     } else if (auto grid = openvdb::GridBase::grid<openvdb::points::PointDataGrid>(base)) {
-        return nanovdb::openToNanoVDB<BufferT, openvdb::points::PointDataTree>(*grid, mortonSort, verbose, mode);
+        return nanovdb::openToNanoVDB<BufferT, openvdb::points::PointDataTree>(*grid, sMode, cMode, mortonSort, verbose);
     } else {
         OPENVDB_THROW(openvdb::RuntimeError, "Unrecognized OpenVDB grid type");
     }
diff -aur nanovdb-20200925/nanovdb/nanovdb/util/Ray.h nanovdb-20201022/nanovdb/nanovdb/util/Ray.h
--- nanovdb-20200925/nanovdb/nanovdb/util/Ray.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/nanovdb/util/Ray.h	2020-10-22 03:52:50.000000000 +0200
@@ -150,11 +150,14 @@
     __hostdev__ bool test(RealT time) const { return mTimeSpan.test(time); }
 
     /// @brief Return a new Ray that is transformed with the specified map.
+    ///
     /// @param map  the map from which to construct the new Ray.
+    ///
     /// @warning Assumes a linear map and a normalized direction.
+    ///
     /// @details The requirement that the direction is normalized
-    /// follows from the transformation of t0 and t1 - and that fact that
-    /// we want applyMap and applyInverseMap to be inverse operations.
+    ///          follows from the transformation of t0 and t1 - and that fact that
+    ///          we want applyMap and applyInverseMap to be inverse operations.
     template<typename MapType>
     __hostdev__ Ray applyMap(const MapType& map) const
     {
@@ -162,8 +165,9 @@
         const Vec3T dir = map.applyJacobian(mDir);
         const RealT length = dir.length(), invLength = RealT(1) / length;
         RealT       t1 = mTimeSpan.t1;
-        if (mTimeSpan.t1 < Maximum<RealT>::value())
+        if (mTimeSpan.t1 < Maximum<RealT>::value()) {
             t1 *= length;
+        }
         return Ray(eye, dir * invLength, length * mTimeSpan.t0, t1);
     }
     template<typename MapType>
@@ -173,17 +177,21 @@
         const Vec3T dir = map.applyJacobianF(mDir);
         const RealT length = dir.length(), invLength = RealT(1) / length;
         RealT       t1 = mTimeSpan.t1;
-        if (mTimeSpan.t1 < Maximum<RealT>::value())
+        if (mTimeSpan.t1 < Maximum<RealT>::value()) {
             t1 *= length;
+        }
         return Ray(eye, dir * invLength, length * mTimeSpan.t0, t1);
     }
 
     /// @brief Return a new Ray that is transformed with the inverse of the specified map.
+    ///
     /// @param map  the map from which to construct the new Ray by inverse mapping.
+    ///
     /// @warning Assumes a linear map and a normalized direction.
+    ///
     /// @details The requirement that the direction is normalized
-    /// follows from the transformation of t0 and t1 - and that fact that
-    /// we want applyMap and applyInverseMap to be inverse operations.
+    ///          follows from the transformation of t0 and t1 - and that fact that
+    ///          we want applyMap and applyInverseMap to be inverse operations.
     template<typename MapType>
     __hostdev__ Ray applyInverseMap(const MapType& map) const
     {
@@ -202,7 +210,7 @@
     }
 
     /// @brief Return a new ray in world space, assuming the existing
-    /// ray is represented in the index space of the specified grid.
+    ///        ray is represented in the index space of the specified grid.
     template<typename GridType>
     __hostdev__ Ray indexToWorldF(const GridType& grid) const
     {
@@ -210,13 +218,14 @@
         const Vec3T dir = grid.indexToWorldDirF(mDir);
         const RealT length = dir.length(), invLength = RealT(1) / length;
         RealT       t1 = mTimeSpan.t1;
-        if (mTimeSpan.t1 < Maximum<RealT>::value())
+        if (mTimeSpan.t1 < Maximum<RealT>::value()) {
             t1 *= length;
+        }
         return Ray(eye, dir * invLength, length * mTimeSpan.t0, t1);
     }
 
     /// @brief Return a new ray in index space, assuming the existing
-    /// ray is represented in the world space of the specified grid.
+    ///        ray is represented in the world space of the specified grid.
     template<typename GridType>
     __hostdev__ Ray worldToIndexF(const GridType& grid) const
     {
@@ -224,23 +233,21 @@
         const Vec3T dir = grid.worldToIndexDirF(mDir);
         const RealT length = dir.length(), invLength = RealT(1) / length;
         RealT       t1 = mTimeSpan.t1;
-        if (mTimeSpan.t1 < Maximum<RealT>::value())
+        if (mTimeSpan.t1 < Maximum<RealT>::value()) {
             t1 *= length;
+        }
         return Ray(eye, dir * invLength, length * mTimeSpan.t0, t1);
     }
 
-    /// @brief Return a new ray in the index space of the specified
-    /// grid, assuming the existing ray is represented in world space.
-    //template<typename GridType>
-    //__hostdev__  Ray worldToIndex(const GridType& grid) const { return this->applyInverseMap(grid); }
-
     /// @brief Return true if this ray intersects the specified sphere.
+    ///
     /// @param center The center of the sphere in the same space as this ray.
     /// @param radius The radius of the sphere in the same units as this ray.
     /// @param t0     The first intersection point if an intersection exists.
     /// @param t1     The second intersection point if an intersection exists.
+    ///
     /// @note If the return value is true, i.e. a hit, and t0 =
-    /// this->t0() or t1 == this->t1() only one true intersection exist.
+    ///       this->t0() or t1 == this->t1() only one true intersection exist.
     __hostdev__ bool intersects(const Vec3T& center, RealT radius, RealT& t0, RealT& t1) const
     {
         const Vec3T origin = mEye - center;
@@ -249,9 +256,9 @@
         const RealT C = origin.lengthSqr() - radius * radius;
         const RealT D = B * B - 4 * A * C;
 
-        if (D < 0)
+        if (D < 0) {
             return false;
-
+        }
         const RealT Q = RealT(-0.5) * (B < 0 ? (B + Sqrt(D)) : (B - Sqrt(D)));
 
         t0 = Q / A;
@@ -262,14 +269,17 @@
             t0 = t1;
             t1 = tmp;
         }
-        if (t0 < mTimeSpan.t0)
+        if (t0 < mTimeSpan.t0) {
             t0 = mTimeSpan.t0;
-        if (t1 > mTimeSpan.t1)
+        }
+        if (t1 > mTimeSpan.t1) {
             t1 = mTimeSpan.t1;
+        }
         return t0 <= t1;
     }
 
     /// @brief Return true if this ray intersects the specified sphere.
+    ///
     /// @param center The center of the sphere in the same space as this ray.
     /// @param radius The radius of the sphere in the same units as this ray.
     __hostdev__ bool intersects(const Vec3T& center, RealT radius) const
@@ -279,27 +289,29 @@
     }
 
     /// @brief Return true if this ray intersects the specified sphere.
+    ///
     /// @note For intersection this ray is clipped to the two intersection points.
+    ///
     /// @param center The center of the sphere in the same space as this ray.
     /// @param radius The radius of the sphere in the same units as this ray.
     __hostdev__ bool clip(const Vec3T& center, RealT radius)
     {
         RealT      t0, t1;
         const bool hit = this->intersects(center, radius, t0, t1);
-        if (hit)
+        if (hit) {
             mTimeSpan.set(t0, t1);
+        }
         return hit;
-        //return this->intersects(center, radius, mTimeSpan.t0, mTimeSpan.t1);
     }
-
+#if 0
     /// @brief Return true if the Ray intersects the specified
-    /// axisaligned bounding box.
+    ///        axisaligned bounding box.
+    ///
     /// @param bbox Axis-aligned bounding box in the same space as the Ray.
     /// @param t0   If an intersection is detected this is assigned
     ///             the time for the first intersection point.
     /// @param t1   If an intersection is detected this is assigned
     ///             the time for the second intersection point.
-#if 0    
     template<typename BBoxT>
     __hostdev__  bool intersects(const BBoxT& bbox, RealT& t0, RealT& t1) const
     {
@@ -309,14 +321,14 @@
         t1       = (bbox[1-mSign[0]][0] - mEye[0]) * mInvDir[0];
         RealT t3 = (bbox[  mSign[1]][1] - mEye[1]) * mInvDir[1];
         if (t3 > t1) return false;
-        if (t3 > t0) t0 = t3; 
+        if (t3 > t0) t0 = t3;
         if (t2 < t1) t1 = t2;
         t3 = (bbox[  mSign[2]][2] - mEye[2]) * mInvDir[2];
-        if (t3 > t1) return false; 
+        if (t3 > t1) return false;
         t2 = (bbox[1-mSign[2]][2] - mEye[2]) * mInvDir[2];
-        if (t0 > t2) return false; 
+        if (t0 > t2) return false;
         if (t3 > t0) t0 = t3;
-        if (mTimeSpan.t1 < t0) return false; 
+        if (mTimeSpan.t1 < t0) return false;
         if (t2 < t1) t1 = t2;
         if (mTimeSpan.t0 > t1) return false;
         if (mTimeSpan.t0 > t0) t0 = mTimeSpan.t0;
@@ -337,8 +349,8 @@
             if (a > t0) t0 = a;
             if (b < t1) t1 = b;
             if (t0 > t1) {
-                //if (gVerbose) printf("Missed BBOX: (%i,%i,%i) -> (%i,%i,%i) t0=%f t1=%f\n", 
-                //                     bbox.min()[0], bbox.min()[1], bbox.min()[2], 
+                //if (gVerbose) printf("Missed BBOX: (%i,%i,%i) -> (%i,%i,%i) t0=%f t1=%f\n",
+                //                     bbox.min()[0], bbox.min()[1], bbox.min()[2],
                 //                     bbox.max()[0], bbox.max()[1], bbox.max()[2], t0, t1);
                 return false;
             }
@@ -348,27 +360,66 @@
         */
     }
 #else
+    /// @brief Returns true if this ray intersects an index bounding box.
+    ///        If the return value is true t0 and t1 are set to the intersection
+    ///        times along the ray.
+    ///
+    /// @warning Intersection with a CoordBBox internally converts to a floating-point bbox
+    ///          which imples that the max is padded with one voxel, i.e. bbox.max += 1! This
+    ///          avoids gaps between neighboring CoordBBox'es, say from neighboring tree nodes.
     __hostdev__ bool intersects(const CoordBBox& bbox, RealT& t0, RealT& t1) const
     {
-        return this->intersects(bbox.asReal<RealT>(), t0, t1);
+        mTimeSpan.get(t0, t1);
+        for (int i = 0; i < 3; ++i) {
+            RealT a = RealT(bbox.min()[i]), b = RealT(bbox.max()[i] + 1);
+            if (a >= b) { // empty bounding box
+                return false;
+            } 
+            a = (a - mEye[i]) * mInvDir[i];
+            b = (b - mEye[i]) * mInvDir[i];
+            if (a > b) {
+                RealT tmp = a;
+                a = b;
+                b = tmp;
+            }
+            if (a > t0) {
+                t0 = a;
+            }
+            if (b < t1) {
+                t1 = b;
+            }
+            if (t0 > t1) {
+                return false;
+            }
+        }
+        return true;
     }
-
-    template<typename BBoxT>
-    __hostdev__ bool intersects(const BBoxT& bbox, RealT& t0, RealT& t1) const
+    /// @brief Returns true if this ray intersects a floating-point bounding box.
+    ///        If the return value is true t0 and t1 are set to the intersection
+    ///        times along the ray.
+    template<typename OtherVec3T>
+    __hostdev__ bool intersects(const BBox<OtherVec3T>& bbox, RealT& t0, RealT& t1) const
     {
+        static_assert(is_floating_point<typename OtherVec3T::ValueType>::value, "Ray::intersects: Expected a floating point coordinate");
         mTimeSpan.get(t0, t1);
         for (int i = 0; i < 3; ++i) {
-            RealT a = (bbox.min()[i] - mEye[i]) * mInvDir[i];
-            RealT b = (bbox.max()[i] - mEye[i]) * mInvDir[i];
+            RealT a = RealT(bbox.min()[i]), b = RealT(bbox.max()[i]);
+            if (a >= b) { // empty bounding box
+                return false;
+            }
+            a = (a - mEye[i]) * mInvDir[i];
+            b = (b - mEye[i]) * mInvDir[i];
             if (a > b) {
                 RealT tmp = a;
                 a = b;
                 b = tmp;
             }
-            if (a > t0)
+            if (a > t0) {
                 t0 = a;
-            if (b < t1)
+            }
+            if (b < t1) {
                 t1 = b;
+            }
             if (t0 > t1) {
                 return false;
             }
@@ -378,7 +429,13 @@
 #endif
 
     /// @brief Return true if this ray intersects the specified bounding box.
+    ///
     /// @param bbox Axis-aligned bounding box in the same space as this ray.
+    ///
+    /// @warning If @a bbox is of the type CoordBBox it is converted to a floating-point
+    ///          bounding box, which imples that the max is padded with one voxel, i.e.
+    ///          bbox.max += 1! This avoids gaps between neighboring CoordBBox'es, say
+    ///          from neighboring tree nodes.
     template<typename BBoxT>
     __hostdev__ bool intersects(const BBoxT& bbox) const
     {
@@ -415,35 +472,45 @@
     }
 
     /// @brief Return true if this ray intersects the specified bounding box.
-    /// @note For intersection this ray is clipped to the two intersection points.
+    ///
+    /// @note For intersection this ray is clipped to the two intersection points
+    ///.
     /// @param bbox Axis-aligned bounding box in the same space as this ray.
+    ///
+    /// @warning If @a bbox is of the type CoordBBox it is converted to a floating-point
+    ///          bounding box, which imples that the max is padded with one voxel, i.e.
+    ///          bbox.max += 1! This avoids gaps between neighboring CoordBBox'es, say
+    ///          from neighboring tree nodes.
     template<typename BBoxT>
     __hostdev__ bool clip(const BBoxT& bbox)
     {
         RealT      t0, t1;
         const bool hit = this->intersects(bbox, t0, t1);
-        if (hit)
+        if (hit) {
             mTimeSpan.set(t0, t1);
+        }
         return hit;
-        //return this->intersects(bbox, mTimeSpan.t0, mTimeSpan.t1);
     }
 
     /// @brief Return true if the Ray intersects the plane specified
-    /// by a normal and distance from the origin.
+    ///        by a normal and distance from the origin.
+    ///
     /// @param normal   Normal of the plane.
     /// @param distance Distance of the plane to the origin.
     /// @param t        Time of intersection, if one exists.
     __hostdev__ bool intersects(const Vec3T& normal, RealT distance, RealT& t) const
     {
         const RealT cosAngle = mDir.dot(normal);
-        if (isApproxZero(cosAngle))
-            return false; //parallel
+        if (isApproxZero(cosAngle)) {
+            return false; // ray is parallel to plane
+        }
         t = (distance - mEye.dot(normal)) / cosAngle;
         return this->test(t);
     }
 
     /// @brief Return true if the Ray intersects the plane specified
-    /// by a normal and point.
+    ///        by a normal and point.
+    ///
     /// @param normal   Normal of the plane.
     /// @param point    Point in the plane.
     /// @param t        Time of intersection, if one exists.
diff -aur nanovdb-20200925/nanovdb/nanovdb/util/SampleFromVoxels.h nanovdb-20201022/nanovdb/nanovdb/util/SampleFromVoxels.h
--- nanovdb-20200925/nanovdb/nanovdb/util/SampleFromVoxels.h	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/nanovdb/util/SampleFromVoxels.h	2020-10-22 03:52:50.000000000 +0200
@@ -31,6 +31,23 @@
 
 namespace nanovdb {
 
+// Forward declaration of sampler with specific polynomial orders
+template<typename TreeT, int Order, bool UseCache = true>
+class SampleFromVoxels;
+
+/// @brief Factory free-function for a sampler of specific polynomial orders
+///
+/// @details This allows for the compact syntax:
+/// @code
+///   auto acc = grid.getAccessor();
+///   auto smp = nanovdb::createSampler<1>( acc );
+/// @endcode
+template<int Order, typename TreeOrAccT, bool UseCache = true>
+__hostdev__ SampleFromVoxels<TreeOrAccT, Order, UseCache> createSampler(const TreeOrAccT& acc)
+{
+    return SampleFromVoxels<TreeOrAccT, Order, UseCache>(acc);
+}
+
 /// @brief Utility function that returns the Coord of the round-down of @a xyz
 ///        and redefined @xyz as the frational part, ie xyz-in = return-value + xyz-out
 template<typename CoordT, typename RealT, template<typename> class Vec3T>
@@ -58,183 +75,350 @@
     return CoordT(int32_t(ijk[0]), int32_t(ijk[1]), int32_t(ijk[2]));
 }
 
-// Forward declaration of sampler with specific polynomial orders
-template<typename TreeT, int Order, bool WithCache = true>
-struct SampleFromVoxels;
-
-/// @brief Factory free-function for a sampler of specific polynomial orders
-///
-/// @details This allows for the compact syntax:
-/// @code
-///   auto acc = grid.getAccessor();
-///   auto smp = nanovdb::createSampler<1>( acc );
-/// @endcode
-template<int Order, typename TreeOrAccT>
-__hostdev__ SampleFromVoxels<TreeOrAccT, Order, true> createSampler(const TreeOrAccT& acc)
-{
-    return SampleFromVoxels<TreeOrAccT, Order, true>(acc);
-}
-
 // ------------------------------> NearestNeighborSampler <--------------------------------------
 
-/// @brief Neigherest neighbor, i.e. zero order, interpolator
-template<typename TreeOrAccT, bool WithCache = true>
-class NearestNeighborSampler;
-
+/// @brief Neigherest neighbor, i.e. zero order, interpolator with caching
 template<typename TreeOrAccT>
-class NearestNeighborSampler<TreeOrAccT, true>
+class SampleFromVoxels<TreeOrAccT, 0, true>
 {
+public:
     using ValueT = typename TreeOrAccT::ValueType;
     using CoordT = typename TreeOrAccT::CoordType;
 
-public:
+    static const int ORDER = 0;
     /// @brief Construction from a Tree or ReadAccessor
-    __hostdev__ NearestNeighborSampler(const TreeOrAccT& acc)
-        : mAcc(&acc)
+    __hostdev__ SampleFromVoxels(const TreeOrAccT& acc)
+        : mAcc(acc)
         , mPos(CoordT::max())
     {
     }
 
+    __hostdev__ const TreeOrAccT& accessor() const { return mAcc; }
+
     /// @note xyz is in index space space
     template<typename Vec3T>
-    inline __hostdev__ ValueT operator()(const Vec3T& xyz);
+    inline __hostdev__ ValueT operator()(const Vec3T& xyz) const;
+
+    inline __hostdev__ ValueT operator()(const CoordT& ijk) const;
 
 private:
-    const TreeOrAccT* mAcc;
-    CoordT            mPos;
-    ValueT            mVal; // private cache
-}; // NearestNeighborSampler
+    const TreeOrAccT& mAcc;
+    mutable CoordT    mPos;
+    mutable ValueT    mVal; // private cache
+}; // SampleFromVoxels<TreeOrAccT, 0, true>
 
+/// @brief Neigherest neighbor, i.e. zero order, interpolator without caching
 template<typename TreeOrAccT>
-class NearestNeighborSampler<TreeOrAccT, false>
+class SampleFromVoxels<TreeOrAccT, 0, false>
 {
+public:
     using ValueT = typename TreeOrAccT::ValueType;
     using CoordT = typename TreeOrAccT::CoordType;
-
-public:
+    static const int ORDER = 0; 
+    
     /// @brief Construction from a Tree or ReadAccessor
-    __hostdev__ NearestNeighborSampler(const TreeOrAccT& acc)
-        : mAcc(&acc)
+    __hostdev__ SampleFromVoxels(const TreeOrAccT& acc)
+        : mAcc(acc)
     {
     }
 
+    __hostdev__ const TreeOrAccT& accessor() const { return mAcc; }
+
     /// @note xyz is in index space space
     template<typename Vec3T>
-    inline __hostdev__ ValueT operator()(const Vec3T& xyz);
+    inline __hostdev__ ValueT operator()(const Vec3T& xyz) const;
+
+    inline __hostdev__ ValueT operator()(const CoordT& ijk) const { return mAcc.getValue(ijk);}
 
 private:
-    const TreeOrAccT* mAcc;
-}; // NearestNeighborSampler
+    const TreeOrAccT& mAcc;
+}; // SampleFromVoxels<TreeOrAccT, 0, false>
 
 template<typename TreeOrAccT>
 template<typename Vec3T>
-typename TreeOrAccT::ValueType NearestNeighborSampler<TreeOrAccT, true>::operator()(const Vec3T& xyz)
+typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 0, true>::operator()(const Vec3T& xyz) const
 {
     const CoordT ijk = Round<CoordT>(xyz);
     if (ijk != mPos) {
         mPos = ijk;
-        mVal = mAcc->getValue(mPos);
+        mVal = mAcc.getValue(mPos);
+    }
+    return mVal;
+}
+
+template<typename TreeOrAccT>
+typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 0, true>::operator()(const CoordT& ijk) const
+{
+    if (ijk != mPos) {
+        mPos = ijk;
+        mVal = mAcc.getValue(mPos);
     }
     return mVal;
 }
 
 template<typename TreeOrAccT>
 template<typename Vec3T>
-typename TreeOrAccT::ValueType NearestNeighborSampler<TreeOrAccT, false>::operator()(const Vec3T& xyz)
+typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 0, false>::operator()(const Vec3T& xyz) const
 {
-    return mAcc->getValue(Round<CoordT>(xyz));
+    return mAcc.getValue(Round<CoordT>(xyz));
 }
 
 // ------------------------------> TrilinearSampler <--------------------------------------
 
 /// @brief Tri-linear sampler, i.e. first order, interpolator
-template<typename TreeOrAccT, bool WithCache = true>
-class TrilinearSampler;
+template<typename TreeOrAccT>
+class TrilinearSampler
+{
+protected:
+    const TreeOrAccT& mAcc;
+
+public:
+    using ValueT = typename TreeOrAccT::ValueType;
+    using CoordT = typename TreeOrAccT::CoordType;
+    static const int ORDER = 1;
+
+    /// @brief Protected constructor from a Tree or ReadAccessor
+    __hostdev__ TrilinearSampler(const TreeOrAccT& acc) : mAcc(acc) {}
+
+    __hostdev__ const TreeOrAccT& accessor() const { return mAcc; }
+
+    /// @brief Extract the stencil of 8 values
+    inline __hostdev__ void stencil(CoordT& ijk, ValueT (&v)[2][2][2]) const;
+
+    template<typename RealT, template<typename...> class Vec3T>
+    static inline __hostdev__ ValueT sample(const Vec3T<RealT> &uvw, const ValueT (&v)[2][2][2]);
+
+    template<typename RealT, template<typename...> class Vec3T>
+    static inline __hostdev__ Vec3T<ValueT> gradient(const Vec3T<RealT> &uvw, const ValueT (&v)[2][2][2]);
+
+    static inline __hostdev__ bool zeroCrossing(const ValueT (&v)[2][2][2]);
+}; // TrilinearSamplerBase
+
+template<typename TreeOrAccT>
+void TrilinearSampler<TreeOrAccT>::stencil(CoordT& ijk, ValueT (&v)[2][2][2]) const
+{
+    v[0][0][0] = mAcc.getValue(ijk); // i, j, k
+
+    ijk[2] += 1;
+    v[0][0][1] = mAcc.getValue(ijk); // i, j, k + 1
+
+    ijk[1] += 1;
+    v[0][1][1] = mAcc.getValue(ijk); // i, j+1, k + 1
+
+    ijk[2] -= 1;
+    v[0][1][0] = mAcc.getValue(ijk); // i, j+1, k
+
+    ijk[0] += 1;
+    ijk[1] -= 1;
+    v[1][0][0] = mAcc.getValue(ijk); // i+1, j, k
+
+    ijk[2] += 1;
+    v[1][0][1] = mAcc.getValue(ijk); // i+1, j, k + 1
+
+    ijk[1] += 1;
+    v[1][1][1] = mAcc.getValue(ijk); // i+1, j+1, k + 1
+
+    ijk[2] -= 1;
+    v[1][1][0] = mAcc.getValue(ijk); // i+1, j+1, k
+}
 
 template<typename TreeOrAccT>
-class TrilinearSampler<TreeOrAccT, true>
+template<typename RealT, template<typename...> class Vec3T>
+typename TreeOrAccT::ValueType TrilinearSampler<TreeOrAccT>::sample(const Vec3T<RealT> &uvw, const ValueT (&v)[2][2][2])
 {
+#if 0
+  auto lerp = [](ValueT a, ValueT b, ValueT w){ return fma(w, b-a, a); };// = w*(b-a) + a
+  //auto lerp = [](ValueT a, ValueT b, ValueT w){ return fma(w, b, fma(-w, a, a));};// = (1-w)*a + w*b
+#else
+    auto lerp = [](ValueT a, ValueT b, RealT w) { return a + ValueT(w) * (b - a); };
+#endif
+    return lerp(lerp(lerp(v[0][0][0], v[0][0][1], uvw[2]), lerp(v[0][1][0], v[0][1][1], uvw[2]), uvw[1]),
+                lerp(lerp(v[1][0][0], v[1][0][1], uvw[2]), lerp(v[1][1][0], v[1][1][1], uvw[2]), uvw[1]),
+                uvw[0]);
+}
+
+template<typename TreeOrAccT>
+template<typename RealT, template<typename...> class Vec3T>
+Vec3T<typename TreeOrAccT::ValueType> TrilinearSampler<TreeOrAccT>::gradient(const Vec3T<RealT> &uvw, const ValueT (&v)[2][2][2])
+{
+    static_assert(std::is_floating_point<ValueT>::value, "TrilinearSampler::gradient requires a floating-point type");
+#if 0
+  auto lerp = [](ValueT a, ValueT b, ValueT w){ return fma(w, b-a, a); };// = w*(b-a) + a
+  //auto lerp = [](ValueT a, ValueT b, ValueT w){ return fma(w, b, fma(-w, a, a));};// = (1-w)*a + w*b
+#else
+    auto lerp = [](ValueT a, ValueT b, RealT w) { return a + ValueT(w) * (b - a); };
+#endif
+
+    ValueT D[4] = {v[0][0][1] - v[0][0][0], v[0][1][1] - v[0][1][0], v[1][0][1] - v[1][0][0], v[1][1][1] - v[1][1][0]};
+
+    // Z component
+    Vec3T<ValueT> grad(0, 0, lerp(lerp(D[0], D[1], uvw[1]), lerp(D[2], D[3], uvw[1]), uvw[0]));
+
+    const ValueT w = ValueT(uvw[2]);
+    D[0] = v[0][0][0] + D[0] * w;
+    D[1] = v[0][1][0] + D[1] * w;
+    D[2] = v[1][0][0] + D[2] * w;
+    D[3] = v[1][1][0] + D[3] * w;
+
+    // X component
+    grad[0] = lerp(D[2], D[3], uvw[1]) - lerp(D[0], D[1], uvw[1]);
+
+    // Y component
+    grad[1] = lerp(D[1] - D[0], D[3] - D[2], uvw[0]);
+
+    return grad;
+}
+
+template<typename TreeOrAccT>
+bool TrilinearSampler<TreeOrAccT>::zeroCrossing(const ValueT (&v)[2][2][2])
+{
+    static_assert(std::is_floating_point<ValueT>::value, "TrilinearSampler::zeroCrossing requires a floating-point type");
+    const bool less = v[0][0][0] < ValueT(0);
+    return (less ^ (v[0][0][1] < ValueT(0))) ||
+           (less ^ (v[0][1][1] < ValueT(0))) ||
+           (less ^ (v[0][1][0] < ValueT(0))) ||
+           (less ^ (v[1][0][0] < ValueT(0))) ||
+           (less ^ (v[1][0][1] < ValueT(0))) ||
+           (less ^ (v[1][1][1] < ValueT(0))) ||
+           (less ^ (v[1][1][0] < ValueT(0)));
+}
+
+/// @brief Template specializaton that does not use caching of stencil points
+template<typename TreeOrAccT>
+class SampleFromVoxels<TreeOrAccT, 1, false> : public TrilinearSampler<TreeOrAccT>
+{
+    using BaseT = TrilinearSampler<TreeOrAccT>;
     using ValueT = typename TreeOrAccT::ValueType;
     using CoordT = typename TreeOrAccT::CoordType;
 
 public:
+
     /// @brief Construction from a Tree or ReadAccessor
-    __hostdev__ TrilinearSampler(const TreeOrAccT& acc)
-        : mAcc(&acc)
-        , mPos(CoordT::max())
-    {
-    }
+    __hostdev__ SampleFromVoxels(const TreeOrAccT& acc) : BaseT(acc) {}
 
     /// @note xyz is in index space space
     template<typename RealT, template<typename...> class Vec3T>
-    inline __hostdev__ ValueT operator()(Vec3T<RealT> xyz);
+    inline __hostdev__ ValueT operator()(Vec3T<RealT> xyz) const;
+
+    /// @note ijk is in index space space
+    __hostdev__ ValueT operator()(const CoordT &ijk) const {return BaseT::mAcc.getValue(ijk);}
 
     /// @brief Return the gradient in index space.
     ///
     /// @warning Will only compile with floating point value types
     template<typename RealT, template<typename...> class Vec3T>
-    inline __hostdev__ Vec3T<ValueT> gradient(Vec3T<RealT> xyz);
+    inline __hostdev__ Vec3T<ValueT> gradient(Vec3T<RealT> xyz) const;
 
     /// @brief Return true if the tr-linear stencil has a zero crossing at the specified index position.
     ///
     /// @warning Will only compile with floating point value types
     template<typename RealT, template<typename...> class Vec3T>
-    inline __hostdev__ bool zeroCrossing(Vec3T<RealT> xyz);
+    inline __hostdev__ bool zeroCrossing(Vec3T<RealT> xyz) const;
 
-    /// @brief Return true if the cached tri-linear stencil has a zero crossing.
-    ///
-    /// @warning Will only compile with floating point value types
-    inline __hostdev__ bool zeroCrossing();
-
-private:
-    const TreeOrAccT* mAcc;
-    CoordT            mPos;
-    ValueT            mVal[2][2][2];
-
-    template<typename Vec3T>
-    __hostdev__ bool update(Vec3T& xyz);
-}; // TrilinearSampler
+}; // SampleFromVoxels<TreeOrAccT, 1, false>
 
+/// @brief Template specialization with caching of stencil values
 template<typename TreeOrAccT>
-class TrilinearSampler<TreeOrAccT, false>
+class SampleFromVoxels<TreeOrAccT, 1, true> : public TrilinearSampler<TreeOrAccT>
 {
+    using BaseT = TrilinearSampler<TreeOrAccT>;
     using ValueT = typename TreeOrAccT::ValueType;
     using CoordT = typename TreeOrAccT::CoordType;
 
+    mutable CoordT mPos;
+    mutable ValueT mVal[2][2][2];
+
+    template<typename RealT, template<typename...> class Vec3T>
+    __hostdev__ void cache(Vec3T<RealT>& xyz) const;
 public:
+
     /// @brief Construction from a Tree or ReadAccessor
-    __hostdev__ TrilinearSampler(const TreeOrAccT& acc)
-        : mAcc(&acc)
-    {
-    }
+    __hostdev__ SampleFromVoxels(const TreeOrAccT& acc) : BaseT(acc), mPos(CoordT::max()){}
 
     /// @note xyz is in index space space
     template<typename RealT, template<typename...> class Vec3T>
-    inline __hostdev__ ValueT operator()(Vec3T<RealT> xyz);
+    inline __hostdev__ ValueT operator()(Vec3T<RealT> xyz) const;
 
-private:
-    const TreeOrAccT* mAcc;
-}; // TrilinearSampler
+    // @note ijk is in index space space
+    __hostdev__ ValueT operator()(const CoordT &ijk) const;
+
+    /// @brief Return the gradient in index space.
+    ///
+    /// @warning Will only compile with floating point value types
+    template<typename RealT, template<typename...> class Vec3T>
+    inline __hostdev__ Vec3T<ValueT> gradient(Vec3T<RealT> xyz) const;
+
+    /// @brief Return true if the tr-linear stencil has a zero crossing at the specified index position.
+    ///
+    /// @warning Will only compile with floating point value types
+    template<typename RealT, template<typename...> class Vec3T>
+    inline __hostdev__ bool zeroCrossing(Vec3T<RealT> xyz) const;
+
+    /// @brief Return true if the cached tri-linear stencil has a zero crossing.
+    ///
+    /// @warning Will only compile with floating point value types
+    __hostdev__ bool zeroCrossing() const { return BaseT::zeroCrossing(mVal); }
+
+}; // SampleFromVoxels<TreeOrAccT, 1, true>
+
+template<typename TreeOrAccT>
+template<typename RealT, template<typename...> class Vec3T>
+typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 1, true>::operator()(Vec3T<RealT> xyz) const
+{
+    this->cache(xyz);
+    return BaseT::sample(xyz, mVal);
+}
+
+template<typename TreeOrAccT>
+typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 1, true>::operator()(const CoordT &ijk) const
+{
+    return  ijk == mPos ? mVal[0][0][0] : BaseT::mAcc.getValue(ijk);
+}
 
 template<typename TreeOrAccT>
 template<typename RealT, template<typename...> class Vec3T>
-typename TreeOrAccT::ValueType TrilinearSampler<TreeOrAccT, true>::operator()(Vec3T<RealT> xyz)
+Vec3T<typename TreeOrAccT::ValueType> SampleFromVoxels<TreeOrAccT, 1, true>::gradient(Vec3T<RealT> xyz) const
 {
-    this->update(xyz);
+    this->cache(xyz);
+    return BaseT::gradient(xyz, mVal);
+}
+
+template<typename TreeOrAccT>
+template<typename RealT, template<typename...> class Vec3T>
+__hostdev__ bool SampleFromVoxels<TreeOrAccT, 1, true>::zeroCrossing(Vec3T<RealT> xyz) const
+{
+    this->cache(xyz);
+    return BaseT::zeroCrossing(mVal);
+}
+
+template<typename TreeOrAccT>
+template<typename RealT, template<typename...> class Vec3T>
+void SampleFromVoxels<TreeOrAccT, 1, true>::cache(Vec3T<RealT>& xyz) const
+{
+    CoordT ijk = Floor<CoordT>(xyz);
+    if (ijk != mPos) {
+        mPos = ijk;
+        BaseT::stencil(ijk, mVal);
+    }
+}
+
 #if 0
-  auto lerp = [](ValueT a, ValueT b, ValueT w){ return fma(w, b-a, a); };// = w*(b-a) + a
-  //auto lerp = [](ValueT a, ValueT b, ValueT w){ return fma(w, b, fma(-w, a, a));};// = (1-w)*a + w*b
-#else
-    auto lerp = [](ValueT a, ValueT b, RealT w) { return a + ValueT(w) * (b - a); };
-#endif
-    return lerp(lerp(lerp(mVal[0][0][0], mVal[0][0][1], xyz[2]), lerp(mVal[0][1][0], mVal[0][1][1], xyz[2]), xyz[1]),
-                lerp(lerp(mVal[1][0][0], mVal[1][0][1], xyz[2]), lerp(mVal[1][1][0], mVal[1][1][1], xyz[2]), xyz[1]),
-                xyz[0]);
+
+template<typename TreeOrAccT>
+template<typename RealT, template<typename...> class Vec3T>
+typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 1, false>::operator()(Vec3T<RealT> xyz) const
+{
+    ValueT val[2][2][2];
+    CoordT ijk = Floor<CoordT>(xyz);
+    BaseT::stencil(ijk, val);
+    return BaseT::sample(xyz, val);
 }
 
+#else
+
 template<typename TreeOrAccT>
 template<typename RealT, template<typename...> class Vec3T>
-typename TreeOrAccT::ValueType TrilinearSampler<TreeOrAccT, false>::operator()(Vec3T<RealT> xyz)
+typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 1, false>::operator()(Vec3T<RealT> xyz) const
 {
     auto lerp = [](ValueT a, ValueT b, RealT w) { return a + ValueT(w) * (b - a); };
 
@@ -242,142 +426,254 @@
 
     ValueT vx, vx1, vy, vy1, vz, vz1;
 
-    vz = mAcc->getValue(coord);
+    vz = BaseT::mAcc.getValue(coord);
     coord[2] += 1;
-    vz1 = mAcc->getValue(coord);
+    vz1 = BaseT::mAcc.getValue(coord);
     vy = lerp(vz, vz1, xyz[2]);
 
     coord[1] += 1;
 
-    vz1 = mAcc->getValue(coord);
+    vz1 = BaseT::mAcc.getValue(coord);
     coord[2] -= 1;
-    vz = mAcc->getValue(coord);
+    vz = BaseT::mAcc.getValue(coord);
     vy1 = lerp(vz, vz1, xyz[2]);
 
     vx = lerp(vy, vy1, xyz[1]);
 
     coord[0] += 1;
 
-    vz = mAcc->getValue(coord);
+    vz = BaseT::mAcc.getValue(coord);
     coord[2] += 1;
-    vz1 = mAcc->getValue(coord);
+    vz1 = BaseT::mAcc.getValue(coord);
     vy1 = lerp(vz, vz1, xyz[2]);
 
     coord[1] -= 1;
 
-    vz1 = mAcc->getValue(coord);
+    vz1 = BaseT::mAcc.getValue(coord);
     coord[2] -= 1;
-    vz = mAcc->getValue(coord);
+    vz = BaseT::mAcc.getValue(coord);
     vy = lerp(vz, vz1, xyz[2]);
 
     vx1 = lerp(vy, vy1, xyz[1]);
 
     return lerp(vx, vx1, xyz[0]);
 }
+#endif
+
 
 template<typename TreeOrAccT>
 template<typename RealT, template<typename...> class Vec3T>
-Vec3T<typename TreeOrAccT::ValueType> TrilinearSampler<TreeOrAccT>::gradient(Vec3T<RealT> xyz)
+inline Vec3T<typename TreeOrAccT::ValueType> SampleFromVoxels<TreeOrAccT, 1, false>::gradient(Vec3T<RealT> xyz) const
 {
-    static_assert(std::is_floating_point<ValueT>::value, "TrilinearSampler::gradient requires a floating-point type");
-    this->update(xyz);
-#if 0
-  auto lerp = [](ValueT a, ValueT b, ValueT w){ return fma(w, b-a, a); };// = w*(b-a) + a
-  //auto lerp = [](ValueT a, ValueT b, ValueT w){ return fma(w, b, fma(-w, a, a));};// = (1-w)*a + w*b
-#else
-    auto lerp = [](ValueT a, ValueT b, RealT w) { return a + ValueT(w) * (b - a); };
-#endif
+    ValueT val[2][2][2];
+    CoordT ijk = Floor<CoordT>(xyz);
+    BaseT::stencil(ijk, val);
+    return BaseT::gradient(xyz, val);
+}
+
+template<typename TreeOrAccT>
+template<typename RealT, template<typename...> class Vec3T>
+bool SampleFromVoxels<TreeOrAccT, 1, false>::zeroCrossing(Vec3T<RealT> xyz) const
+{
+    ValueT val[2][2][2];
+    CoordT ijk = Floor<CoordT>(xyz);
+    BaseT::stencil(ijk, val);
+    return BaseT::zeroCrossing(val);
+}
 
-    ValueT D[4] = {mVal[0][0][1] - mVal[0][0][0], mVal[0][1][1] - mVal[0][1][0], mVal[1][0][1] - mVal[1][0][0], mVal[1][1][1] - mVal[1][1][0]};
+// ------------------------------> TriquadraticSampler <--------------------------------------
 
-    // Z component
-    Vec3T<ValueT> grad(0, 0, lerp(lerp(D[0], D[1], xyz[1]), lerp(D[2], D[3], xyz[1]), xyz[0]));
+/// @brief Tri-quadratic sampler, i.e. second order, interpolator
+template<typename TreeOrAccT>
+class TriquadraticSampler
+{
+protected:
+    const TreeOrAccT& mAcc;
 
-    const ValueT w = ValueT(xyz[2]);
-    D[0] = mVal[0][0][0] + D[0] * w;
-    D[1] = mVal[0][1][0] + D[1] * w;
-    D[2] = mVal[1][0][0] + D[2] * w;
-    D[3] = mVal[1][1][0] + D[3] * w;
+public:
+    using ValueT = typename TreeOrAccT::ValueType;
+    using CoordT = typename TreeOrAccT::CoordType;
+    static const int ORDER = 1;
 
-    // X component
-    grad[0] = lerp(D[2], D[3], xyz[1]) - lerp(D[0], D[1], xyz[1]);
+    /// @brief Protected constructor from a Tree or ReadAccessor
+    __hostdev__ TriquadraticSampler(const TreeOrAccT& acc) : mAcc(acc) {}
 
-    // Y component
-    grad[1] = lerp(D[1] - D[0], D[3] - D[2], xyz[0]);
+    __hostdev__ const TreeOrAccT& accessor() const { return mAcc; }
 
-    return grad;
-}
+    /// @brief Extract the stencil of 27 values
+    inline __hostdev__ void stencil(const CoordT &ijk, ValueT (&v)[3][3][3]) const;
+
+    template<typename RealT, template<typename...> class Vec3T>
+    static inline __hostdev__ ValueT sample(const Vec3T<RealT> &uvw, const ValueT (&v)[3][3][3]);
+
+    static inline __hostdev__ bool zeroCrossing(const ValueT (&v)[3][3][3]);
+}; // TriquadraticSamplerBase
 
 template<typename TreeOrAccT>
-bool TrilinearSampler<TreeOrAccT>::zeroCrossing()
+void TriquadraticSampler<TreeOrAccT>::stencil(const CoordT &ijk, ValueT (&v)[3][3][3]) const
 {
-    static_assert(std::is_floating_point<ValueT>::value, "TrilinearSampler::zeroCrossing requires a floating-point type");
-    const bool less = mVal[0][0][0] < ValueT(0);
-    return (less ^ (mVal[0][0][1] < ValueT(0))) ||
-           (less ^ (mVal[0][1][1] < ValueT(0))) ||
-           (less ^ (mVal[0][1][0] < ValueT(0))) ||
-           (less ^ (mVal[1][0][0] < ValueT(0))) ||
-           (less ^ (mVal[1][0][1] < ValueT(0))) ||
-           (less ^ (mVal[1][1][1] < ValueT(0))) ||
-           (less ^ (mVal[1][1][0] < ValueT(0)));
+    CoordT p(ijk[0] - 1, 0, 0);
+    for (int dx = 0; dx < 3; ++dx, ++p[0]) {
+        p[1] = ijk[1] - 1;
+        for (int dy = 0; dy < 3; ++dy, ++p[1]) {
+            p[2] = ijk[2] - 1;
+            for (int dz = 0; dz < 3; ++dz, ++p[2]) {
+                v[dx][dy][dz] = mAcc.getValue(p);// extract the stencil of 27 values
+            }
+        }
+    }
 }
 
 template<typename TreeOrAccT>
 template<typename RealT, template<typename...> class Vec3T>
-bool TrilinearSampler<TreeOrAccT>::zeroCrossing(Vec3T<RealT> xyz)
+typename TreeOrAccT::ValueType TriquadraticSampler<TreeOrAccT>::sample(const Vec3T<RealT> &uvw, const ValueT (&v)[3][3][3])
 {
-    this->update(xyz);
-    return this->zeroCrossing();
+    auto kernel = [](const ValueT* value, double weight)->ValueT {
+        return weight * (weight * (0.5f * (value[0] + value[2]) - value[1]) + 
+                        0.5f * (value[2] - value[0])) + value[1];
+    };
+
+    ValueT vx[3];
+    for (int dx = 0; dx < 3; ++dx) {
+        ValueT vy[3];
+        for (int dy = 0; dy < 3; ++dy) {
+            vy[dy] = kernel(&v[dx][dy][0], uvw[2]);
+        }//loop over y
+        vx[dx] = kernel(vy, uvw[1]);
+    }//loop over x
+    return kernel(vx, uvw[0]);
 }
 
 template<typename TreeOrAccT>
-template<typename Vec3T>
-bool TrilinearSampler<TreeOrAccT>::update(Vec3T& xyz)
+bool TriquadraticSampler<TreeOrAccT>::zeroCrossing(const ValueT (&v)[3][3][3])
 {
-    CoordT ijk = Floor<CoordT>(xyz);
+    static_assert(std::is_floating_point<ValueT>::value, "TrilinearSampler::zeroCrossing requires a floating-point type");
+    const bool less = v[0][0][0] < ValueT(0);
+    for (int dx = 0; dx < 3; ++dx) {
+        for (int dy = 0; dy < 3; ++dy) {
+            for (int dz = 0; dz < 3; ++dz) {
+                if (less ^ (v[dx][dy][dz] < ValueT(0))) return true;
+            }
+        }
+    }
+    return false;
+}
+
+/// @brief Template specializaton that does not use caching of stencil points
+template<typename TreeOrAccT>
+class SampleFromVoxels<TreeOrAccT, 2, false> : public TriquadraticSampler<TreeOrAccT>
+{
+    using BaseT = TriquadraticSampler<TreeOrAccT>;
+    using ValueT = typename TreeOrAccT::ValueType;
+    using CoordT = typename TreeOrAccT::CoordType;
+public:
 
-    if (ijk == mPos)
-        return false; // early out - reuse cached values
+    /// @brief Construction from a Tree or ReadAccessor
+    __hostdev__ SampleFromVoxels(const TreeOrAccT& acc) : BaseT(acc) {}
 
-    mPos = ijk;
+    /// @note xyz is in index space space
+    template<typename RealT, template<typename...> class Vec3T>
+    inline __hostdev__ ValueT operator()(Vec3T<RealT> xyz) const;
 
-    mVal[0][0][0] = mAcc->getValue(ijk); // i, j, k
+    __hostdev__ ValueT operator()(const CoordT &ijk) const {return BaseT::mAcc.getValue(ijk);}
 
-    ijk[2] += 1;
-    mVal[0][0][1] = mAcc->getValue(ijk); // i, j, k + 1
+    /// @brief Return true if the tr-linear stencil has a zero crossing at the specified index position.
+    ///
+    /// @warning Will only compile with floating point value types
+    template<typename RealT, template<typename...> class Vec3T>
+    inline __hostdev__ bool zeroCrossing(Vec3T<RealT> xyz) const;
 
-    ijk[1] += 1;
-    mVal[0][1][1] = mAcc->getValue(ijk); // i, j+1, k + 1
+}; // SampleFromVoxels<TreeOrAccT, 2, false>
 
-    ijk[2] -= 1;
-    mVal[0][1][0] = mAcc->getValue(ijk); // i, j+1, k
+/// @brief Template specialization with caching of stencil values
+template<typename TreeOrAccT>
+class SampleFromVoxels<TreeOrAccT, 2, true> : public TriquadraticSampler<TreeOrAccT>
+{
+    using BaseT = TriquadraticSampler<TreeOrAccT>;
+    using ValueT = typename TreeOrAccT::ValueType;
+    using CoordT = typename TreeOrAccT::CoordType;
 
-    ijk[0] += 1;
-    ijk[1] -= 1;
-    mVal[1][0][0] = mAcc->getValue(ijk); // i+1, j, k
+    mutable CoordT mPos;
+    mutable ValueT mVal[3][3][3];
 
-    ijk[2] += 1;
-    mVal[1][0][1] = mAcc->getValue(ijk); // i+1, j, k + 1
+    template<typename RealT, template<typename...> class Vec3T>
+    __hostdev__ void cache(Vec3T<RealT>& xyz) const;
+public:
 
-    ijk[1] += 1;
-    mVal[1][1][1] = mAcc->getValue(ijk); // i+1, j+1, k + 1
+    /// @brief Construction from a Tree or ReadAccessor
+    __hostdev__ SampleFromVoxels(const TreeOrAccT& acc) : BaseT(acc), mPos(CoordT::max()){}
 
-    ijk[2] -= 1;
-    mVal[1][1][0] = mAcc->getValue(ijk); // i+1, j+1, k
+    /// @note xyz is in index space space
+    template<typename RealT, template<typename...> class Vec3T>
+    inline __hostdev__ ValueT operator()(Vec3T<RealT> xyz) const;
+
+    inline __hostdev__ ValueT operator()(const CoordT &ijk) const;
 
-    return true;
+    /// @brief Return true if the tr-linear stencil has a zero crossing at the specified index position.
+    ///
+    /// @warning Will only compile with floating point value types
+    template<typename RealT, template<typename...> class Vec3T>
+    inline __hostdev__ bool zeroCrossing(Vec3T<RealT> xyz) const;
+
+    /// @brief Return true if the cached tri-linear stencil has a zero crossing.
+    ///
+    /// @warning Will only compile with floating point value types
+    __hostdev__ bool zeroCrossing() const { return BaseT::zeroCrossing(mVal); }
+
+}; // SampleFromVoxels<TreeOrAccT, 2, true>
+
+template<typename TreeOrAccT>
+template<typename RealT, template<typename...> class Vec3T>
+typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 2, true>::operator()(Vec3T<RealT> xyz) const
+{
+    this->cache(xyz);
+    return BaseT::sample(xyz, mVal);
 }
 
-// ------------------------------> TriquadraticSampler <--------------------------------------
+template<typename TreeOrAccT>
+typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 2, true>::operator()(const CoordT &ijk) const
+{
+    return  ijk == mPos ? mVal[1][1][1] : BaseT::mAcc.getValue(ijk);
+}
 
-/// @brief Tri-quadratic sampler, i.e. second order, interpolator
-///
-/// @warning TriquadraticSampler has not implemented yet!
-template<typename TreeT, bool WithCache = true>
-class TriquadraticSampler
+template<typename TreeOrAccT>
+template<typename RealT, template<typename...> class Vec3T>
+__hostdev__ bool SampleFromVoxels<TreeOrAccT, 2, true>::zeroCrossing(Vec3T<RealT> xyz) const
 {
-    // TriquadraticSampler has not implemented yet!
-};
+    this->cache(xyz);
+    return BaseT::zeroCrossing(mVal);
+}
+
+template<typename TreeOrAccT>
+template<typename RealT, template<typename...> class Vec3T>
+void SampleFromVoxels<TreeOrAccT, 2, true>::cache(Vec3T<RealT>& xyz) const
+{
+    CoordT ijk = Floor<CoordT>(xyz);
+    if (ijk != mPos) {
+        mPos = ijk;
+        BaseT::stencil(ijk, mVal);
+    }
+}
+
+template<typename TreeOrAccT>
+template<typename RealT, template<typename...> class Vec3T>
+typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 2, false>::operator()(Vec3T<RealT> xyz) const
+{
+    ValueT val[3][3][3];
+    CoordT ijk = Floor<CoordT>(xyz);
+    BaseT::stencil(ijk, val);
+    return BaseT::sample(xyz, val);
+}
+
+template<typename TreeOrAccT>
+template<typename RealT, template<typename...> class Vec3T>
+bool SampleFromVoxels<TreeOrAccT, 2, false>::zeroCrossing(Vec3T<RealT> xyz) const
+{
+    ValueT val[3][3][3];
+    CoordT ijk = Floor<CoordT>(xyz);
+    BaseT::stencil(ijk, val);
+    return BaseT::zeroCrossing(val);
+}
 
 // ------------------------------> TricubicSampler <--------------------------------------
 
@@ -387,105 +683,44 @@
 /// Lekien, F. and Marsden, J.: Tricubic interpolation in three dimensions.
 ///                         In: International Journal for Numerical Methods
 ///                         in Engineering (2005), No. 63, p. 455-471
-template<typename TreeOrAccT, bool WithCache = true>
-class TricubicSampler;
 
 template<typename TreeOrAccT>
-class TricubicSampler<TreeOrAccT, true>
+class TricubicSampler
 {
+protected:
     using ValueT = typename TreeOrAccT::ValueType;
     using CoordT = typename TreeOrAccT::CoordType;
 
-public:
-    /// @brief Construction from a Tree or ReadAccessor
-    __hostdev__ TricubicSampler(const TreeOrAccT& acc)
-        : mAcc(&acc)
-        , mPos(CoordT::max())
-    {
-    }
-
-    /// @note xyz is in index space space
-    template<typename Vec3T>
-    inline __hostdev__ ValueT operator()(Vec3T xyz);
-
-private:
-    const TreeOrAccT* mAcc;
-    CoordT            mPos;
-    ValueT            mC[64]; //private cache
-
-    template<typename Vec3T>
-    __hostdev__ bool update(Vec3T& xyz);
-}; // TricubicSampler
-
-template<typename TreeOrAccT>
-class TricubicSampler<TreeOrAccT, false>
-{
-    using ValueT = typename TreeOrAccT::ValueType;
-    using CoordT = typename TreeOrAccT::CoordType;
+    const TreeOrAccT& mAcc;
 
 public:
     /// @brief Construction from a Tree or ReadAccessor
     __hostdev__ TricubicSampler(const TreeOrAccT& acc)
-        : mAcc(&acc)
+        : mAcc(acc)
     {
     }
 
-    /// @note xyz is in index space space
-    template<typename Vec3T>
-    inline __hostdev__ ValueT operator()(Vec3T xyz);
-
-private:
-    const TreeOrAccT* mAcc;
-}; // TricubicSampler
+    __hostdev__ const TreeOrAccT& accessor() const { return mAcc; }
 
-template<typename TreeOrAccT>
-template<typename Vec3T>
-__hostdev__ typename TreeOrAccT::ValueType TricubicSampler<TreeOrAccT, true>::operator()(Vec3T xyz)
-{
-    this->update(xyz); // modifies xyz and re-computes mC and mPos if required
+     /// @brief Extract the stencil of 8 values
+    inline __hostdev__ void stencil(const CoordT& ijk, ValueT (&c)[64]) const;
 
-    ValueT zPow(1), sum(0);
-    for (int k = 0, n = 0; k < 4; ++k) {
-        ValueT yPow(1);
-        for (int j = 0; j < 4; ++j, n += 4) {
-#if 0
-            sum = fma( yPow, zPow * fma(xyz[0], fma(xyz[0], fma(xyz[0], mC[n + 3], mC[n + 2]), mC[n + 1]), mC[n]), sum);
-#else
-            sum += yPow * zPow * (mC[n] + xyz[0] * (mC[n + 1] + xyz[0] * (mC[n + 2] + xyz[0] * mC[n + 3])));
-#endif
-            yPow *= xyz[1];
-        }
-        zPow *= xyz[2];
-    }
-    return sum;
-}
+    template<typename RealT, template<typename...> class Vec3T>
+    static inline __hostdev__ ValueT sample(const Vec3T<RealT> &uvw, const ValueT (&c)[64]);
+}; // TricubicSampler
 
 template<typename TreeOrAccT>
-template<typename Vec3T>
-__hostdev__ typename TreeOrAccT::ValueType TricubicSampler<TreeOrAccT, false>::operator()(Vec3T xyz)
+void TricubicSampler<TreeOrAccT>::stencil(const CoordT& ijk, ValueT (&C)[64]) const
 {
-    return TricubicSampler<TreeOrAccT, true>(*mAcc)(xyz);
-}
-
-template<typename TreeOrAccT>
-template<typename Vec3T>
-bool TricubicSampler<TreeOrAccT>::update(Vec3T& xyz)
-{
-    const CoordT ijk = Floor<CoordT>(xyz);
-
-    if (ijk == mPos)
-        return false; // early out - reuse cached values
-    mPos = ijk;
-
-    auto fetch = [&](int i, int j, int k) -> ValueT& { return mC[((i + 1) << 4) + ((j + 1) << 2) + k + 1]; };
+    auto fetch = [&](int i, int j, int k) -> ValueT& { return C[((i + 1) << 4) + ((j + 1) << 2) + k + 1]; };
 
     // fetch 64 point stencil values
     for (int i = -1; i < 3; ++i) {
         for (int j = -1; j < 3; ++j) {
-            fetch(i, j, -1) = mAcc->getValue(mPos + CoordT(i, j, -1));
-            fetch(i, j, 0) = mAcc->getValue(mPos + CoordT(i, j, 0));
-            fetch(i, j, 1) = mAcc->getValue(mPos + CoordT(i, j, 1));
-            fetch(i, j, 2) = mAcc->getValue(mPos + CoordT(i, j, 2));
+            fetch(i, j, -1) = mAcc.getValue(ijk + CoordT(i, j, -1));
+            fetch(i, j,  0) = mAcc.getValue(ijk + CoordT(i, j,  0));
+            fetch(i, j,  1) = mAcc.getValue(ijk + CoordT(i, j,  1));
+            fetch(i, j,  2) = mAcc.getValue(ijk + CoordT(i, j,  2));
         }
     }
     const ValueT half(0.5), quarter(0.25), eighth(0.125);
@@ -630,58 +865,118 @@
         {8, -8, -8, 8, -8, 8, 8, -8, 4, 4, -4, -4, -4, -4, 4, 4, 4, -4, 4, -4, -4, 4, -4, 4, 4, -4, -4, 4, 4, -4, -4, 4, 2, 2, 2, 2, -2, -2, -2, -2, 2, 2, -2, -2, 2, 2, -2, -2, 2, -2, 2, -2, 2, -2, 2, -2, 1, 1, 1, 1, 1, 1, 1, 1}};
 
     for (int i = 0; i < 64; ++i) { // C = A * X
-        mC[i] = ValueT(0);
+        C[i] = ValueT(0);
 #if 0
     for (int j = 0; j < 64; j += 4) {
-      mC[i] = fma(A[i][j], X[j], fma(A[i][j+1], X[j+1], fma(A[i][j+2], X[j+2], fma(A[i][j+3], X[j+3], mC[i]))));
+      C[i] = fma(A[i][j], X[j], fma(A[i][j+1], X[j+1], fma(A[i][j+2], X[j+2], fma(A[i][j+3], X[j+3], C[i]))));
     }
 #else
         for (int j = 0; j < 64; j += 4) {
-            mC[i] += A[i][j] * X[j] + A[i][j + 1] * X[j + 1] + A[i][j + 2] * X[j + 2] + A[i][j + 3] * X[j + 3];
+            C[i] += A[i][j] * X[j] + A[i][j + 1] * X[j + 1] + A[i][j + 2] * X[j + 2] + A[i][j + 3] * X[j + 3];
         }
 #endif
     }
-
-    return true;
 }
 
-// ------------------------------> Sampler <--------------------------------------
-
-template<typename TreeOrAccT, bool WithCache>
-struct SampleFromVoxels<TreeOrAccT, 0, WithCache> : public NearestNeighborSampler<TreeOrAccT, WithCache>
+template<typename TreeOrAccT>
+template<typename RealT, template<typename...> class Vec3T>
+__hostdev__ typename TreeOrAccT::ValueType TricubicSampler<TreeOrAccT>::sample(const Vec3T<RealT> &xyz, const ValueT (&C)[64])
 {
-    __hostdev__ SampleFromVoxels(const TreeOrAccT& tree)
-        : NearestNeighborSampler<TreeOrAccT, WithCache>(tree)
-    {
+    ValueT zPow(1), sum(0);
+    for (int k = 0, n = 0; k < 4; ++k) {
+        ValueT yPow(1);
+        for (int j = 0; j < 4; ++j, n += 4) {
+#if 0
+            sum = fma( yPow, zPow * fma(xyz[0], fma(xyz[0], fma(xyz[0], C[n + 3], C[n + 2]), C[n + 1]), C[n]), sum);
+#else
+            sum += yPow * zPow * (C[n] + xyz[0] * (C[n + 1] + xyz[0] * (C[n + 2] + xyz[0] * C[n + 3])));
+#endif
+            yPow *= xyz[1];
+        }
+        zPow *= xyz[2];
     }
-};
+    return sum;
+}
 
-template<typename TreeOrAccT, bool WithCache>
-struct SampleFromVoxels<TreeOrAccT, 1, WithCache> : public TrilinearSampler<TreeOrAccT, WithCache>
+template<typename TreeOrAccT>
+class SampleFromVoxels<TreeOrAccT, 3, true> : public TricubicSampler<TreeOrAccT>
 {
-    __hostdev__ SampleFromVoxels(const TreeOrAccT& tree)
-        : TrilinearSampler<TreeOrAccT, WithCache>(tree)
+    using BaseT  = TricubicSampler<TreeOrAccT>;
+    using ValueT = typename TreeOrAccT::ValueType;
+    using CoordT = typename TreeOrAccT::CoordType;
+
+    mutable CoordT mPos;
+    mutable ValueT mC[64];
+
+    template<typename RealT, template<typename...> class Vec3T>
+    __hostdev__ void cache(Vec3T<RealT>& xyz) const;
+
+public:
+    /// @brief Construction from a Tree or ReadAccessor
+    __hostdev__ SampleFromVoxels(const TreeOrAccT& acc)
+        : BaseT(acc)
     {
     }
-};
 
-template<typename TreeOrAccT, bool WithCache>
-struct SampleFromVoxels<TreeOrAccT, 2, WithCache> : public TriquadraticSampler<TreeOrAccT, WithCache>
+    /// @note xyz is in index space space
+    template<typename RealT, template<typename...> class Vec3T>
+    inline __hostdev__ ValueT operator()(Vec3T<RealT> xyz) const;
+
+    // @brief Return value at the coordinate @a ijk in index space space
+    __hostdev__ ValueT operator()(const CoordT &ijk) const {return BaseT::mAcc.getValue(ijk);}
+
+}; // SampleFromVoxels<TreeOrAccT, 3, true>
+
+template<typename TreeOrAccT>
+template<typename RealT, template<typename...> class Vec3T>
+typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 3, true>::operator()(Vec3T<RealT> xyz) const
 {
-    __hostdev__ SampleFromVoxels(const TreeOrAccT& tree)
-        : TriquadraticSampler<TreeOrAccT, WithCache>(tree)
-    {
+    this->cache(xyz);
+    return BaseT::sample(xyz, mC);
+}
+
+template<typename TreeOrAccT>
+template<typename RealT, template<typename...> class Vec3T>
+void SampleFromVoxels<TreeOrAccT, 3, true>::cache(Vec3T<RealT>& xyz) const
+{
+    CoordT ijk = Floor<CoordT>(xyz);
+    if (ijk != mPos) {
+        mPos = ijk;
+        BaseT::stencil(ijk, mC);
     }
-};
+}
 
-template<typename TreeOrAccT, bool WithCache>
-struct SampleFromVoxels<TreeOrAccT, 3, WithCache> : public TricubicSampler<TreeOrAccT, WithCache>
+template<typename TreeOrAccT>
+class SampleFromVoxels<TreeOrAccT, 3, false> : public TricubicSampler<TreeOrAccT>
 {
-    __hostdev__ SampleFromVoxels(const TreeOrAccT& tree)
-        : TricubicSampler<TreeOrAccT, WithCache>(tree)
+    using BaseT  = TricubicSampler<TreeOrAccT>;
+    using ValueT = typename TreeOrAccT::ValueType;
+    using CoordT = typename TreeOrAccT::CoordType;
+
+public:
+    /// @brief Construction from a Tree or ReadAccessor
+    __hostdev__ SampleFromVoxels(const TreeOrAccT& acc)
+        : BaseT(acc)
     {
     }
-};
+
+    /// @note xyz is in index space space
+    template<typename RealT, template<typename...> class Vec3T>
+    inline __hostdev__ ValueT operator()(Vec3T<RealT> xyz) const;
+
+    __hostdev__ ValueT operator()(const CoordT &ijk) const {return BaseT::mAcc.getValue(ijk);}
+
+}; // SampleFromVoxels<TreeOrAccT, 3, true>
+
+template<typename TreeOrAccT>
+template<typename RealT, template<typename...> class Vec3T>
+__hostdev__ typename TreeOrAccT::ValueType SampleFromVoxels<TreeOrAccT, 3, false>::operator()(Vec3T<RealT> xyz) const
+{
+    ValueT C[64];
+    CoordT ijk = Floor<CoordT>(xyz);
+    BaseT::stencil(ijk, C);
+    return BaseT::sample(xyz, C);
+}
 
 } // namespace nanovdb
 
diff -aur nanovdb-20200925/nanovdb/unittest/TestNanoVDB.cpp nanovdb-20201022/nanovdb/unittest/TestNanoVDB.cpp
--- nanovdb-20200925/nanovdb/unittest/TestNanoVDB.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/unittest/TestNanoVDB.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -5,9 +5,11 @@
 #include <cstdlib>
 #include <sstream> // for std::stringstream
 #include <vector>
+#include <limits.h> // CHAR_BIT
 #include <algorithm> // for std::is_sorted
 #define _USE_MATH_DEFINES
 #include <cmath>
+#include <cstdlib> 
 
 #include "gtest/gtest.h"
 
@@ -26,7 +28,7 @@
 inline std::ostream&
 operator<<(std::ostream& os, const nanovdb::CoordBBox& b)
 {
-    os << "(" << b[0][0] << "," << b[0][1] << "," << b[0][2] << ") ->"
+    os << "(" << b[0][0] << "," << b[0][1] << "," << b[0][2] << ") -> "
        << "(" << b[1][0] << "," << b[1][1] << "," << b[1][2] << ")";
     return os;
 }
@@ -38,7 +40,7 @@
     return os;
 }
 
-template <typename T>
+template<typename T>
 inline std::ostream&
 operator<<(std::ostream& os, const nanovdb::Vec3<T>& v)
 {
@@ -74,23 +76,30 @@
         const char* str = std::getenv(name.c_str());
         return str == nullptr ? std::string("") : std::string(str);
     }
-    /*
-    nanovdb::GridHandle<> getSrcGrid(int verbose = 1)
+
+    template<typename T>
+    void printType(const std::string& s)
     {
+        const auto n = sizeof(T);
+        std::cerr << "Size of " << s << ": " << n << " bytes which is" << (n % 32 == 0 ? " " : " NOT ") << "32 byte aligned" << std::endl;
     }
-*/
     nanovdb::CpuTimer<> mTimer;
 }; // TestNanoVDB
 
 TEST_F(TestNanoVDB, Basic)
 {
+    { // CHAR_BIT
+        EXPECT_EQ(8, CHAR_BIT);
+    }
     {
         std::vector<int> v = {3, 1, 7, 0};
         EXPECT_FALSE(std::is_sorted(v.begin(), v.end()));
         std::map<int, void*> m;
-        for (const auto& i : v) m[i] = nullptr;
+        for (const auto& i : v)
+            m[i] = nullptr;
         v.clear();
-        for (const auto& i : m) v.push_back(i.first);
+        for (const auto& i : m)
+            v.push_back(i.first);
         EXPECT_TRUE(std::is_sorted(v.begin(), v.end()));
     }
     {
@@ -126,7 +135,7 @@
 
 TEST_F(TestNanoVDB, Magic)
 {
-    EXPECT_EQ(25, NANOVDB_MAJOR_VERSION_NUMBER);
+    EXPECT_EQ(28, NANOVDB_MAJOR_VERSION_NUMBER);
     EXPECT_EQ(0, NANOVDB_MINOR_VERSION_NUMBER);
     EXPECT_EQ(0, NANOVDB_PATCH_VERSION_NUMBER);
     EXPECT_EQ(0x304244566f6e614eUL, NANOVDB_MAGIC_NUMBER); // Magic number: "NanoVDB0" in hex)
@@ -137,7 +146,7 @@
     EXPECT_EQ(8u, strlen(str));
     std::stringstream ss1;
     ss1 << "0x";
-    for (int i = 7; i>=0; --i)
+    for (int i = 7; i >= 0; --i)
         ss1 << std::hex << unsigned(str[i]);
     ss1 << "UL";
     //std::cerr << ss1.str() << std::endl;
@@ -160,28 +169,42 @@
     EXPECT_EQ(magic, nanovdb::io::reverseEndianness(NANOVDB_MAGIC_NUMBER));
 }
 
+TEST_F(TestNanoVDB, FindBits)
+{
+    for (uint32_t i = 0; i < 32; ++i) {
+        uint32_t word = uint32_t(1) << i;
+        EXPECT_EQ(i, nanovdb::FindLowestOn(word));
+        EXPECT_EQ(i, nanovdb::FindHighestOn(word));
+    }
+    for (uint32_t i = 0; i < 64; ++i) {
+        uint64_t word = uint64_t(1) << i;
+        EXPECT_EQ(i, nanovdb::FindLowestOn(word));
+        EXPECT_EQ(i, nanovdb::FindHighestOn(word));
+    }
+}
+
 TEST_F(TestNanoVDB, CRC32)
 {
-    {// test function that uses iterators
+    { // test function that uses iterators
         const std::string s{"The quick brown fox jumps over the lazy dog"};
         std::stringstream ss;
         ss << std::hex << std::setw(8) << std::setfill('0') << nanovdb::crc32(s.begin(), s.end());
         EXPECT_EQ("414fa339", ss.str());
     }
-    {// test the checksum for a modified string
+    { // test the checksum for a modified string
         const std::string s{"The quick brown Fox jumps over the lazy dog"};
         std::stringstream ss;
         ss << std::hex << std::setw(8) << std::setfill('0') << nanovdb::crc32(s.begin(), s.end());
         EXPECT_NE("414fa339", ss.str());
     }
-    {// test function that uses void pointer and byte size
+    { // test function that uses void pointer and byte size
         const std::string s{"The quick brown fox jumps over the lazy dog"};
         std::stringstream ss;
         ss << std::hex << std::setw(8) << std::setfill('0') << nanovdb::crc32(s.data(), s.size());
         EXPECT_EQ("414fa339", ss.str());
     }
-    {// test accumulation
-        nanovdb::CRC32 crc;
+    { // test accumulation
+        nanovdb::CRC32    crc;
         const std::string s1{"The quick brown fox jum"};
         crc(s1.begin(), s1.end());
         const std::string s2{"ps over the lazy dog"};
@@ -202,9 +225,9 @@
     EXPECT_TRUE(r1.is_divisible());
     EXPECT_EQ(0U, r1.begin());
     EXPECT_EQ(20U, r1.end());
-        
+
     nanovdb::Range1D r2(r1, nanovdb::Split());
-        
+
     EXPECT_FALSE(r1.empty());
     EXPECT_EQ(2U, r1.grainsize());
     EXPECT_EQ(10U, r1.size());
@@ -225,7 +248,7 @@
 TEST_F(TestNanoVDB, Range2D)
 {
     nanovdb::Range<2, int> r1(-20, 20, 1u, 0, 20, 2u);
-        
+
     EXPECT_FALSE(r1.empty());
     EXPECT_EQ(1U, r1[0].grainsize());
     EXPECT_EQ(40U, r1[0].size());
@@ -233,23 +256,23 @@
     EXPECT_TRUE(r1[0].is_divisible());
     EXPECT_EQ(-20, r1[0].begin());
     EXPECT_EQ(20, r1[0].end());
-        
+
     EXPECT_EQ(2U, r1[1].grainsize());
     EXPECT_EQ(20U, r1[1].size());
     EXPECT_EQ(10, r1[1].middle());
     EXPECT_TRUE(r1[1].is_divisible());
     EXPECT_EQ(0, r1[1].begin());
     EXPECT_EQ(20, r1[1].end());
-        
+
     nanovdb::Range<2, int> r2(r1, nanovdb::Split());
-        
+
     EXPECT_FALSE(r1.empty());
     EXPECT_EQ(1U, r1[0].grainsize());
     EXPECT_EQ(20U, r1[0].size());
     EXPECT_EQ(-10, r1[0].middle());
     EXPECT_TRUE(r1[0].is_divisible());
     EXPECT_EQ(-20, r1[0].begin());
-    EXPECT_EQ(  0, r1[0].end());
+    EXPECT_EQ(0, r1[0].end());
 
     EXPECT_EQ(2U, r1[1].grainsize());
     EXPECT_EQ(20U, r1[1].size());
@@ -261,7 +284,7 @@
     EXPECT_FALSE(r2.empty());
     EXPECT_EQ(1U, r2[0].grainsize());
     EXPECT_EQ(20U, r2[0].size());
-    EXPECT_EQ( 10, r2[0].middle());
+    EXPECT_EQ(10, r2[0].middle());
     EXPECT_TRUE(r2[0].is_divisible());
     EXPECT_EQ(0, r2[0].begin());
     EXPECT_EQ(20, r2[0].end());
@@ -278,7 +301,7 @@
 TEST_F(TestNanoVDB, Range3D)
 {
     nanovdb::Range<3, int> r1(-20, 20, 1u, 0, 20, 2u, 0, 10, 5);
-        
+
     EXPECT_FALSE(r1.empty());
     EXPECT_EQ(1U, r1[0].grainsize());
     EXPECT_EQ(40U, r1[0].size());
@@ -286,7 +309,7 @@
     EXPECT_TRUE(r1[0].is_divisible());
     EXPECT_EQ(-20, r1[0].begin());
     EXPECT_EQ(20, r1[0].end());
-        
+
     EXPECT_EQ(2U, r1[1].grainsize());
     EXPECT_EQ(20U, r1[1].size());
     EXPECT_EQ(10, r1[1].middle());
@@ -300,16 +323,16 @@
     EXPECT_TRUE(r1[2].is_divisible());
     EXPECT_EQ(0, r1[2].begin());
     EXPECT_EQ(10, r1[2].end());
-        
+
     nanovdb::Range<3, int> r2(r1, nanovdb::Split());
-        
+
     EXPECT_FALSE(r1.empty());
     EXPECT_EQ(1U, r1[0].grainsize());
     EXPECT_EQ(20U, r1[0].size());
     EXPECT_EQ(-10, r1[0].middle());
     EXPECT_TRUE(r1[0].is_divisible());
     EXPECT_EQ(-20, r1[0].begin());
-    EXPECT_EQ(  0, r1[0].end());
+    EXPECT_EQ(0, r1[0].end());
 
     EXPECT_EQ(2U, r1[1].grainsize());
     EXPECT_EQ(20U, r1[1].size());
@@ -328,7 +351,7 @@
     EXPECT_FALSE(r2.empty());
     EXPECT_EQ(1U, r2[0].grainsize());
     EXPECT_EQ(20U, r2[0].size());
-    EXPECT_EQ( 10, r2[0].middle());
+    EXPECT_EQ(10, r2[0].middle());
     EXPECT_TRUE(r2[0].is_divisible());
     EXPECT_EQ(0, r2[0].begin());
     EXPECT_EQ(20, r2[0].end());
@@ -352,11 +375,10 @@
 
 TEST_F(TestNanoVDB, Coord)
 {
-    
     EXPECT_EQ(size_t(3 * 4), nanovdb::Coord::memUsage()); // due to padding
     {
         nanovdb::Coord ijk;
-        EXPECT_EQ( sizeof(ijk), size_t(3 * 4));
+        EXPECT_EQ(sizeof(ijk), size_t(3 * 4));
         EXPECT_EQ(0, ijk[0]);
         EXPECT_EQ(0, ijk[1]);
         EXPECT_EQ(0, ijk[2]);
@@ -399,10 +421,10 @@
 TEST_F(TestNanoVDB, BBox)
 {
     nanovdb::BBox<nanovdb::Vec3f> bbox;
-    EXPECT_EQ( sizeof(bbox), size_t(2*3*4) );
-    EXPECT_EQ( std::numeric_limits<float>::max(), bbox[0][0]);
-    EXPECT_EQ( std::numeric_limits<float>::max(), bbox[0][1]);
-    EXPECT_EQ( std::numeric_limits<float>::max(), bbox[0][2]);
+    EXPECT_EQ(sizeof(bbox), size_t(2 * 3 * 4));
+    EXPECT_EQ(std::numeric_limits<float>::max(), bbox[0][0]);
+    EXPECT_EQ(std::numeric_limits<float>::max(), bbox[0][1]);
+    EXPECT_EQ(std::numeric_limits<float>::max(), bbox[0][2]);
     EXPECT_EQ(-std::numeric_limits<float>::max(), bbox[1][0]);
     EXPECT_EQ(-std::numeric_limits<float>::max(), bbox[1][1]);
     EXPECT_EQ(-std::numeric_limits<float>::max(), bbox[1][2]);
@@ -411,28 +433,28 @@
     bbox.expand(nanovdb::Vec3f(57.0f, -31.0f, 60.0f));
     EXPECT_TRUE(bbox.empty());
     EXPECT_EQ(nanovdb::Vec3f(0.0f), bbox.dim());
-    EXPECT_EQ( 57.0f, bbox[0][0]);
+    EXPECT_EQ(57.0f, bbox[0][0]);
     EXPECT_EQ(-31.0f, bbox[0][1]);
-    EXPECT_EQ( 60.0f, bbox[0][2]);
-    EXPECT_EQ( 57.0f, bbox[1][0]);
+    EXPECT_EQ(60.0f, bbox[0][2]);
+    EXPECT_EQ(57.0f, bbox[1][0]);
     EXPECT_EQ(-31.0f, bbox[1][1]);
-    EXPECT_EQ( 60.0f, bbox[1][2]);
+    EXPECT_EQ(60.0f, bbox[1][2]);
 
     bbox.expand(nanovdb::Vec3f(58.0f, 0.0f, 62.0f));
     EXPECT_FALSE(bbox.empty());
     EXPECT_EQ(nanovdb::Vec3f(1.0f, 31.0f, 2.0f), bbox.dim());
-    EXPECT_EQ( 57.0f, bbox[0][0]);
+    EXPECT_EQ(57.0f, bbox[0][0]);
     EXPECT_EQ(-31.0f, bbox[0][1]);
-    EXPECT_EQ( 60.0f, bbox[0][2]);
-    EXPECT_EQ( 58.0f, bbox[1][0]);
-    EXPECT_EQ(  0.0f, bbox[1][1]);
-    EXPECT_EQ( 62.0f, bbox[1][2]);
+    EXPECT_EQ(60.0f, bbox[0][2]);
+    EXPECT_EQ(58.0f, bbox[1][0]);
+    EXPECT_EQ(0.0f, bbox[1][1]);
+    EXPECT_EQ(62.0f, bbox[1][2]);
 }
 
 TEST_F(TestNanoVDB, CoordBBox)
 {
     nanovdb::CoordBBox bbox;
-    EXPECT_EQ( sizeof(bbox), size_t(2*3*4) );
+    EXPECT_EQ(sizeof(bbox), size_t(2 * 3 * 4));
     EXPECT_EQ(std::numeric_limits<int32_t>::max(), bbox[0][0]);
     EXPECT_EQ(std::numeric_limits<int32_t>::max(), bbox[0][1]);
     EXPECT_EQ(std::numeric_limits<int32_t>::max(), bbox[0][2]);
@@ -461,14 +483,14 @@
     EXPECT_EQ(0, bbox[1][1]);
     EXPECT_EQ(62, bbox[1][2]);
 
-    {// test convert
-      auto bbox2 = bbox.asReal<float>();
-      EXPECT_FALSE( bbox2.empty() );
-      EXPECT_EQ(nanovdb::Vec3f(57.0f,-31.0f,60.0f), bbox2.min());
-      EXPECT_EQ(nanovdb::Vec3f(59.0f,  1.0f,63.0f), bbox2.max());
+    { // test convert
+        auto bbox2 = bbox.asReal<float>();
+        EXPECT_FALSE(bbox2.empty());
+        EXPECT_EQ(nanovdb::Vec3f(57.0f, -31.0f, 60.0f), bbox2.min());
+        EXPECT_EQ(nanovdb::Vec3f(59.0f, 1.0f, 63.0f), bbox2.max());
     }
 
-    {// test prefix iterator
+    { // test prefix iterator
         auto iter = bbox.begin();
         EXPECT_TRUE(iter);
         for (int i = bbox.min()[0]; i <= bbox.max()[0]; ++i) {
@@ -476,37 +498,51 @@
                 for (int k = bbox.min()[2]; k <= bbox.max()[2]; ++k) {
                     EXPECT_TRUE(bbox.isInside(*iter));
                     EXPECT_TRUE(iter);
-                    const auto &ijk = *iter;// note, copy by reference
-                    EXPECT_EQ( ijk[0] , i);
-                    EXPECT_EQ( ijk[1] , j);
-                    EXPECT_EQ( ijk[2] , k);
+                    const auto& ijk = *iter; // note, copy by reference
+                    EXPECT_EQ(ijk[0], i);
+                    EXPECT_EQ(ijk[1], j);
+                    EXPECT_EQ(ijk[2], k);
                     ++iter;
                 }
             }
         }
         EXPECT_FALSE(iter);
     }
-    
-    {// test postfix iterator 
+
+    { // test postfix iterator
         auto iter = bbox.begin();
         EXPECT_TRUE(iter);
         for (int i = bbox.min()[0]; i <= bbox.max()[0]; ++i) {
             for (int j = bbox.min()[1]; j <= bbox.max()[1]; ++j) {
                 for (int k = bbox.min()[2]; k <= bbox.max()[2]; ++k) {
                     EXPECT_TRUE(iter);
-                    const auto ijk = *iter++;// note, copy by value!
-                    EXPECT_EQ( ijk[0] , i);
-                    EXPECT_EQ( ijk[1] , j);
-                    EXPECT_EQ( ijk[2] , k);
+                    const auto ijk = *iter++; // note, copy by value!
+                    EXPECT_EQ(ijk[0], i);
+                    EXPECT_EQ(ijk[1], j);
+                    EXPECT_EQ(ijk[2], k);
                 }
-            }   
+            }
         }
         EXPECT_FALSE(iter);
     }
 }
 
-TEST_F(TestNanoVDB, Vec3R)
+TEST_F(TestNanoVDB, Vec3)
 {
+    bool test = nanovdb::is_specialization<double, nanovdb::Vec3>::value;
+    EXPECT_FALSE(test);
+    test = nanovdb::TensorTraits<double>::IsVector;
+    EXPECT_FALSE(test);
+    test = nanovdb::is_specialization<nanovdb::Vec3R, nanovdb::Vec3>::value;
+    EXPECT_TRUE(test);
+    test = nanovdb::is_same<double, nanovdb::Vec3R::ValueType>::value;
+    EXPECT_TRUE(test);
+    test = nanovdb::TensorTraits<nanovdb::Vec3R>::IsVector;
+    EXPECT_TRUE(test);
+    test = nanovdb::is_same<double, nanovdb::TensorTraits<nanovdb::Vec3R>::ElementType>::value;
+    EXPECT_TRUE(test);
+    test = nanovdb::is_same<double, nanovdb::FloatTraits<nanovdb::Vec3R>::FloatType>::value;
+    EXPECT_TRUE(test);
     EXPECT_EQ(size_t(3 * 8), sizeof(nanovdb::Vec3R));
 
     nanovdb::Vec3R xyz(1.0, 2.0, 3.0);
@@ -523,6 +559,156 @@
     EXPECT_EQ(sqrt(1.0 + 4.0 + 9.0), xyz.length());
 }
 
+TEST_F(TestNanoVDB, Vec4)
+{
+    bool test = nanovdb::is_specialization<double, nanovdb::Vec4>::value;
+    EXPECT_FALSE(test);
+    test = nanovdb::TensorTraits<double>::IsVector;
+    EXPECT_FALSE(test);
+    test = nanovdb::TensorTraits<double>::IsScalar;
+    EXPECT_TRUE(test);
+    int rank = nanovdb::TensorTraits<double>::Rank;
+    EXPECT_EQ(0, rank);
+    rank = nanovdb::TensorTraits<nanovdb::Vec3R>::Rank;
+    EXPECT_EQ(1, rank);
+    test = nanovdb::is_same<double, nanovdb::FloatTraits<float>::FloatType>::value;
+    EXPECT_FALSE(test);
+    test = nanovdb::is_same<double, nanovdb::FloatTraits<double>::FloatType>::value;
+    EXPECT_TRUE(test);
+    test = nanovdb::is_same<float, nanovdb::FloatTraits<uint32_t>::FloatType>::value;
+    EXPECT_TRUE(test);
+    test = nanovdb::is_same<double, nanovdb::FloatTraits<uint64_t>::FloatType>::value;
+    EXPECT_TRUE(test);
+    test = nanovdb::is_specialization<nanovdb::Vec4R, nanovdb::Vec4>::value;
+    EXPECT_TRUE(test);
+    test = nanovdb::is_specialization<nanovdb::Vec3R, nanovdb::Vec4>::value;
+    EXPECT_FALSE(test);
+    test = nanovdb::is_same<double, nanovdb::Vec4R::ValueType>::value;
+    EXPECT_TRUE(test);
+    test = nanovdb::TensorTraits<nanovdb::Vec3R>::IsVector;
+    EXPECT_TRUE(test);
+    test = nanovdb::is_same<double, nanovdb::TensorTraits<nanovdb::Vec4R>::ElementType>::value;
+    EXPECT_TRUE(test);
+    test = nanovdb::is_same<double, nanovdb::TensorTraits<double>::ElementType>::value;
+    EXPECT_TRUE(test);
+    test = nanovdb::is_same<float, nanovdb::TensorTraits<float>::ElementType>::value;
+    EXPECT_TRUE(test);
+    test = nanovdb::is_same<uint32_t, nanovdb::TensorTraits<uint32_t>::ElementType>::value;
+    EXPECT_TRUE(test);
+    test = nanovdb::is_same<double, nanovdb::FloatTraits<nanovdb::Vec4R>::FloatType>::value;
+    EXPECT_TRUE(test);
+    EXPECT_EQ(size_t(4 * 8), sizeof(nanovdb::Vec4R));
+
+    nanovdb::Vec4R xyz(1.0, 2.0, 3.0, 4.0);
+    EXPECT_EQ(1.0, xyz[0]);
+    EXPECT_EQ(2.0, xyz[1]);
+    EXPECT_EQ(3.0, xyz[2]);
+    EXPECT_EQ(4.0, xyz[3]);
+
+    xyz[1] = -2.0;
+    EXPECT_EQ(1.0, xyz[0]);
+    EXPECT_EQ(-2.0, xyz[1]);
+    EXPECT_EQ(3.0, xyz[2]);
+    EXPECT_EQ(4.0, xyz[3]);
+
+    EXPECT_EQ(1.0 + 4.0 + 9.0 + 16.0, xyz.lengthSqr());
+    EXPECT_EQ(sqrt(1.0 + 4.0 + 9.0 + 16.0), xyz.length());
+}
+
+TEST_F(TestNanoVDB, Extrema)
+{
+    { // int
+        nanovdb::Extrema<int> e(-1);
+        EXPECT_EQ(-1, e.min());
+        EXPECT_EQ(-1, e.max());
+        e.add(-2);
+        e.add(5);
+        EXPECT_TRUE(e);
+        EXPECT_EQ(-2, e.min());
+        EXPECT_EQ(5, e.max());
+    }
+    { // float
+        nanovdb::Extrema<float> e(-1.0f);
+        EXPECT_EQ(-1.0f, e.min());
+        EXPECT_EQ(-1.0f, e.max());
+        e.add(-2.0f);
+        e.add(5.0f);
+        EXPECT_TRUE(e);
+        EXPECT_EQ(-2.0f, e.min());
+        EXPECT_EQ(5.0f, e.max());
+    }
+    { // Vec3f
+        nanovdb::Extrema<nanovdb::Vec3f> e(nanovdb::Vec3f(1.0f, 1.0f, 0.0f));
+        EXPECT_EQ(nanovdb::Vec3f(1.0f, 1.0f, 0.0f), e.min());
+        EXPECT_EQ(nanovdb::Vec3f(1.0f, 1.0f, 0.0f), e.max());
+        e.add(nanovdb::Vec3f(1.0f, 0.0f, 0.0f));
+        e.add(nanovdb::Vec3f(1.0f, 1.0f, 1.0f));
+        EXPECT_TRUE(e);
+        EXPECT_EQ(nanovdb::Vec3f(1.0f, 0.0f, 0.0f), e.min());
+        EXPECT_EQ(nanovdb::Vec3f(1.0f, 1.0f, 1.0f), e.max());
+    }
+}
+
+TEST_F(TestNanoVDB, RayEmptyBBox)
+{
+    using RealT = float;
+    using Vec3T = nanovdb::Vec3<RealT>;
+    using CoordT = nanovdb::Coord;
+    using CoordBBoxT = nanovdb::BBox<CoordT>;
+    using BBoxT = nanovdb::BBox<Vec3T>;
+    using RayT = nanovdb::Ray<RealT>;
+
+    // test bbox clip
+    const Vec3T dir(1.0, 0.0, 0.0);
+    const Vec3T eye(-1.0, 0.5, 0.5);
+    RealT       t0 = 0.0, t1 = 10000.0;
+    RayT        ray(eye, dir, t0, t1);
+    
+    const CoordBBoxT bbox1;
+    EXPECT_TRUE(bbox1.empty());
+    EXPECT_FALSE(ray.intersects(bbox1, t0, t1));
+
+    const BBoxT bbox2;
+    EXPECT_TRUE(bbox2.empty());
+    EXPECT_FALSE(ray.intersects(bbox2, t0, t1));
+}
+
+TEST_F(TestNanoVDB, RayBasic)
+{
+    using RealT = float;
+    using Vec3T = nanovdb::Vec3<RealT>;
+    using CoordT = nanovdb::Coord;
+    using CoordBBoxT = nanovdb::BBox<CoordT>;
+    using BBoxT = nanovdb::BBox<Vec3T>;
+    using RayT = nanovdb::Ray<RealT>;
+
+    // test bbox clip
+    const Vec3T dir(1.0, 0.0, 0.0);
+    const Vec3T eye(-1.0, 0.5, 0.5);
+    RealT       t0 = 0.0, t1 = 10000.0;
+    RayT        ray(eye, dir, t0, t1);
+
+    const CoordBBoxT bbox(CoordT(0, 0, 0), CoordT(0, 0, 0)); // only contains a single point (0,0,0)
+    EXPECT_FALSE(bbox.empty());
+    EXPECT_EQ(bbox.dim(), CoordT(1, 1, 1));
+
+    const BBoxT bbox2(CoordT(0, 0, 0), CoordT(0, 0, 0));
+    EXPECT_EQ(bbox2, bbox.asReal<float>());
+    EXPECT_FALSE(bbox2.empty());
+    EXPECT_EQ(bbox2.dim(), Vec3T(1.0f, 1.0f, 1.0f));
+    EXPECT_EQ(bbox2[0], Vec3T(0.0f, 0.0f, 0.0f));
+    EXPECT_EQ(bbox2[1], Vec3T(1.0f, 1.0f, 1.0f));
+
+    EXPECT_TRUE(ray.clip(bbox)); // ERROR: how can a non-empty bbox have no intersections!?
+    //EXPECT_TRUE( ray.clip(bbox.asReal<float>()));// correct!
+
+    // intersects the two faces of the box perpendicular to the x-axis!
+    EXPECT_EQ(1.0f, ray.t0());
+    EXPECT_EQ(2.0f, ray.t1());
+    EXPECT_EQ(ray(1.0f), Vec3T(0.0f, 0.5f, 0.5f)); //lower y component of intersection
+    EXPECT_EQ(ray(2.0f), Vec3T(1.0f, 0.5f, 0.5f)); //higher y component of intersection
+} // RayBasic
+
 TEST_F(TestNanoVDB, Ray)
 {
     using RealT = float;
@@ -539,15 +725,17 @@
     RayT        ray(eye, dir, t0, t1);
 
     // intersects the two faces of the box perpendicular to the y-axis!
-    EXPECT_TRUE(ray.clip(CoordBBoxT(CoordT(0, 2, 2), CoordT(2, 4, 6) - CoordT(1))));
+    EXPECT_TRUE(ray.clip(CoordBBoxT(CoordT(0, 2, 2), CoordT(2, 4, 6))));
+    //std::cerr << ray(0.5) << ", " << ray(2.0) << std::endl;
     EXPECT_EQ(0.5, ray.t0());
-    EXPECT_EQ(1.5, ray.t1());
+    EXPECT_EQ(2.0, ray.t1());
     EXPECT_EQ(ray(0.5)[1], 2); //lower y component of intersection
-    EXPECT_EQ(ray(1.5)[1], 4); //higher y component of intersection
+    EXPECT_EQ(ray(2.0)[1], 5); //higher y component of intersection
 
     ray.reset(eye, dir, t0, t1);
     // intersects the lower edge anlong the z-axis of the box
     EXPECT_TRUE(ray.clip(BBoxT(Vec3T(1.5, 2.0, 2.0), Vec3T(4.5, 4.0, 6.0))));
+    //std::cerr << ray(0.5) << ", " << ray(2.0) << std::endl;
     EXPECT_EQ(0.5, ray.t0());
     EXPECT_EQ(0.5, ray.t1());
     EXPECT_EQ(ray(0.5)[0], 1.5); //lower y component of intersection
@@ -555,7 +743,7 @@
 
     ray.reset(eye, dir, t0, t1);
     // no intersections
-    EXPECT_TRUE(!ray.clip(CoordBBoxT(CoordT(4, 2, 2), CoordT(6, 4, 6) - CoordT(1))));
+    EXPECT_TRUE(!ray.clip(CoordBBoxT(CoordT(4, 2, 2), CoordT(6, 4, 6))));
     EXPECT_EQ(t0, ray.t0());
     EXPECT_EQ(t1, ray.t1());
 }
@@ -728,20 +916,31 @@
 TEST_F(TestNanoVDB, LeafNode)
 {
     using LeafT = nanovdb::LeafNode<float>;
-    EXPECT_FALSE(LeafT::IgnoreValues);
+    //EXPECT_FALSE(LeafT::IgnoreValues);
     EXPECT_EQ(8u, LeafT::dim());
     EXPECT_EQ(512u, LeafT::voxelCount());
+    EXPECT_EQ(size_t(
+                  3 * 4 + // mBBoxMin
+                  4 * 1 + // mBBoxDif[3] + mFlags
+                  8 * 8 + // mValueMask,
+                  2 * 4 + // mMinimum, mMaximum
+                  2 * 4 + // mAverage, mVariance
+                  512 * 4 // mValues[512]
+                  ),
+              sizeof(LeafT)); // this particular value type happens to be exatly 32B aligned!
     EXPECT_EQ(nanovdb::AlignUp<NANOVDB_DATA_ALIGNMENT>(
                   3 * 4 + // mBBoxMin
                   4 * 1 + // mBBoxDif[3] + mFlags
                   8 * 8 + // mValueMask,
-                  2 * 4 + // mValueMin, mValueMax
+                  2 * 4 + // mMinimum, mMaximum
+                  2 * 4 + // mAverage, mVariance
                   512 * 4 // mValues[512]
                   ),
               sizeof(LeafT));
 
     // allocate buffer
     std::unique_ptr<uint8_t[]> buffer(new uint8_t[LeafT::memUsage()]);
+    std::memset(buffer.get(), 0, LeafT::memUsage());
     LeafT*                     leaf = reinterpret_cast<LeafT*>(buffer.get());
 
     { // set members of the leaf node
@@ -754,8 +953,36 @@
             data.mValueMask.setOn(i);
             *values++ = 1.234f;
         }
-        data.mValueMin = 0.0f;
-        data.mValueMax = 1.234f;
+        data.mMinimum = 0.0f;
+        data.mMaximum = 1.234f;
+    }
+
+    { // compute BBox
+        auto& data = *reinterpret_cast<LeafT::DataType*>(buffer.get());
+        EXPECT_EQ(8u, data.mValueMask.wordCount());
+
+        nanovdb::CoordBBox bbox(nanovdb::Coord(-1), nanovdb::Coord(-1));
+        uint64_t           word = 0u;
+        for (int i = 0; i < 8; ++i) {
+            if (uint64_t w = data.mValueMask.getWord<uint64_t>(i)) {
+                word |= w;
+                if (bbox[0][0] == -1)
+                    bbox[0][0] = i;
+                bbox[1][0] = i;
+            }
+        }
+        EXPECT_TRUE(word != 0u);
+        bbox[0][1] = nanovdb::FindLowestOn(word) >> 3;
+        bbox[1][1] = nanovdb::FindHighestOn(word) >> 3;
+
+        const uint8_t* p = reinterpret_cast<const uint8_t*>(&word);
+        uint32_t       b = p[0] | p[1] | p[2] | p[3] | p[4] | p[5] | p[6] | p[7];
+        EXPECT_TRUE(b != 0u);
+        bbox[0][2] = nanovdb::FindLowestOn(b);
+        bbox[1][2] = nanovdb::FindHighestOn(b);
+        //std::cerr << bbox << std::endl;
+        EXPECT_EQ(bbox[0], nanovdb::Coord(4, 0, 0));
+        EXPECT_EQ(bbox[1], nanovdb::Coord(7, 7, 7));
     }
 
     // check values
@@ -771,17 +998,72 @@
     }
     EXPECT_EQ(0.0f, leaf->valueMin());
     EXPECT_EQ(1.234f, leaf->valueMax());
+
+    { // test stand-alone implementation
+        auto localBBox = [](const LeafT* leaf) {
+            // static_assert(8u == LeafT::dim(), "Expected dim = 8");
+            nanovdb::CoordBBox bbox(nanovdb::Coord(-1, 0, 0), nanovdb::Coord(-1, 7, 7));
+            uint64_t           word64 = 0u;
+            for (int i = 0; i < 8; ++i) {
+                if (uint64_t w = leaf->valueMask().getWord<uint64_t>(i)) {
+                    word64 |= w;
+                    if (bbox[0][0] == -1)
+                        bbox[0][0] = i; // only set once
+                    bbox[1][0] = i;
+                }
+            }
+            assert(word64);
+            if (word64 == ~uint64_t(0))
+                return bbox; // early out of dense leaf
+            bbox[0][1] = nanovdb::FindLowestOn(word64) >> 3;
+            bbox[1][1] = nanovdb::FindHighestOn(word64) >> 3;
+            const uint32_t *p = reinterpret_cast<const uint32_t*>(&word64), word32 = p[0] | p[1];
+            const uint16_t *q = reinterpret_cast<const uint16_t*>(&word32), word16 = q[0] | q[1];
+            const uint8_t * b = reinterpret_cast<const uint8_t*>(&word16), byte = b[0] | b[1];
+            assert(byte);
+            bbox[0][2] = nanovdb::FindLowestOn(uint32_t(byte));
+            bbox[1][2] = nanovdb::FindHighestOn(uint32_t(byte));
+            return bbox;
+        }; // bboxOp
+
+        // test
+        leaf->data()->mValueMask.setOff();
+        const nanovdb::Coord min(1, 2, 3), max(5, 6, 7);
+        leaf->setValue(min, 1.0f);
+        leaf->setValue(max, 2.0f);
+        EXPECT_EQ(1.0f, leaf->getValue(min));
+        EXPECT_EQ(2.0f, leaf->getValue(max));
+        const auto bbox = localBBox(leaf);
+        //std::cerr << "bbox = " << bbox << std::endl;
+        EXPECT_EQ(bbox[0], min);
+        EXPECT_EQ(bbox[1], max);
+    }
+
+    { // test LeafNode::updateBBox
+        leaf->data()->mValueMask.setOff();
+        const nanovdb::Coord min(1, 2, 3), max(5, 6, 7);
+        leaf->setValue(min, 1.0f);
+        leaf->setValue(max, 2.0f);
+        EXPECT_EQ(1.0f, leaf->getValue(min));
+        EXPECT_EQ(2.0f, leaf->getValue(max));
+        leaf->updateBBox();
+        const auto bbox = leaf->bbox();
+        //std::cerr << "bbox = " << bbox << std::endl;
+        EXPECT_EQ(bbox[0], min);
+        EXPECT_EQ(bbox[1], max);
+    }
+
 } // LeafNode
 
 TEST_F(TestNanoVDB, LeafNodeValueMask)
 {
     using LeafT = nanovdb::LeafNode<nanovdb::ValueMask>;
-    EXPECT_TRUE(LeafT::IgnoreValues);
+    //EXPECT_TRUE(LeafT::IgnoreValues);
     EXPECT_EQ(8u, LeafT::dim());
     EXPECT_EQ(512u, LeafT::voxelCount());
     EXPECT_EQ(nanovdb::AlignUp<NANOVDB_DATA_ALIGNMENT>(8 * 8 + // mValueMask
                                                        3 * 4 + // mBBoxMin
-                                                       4 * 1), /// mBBoxDif[3] + mFalgs
+                                                       4 * 1), // mBBoxDif[3] + mFlags
               sizeof(LeafT));
 
     // allocate buffer
@@ -837,8 +1119,8 @@
             data.mValueMask.setOn(i);
             tiles->value = 1.234f;
         }
-        data.mValueMin = 0.0f;
-        data.mValueMax = 1.234f;
+        data.mMinimum = 0.0f;
+        data.mMaximum = 1.234f;
     }
 
     // check values
@@ -861,10 +1143,10 @@
 {
     using LeafT = nanovdb::LeafNode<nanovdb::ValueMask>;
     using NodeT = nanovdb::InternalNode<LeafT>;
-    EXPECT_TRUE(LeafT::IgnoreValues);
-    EXPECT_TRUE(NodeT::IgnoreValues);
+    //EXPECT_TRUE(LeafT::IgnoreValues);
+    //EXPECT_TRUE(NodeT::IgnoreValues);
     EXPECT_EQ(8 * 16u, NodeT::dim());
-    
+
     /*
     BBox<CoordT> mBBox; // 24B. node bounding box.
     int32_t      mOffset; // 4B. number of node offsets till first tile
@@ -872,11 +1154,11 @@
     MaskT        mValueMask; // LOG2DIM(5): 4096B, LOG2DIM(4): 512B
     MaskT        mChildMask; // LOG2DIM(5): 4096B, LOG2DIM(4): 512B
 
-    ValueT mValueMin;
-    ValueT mValueMax;
+    ValueT mMinimum;
+    ValueT mMaximum;
     alignas(32) Tile mTable[1u << (3 * LOG2DIM)];
     */
-    EXPECT_EQ(nanovdb::AlignUp<NANOVDB_DATA_ALIGNMENT>(size_t(24 + 4 + 4 + 512 + 512 + 4 + 4 + (16*16*16)*4)), NodeT::memUsage()); 
+    EXPECT_EQ(nanovdb::AlignUp<NANOVDB_DATA_ALIGNMENT>(size_t(24 + 4 + 4 + 512 + 512 + 4 + 4 + (16 * 16 * 16) * 4)), NodeT::memUsage());
 
     // an empty InternalNode
     std::unique_ptr<uint8_t[]> buffer(new uint8_t[NodeT::memUsage()]);
@@ -894,8 +1176,8 @@
             data.mValueMask.setOn(i);
             tiles->value = 1u;
         }
-        data.mValueMin = 0u;
-        data.mValueMax = 1u;
+        data.mMinimum = 0u;
+        data.mMaximum = 1u;
     }
 
     // check values
@@ -922,7 +1204,7 @@
     using NodeT3 = nanovdb::RootNode<NodeT2>;
     using CoordT = NodeT3::CoordType;
 
-    EXPECT_EQ(nanovdb::AlignUp<NANOVDB_DATA_ALIGNMENT>(sizeof(nanovdb::CoordBBox) + sizeof(uint64_t) + sizeof(uint32_t) + (3 * sizeof(float))), NodeT3::memUsage(0));
+    EXPECT_EQ(nanovdb::AlignUp<NANOVDB_DATA_ALIGNMENT>(sizeof(nanovdb::CoordBBox) + sizeof(uint64_t) + sizeof(uint32_t) + (5 * sizeof(float))), NodeT3::memUsage(0));
 
     // an empty RootNode
     std::unique_ptr<uint8_t[]> buffer(new uint8_t[NodeT3::memUsage(0)]);
@@ -930,7 +1212,7 @@
 
     { // set members of the node
         auto& data = *reinterpret_cast<NodeT3::DataType*>(buffer.get());
-        data.mBackground = data.mValueMin = data.mValueMax = 1.234f;
+        data.mBackground = data.mMinimum = data.mMaximum = 1.234f;
         data.mTileCount = 0;
     }
 
@@ -964,9 +1246,33 @@
     using GridT = nanovdb::Grid<TreeT>;
     using CoordT = LeafT::CoordType;
 
-   {// check GridData memory alignment
-    /*
-        static const int MaxNameSize = 256;
+    {
+        // This is just for visual insepction
+        /*
+        this->printType<GridT>("Grid");
+        this->printType<TreeT>("Tree");
+        this->printType<NodeT2>("Upper InternalNode");
+        this->printType<NodeT1>("Lower InternalNode");
+        this->printType<LeafT>("Leaf");
+        Old: W/O mAverage and mVariance
+            Size of Grid: 672 bytes which is 32 byte aligned
+            Size of Tree: 64 bytes which is 32 byte aligned
+            Size of Upper InternalNode: 139328 bytes which is 32 byte aligned
+            Size of Lower InternalNode: 17472 bytes which is 32 byte aligned
+            Size of Leaf: 2144 bytes which is 32 byte aligned
+        
+        New: WITH mAverage and mVariance
+            Size of Grid: 672 bytes which is 32 byte aligned
+            Size of Tree: 64 bytes which is 32 byte aligned
+            Size of Upper InternalNode: 139328 bytes which is 32 byte aligned
+            Size of Lower InternalNode: 17472 bytes which is 32 byte aligned
+            Size of Leaf: 2144 bytes which is 32 byte aligned
+        */
+    }
+
+    { // check GridData memory alignment
+        /*
+    static const int MaxNameSize = 256;
     uint64_t         mMagic; // 8B magic to validate it is valid grid data.
     uint64_t         mChecksum; // 8B. Checksum of grid buffer.
     uint32_t         mMajor;// 4B. major version number
@@ -1023,9 +1329,10 @@
         EXPECT_EQ(off, offset);
         offset += 4;
     }
-    
-    EXPECT_EQ(nanovdb::AlignUp<NANOVDB_DATA_ALIGNMENT>(8 + 8 + 4 + 4 + 8 + nanovdb::GridData::MaxNameSize + 48 + sizeof(nanovdb::Map) + 24 + 4 + 4 + 8 + 4), sizeof(GridT));
-    EXPECT_EQ(nanovdb::AlignUp<NANOVDB_DATA_ALIGNMENT>((4 + 8) * (RootT::LEVEL + 1)), sizeof(TreeT));
+
+    EXPECT_EQ(sizeof(GridT), nanovdb::AlignUp<NANOVDB_DATA_ALIGNMENT>(8 + 8 + 4 + 4 + 8 + nanovdb::GridData::MaxNameSize + 48 + sizeof(nanovdb::Map) + 24 + 4 + 4 + 8 + 4));
+    EXPECT_EQ(sizeof(TreeT), nanovdb::AlignUp<NANOVDB_DATA_ALIGNMENT>((2 * 4 + 8) * (RootT::LEVEL + 1)));
+    EXPECT_EQ(sizeof(TreeT), size_t((2 * 4 + 8) * (RootT::LEVEL + 1))); // should already be 32B aligned
 
     size_t bytes[6] = {GridT::memUsage(), TreeT::memUsage(), RootT::memUsage(1), NodeT2::memUsage(), NodeT1::memUsage(), LeafT::memUsage()};
     for (int i = 1; i < 6; ++i)
@@ -1044,8 +1351,8 @@
             data.mValueMask.setOn(i);
             *voxels++ = 1.234f;
         }
-        data.mValueMin = 0.0f;
-        data.mValueMax = 1.234f;
+        data.mMinimum = 0.0f;
+        data.mMaximum = 1.234f;
     }
 
     // lower internal node
@@ -1063,8 +1370,8 @@
             data.mValueMask.setOn(i);
             tiles->value = 1.234f;
         }
-        data.mValueMin = 0.0f;
-        data.mValueMax = 1.234f;
+        data.mMinimum = 0.0f;
+        data.mMaximum = 1.234f;
         data.mOffset = 1;
         EXPECT_EQ(leaf, data.child(0));
     }
@@ -1084,8 +1391,8 @@
             data.mValueMask.setOn(i);
             tiles->value = 1.234f;
         }
-        data.mValueMin = 0.0f;
-        data.mValueMax = 1.234f;
+        data.mMinimum = 0.0f;
+        data.mMaximum = 1.234f;
         data.mOffset = 1;
         EXPECT_EQ(node1, data.child(0));
     }
@@ -1094,7 +1401,7 @@
     RootT* root = reinterpret_cast<RootT*>(buffer.get() + bytes[1]);
     { // set members of the root node
         auto& data = *reinterpret_cast<RootT::DataType*>(buffer.get() + bytes[1]);
-        data.mBackground = data.mValueMin = data.mValueMax = 1.234f;
+        data.mBackground = data.mMinimum = data.mMaximum = 1.234f;
         data.mTileCount = 1;
         auto& tile = data.tile(0);
         tile.setChild(RootT::CoordType(0), 0);
@@ -1287,7 +1594,7 @@
         EXPECT_EQ(nanovdb::GridClass::Unknown, meta->gridClass());
         auto* dstGrid = handle.grid<float>();
         EXPECT_TRUE(dstGrid);
-        EXPECT_EQ(nanovdb::Vec3R(1.0) , dstGrid->voxelSize());
+        EXPECT_EQ(nanovdb::Vec3R(1.0), dstGrid->voxelSize());
         EXPECT_EQ(1u, dstGrid->activeVoxelCount());
         auto dstAcc = dstGrid->getAccessor();
         EXPECT_EQ(1.0f, dstAcc.getValue(nanovdb::Coord(1, 2, 3)));
@@ -1319,6 +1626,15 @@
         auto dstAcc = dstGrid->getAccessor();
         EXPECT_EQ(1.0f, dstAcc.getValue(nanovdb::Coord(1, 2, 3)));
         EXPECT_EQ(2.0f, dstAcc.getValue(nanovdb::Coord(2, -2, 9)));
+
+        const nanovdb::BBox<nanovdb::Vec3R> indexBBox = dstGrid->indexBBox();
+        EXPECT_DOUBLE_EQ(1.0, indexBBox[0][0]);
+        EXPECT_DOUBLE_EQ(-2.0, indexBBox[0][1]);
+        EXPECT_DOUBLE_EQ(3.0, indexBBox[0][2]);
+        EXPECT_DOUBLE_EQ(3.0, indexBBox[1][0]);
+        EXPECT_DOUBLE_EQ(3.0, indexBBox[1][1]);
+        EXPECT_DOUBLE_EQ(10.0, indexBBox[1][2]);
+
         EXPECT_EQ(nanovdb::Coord(1, -2, 3), dstGrid->indexBBox()[0]);
         EXPECT_EQ(nanovdb::Coord(2, 2, 9), dstGrid->indexBBox()[1]);
     }
@@ -1467,6 +1783,45 @@
     EXPECT_EQ(nanovdb::GridClass::LevelSet, meta->gridClass());
     auto* dstGrid = handle.grid<float>();
     EXPECT_TRUE(dstGrid);
+    EXPECT_TRUE(dstGrid->hasBBox());
+    EXPECT_TRUE(dstGrid->hasMinMax());
+    EXPECT_TRUE(dstGrid->hasAverage());
+    EXPECT_TRUE(dstGrid->hasStdDeviation());
+
+    const auto& tree = dstGrid->tree();
+
+    uint32_t n = 0;
+
+    // check root node
+    EXPECT_EQ(1u, tree.nodeCount(3));
+    const auto* node = dstGrid->tree().getNode<3>(0);
+    EXPECT_TRUE(node != nullptr);
+    EXPECT_EQ(0u, tree.getNodeID(*node));
+    EXPECT_EQ(n++, tree.getLinearOffset(*node));
+
+    // check upper internal nodes
+    for (uint32_t i = 0; i < tree.nodeCount(2); ++i) {
+        const auto* node = dstGrid->tree().getNode<2>(i);
+        EXPECT_TRUE(node != nullptr);
+        EXPECT_EQ(i, tree.getNodeID(*node));
+        EXPECT_EQ(n++, tree.getLinearOffset(*node));
+    }
+
+    // check lower internal nodes
+    for (uint32_t i = 0; i < tree.nodeCount(1); ++i) {
+        const auto* node = dstGrid->tree().getNode<1>(i);
+        EXPECT_TRUE(node != nullptr);
+        EXPECT_EQ(i, tree.getNodeID(*node));
+        EXPECT_EQ(n++, tree.getLinearOffset(*node));
+    }
+
+    // Check leaf nodes
+    for (uint32_t i = 0; i < tree.nodeCount(0); ++i) {
+        const auto* node = dstGrid->tree().getNode<0>(i);
+        EXPECT_TRUE(node != nullptr);
+        EXPECT_EQ(i, tree.getNodeID(*node));
+        EXPECT_EQ(n++, tree.getLinearOffset(*node));
+    }
 
     //std::cerr << "bbox.min = (" << dstGrid->indexBBox()[0][0] << ", " <<  dstGrid->indexBBox()[0][1] << ", " <<  dstGrid->indexBBox()[0][2] << ")" << std::endl;
     //std::cerr << "bbox.max = (" << dstGrid->indexBBox()[1][0] << ", " <<  dstGrid->indexBBox()[1][1] << ", " <<  dstGrid->indexBBox()[1][2] << ")" << std::endl;
@@ -1511,6 +1866,20 @@
     auto* dstGrid = handle.grid<float>();
     EXPECT_TRUE(dstGrid);
 
+    EXPECT_TRUE(dstGrid->hasBBox());
+    EXPECT_TRUE(dstGrid->hasMinMax());
+    EXPECT_TRUE(dstGrid->hasAverage());
+    EXPECT_TRUE(dstGrid->hasStdDeviation());
+
+    EXPECT_NEAR( -3.0f, dstGrid->tree().root().valueMin(), 0.04f);
+    EXPECT_NEAR(  3.0f, dstGrid->tree().root().valueMax(), 0.04f);
+    EXPECT_NEAR(  0.0f, dstGrid->tree().root().average(), 0.3f);
+    //std::cerr << dstGrid->tree().root().valueMin() << std::endl;
+    //std::cerr << dstGrid->tree().root().valueMax() << std::endl;
+    //std::cerr << dstGrid->tree().root().average() << std::endl;
+    //std::cerr << dstGrid->tree().root().stdDeviation() << std::endl;
+
+
     EXPECT_EQ(nanovdb::Coord(50 - 20 - 2), dstGrid->indexBBox()[0]);
     EXPECT_EQ(nanovdb::Coord(50 + 20 + 2), dstGrid->indexBBox()[1]);
 
@@ -1546,12 +1915,26 @@
     EXPECT_EQ(nanovdb::GridClass::FogVolume, meta->gridClass());
     auto* dstGrid = handle.grid<float>();
     EXPECT_TRUE(dstGrid);
+    EXPECT_TRUE(dstGrid->hasBBox());
+    EXPECT_TRUE(dstGrid->hasMinMax());
+    EXPECT_TRUE(dstGrid->hasAverage());
+    EXPECT_TRUE(dstGrid->hasStdDeviation());
+
+    EXPECT_NEAR(  0.0f, dstGrid->tree().root().valueMin(),1e-5);
+    EXPECT_NEAR(  1.0f, dstGrid->tree().root().valueMax(), 1e-5);
+    EXPECT_NEAR(  0.8f, dstGrid->tree().root().average(), 1e-3);
+    EXPECT_NEAR(  0.3f, dstGrid->tree().root().stdDeviation(), 1e-2);
+    //std::cerr << dstGrid->tree().root().valueMin() << std::endl;
+    //std::cerr << dstGrid->tree().root().valueMax() << std::endl;
+    //std::cerr << dstGrid->tree().root().average() << std::endl;
+    //std::cerr << dstGrid->tree().root().stdDeviation() << std::endl;
+
+    //std::cerr << "bbox.min = (" << dstGrid->indexBBox()[0][0] << ", " <<  dstGrid->indexBBox()[0][1] << ", " <<  dstGrid->indexBBox()[0][2] << ")" << std::endl;
+    //std::cerr << "bbox.max = (" << dstGrid->indexBBox()[1][0] << ", " <<  dstGrid->indexBBox()[1][1] << ", " <<  dstGrid->indexBBox()[1][2] << ")" << std::endl;
 
     EXPECT_EQ(nanovdb::Coord(50 - 20), dstGrid->indexBBox()[0]);
     EXPECT_EQ(nanovdb::Coord(50 + 20), dstGrid->indexBBox()[1]);
 
-    //std::cerr << "bbox.min = (" << dstGrid->indexBBox()[0][0] << ", " <<  dstGrid->indexBBox()[0][1] << ", " <<  dstGrid->indexBBox()[0][2] << ")" << std::endl;
-    //std::cerr << "bbox.max = (" << dstGrid->indexBBox()[1][0] << ", " <<  dstGrid->indexBBox()[1][1] << ", " <<  dstGrid->indexBBox()[1][2] << ")" << std::endl;
     Sphere<float> sphere(nanovdb::Vec3<float>(50), 20.0f);
     uint64_t      count = 0;
     auto          dstAcc = dstGrid->getAccessor();
@@ -1585,7 +1968,12 @@
     EXPECT_EQ(-1.0f, sphere(nanovdb::Coord(0, 0, 99)));
     EXPECT_EQ(1.0f, sphere(nanovdb::Coord(0, 0, 101)));
 
-    auto handle = nanovdb::createPointSphere<float>(1, 100.0f, nanovdb::Vec3d(0), 1.0f, nanovdb::Vec3d(0), "point_sphere");
+    auto handle = nanovdb::createPointSphere<float>(1,
+                                                    100.0f,
+                                                    nanovdb::Vec3d(0),
+                                                    1.0f,
+                                                    nanovdb::Vec3d(0),
+                                                    "point_sphere");
 
     const nanovdb::CoordBBox bbox(nanovdb::Coord(-100), nanovdb::Coord(100));
 
@@ -1597,6 +1985,10 @@
     EXPECT_EQ(nanovdb::GridClass::PointData, meta->gridClass());
     auto* dstGrid = handle.grid<uint32_t>();
     EXPECT_TRUE(dstGrid);
+    EXPECT_TRUE(dstGrid->hasBBox());
+    EXPECT_TRUE(dstGrid->hasMinMax());
+    EXPECT_FALSE(dstGrid->hasAverage());
+    EXPECT_FALSE(dstGrid->hasStdDeviation());
 
     EXPECT_EQ(bbox[0], dstGrid->indexBBox()[0]);
     EXPECT_EQ(bbox[1], dstGrid->indexBBox()[1]);
@@ -1641,6 +2033,10 @@
     EXPECT_EQ(nanovdb::GridClass::LevelSet, meta->gridClass());
     auto* dstGrid = handle.grid<float>();
     EXPECT_TRUE(dstGrid);
+    EXPECT_TRUE(dstGrid->hasBBox());
+    EXPECT_TRUE(dstGrid->hasMinMax());
+    EXPECT_TRUE(dstGrid->hasAverage());
+    EXPECT_TRUE(dstGrid->hasStdDeviation());
 
     EXPECT_EQ(nanovdb::Coord(50 - 100 - 50 - 2, 50 - 50 - 2, 50 - 100 - 50 - 2), dstGrid->indexBBox()[0]);
     EXPECT_EQ(nanovdb::Coord(50 + 100 + 50 + 2, 50 + 50 + 2, 50 + 100 + 50 + 2), dstGrid->indexBBox()[1]);
@@ -1671,6 +2067,10 @@
     EXPECT_EQ(nanovdb::GridClass::FogVolume, meta->gridClass());
     auto* dstGrid = handle.grid<float>();
     EXPECT_TRUE(dstGrid);
+    EXPECT_TRUE(dstGrid->hasBBox());
+    EXPECT_TRUE(dstGrid->hasMinMax());
+    EXPECT_TRUE(dstGrid->hasAverage());
+    EXPECT_TRUE(dstGrid->hasStdDeviation());
 
     //std::cerr << "bbox.min = (" << dstGrid->indexBBox()[0][0] << ", " <<  dstGrid->indexBBox()[0][1] << ", " <<  dstGrid->indexBBox()[0][2] << ")" << std::endl;
     //std::cerr << "bbox.max = (" << dstGrid->indexBBox()[1][0] << ", " <<  dstGrid->indexBBox()[1][1] << ", " <<  dstGrid->indexBBox()[1][2] << ")" << std::endl;
@@ -1704,6 +2104,10 @@
     EXPECT_EQ(nanovdb::GridClass::LevelSet, meta->gridClass());
     auto* dstGrid = handle.grid<float>();
     EXPECT_TRUE(dstGrid);
+    EXPECT_TRUE(dstGrid->hasBBox());
+    EXPECT_TRUE(dstGrid->hasMinMax());
+    EXPECT_TRUE(dstGrid->hasAverage());
+    EXPECT_TRUE(dstGrid->hasStdDeviation());
 
     EXPECT_EQ(nanovdb::Coord(50 - 20 - 2, 50 - 30 - 2, 50 - 40 - 2), dstGrid->indexBBox()[0]);
     EXPECT_EQ(nanovdb::Coord(50 + 20 + 2, 50 + 30 + 2, 50 + 40 + 2), dstGrid->indexBBox()[1]);
@@ -1733,6 +2137,10 @@
     EXPECT_EQ(nanovdb::GridClass::FogVolume, meta->gridClass());
     auto* dstGrid = handle.grid<float>();
     EXPECT_TRUE(dstGrid);
+    EXPECT_TRUE(dstGrid->hasBBox());
+    EXPECT_TRUE(dstGrid->hasMinMax());
+    EXPECT_TRUE(dstGrid->hasAverage());
+    EXPECT_TRUE(dstGrid->hasStdDeviation());
 
     EXPECT_EQ(nanovdb::Coord(50 - 20, 50 - 30, 50 - 40), dstGrid->indexBBox()[0]);
     EXPECT_EQ(nanovdb::Coord(50 + 20, 50 + 30, 50 + 40), dstGrid->indexBBox()[1]);
@@ -1779,188 +2187,194 @@
 TEST_F(TestNanoVDB, GridStats)
 {
     using GridT = nanovdb::NanoGrid<float>;
-    Sphere<float> sphere(nanovdb::Vec3<float>(50), 50.0f);
+    Sphere<float>               sphere(nanovdb::Vec3<float>(50), 50.0f);
     nanovdb::GridBuilder<float> builder(sphere.background());
-    const nanovdb::CoordBBox bbox(nanovdb::Coord(-100), nanovdb::Coord(100));
+    const nanovdb::CoordBBox    bbox(nanovdb::Coord(-100), nanovdb::Coord(100));
     //mTimer.start("GridBuilder");
     builder(sphere, bbox);
     //mTimer.stop();
     const auto handle1 = builder.getHandle<>(1.0, nanovdb::Vec3d(0.0), "test", nanovdb::GridClass::LevelSet);
-    auto handle2 = builder.getHandle<>(1.0, nanovdb::Vec3d(0.0), "test", nanovdb::GridClass::LevelSet);
+    auto       handle2 = builder.getHandle<>(1.0, nanovdb::Vec3d(0.0), "test", nanovdb::GridClass::LevelSet);
     EXPECT_TRUE(handle1);
     EXPECT_TRUE(handle2);
     const GridT* grid1 = handle1.grid<float>();
-    GridT *grid2 = handle2.grid<float>();
+    GridT*       grid2 = handle2.grid<float>();
     EXPECT_TRUE(grid1);
     EXPECT_TRUE(grid2);
 
     //std::cerr << "grid1 = " << grid1->indexBBox() << ", grid2 = " << grid2->indexBBox() << std::endl;
-    EXPECT_EQ( grid1->activeVoxelCount(), grid2->activeVoxelCount() );
-    EXPECT_EQ( grid1->worldBBox(), grid2->worldBBox() );
-    EXPECT_EQ( grid1->indexBBox(), grid2->indexBBox() );
+    EXPECT_EQ(grid1->activeVoxelCount(), grid2->activeVoxelCount());
+    EXPECT_EQ(grid1->worldBBox(), grid2->worldBBox());
+    EXPECT_EQ(grid1->indexBBox(), grid2->indexBBox());
 
-    {// reset stats in grid2
+    { // reset stats in grid2
         grid2->tree().root().data()->mActiveVoxelCount = uint64_t(0);
         grid2->data()->mWorldBBox = nanovdb::BBox<nanovdb::Vec3R>();
         grid2->tree().root().data()->mBBox = nanovdb::BBox<nanovdb::Coord>();
-        for (uint32_t i=0; i< grid2->tree().nodeCount(0); ++i) {
-            auto *leaf = grid2->tree().getNode<0>(i);
-            auto *data = leaf->data();
-            data->mValueMin = data->mValueMax = 0.0f;
-            data->mBBoxMin &= ~nanovdb::NanoLeaf<float>::MASK;/// set to origin!
+        for (uint32_t i = 0; i < grid2->tree().nodeCount(0); ++i) {
+            auto* leaf = grid2->tree().getNode<0>(i);
+            auto* data = leaf->data();
+            data->mMinimum = data->mMaximum = 0.0f;
+            data->mBBoxMin &= ~nanovdb::NanoLeaf<float>::MASK; /// set to origin!
             data->mBBoxDif[0] = data->mBBoxDif[1] = data->mBBoxDif[2] = uint8_t(255);
             EXPECT_EQ(data->mBBoxDif[0], uint8_t(255));
         }
-        for (uint32_t i=0; i< grid2->tree().nodeCount(1); ++i) {
-             auto *node = grid2->tree().getNode<1>(i);
-             auto *data = node->data();
-             data->mValueMin = data->mValueMax = 0.0f;
-             data->mBBox[0] &= ~nanovdb::NanoNode1<float>::MASK;/// set to origin!
-             data->mBBox[1] = nanovdb::Coord(0);
-        }
-        for (uint32_t i=0; i< grid2->tree().nodeCount(2); ++i) {
-             auto *node = grid2->tree().getNode<2>(i);
-             auto *data = node->data();
-             data->mValueMin = data->mValueMax = 0.0f;
-             data->mBBox[0] &= ~nanovdb::NanoNode2<float>::MASK;/// set to origin!
-             data->mBBox[1] = nanovdb::Coord(0);
+        for (uint32_t i = 0; i < grid2->tree().nodeCount(1); ++i) {
+            auto* node = grid2->tree().getNode<1>(i);
+            auto* data = node->data();
+            data->mMinimum = data->mMaximum = 0.0f;
+            data->mBBox[0] &= ~nanovdb::NanoNode1<float>::MASK; /// set to origin!
+            data->mBBox[1] = nanovdb::Coord(0);
+        }
+        for (uint32_t i = 0; i < grid2->tree().nodeCount(2); ++i) {
+            auto* node = grid2->tree().getNode<2>(i);
+            auto* data = node->data();
+            data->mMinimum = data->mMaximum = 0.0f;
+            data->mBBox[0] &= ~nanovdb::NanoNode2<float>::MASK; /// set to origin!
+            data->mBBox[1] = nanovdb::Coord(0);
         }
     }
     //std::cerr << "grid1 = " << grid1->indexBBox() << ", grid2 = " << grid2->indexBBox() << std::endl;
-    EXPECT_NE( grid1->activeVoxelCount(), grid2->activeVoxelCount() );
-    EXPECT_NE( grid1->indexBBox(), grid2->indexBBox() );
-    EXPECT_NE( grid1->worldBBox(), grid2->worldBBox() );
-
-    {// check stats in grid2
-        EXPECT_EQ( grid1->tree().nodeCount(0), grid2->tree().nodeCount(0));
-       
-        for (uint32_t i=0; i< grid2->tree().nodeCount(0); ++i) {
-            auto *leaf1 = grid1->tree().getNode<0>(i);
-            auto *leaf2 = grid2->tree().getNode<0>(i);
+    EXPECT_NE(grid1->activeVoxelCount(), grid2->activeVoxelCount());
+    EXPECT_NE(grid1->indexBBox(), grid2->indexBBox());
+    EXPECT_NE(grid1->worldBBox(), grid2->worldBBox());
+
+    { // check stats in grid2
+        EXPECT_EQ(grid1->tree().nodeCount(0), grid2->tree().nodeCount(0));
+
+        for (uint32_t i = 0; i < grid2->tree().nodeCount(0); ++i) {
+            auto* leaf1 = grid1->tree().getNode<0>(i);
+            auto* leaf2 = grid2->tree().getNode<0>(i);
             EXPECT_NE(leaf1->valueMin(), leaf2->valueMin());
             EXPECT_NE(leaf1->valueMax(), leaf2->valueMax());
             EXPECT_NE(leaf1->bbox(), leaf2->bbox());
         }
-        
-        EXPECT_EQ( grid1->tree().nodeCount(1), grid2->tree().nodeCount(1));
-        for (uint32_t i=0; i< grid2->tree().nodeCount(1); ++i) {
-            auto *node1 = grid1->tree().getNode<1>(i);
-            auto *node2 = grid2->tree().getNode<1>(i);
+
+        EXPECT_EQ(grid1->tree().nodeCount(1), grid2->tree().nodeCount(1));
+        for (uint32_t i = 0; i < grid2->tree().nodeCount(1); ++i) {
+            auto* node1 = grid1->tree().getNode<1>(i);
+            auto* node2 = grid2->tree().getNode<1>(i);
             EXPECT_NE(node1->valueMin(), node2->valueMin());
             EXPECT_NE(node1->valueMax(), node2->valueMax());
             EXPECT_NE(node1->bbox(), node2->bbox());
         }
-        EXPECT_EQ( grid1->tree().nodeCount(2), grid2->tree().nodeCount(2));
-        for (uint32_t i=0; i< grid2->tree().nodeCount(2); ++i) {
-            auto *node1 = grid1->tree().getNode<2>(i);
-            auto *node2 = grid2->tree().getNode<2>(i);
+        EXPECT_EQ(grid1->tree().nodeCount(2), grid2->tree().nodeCount(2));
+        for (uint32_t i = 0; i < grid2->tree().nodeCount(2); ++i) {
+            auto* node1 = grid1->tree().getNode<2>(i);
+            auto* node2 = grid2->tree().getNode<2>(i);
             EXPECT_NE(node1->valueMin(), node2->valueMin());
             EXPECT_NE(node1->valueMax(), node2->valueMax());
             EXPECT_NE(node1->bbox(), node2->bbox());
         }
     }
-    
+
     //mTimer.start("GridStats");
-    nanovdb::gridStats( *grid2 );
+    nanovdb::gridStats(*grid2);
     //mTimer.stop();
 
-    {// check stats in grid2
-        EXPECT_EQ( grid1->tree().nodeCount(0), grid2->tree().nodeCount(0));
-        for (uint32_t i=0; i< grid2->tree().nodeCount(0); ++i) {
-            auto *leaf1 = grid1->tree().getNode<0>(i);
-            auto *leaf2 = grid2->tree().getNode<0>(i);
+    { // check stats in grid2
+        EXPECT_EQ(grid1->tree().nodeCount(0), grid2->tree().nodeCount(0));
+        for (uint32_t i = 0; i < grid2->tree().nodeCount(0); ++i) {
+            auto* leaf1 = grid1->tree().getNode<0>(i);
+            auto* leaf2 = grid2->tree().getNode<0>(i);
             EXPECT_EQ(leaf1->valueMin(), leaf2->valueMin());
             EXPECT_EQ(leaf1->valueMax(), leaf2->valueMax());
             EXPECT_EQ(leaf1->bbox(), leaf2->bbox());
         }
-        EXPECT_EQ( grid1->tree().nodeCount(1), grid2->tree().nodeCount(1));
-        for (uint32_t i=0; i< grid2->tree().nodeCount(1); ++i) {
-            auto *node1 = grid1->tree().getNode<1>(i);
-            auto *node2 = grid2->tree().getNode<1>(i);
+        EXPECT_EQ(grid1->tree().nodeCount(1), grid2->tree().nodeCount(1));
+        for (uint32_t i = 0; i < grid2->tree().nodeCount(1); ++i) {
+            auto* node1 = grid1->tree().getNode<1>(i);
+            auto* node2 = grid2->tree().getNode<1>(i);
             EXPECT_EQ(node1->valueMin(), node2->valueMin());
             EXPECT_EQ(node1->valueMax(), node2->valueMax());
             EXPECT_EQ(node1->bbox(), node2->bbox());
         }
-        EXPECT_EQ( grid1->tree().nodeCount(2), grid2->tree().nodeCount(2));
-        for (uint32_t i=0; i< grid2->tree().nodeCount(2); ++i) {
-            auto *node1 = grid1->tree().getNode<2>(i);
-            auto *node2 = grid2->tree().getNode<2>(i);
+        EXPECT_EQ(grid1->tree().nodeCount(2), grid2->tree().nodeCount(2));
+        for (uint32_t i = 0; i < grid2->tree().nodeCount(2); ++i) {
+            auto* node1 = grid1->tree().getNode<2>(i);
+            auto* node2 = grid2->tree().getNode<2>(i);
             EXPECT_EQ(node1->valueMin(), node2->valueMin());
             EXPECT_EQ(node1->valueMax(), node2->valueMax());
             EXPECT_EQ(node1->bbox(), node2->bbox());
         }
     }
 
-    //std::cerr << "grid1 = " << grid1->indexBBox() << ", grid2 = " << grid2->indexBBox() << std::endl; 
-    EXPECT_EQ( grid1->activeVoxelCount(), grid2->activeVoxelCount() );
-    EXPECT_EQ( grid1->indexBBox(), grid2->indexBBox() );
-    EXPECT_EQ( grid1->worldBBox(), grid2->worldBBox() );
+    //std::cerr << "grid1 = " << grid1->indexBBox() << ", grid2 = " << grid2->indexBBox() << std::endl;
+    EXPECT_EQ(grid1->activeVoxelCount(), grid2->activeVoxelCount());
+    EXPECT_EQ(grid1->indexBBox(), grid2->indexBBox());
+    EXPECT_EQ(grid1->worldBBox(), grid2->worldBBox());
 
-}// GridStats
+} // GridStats
 
 TEST_F(TestNanoVDB, ScalarSampleFromVoxels)
 {
     // create a grid so sample from
-    const float dx = 0.5f;// voxel size
-    auto trilinearWorld = [&](const nanovdb::Vec3d& xyz) -> float {
+    const float dx = 0.5f; // voxel size
+    auto        trilinearWorld = [&](const nanovdb::Vec3d& xyz) -> float {
         return 0.34f + 1.6f * xyz[0] + 6.7f * xyz[1] - 3.5f * xyz[2]; // index coordinates
     };
     auto trilinearIndex = [&](const nanovdb::Coord& ijk) -> float {
-        return 0.34f + 1.6f * dx* ijk[0] + 6.7f * dx * ijk[1] - 3.5f * dx * ijk[2]; // index coordinates
+        return 0.34f + 1.6f * dx * ijk[0] + 6.7f * dx * ijk[1] - 3.5f * dx * ijk[2]; // index coordinates
     };
-    
+
     nanovdb::GridBuilder<float> builder(1.0f);
-    const nanovdb::CoordBBox bbox(nanovdb::Coord(0), nanovdb::Coord(128));
+    const nanovdb::CoordBBox    bbox(nanovdb::Coord(0), nanovdb::Coord(128));
     builder(trilinearIndex, bbox);
     auto handle = builder.getHandle<>(dx);
     EXPECT_TRUE(handle);
     auto* grid = handle.grid<float>();
     EXPECT_TRUE(grid);
 
-    const nanovdb::Vec3d ijk(13.4, 24.67, 5.23); // in index space
-    const auto exact = trilinearWorld(grid->indexToWorld(ijk));
-    const auto approx = trilinearIndex(nanovdb::Coord(13, 25, 5));
+    const nanovdb::Vec3d xyz(13.4, 24.67, 5.23); // in index space
+    const nanovdb::Coord ijk(13, 25, 5); // in index space (nearest)
+    const auto           exact = trilinearWorld(grid->indexToWorld(xyz));
+    const auto           approx = trilinearIndex(ijk);
     //std::cerr << "Trilinear: exact = " << exact << ", approx = " << approx << std::endl;
 
     auto acc = grid->getAccessor();
-    auto sampler0 = nanovdb::createSampler<0>(acc);
-    //std::cerr << "0'th order: v = " << sampler0(ijk) << std::endl;
-    EXPECT_EQ(approx, sampler0(ijk));
-
-    auto sampler1 = nanovdb::createSampler<1>(acc); // faster since it's using an accessor!!!
-    //std::cerr << "1'th order: v = " << sampler1(ijk) << std::endl;
-    EXPECT_NEAR(exact, sampler1(ijk), 1e-5);
+    auto sampler0 = nanovdb::createSampler<0>(grid->tree());
+    auto sampler1 = nanovdb::createSampler<1>(acc);
+    auto sampler2 = nanovdb::createSampler<2>(acc);
+    auto sampler3 = nanovdb::createSampler<3>(acc);
+    //std::cerr << "0'th order: v = " << sampler0(xyz) << std::endl;
+    EXPECT_EQ(approx, sampler0(xyz));
+    EXPECT_NE(exact, sampler0(xyz));
+    //std::cerr << "1'th order: v = " << sampler1(xyz) << std::endl;
+    EXPECT_NEAR(exact, sampler1(xyz), 1e-5);
+    //std::cerr << "2'th order: v = " << sampler2(xyz) << std::endl;
+    EXPECT_NEAR(exact, sampler2(xyz), 1e-4);
+    //std::cerr << "3'rd order: v = " << sampler3(xyz) << std::endl;
+    EXPECT_NEAR(exact, sampler3(xyz), 1e-5);
 
     EXPECT_FALSE(sampler1.zeroCrossing());
-    const auto gradIndex = sampler1.gradient(ijk); //in index space
-    EXPECT_NEAR( 1.6f, gradIndex[0] / dx, 2e-5);
-    EXPECT_NEAR( 6.7f, gradIndex[1] / dx, 2e-5);
+    const auto gradIndex = sampler1.gradient(xyz); //in index space
+    EXPECT_NEAR(1.6f, gradIndex[0] / dx, 2e-5);
+    EXPECT_NEAR(6.7f, gradIndex[1] / dx, 2e-5);
     EXPECT_NEAR(-3.5f, gradIndex[2] / dx, 2e-5);
-    const auto gradWorld = grid->indexToWorldDir(gradIndex); // in world units
-    EXPECT_NEAR( 1.6f, gradWorld[0], 2e-5);
-    EXPECT_NEAR( 6.7f, gradWorld[1], 2e-5);
+    const auto gradWorld = grid->indexToWorldGrad(gradIndex); // in world units
+    EXPECT_NEAR(1.6f, gradWorld[0], 2e-5);
+    EXPECT_NEAR(6.7f, gradWorld[1], 2e-5);
     EXPECT_NEAR(-3.5f, gradWorld[2], 2e-5);
 
-    nanovdb::SampleFromVoxels<nanovdb::NanoTree<float>, 3> sampler3(grid->tree());
-    //auto sampler3 = nanovdb::createSampler<3>( dstAcc );
-    //std::cerr << "3'rd order: v = " << sampler3(ijk) << std::endl;
-    EXPECT_NEAR(exact, sampler3(ijk), 1e-5);
-    
+    EXPECT_EQ(grid->tree().getValue(ijk), sampler0.accessor().getValue(ijk));
+    EXPECT_EQ(grid->tree().getValue(ijk), sampler1.accessor().getValue(ijk));
+    EXPECT_EQ(grid->tree().getValue(ijk), sampler2.accessor().getValue(ijk));
+    EXPECT_EQ(grid->tree().getValue(ijk), sampler3.accessor().getValue(ijk));
 } // ScalarSampleFromVoxels
 
 TEST_F(TestNanoVDB, VectorSampleFromVoxels)
 {
     // create a grid so sample from
-    const float dx = 0.5f;// voxel size
-    auto trilinearWorld = [&](const nanovdb::Vec3d& xyz) -> nanovdb::Vec3f {
-        return nanovdb::Vec3f(0.34f, 1.6f * xyz[0] + 6.7f * xyz[1], - 3.5f * xyz[2]); // index coordinates
+    const float dx = 0.5f; // voxel size
+    auto        trilinearWorld = [&](const nanovdb::Vec3d& xyz) -> nanovdb::Vec3f {
+        return nanovdb::Vec3f(0.34f, 1.6f * xyz[0] + 6.7f * xyz[1], -3.5f * xyz[2]); // index coordinates
     };
     auto trilinearIndex = [&](const nanovdb::Coord& ijk) -> nanovdb::Vec3f {
-        return nanovdb::Vec3f(0.34f, 1.6f * dx* ijk[0] + 6.7f * dx * ijk[1], - 3.5f * dx * ijk[2]); // index coordinates
+        return nanovdb::Vec3f(0.34f, 1.6f * dx * ijk[0] + 6.7f * dx * ijk[1], -3.5f * dx * ijk[2]); // index coordinates
     };
-    
+
     nanovdb::GridBuilder<nanovdb::Vec3f> builder(nanovdb::Vec3f(1.0f));
-    const nanovdb::CoordBBox bbox(nanovdb::Coord(0), nanovdb::Coord(128));
+    const nanovdb::CoordBBox             bbox(nanovdb::Coord(0), nanovdb::Coord(128));
     builder(trilinearIndex, bbox);
     auto handle = builder.getHandle<>(dx);
     EXPECT_TRUE(handle);
@@ -1968,8 +2382,8 @@
     EXPECT_TRUE(grid);
 
     const nanovdb::Vec3d ijk(13.4, 24.67, 5.23); // in index space
-    const auto exact = trilinearWorld(grid->indexToWorld(ijk));
-    const auto approx = trilinearIndex(nanovdb::Coord(13, 25, 5));
+    const auto           exact = trilinearWorld(grid->indexToWorld(ijk));
+    const auto           approx = trilinearIndex(nanovdb::Coord(13, 25, 5));
     //std::cerr << "Trilinear: exact = " << exact << ", approx = " << approx << std::endl;
 
     auto acc = grid->getAccessor();
@@ -1979,15 +2393,17 @@
 
     auto sampler1 = nanovdb::createSampler<1>(acc); // faster since it's using an accessor!!!
     //std::cerr << "1'th order: v = " << sampler1(ijk) << std::endl;
-    for (int i=0; i<3; ++i) EXPECT_NEAR(exact[i], sampler1(ijk)[i], 1e-5);
+    for (int i = 0; i < 3; ++i)
+        EXPECT_NEAR(exact[i], sampler1(ijk)[i], 1e-5);
     //EXPECT_FALSE(sampler1.zeroCrossing());// triggeres a static_assert error
     //EXPECT_FALSE(sampler1.gradient(grid->indexToWorld(ijk)));// triggeres a static_assert error
 
     nanovdb::SampleFromVoxels<nanovdb::NanoTree<nanovdb::Vec3f>, 3> sampler3(grid->tree());
     //auto sampler3 = nanovdb::createSampler<3>( acc );
     //std::cerr << "3'rd order: v = " << sampler3(ijk) << std::endl;
-    for (int i=0; i<3; ++i) EXPECT_NEAR(exact[i], sampler3(ijk)[i], 1e-5);
-    
+    for (int i = 0; i < 3; ++i)
+        EXPECT_NEAR(exact[i], sampler3(ijk)[i], 1e-5);
+
 } // VectorSampleFromVoxels
 
 TEST_F(TestNanoVDB, GridChecksum)
@@ -2005,14 +2421,21 @@
 
     nanovdb::CpuTimer<> timer;
     //timer.start("nanovdb::createLevelSetSphere");
-    auto handle = nanovdb::createLevelSetSphere<float>(100.0f, nanovdb::Vec3d(50), 1.0f, 3.0f, nanovdb::Vec3d(0), "sphere_20", nanovdb::ChecksumMode::Disable);
+    auto handle = nanovdb::createLevelSetSphere<float>(100.0f,
+                                                       nanovdb::Vec3d(50),
+                                                       1.0f,
+                                                       3.0f,
+                                                       nanovdb::Vec3d(0),
+                                                       "sphere_20",
+                                                       nanovdb::StatsMode::Disable,
+                                                       nanovdb::ChecksumMode::Disable);
     //timer.stop();
     EXPECT_TRUE(handle);
     auto* grid = handle.grid<float>();
     EXPECT_TRUE(grid);
 
     nanovdb::GridChecksum checksum1, checksum2, checksum3;
-    
+
     //timer.start("Full checksum");
     checksum1(*grid, nanovdb::ChecksumMode::Full);
     //timer.stop();
@@ -2023,77 +2446,193 @@
 
     checksum2(*grid, nanovdb::ChecksumMode::Full);
 
-    EXPECT_EQ( checksum1, checksum2 );
+    EXPECT_EQ(checksum1, checksum2);
 
-    auto *leaf = const_cast<nanovdb::NanoLeaf<float>*>(grid->tree().getNode<0>(0));
-    leaf->data()->mValues[0] += 0.00001f;// slightly modify a single voxel value 
+    auto* leaf = const_cast<nanovdb::NanoLeaf<float>*>(grid->tree().getNode<0>(0));
+    leaf->data()->mValues[0] += 0.00001f; // slightly modify a single voxel value
 
     checksum2(*grid, nanovdb::ChecksumMode::Full);
-    EXPECT_NE( checksum1, checksum2 );
+    EXPECT_NE(checksum1, checksum2);
 
-    leaf->data()->mValues[0] -= 0.00001f;// change back the single voxel value to it's original value
+    leaf->data()->mValues[0] -= 0.00001f; // change back the single voxel value to it's original value
 
     checksum2(*grid, nanovdb::ChecksumMode::Full);
-    EXPECT_EQ( checksum1, checksum2 );
+    EXPECT_EQ(checksum1, checksum2);
 
-    leaf->data()->mValueMask.toggle(0);// change a single bit in a value mask
+    leaf->data()->mValueMask.toggle(0); // change a single bit in a value mask
 
     checksum2(*grid, nanovdb::ChecksumMode::Full);
-    EXPECT_NE( checksum1, checksum2 );
+    EXPECT_NE(checksum1, checksum2);
 
     //timer.start("Incomplete checksum");
     checksum2(*grid, nanovdb::ChecksumMode::Partial);
-    //timer.stop(); 
-    EXPECT_EQ( checksum2, checksum3 );
-}// GridChecksum
+    //timer.stop();
+    EXPECT_EQ(checksum2, checksum3);
+} // GridChecksum
 
 TEST_F(TestNanoVDB, GridValidator)
 {
     //nanovdb::CpuTimer<> timer;
     //timer.start("nanovdb::createLevelSetSphere");
-    auto handle = nanovdb::createLevelSetSphere<float>(100.0f, nanovdb::Vec3d(50), 1.0f, 3.0f, nanovdb::Vec3d(0), "sphere_20", nanovdb::ChecksumMode::Full);
+    auto handle = nanovdb::createLevelSetSphere<float>(100.0f, 
+                                                       nanovdb::Vec3d(50), 
+                                                       1.0f, 3.0f, 
+                                                       nanovdb::Vec3d(0), 
+                                                       "sphere_20",
+                                                       nanovdb::StatsMode::All,
+                                                       nanovdb::ChecksumMode::Full);
     //timer.stop();
     EXPECT_TRUE(handle);
     auto* grid = handle.grid<float>();
     EXPECT_TRUE(grid);
-    
+
     //timer.start("isValid - detailed");
-    EXPECT_TRUE( nanovdb::isValid(*grid, true, true ) );
+    EXPECT_TRUE(nanovdb::isValid(*grid, true, true));
     //timer.stop();
 
     //timer.start("isValid - not detailed");
-    EXPECT_TRUE( nanovdb::isValid(*grid, false, true ) );
+    EXPECT_TRUE(nanovdb::isValid(*grid, false, true));
     //timer.stop();
 
     //timer.start("Slow CRC");
     auto slowChecksum = nanovdb::crc32_slow(*grid);
     //timer.stop();
-    EXPECT_EQ( slowChecksum, nanovdb::crc32_slow(*grid));
-    
+    EXPECT_EQ(slowChecksum, nanovdb::crc32_slow(*grid));
+
     //timer.start("Fast CRC");
     auto fastChecksum = nanovdb::crc32(*grid);
     //timer.stop();
-    EXPECT_EQ( fastChecksum, nanovdb::crc32(*grid));
+    EXPECT_EQ(fastChecksum, nanovdb::crc32(*grid));
 
-    auto *leaf = const_cast<nanovdb::NanoLeaf<float>*>(grid->tree().getNode<0>(0));
-    leaf->data()->mValues[0] += 0.00001f;// slightly modify a single voxel value 
+    auto* leaf = const_cast<nanovdb::NanoLeaf<float>*>(grid->tree().getNode<0>(0));
+    leaf->data()->mValues[0] += 0.00001f; // slightly modify a single voxel value
 
-    EXPECT_NE( slowChecksum, nanovdb::crc32_slow(*grid));
-    EXPECT_NE( fastChecksum, nanovdb::crc32(*grid));
-    EXPECT_FALSE( nanovdb::isValid(*grid, true, false ) );
+    EXPECT_NE(slowChecksum, nanovdb::crc32_slow(*grid));
+    EXPECT_NE(fastChecksum, nanovdb::crc32(*grid));
+    EXPECT_FALSE(nanovdb::isValid(*grid, true, false));
+
+    leaf->data()->mValues[0] -= 0.00001f; // change back the single voxel value to it's original value
+
+    EXPECT_EQ(slowChecksum, nanovdb::crc32_slow(*grid));
+    EXPECT_EQ(fastChecksum, nanovdb::crc32(*grid));
+    EXPECT_TRUE(nanovdb::isValid(*grid, true, true));
+
+    leaf->data()->mValueMask.toggle(0); // change a singel bit in a value mask
+
+    EXPECT_NE(slowChecksum, nanovdb::crc32_slow(*grid));
+    EXPECT_NE(fastChecksum, nanovdb::crc32(*grid));
+    EXPECT_FALSE(nanovdb::isValid(*grid, true, false));
+} // GridValidator
+
+TEST_F(TestNanoVDB, RandomReadAccessor)
+{
+    const float background = 0.0f;
+    const int voxelCount = 512, min = -10000, max = 10000;
+    std::srand(98765);
+    auto op = [&](){return rand() % (max - min) + min;};
+
+    for (int i=0; i<10; ++i) {
+        nanovdb::GridBuilder<float> builder(background);
+        auto acc = builder.getAccessor();
+        std::vector<nanovdb::Coord> voxels(voxelCount);
+        for (int j=0; j<voxelCount; ++j) {
+            auto &ijk = voxels[j];
+            ijk[0] = op();
+            ijk[1] = op();
+            ijk[2] = op();
+            acc.setValue(ijk, 1.0f*j);
+        }
+        auto gridHdl = builder.getHandle<>();
+        EXPECT_TRUE(gridHdl);
+        auto grid = gridHdl.grid<float>();
+        EXPECT_TRUE(grid);
+        const auto &root = grid->tree().root();
+#if 1
+        auto acc0a = nanovdb::createAccessor<>(root);// no node caching
+        auto acc1a = nanovdb::createAccessor<0>(root);// cache leaf node only
+        auto acc1b = nanovdb::createAccessor<1>(root);// cache lower internal node only
+        auto acc1c = nanovdb::createAccessor<2>(root);// cache upper internal node only
+        auto acc2a = nanovdb::createAccessor<0, 1>(root);// cache leaf and lower internal nodes
+        auto acc2b = nanovdb::createAccessor<1, 2>(root);// cache lower and upper internal nodes
+        auto acc2c = nanovdb::createAccessor<0, 2>(root);// cache leaf and upper internal nodes
+        auto acc3a = nanovdb::createAccessor<0, 1, 2>(root);// cache leaf and both intern node levels
+        auto acc3b = root.getAccessor();// same as the one above where all levels are cached
+        auto acc3c = nanovdb::DefaultReadAccessor<float>(root);// same as the one above where all levels are cached
+#else
+        // Alternative (more verbose) way to create accessors
+        auto acc0a = nanovdb::ReadAccessor<float>(root);// no node caching
+        auto acc1a = nanovdb::ReadAccessor<float, 0>(root);// cache leaf node only
+        auto acc1b = nanovdb::ReadAccessor<float, 1>(root);// cache lower internal node only
+        auto acc1c = nanovdb::ReadAccessor<float, 2>(root);// cache upper internal node only
+        auto acc2a = nanovdb::ReadAccessor<float, 0, 1>(root);// cache leaf and lower internal nodes
+        auto acc2b = nanovdb::ReadAccessor<float, 1, 2>(root);// cache lower and upper internal nodes
+        auto acc2c = nanovdb::ReadAccessor<float, 0, 2>(root);// cache leaf and upper internal nodes
+        auto acc3a = nanovdb::ReadAccessor<float, 0, 1, 2>(root);// cache leaf and both intern node levels
+        auto acc3b = nanovdb::DefaultReadAccessor<float>(root);// same as the one above where all levels are cached
+#endif
+        for (int j=0; j<voxelCount; ++j) {
+            const float v = 1.0f * j;
+            const auto &ijk = voxels[j];
+            //if (j<5) std::cerr << ijk << std::endl;
+            EXPECT_EQ( v, acc0a.getValue(ijk) );
+            EXPECT_EQ( v, acc1a.getValue(ijk) );
+            EXPECT_EQ( v, acc1b.getValue(ijk) );
+            EXPECT_EQ( v, acc1c.getValue(ijk) );
+            EXPECT_EQ( v, acc2a.getValue(ijk) );
+            EXPECT_EQ( v, acc2b.getValue(ijk) );
+            EXPECT_EQ( v, acc2c.getValue(ijk) );
+            EXPECT_EQ( v, acc3a.getValue(ijk) );
+            EXPECT_EQ( v, acc3b.getValue(ijk) );
+            EXPECT_EQ( v, acc3c.getValue(ijk) );
+        }
+    }
+}
 
-    leaf->data()->mValues[0] -= 0.00001f;// change back the single voxel value to it's original value
+TEST_F(TestNanoVDB, StandardDeviation)
+{
+    nanovdb::GridBuilder<float> builder(0.5f);
 
-    EXPECT_EQ( slowChecksum, nanovdb::crc32_slow(*grid));
-    EXPECT_EQ( fastChecksum, nanovdb::crc32(*grid));
-    EXPECT_TRUE( nanovdb::isValid(*grid, true, true ) );
+    {
+        auto acc = builder.getAccessor();
+        acc.setValue(nanovdb::Coord(-1), 1.0f);
+        acc.setValue(nanovdb::Coord(0), 2.0f);
+        acc.setValue(nanovdb::Coord(1), 3.0f);
+        acc.setValue(nanovdb::Coord(2), 0.0f);
+    }
 
-    leaf->data()->mValueMask.toggle(0);// change a singel bit in a value mask
+    auto gridHdl = builder.getHandle<>();
+    EXPECT_TRUE(gridHdl);
+    auto grid = gridHdl.grid<float>();
+    EXPECT_TRUE(grid);
+    nanovdb::gridStats(*grid);
 
-    EXPECT_NE( slowChecksum, nanovdb::crc32_slow(*grid));
-    EXPECT_NE( fastChecksum, nanovdb::crc32(*grid));
-    EXPECT_FALSE( nanovdb::isValid(*grid, true, false ) );
-}// GridValidator
+    auto acc  = grid->tree().getAccessor();
+    {
+        EXPECT_EQ( 1.0f,  acc.getValue(nanovdb::Coord(-1)) );
+        EXPECT_EQ( 2.0f,  acc.getValue(nanovdb::Coord( 0)) );
+        EXPECT_EQ( 3.0f,  acc.getValue(nanovdb::Coord( 1)) );
+        EXPECT_EQ( 0.0f,  acc.getValue(nanovdb::Coord( 2)) );
+        auto nodeInfo = acc.getNodeInfo(nanovdb::Coord(-1));
+        EXPECT_EQ(nodeInfo.mAverage, 1.f);
+        EXPECT_EQ(nodeInfo.mLevel, 0u);
+        EXPECT_EQ(nodeInfo.mDim, 8u);
+    }
+    {
+        auto nodeInfo = acc.getNodeInfo(nanovdb::Coord(1));
+        EXPECT_EQ(nodeInfo.mAverage, (2.0f + 3.0f) / 3.0f);
+        auto getStdDev = [&](int n, float a, float b, float c) {
+            float m = (a + b + c) / n;
+            float sd = sqrtf(((a - m) * (a - m) +
+                              (b - m) * (b - m) +
+                              (c - m) * (c - m)) /
+                             n);
+            return sd;
+        };
+        EXPECT_NEAR(nodeInfo.mStdDevi, getStdDev(3.0f, 2.0f, 3.0f, 0), 1e-5);
+        EXPECT_EQ(nodeInfo.mLevel, 0u);
+        EXPECT_EQ(nodeInfo.mDim, 8u);
+    }
+} // ReadAccessor
 
 int main(int argc, char** argv)
 {
diff -aur nanovdb-20200925/nanovdb/unittest/TestOpenVDB.cpp nanovdb-20201022/nanovdb/unittest/TestOpenVDB.cpp
--- nanovdb-20200925/nanovdb/unittest/TestOpenVDB.cpp	2020-09-25 05:19:30.000000000 +0200
+++ nanovdb-20201022/nanovdb/unittest/TestOpenVDB.cpp	2020-10-22 03:52:50.000000000 +0200
@@ -31,6 +31,29 @@
 #include <tbb/parallel_for.h>
 #include <tbb/parallel_invoke.h>
 
+inline std::ostream&
+operator<<(std::ostream& os, const nanovdb::CoordBBox& b)
+{
+    os << "(" << b[0][0] << "," << b[0][1] << "," << b[0][2] << ") -> "
+       << "(" << b[1][0] << "," << b[1][1] << "," << b[1][2] << ")";
+    return os;
+}
+
+inline std::ostream&
+operator<<(std::ostream& os, const nanovdb::Coord& ijk)
+{
+    os << "(" << ijk[0] << "," << ijk[1] << "," << ijk[2] << ")";
+    return os;
+}
+
+template<typename T>
+inline std::ostream&
+operator<<(std::ostream& os, const nanovdb::Vec3<T>& v)
+{
+    os << "(" << v[0] << "," << v[1] << "," << v[2] << ")";
+    return os;
+}
+
 // define the enviroment variable VDB_DATA_PATH to use models from the web
 // e.g. setenv VDB_DATA_PATH /home/kmu/dev/data/vdb
 // or   export VDB_DATA_PATH=/Users/ken/dev/data/vdb
@@ -103,6 +126,14 @@
     openvdb::util::CpuTimer mTimer;
 }; // TestOpenVDB
 
+TEST_F(TestOpenVDB, Basic)
+{
+    { // openvdb::VEc3::operator<
+        openvdb::Vec3f a(1.0f, 0.0f, 0.0f), b(2.0f, 0.0f, 0.0f);
+        EXPECT_TRUE(a < b);
+    }
+}
+
 TEST_F(TestOpenVDB, Grid)
 {
     using LeafT = nanovdb::LeafNode<float>;
@@ -133,8 +164,8 @@
             data.mValueMask.setOn(i);
             *voxels++ = 1.234f;
         }
-        data.mValueMin = 0.0f;
-        data.mValueMax = 1.234f;
+        data.mMinimum = 0.0f;
+        data.mMaximum = 1.234f;
     }
 
     // lower internal node
@@ -152,8 +183,8 @@
             data.mValueMask.setOn(i);
             tiles->value = 1.234f;
         }
-        data.mValueMin = 0.0f;
-        data.mValueMax = 1.234f;
+        data.mMinimum = 0.0f;
+        data.mMaximum = 1.234f;
         data.mOffset = 1;
         EXPECT_EQ(leaf, data.child(0));
     }
@@ -173,8 +204,8 @@
             data.mValueMask.setOn(i);
             tiles->value = 1.234f;
         }
-        data.mValueMin = 0.0f;
-        data.mValueMax = 1.234f;
+        data.mMinimum = 0.0f;
+        data.mMaximum = 1.234f;
         data.mOffset = 1;
         EXPECT_EQ(node1, data.child(0));
     }
@@ -183,7 +214,7 @@
     RootT* root = reinterpret_cast<RootT*>(buffer.get() + bytes[1]);
     { // set members of the root node
         auto& data = *reinterpret_cast<RootT::DataType*>(buffer.get() + bytes[1]);
-        data.mBackground = data.mValueMin = data.mValueMax = 1.234f;
+        data.mBackground = data.mMinimum = data.mMaximum = 1.234f;
         data.mTileCount = 1;
         auto& tile = data.tile(0);
         tile.setChild(RootT::CoordType(0), 0);
@@ -317,6 +348,9 @@
 
 } // Grid
 
+// The unit-test below is disabled because it has been replaced by the OpenToNanoVDB
+// class and hence is out of date and ultimately irrelevant
+/*
 TEST_F(TestOpenVDB, Conversion)
 {
     using SrcGridT = openvdb::FloatGrid;
@@ -446,12 +480,12 @@
                 const ValueT* src = srcLeaf->buffer().data();
                 ValueT*       dst = data->mValues;
 #if 0
-        data->mValueMin = data->mValueMax = *src; *dst++ = *src++;// process first element
+        data->mMinimum = data->mMaximum = *src; *dst++ = *src++;// process first element
         for (int j=1; j<SrcNode0::size(); ++j) {
-          if (*src < data->mValueMin) {
-            data->mValueMin = *src; 
-          } else if (*src > data->mValueMax) {
-            data->mValueMax = *src;
+          if (*src < data->mMinimum) {
+            data->mMinimum = *src; 
+          } else if (*src > data->mMaximum) {
+            data->mMaximum = *src;
           }
           *dst++ = *src++;
         }
@@ -460,15 +494,15 @@
                     *dst++ = *src++; //copy all voxel values
                 auto iter = srcLeaf->cbeginValueOn(); // iterate over active voxels
                 assert(iter); //these should be at least one active voxel
-                data->mValueMin = *iter, data->mValueMax = data->mValueMin;
+                data->mMinimum = *iter, data->mMaximum = data->mMinimum;
                 openvdb::CoordBBox bbox;
                 for (; iter; ++iter) {
                     bbox.expand(srcLeaf->offsetToLocalCoord(iter.pos()));
                     const ValueT& v = *iter;
-                    if (v < data->mValueMin) {
-                        data->mValueMin = v;
-                    } else if (v > data->mValueMax) {
-                        data->mValueMax = v;
+                    if (v < data->mMinimum) {
+                        data->mMinimum = v;
+                    } else if (v > data->mMaximum) {
+                        data->mMaximum = v;
                     }
                 }
                 bbox.translate(srcLeaf->origin());
@@ -509,8 +543,8 @@
                 data->mTable[iter.pos()].childID = childID; // set child id
                 const_cast<openvdb::Coord&>(iter->origin())[0] = cache0[childID]; // restore coordinate
                 auto* dstChild = data->child(iter.pos());
-                data->mValueMin = dstChild->valueMin();
-                data->mValueMax = dstChild->valueMax();
+                data->mMinimum = dstChild->valueMin();
+                data->mMaximum = dstChild->valueMax();
                 data->mBBox = dstChild->bbox();
 #if 1
                 for (++iter; iter; ++iter) {
@@ -519,10 +553,10 @@
                     data->mTable[n].childID = childID;
                     const_cast<openvdb::Coord&>(iter->origin())[0] = cache0[childID]; // restore origin[0]
                     auto* dstChild = data->child(n);
-                    if (dstChild->valueMin() < data->mValueMin)
-                        data->mValueMin = dstChild->valueMin();
-                    if (dstChild->valueMax() > data->mValueMax)
-                        data->mValueMax = dstChild->valueMax();
+                    if (dstChild->valueMin() < data->mMinimum)
+                        data->mMinimum = dstChild->valueMin();
+                    if (dstChild->valueMax() > data->mMaximum)
+                        data->mMaximum = dstChild->valueMax();
                     const auto& bbox = dstChild->bbox();
                     data->mBBox.min().minComponent(bbox.min());
                     data->mBBox.max().maxComponent(bbox.max());
@@ -531,10 +565,10 @@
                     data->mTable[iter.pos()].value = *iter;
                 for (auto iter = srcNode->cbeginValueOn(); iter; ++iter) { // typically there are few active tiles
                     const auto& value = *iter;
-                    if (value < data->mValueMin) {
-                        data->mValueMin = value;
-                    } else if (value > data->mValueMax) {
-                        data->mValueMax = value;
+                    if (value < data->mMinimum) {
+                        data->mMinimum = value;
+                    } else if (value > data->mMaximum) {
+                        data->mMaximum = value;
                     }
                     data->mBBox.min().minComponent(iter.getCoord());
                     data->mBBox.max().maxComponent(iter.getCoord().offsetBy(SrcNode0::DIM - 1));
@@ -593,8 +627,8 @@
                 data->mTable[iter.pos()].childID = childID;
                 const_cast<openvdb::Coord&>(iter->origin())[0] = cache1[childID];
                 auto* dstChild = data->child(iter.pos());
-                data->mValueMin = dstChild->valueMin();
-                data->mValueMax = dstChild->valueMax();
+                data->mMinimum = dstChild->valueMin();
+                data->mMaximum = dstChild->valueMax();
                 data->mBBox = dstChild->bbox();
 #if 1
                 for (++iter; iter; ++iter) {
@@ -603,10 +637,10 @@
                     data->mTable[n].childID = childID;
                     const_cast<openvdb::Coord&>(iter->origin())[0] = cache1[childID]; // restore cached coordinate
                     auto* dstChild = data->child(n);
-                    if (dstChild->valueMin() < data->mValueMin)
-                        data->mValueMin = dstChild->valueMin();
-                    if (dstChild->valueMax() > data->mValueMax)
-                        data->mValueMax = dstChild->valueMax();
+                    if (dstChild->valueMin() < data->mMinimum)
+                        data->mMinimum = dstChild->valueMin();
+                    if (dstChild->valueMax() > data->mMaximum)
+                        data->mMaximum = dstChild->valueMax();
                     const auto& bbox = dstChild->bbox();
                     data->mBBox.min().minComponent(bbox.min());
                     data->mBBox.max().maxComponent(bbox.max());
@@ -615,10 +649,10 @@
                     data->mTable[iter.pos()].value = *iter;
                 for (auto iter = srcNode->cbeginValueOn(); iter; ++iter) { // typically there are few active tiles
                     const auto& value = *iter;
-                    if (value < data->mValueMin) {
-                        data->mValueMin = value;
-                    } else if (value > data->mValueMax) {
-                        data->mValueMax = value;
+                    if (value < data->mMinimum) {
+                        data->mMinimum = value;
+                    } else if (value > data->mMaximum) {
+                        data->mMaximum = value;
                     }
                     data->mBBox.min().minComponent(iter.getCoord());
                     data->mBBox.max().maxComponent(iter.getCoord().offsetBy(SrcNode1::DIM - 1));
@@ -668,7 +702,7 @@
         // since openvdb::RootNode internally uses a std::map for child nodes its iterator
         // visits elements in the stored order required by the nanovdb::RootNode
         if (data.mTileCount == 0) { // empty root node
-            data.mValueMin = data.mValueMax = data.mBackground;
+            data.mMinimum = data.mMaximum = data.mBackground;
             data.mBBox.min() = openvdb::Coord::max(); // set to an empty bounding box
             data.mBBox.max() = openvdb::Coord::min();
             data.mActiveVoxelCount = 0;
@@ -680,8 +714,8 @@
             const_cast<openvdb::Coord&>(node->origin())[0] = cache2[childID]; // restore cached coordinate
             tile.setChild(node->origin(), childID);
             auto& dstChild = data.child(tile);
-            data.mValueMin = dstChild.valueMin();
-            data.mValueMax = dstChild.valueMax();
+            data.mMinimum = dstChild.valueMin();
+            data.mMaximum = dstChild.valueMax();
             data.mBBox = dstChild.bbox();
             for (size_t i = 1; i < array2.size(); ++i) {
                 node = array2[i];
@@ -691,10 +725,10 @@
                 const_cast<openvdb::Coord&>(node->origin())[0] = cache2[childID]; // restore cached coordinate
                 tile.setChild(node->origin(), childID);
                 auto& dstChild = data.child(tile);
-                if (dstChild.valueMin() < data.mValueMin)
-                    data.mValueMin = dstChild.valueMin();
-                if (dstChild.valueMax() > data.mValueMax)
-                    data.mValueMax = dstChild.valueMax();
+                if (dstChild.valueMin() < data.mMinimum)
+                    data.mMinimum = dstChild.valueMin();
+                if (dstChild.valueMax() > data.mMaximum)
+                    data.mMaximum = dstChild.valueMax();
                 data.mBBox.min().minComponent(dstChild.bbox().min());
                 data.mBBox.max().maxComponent(dstChild.bbox().max());
             }
@@ -703,10 +737,10 @@
                 auto& tile = data.tile(iter.pos());
                 tile.setValue(iter.getCoord(), iter.isValueOn(), *iter);
                 if (iter.isValueOn()) {
-                    if (tile.value < data.mValueMin) {
-                        data.mValueMin = tile.value;
-                    } else if (tile.value > data.mValueMax) {
-                        data.mValueMax = tile.value;
+                    if (tile.value < data.mMinimum) {
+                        data.mMinimum = tile.value;
+                    } else if (tile.value > data.mMaximum) {
+                        data.mMaximum = tile.value;
                     }
                     data.mBBox.min().minComponent(iter.getCoord());
                     data.mBBox.max().maxComponent(iter.getCoord().offsetBy(SrcNode2::DIM - 1));
@@ -918,10 +952,11 @@
             auto dstAcc = dstGrid->getAccessor();
             auto srcAcc = srcGrid->getUnsafeAccessor(); // not registered
             for (auto it = bbox.begin(); it; ++it) {
+                const nanovdb::Coord ijk(it->data());
                 DstGridT::ValueType srcV = srcAcc.getValue(*it), dstV;
                 EXPECT_EQ(srcV, dstAcc.getValue(*it));
-                EXPECT_EQ(srcAcc.isValueOn(*it), dstAcc.isActive(*it));
-                EXPECT_EQ(srcAcc.isValueOn(*it), dstAcc.probeValue(*it, dstV));
+                EXPECT_EQ(srcAcc.isValueOn(*it), dstAcc.isActive(ijk));
+                EXPECT_EQ(srcAcc.isValueOn(*it), dstAcc.probeValue(ijk, dstV));
                 EXPECT_EQ(srcV, dstV);
             }
         };
@@ -929,12 +964,12 @@
     }
     mTimer.stop();
 } // Conversion
-
+*/
 TEST_F(TestOpenVDB, OpenToNanoVDB)
 {
     auto srcGrid = this->getSrcGrid();
     mTimer.start("Generating NanoVDB grid");
-    auto handle = nanovdb::openToNanoVDB(*srcGrid, /*mortonSort*/ false, 2);
+    auto handle = nanovdb::openToNanoVDB(*srcGrid, nanovdb::StatsMode::All, nanovdb::ChecksumMode::Full, false, 2);
     mTimer.restart("Writing NanoVDB grid");
 #if defined(NANOVDB_USE_BLOSC)
     nanovdb::io::writeGrid("data/test.nvdb", handle, nanovdb::io::Codec::BLOSC);
@@ -1047,7 +1082,7 @@
     EXPECT_EQ(pointCount, count);
 
     mTimer.start("Generating NanoVDB grid from PointIndexGrid");
-    auto handle = nanovdb::openToNanoVDB(*srcGrid, /*mortonSort*/ false, 2);
+    auto handle = nanovdb::openToNanoVDB(*srcGrid, nanovdb::StatsMode::All, nanovdb::ChecksumMode::Full, /*mortonSort*/ false, 2);
     mTimer.stop();
     EXPECT_TRUE(handle);
     auto* meta = handle.gridMetaData();
@@ -1102,6 +1137,7 @@
 
     mTimer.start("Testing bounding box");
     const auto dstBBox = dstGrid->indexBBox();
+    std::cerr << "\nBBox = " << dstBBox << std::endl;
     const auto srcBBox = srcGrid->evalActiveVoxelBoundingBox();
     EXPECT_EQ(dstBBox.min()[0], srcBBox.min()[0]);
     EXPECT_EQ(dstBBox.min()[1], srcBBox.min()[1]);
@@ -1307,7 +1343,7 @@
     EXPECT_TRUE(handle);
     EXPECT_TRUE(handle.data());
 
-    const cnanovdb_griddata*  gridData = (const cnanovdb_griddata*)(handle.data());
+    const cnanovdb_griddata* gridData = (const cnanovdb_griddata*)(handle.data());
     EXPECT_TRUE(cnanovdb_griddata_valid(gridData));
     EXPECT_TRUE(cnanovdb_griddata_validF(gridData));
     EXPECT_FALSE(cnanovdb_griddata_validF3(gridData));
@@ -1319,7 +1355,7 @@
         cnanovdb_readaccessor_init(&dstAcc, rootData);
         auto srcAcc = srcGrid->getUnsafeAccessor(); // not registered
         for (auto it = bbox.begin(); it; ++it) {
-            auto          ijk = *it;
+            auto           ijk = *it;
             cnanovdb_Vec3F cn_xyz;
             cn_xyz.mVec[0] = ijk[0] + 0.3;
             cn_xyz.mVec[1] = ijk[1] + 0.7;
@@ -1360,7 +1396,7 @@
         cnanovdb_stencil1F_clear(&stencil);
         auto srcAcc = srcGrid->getUnsafeAccessor(); // not registered
         for (auto it = bbox.begin(); it; ++it) {
-            auto          ijk = *it;
+            auto           ijk = *it;
             cnanovdb_Vec3F cn_xyz;
             cn_xyz.mVec[0] = ijk[0] + 0.3;
             cn_xyz.mVec[1] = ijk[1] + 0.7;
@@ -1646,7 +1682,7 @@
         EXPECT_EQ(nanovdb::Vec3f(0.0f, 0.0f, -1.0f), grid->tree().getValue(ijk + nanovdb::Coord(1, 0, 0)));
         EXPECT_EQ(nanovdb::Vec3f(1.0f, 0.0f, 0.0f), grid->tree().root().valueMin());
         EXPECT_EQ(nanovdb::Vec3f(1.0f, 0.0f, 0.0f), grid->tree().root().valueMax());
-        EXPECT_EQ(nanovdb::CoordBBox(ijk, ijk), grid->tree().bbox());
+        EXPECT_EQ(nanovdb::CoordBBox(ijk, ijk), grid->indexBBox());
         EXPECT_FALSE(grid->isLevelSet());
         EXPECT_FALSE(grid->isFogVolume());
         EXPECT_FALSE(grid->isUnknown());
@@ -1689,7 +1725,8 @@
         file.open(false); //disable delayed loading
         auto srcGrid = openvdb::gridPtrCast<openvdb::FloatGrid>(file.readGrid(file.beginName().gridName()));
         mTimer.restart("Generating NanoVDB grid");
-        auto handle = nanovdb::openToNanoVDB(*srcGrid, /*mortonSort*/ false, 1);
+        auto handle = nanovdb::openToNanoVDB(*srcGrid, nanovdb::StatsMode::All, nanovdb::ChecksumMode::Partial, false, 1);
+        //auto handle = nanovdb::openToNanoVDB(*srcGrid, nanovdb::StatsMode::Disable, nanovdb::ChecksumMode::Disable, false, 1);
         mTimer.restart("Writing NanoVDB grid");
 #if defined(NANOVDB_USE_BLOSC)
         nanovdb::io::writeGrid(os, handle, nanovdb::io::Codec::BLOSC);
@@ -1785,7 +1822,7 @@
     EXPECT_NEAR(1.6f, gradIndex[0] / voxelSize, 1e-5);
     EXPECT_NEAR(6.7f, gradIndex[1] / voxelSize, 1e-5);
     EXPECT_NEAR(-3.5f, gradIndex[2] / voxelSize, 1e-5);
-    const auto gradWorld = dstGrid->indexToWorldDir(gradIndex); // in world units
+    const auto gradWorld = dstGrid->indexToWorldGrad(gradIndex); // in world units
     EXPECT_NEAR(1.6f, gradWorld[0], 1e-5);
     EXPECT_NEAR(6.7f, gradWorld[1], 1e-5);
     EXPECT_NEAR(-3.5f, gradWorld[2], 1e-5);
@@ -1796,10 +1833,70 @@
     EXPECT_EQ(exact, sampler3(ijk));
 } // Trilinear
 
+TEST_F(TestOpenVDB, Triquadratic)
+{
+    // create a grid so sample from
+    auto triquadratic = [](const openvdb::Vec3R& xyz) -> double {
+        return 0.34 + 1.6 * xyz[0] + 2.7 * xyz[1] + 1.5 * xyz[2] +
+               0.025 * xyz[0] * xyz[1] * xyz[2] - 0.013 * xyz[0] * xyz[0]; // world coordinates
+    };
+
+    mTimer.start("Generating a dense tri-cubic openvdb grid");
+    auto srcGrid = openvdb::createGrid<openvdb::DoubleGrid>(/*background=*/1.0);
+    srcGrid->setName("Tri-Quadratic");
+    srcGrid->setTransform(openvdb::math::Transform::createLinearTransform(/*voxel size=*/0.5));
+    const openvdb::CoordBBox bbox(openvdb::Coord(0), openvdb::Coord(128));
+    auto                     acc = srcGrid->getAccessor();
+    for (auto iter = bbox.begin(); iter; ++iter) {
+        auto ijk = *iter;
+        acc.setValue(ijk, triquadratic(srcGrid->indexToWorld(ijk)));
+    }
+    mTimer.restart("Generating NanoVDB grid");
+    auto handle = nanovdb::openToNanoVDB(*srcGrid);
+    mTimer.restart("Writing NanoVDB grid");
+    nanovdb::io::writeGrid("data/tmp.nvdb", handle);
+    mTimer.stop();
+
+    { //test File::hasGrid
+        EXPECT_TRUE(nanovdb::io::hasGrid("data/tmp.nvdb", "Tri-Quadratic"));
+        EXPECT_FALSE(nanovdb::io::hasGrid("data/tmp.nvdb", "Tri-Linear"));
+    }
+
+    mTimer.start("Reading NanoVDB from file");
+    auto handles = nanovdb::io::readGrids("data/tmp.nvdb", 1);
+    mTimer.stop();
+    auto* dstGrid = handles[0].grid<double>();
+    EXPECT_TRUE(dstGrid);
+
+    const openvdb::Vec3R ijk(3.4, 4.67, 5.23); // in index space
+    const float          exact = triquadratic(srcGrid->indexToWorld(ijk));
+    const float          approx = triquadratic(srcGrid->indexToWorld(openvdb::Coord(3, 5, 5)));
+    //std::cerr << "Trilinear: exact = " << exact << ", approx = " << approx << std::endl;
+    auto dstAcc = dstGrid->getAccessor();
+
+    auto sampler0 = nanovdb::createSampler<0>(dstAcc);
+    //std::cerr << "0'th order: v = " << sampler0(ijk) << std::endl;
+    EXPECT_NEAR(approx, sampler0(ijk), 1e-6);
+
+    auto sampler1 = nanovdb::createSampler<1>(dstAcc);
+    //std::cerr << "1'rd order: nanovdb = " << sampler1(ijk) << ", openvdb: " << openvdb::tools::Sampler<1>::sample(srcGrid->tree(), ijk) << std::endl;
+    EXPECT_NE(exact, sampler1(ijk)); // it's non-linear
+    EXPECT_NEAR(sampler1(ijk), openvdb::tools::Sampler<1>::sample(srcGrid->tree(), ijk), 1e-6);
+
+    auto sampler2 = nanovdb::createSampler<2>(dstAcc);
+    //std::cerr << "2'rd order: nanovdb = " << sampler2(ijk) << ", openvdb: " << openvdb::tools::Sampler<2>::sample(srcGrid->tree(), ijk) << std::endl;
+    EXPECT_NEAR(sampler2(ijk), openvdb::tools::Sampler<2>::sample(srcGrid->tree(), ijk), 1e-6);
+    EXPECT_NEAR(exact, sampler2(ijk), 1e-5); // it's a 2nd order polynomial
+
+    auto sampler3 = nanovdb::createSampler<3>(dstAcc);
+    //std::cerr << "3'rd order: v = " << sampler3(ijk) << std::endl;
+    EXPECT_NEAR(exact, sampler3(ijk), 1e-4); // it's a 2nd order polynomial
+} // Triquadratic
+
 TEST_F(TestOpenVDB, Tricubic)
 {
     // create a grid so sample from
-    auto trilinear = [](const openvdb::Vec3R& xyz) -> double {
+    auto tricubic = [](const openvdb::Vec3R& xyz) -> double {
         return 0.34 + 1.6 * xyz[0] + 2.7 * xyz[1] + 1.5 * xyz[2] + 0.025 * xyz[0] * xyz[1] * xyz[2] - 0.013 * xyz[0] * xyz[0] * xyz[0]; // world coordinates
     };
 
@@ -1811,7 +1908,7 @@
     auto                     acc = srcGrid->getAccessor();
     for (auto iter = bbox.begin(); iter; ++iter) {
         auto ijk = *iter;
-        acc.setValue(ijk, trilinear(srcGrid->indexToWorld(ijk)));
+        acc.setValue(ijk, tricubic(srcGrid->indexToWorld(ijk)));
     }
     mTimer.restart("Generating NanoVDB grid");
     auto handle = nanovdb::openToNanoVDB(*srcGrid);
@@ -1831,8 +1928,8 @@
     EXPECT_TRUE(dstGrid);
 
     const openvdb::Vec3R ijk(3.4, 4.67, 5.23); // in index space
-    const float          exact = trilinear(srcGrid->indexToWorld(ijk));
-    const float          approx = trilinear(srcGrid->indexToWorld(openvdb::Coord(3, 5, 5)));
+    const float          exact = tricubic(srcGrid->indexToWorld(ijk));
+    const float          approx = tricubic(srcGrid->indexToWorld(openvdb::Coord(3, 5, 5)));
     //std::cerr << "Trilinear: exact = " << exact << ", approx = " << approx << std::endl;
     auto dstAcc = dstGrid->getAccessor();
 
@@ -1840,62 +1937,68 @@
     //std::cerr << "0'th order: v = " << sampler0(ijk) << std::endl;
     EXPECT_NEAR(approx, sampler0(ijk), 1e-6);
 
-    //nanovdb::SampleFromVoxels<TreeT, 1> sampler1( dstGrid->tree());
-    //std::cerr << "1'th order: v = " << sampler1(ijk) << std::endl;
-    //EXPECT_EQ( exact, sampler1(ijk) );
+    auto sampler1 = nanovdb::createSampler<1>(dstAcc);
+    //std::cerr << "1'rd order: nanovdb = " << sampler1(ijk) << ", openvdb: " << openvdb::tools::Sampler<1>::sample(srcGrid->tree(), ijk) << std::endl;
+    EXPECT_NE(exact, sampler1(ijk)); // it's non-linear
+    EXPECT_NEAR(sampler1(ijk), openvdb::tools::Sampler<1>::sample(srcGrid->tree(), ijk), 1e-6);
+
+    auto sampler2 = nanovdb::createSampler<2>(dstAcc);
+    //std::cerr << "2'rd order: nanovdb = " << sampler2(ijk) << ", openvdb: " << openvdb::tools::Sampler<2>::sample(srcGrid->tree(), ijk) << std::endl;
+    EXPECT_NEAR(sampler2(ijk), openvdb::tools::Sampler<2>::sample(srcGrid->tree(), ijk), 1e-6);
+    EXPECT_NE(exact, sampler2(ijk)); // it's a 3nd order polynomial
 
     auto sampler3 = nanovdb::createSampler<3>(dstAcc);
     //std::cerr << "3'rd order: v = " << sampler3(ijk) << std::endl;
-    EXPECT_NEAR(exact, sampler3(ijk), 1e-4);
+    EXPECT_NEAR(exact, sampler3(ijk), 1e-4); // it's a 3nd order polynomial
 } // Tricubic
 
 TEST_F(TestOpenVDB, GridValidator)
 {
     auto srcGrid = this->getSrcGrid();
-    auto handle = nanovdb::openToNanoVDB(*srcGrid, false, 0, nanovdb::ChecksumMode::Full);
+    auto handle = nanovdb::openToNanoVDB(*srcGrid, nanovdb::StatsMode::All, nanovdb::ChecksumMode::Full, false, 0);
     mTimer.stop();
     EXPECT_TRUE(handle);
     EXPECT_TRUE(handle.data());
     auto* grid = handle.grid<float>();
     EXPECT_TRUE(grid);
-    
+
     //mTimer.start("isValid - detailed");
-    EXPECT_TRUE( nanovdb::isValid(*grid, true, true ) );
+    EXPECT_TRUE(nanovdb::isValid(*grid, true, true));
     //mTimer.stop();
 
     //mTimer.start("isValid - not detailed");
-    EXPECT_TRUE( nanovdb::isValid(*grid, false, true ) );
+    EXPECT_TRUE(nanovdb::isValid(*grid, false, true));
     //mTimer.stop();
 
     //mTimer.start("Slow CRC");
     auto slowChecksum = nanovdb::crc32_slow(*grid);
     //mTimer.stop();
-    EXPECT_EQ( slowChecksum, nanovdb::crc32_slow(*grid));
-    
+    EXPECT_EQ(slowChecksum, nanovdb::crc32_slow(*grid));
+
     //mTimer.start("Fast CRC");
     auto fastChecksum = nanovdb::crc32(*grid);
     //mTimer.stop();
-    EXPECT_EQ( fastChecksum, nanovdb::crc32(*grid));
+    EXPECT_EQ(fastChecksum, nanovdb::crc32(*grid));
 
-    auto *leaf = const_cast<nanovdb::NanoLeaf<float>*>(grid->tree().getNode<0>(0));
-    leaf->data()->mValues[512>>1] += 0.00001f;// slightly modify a single voxel value 
+    auto* leaf = const_cast<nanovdb::NanoLeaf<float>*>(grid->tree().getNode<0>(0));
+    leaf->data()->mValues[512 >> 1] += 0.00001f; // slightly modify a single voxel value
 
-    EXPECT_NE( slowChecksum, nanovdb::crc32_slow(*grid));
-    EXPECT_NE( fastChecksum, nanovdb::crc32(*grid));
-    EXPECT_FALSE( nanovdb::isValid(*grid, true, false ) );
+    EXPECT_NE(slowChecksum, nanovdb::crc32_slow(*grid));
+    EXPECT_NE(fastChecksum, nanovdb::crc32(*grid));
+    EXPECT_FALSE(nanovdb::isValid(*grid, true, false));
 
-    leaf->data()->mValues[512>>1] -= 0.00001f;// change back the single voxel value to it's original value
+    leaf->data()->mValues[512 >> 1] -= 0.00001f; // change back the single voxel value to it's original value
 
-    EXPECT_EQ( slowChecksum, nanovdb::crc32_slow(*grid));
-    EXPECT_EQ( fastChecksum, nanovdb::crc32(*grid));
-    EXPECT_TRUE( nanovdb::isValid(*grid, true, true ) );
+    EXPECT_EQ(slowChecksum, nanovdb::crc32_slow(*grid));
+    EXPECT_EQ(fastChecksum, nanovdb::crc32(*grid));
+    EXPECT_TRUE(nanovdb::isValid(*grid, true, true));
 
-    leaf->data()->mValueMask.toggle(512>>1);// change a single bit in a value mask
+    leaf->data()->mValueMask.toggle(512 >> 1); // change a single bit in a value mask
 
-    EXPECT_NE( slowChecksum, nanovdb::crc32_slow(*grid));
-    EXPECT_NE( fastChecksum, nanovdb::crc32(*grid));
-    EXPECT_FALSE( nanovdb::isValid(*grid, true, false ) );
-}// GridValidator
+    EXPECT_NE(slowChecksum, nanovdb::crc32_slow(*grid));
+    EXPECT_NE(fastChecksum, nanovdb::crc32(*grid));
+    EXPECT_FALSE(nanovdb::isValid(*grid, true, false));
+} // GridValidator
 
 int main(int argc, char** argv)
 {
Seulement dans nanovdb-20201022/tsc/meetings: 2020-09-22.md
Seulement dans nanovdb-20201022/tsc/meetings: 2020-09-29.md
