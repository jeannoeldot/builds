diff -aur openvdb.3.2.0/CHANGES openvdb.4.0.0/CHANGES
--- openvdb.3.2.0/CHANGES	2016-08-14 11:11:27.000000000 +0200
+++ openvdb.4.0.0/CHANGES	2016-10-09 10:18:58.000000000 +0200
@@ -1,6 +1,75 @@
 OpenVDB Version History
 =======================
 
+Version 4.0.0 - In development
+
+    Highlights:
+    - Introduced some C++11 constructs.  A C++11-compatible compiler
+      is now required.
+    - Vector-valued grids are now much faster to construct and destroy.
+
+      This change and other changes in this release (see "ABI changes" below)
+      alter the grid ABI so that it is incompatible with earlier versions
+      of the OpenVDB library, such as the ones in Houdini 15.0 and 15.5.
+      Define the macro OPENVDB_3_ABI_COMPATIBLE when compiling OpenVDB
+      to disable these changes and preserve ABI compatibility.
+
+    New features:
+    - Added an option to the point scattering tools to specify how far
+      each point may be displaced from the center of its host voxel or tile.
+    - Added a toggle to tools::clip() to invert the clipping mask.
+
+    Improvements:
+    - Vector-valued grids are now much faster to construct and destroy.
+    - Changed math::Coord's data representation to facilitate C++11
+      uniform initialization.
+    - Made many small changes to address type conversion and other warnings
+      reported by newer compilers, including Clang 3.8.
+
+    Bug fixes:
+    - Fixed a bug that caused topology operations (union, intersection
+      and difference) on MaskGrids to sometimes produce incorrect results.
+      (MaskGrids are used internally in a number of tools.)
+    - Changed GridBase::copyGrid() and Grid::copy() to close
+      const-correctness holes.
+
+    ABI changes:
+    - Added a NodeUnion template specialization for non-POD value types
+      that significantly expedites construction and destruction
+      of vector-valued grids.
+    - Changed math::Coord's internal data representation.
+    - Replaced occurrences of boost::shared_ptr with std::shared_ptr.
+    - Changed GridBase::copyGrid() and Grid::copy() to close
+      const-correctness holes.
+
+    API changes:
+    - Introduced some C++11 constructs.  A C++11-compatible compiler
+      is now required.
+    - Added a parameter to the point scattering tools that controls the
+      displacement of each point from the center of its host voxel or tile.
+      The default behavior, as before, is to allow each point to be placed
+      (randomly) anywhere within its voxel or tile.
+    - Renamed LeafManager::getPreFixSum() to LeafManager::getPrefixSum().
+    - Dropped the CopyPolicy enum and added GridBase::copyGridWithNewTree()
+      and Grid::copyWithNewTree() in order to close const-correctness holes
+      that allowed newly-constructed, non-const grids to share their trees
+      with existing const grids.  (Where that behavior is still required,
+      use a ConstPtrCast.)
+
+    Houdini:
+    - Certain changes in this release (see "ABI changes" above) alter
+      the grid ABI so that it is incompatible with earlier versions of
+      the OpenVDB library, such as the ones in Houdini 15.0 and 15.5.
+      Define the macro OPENVDB_3_ABI_COMPATIBLE when compiling OpenVDB
+      to disable these changes and preserve ABI compatibility.
+    - Introduced some C++11 constructs that are incompatible with
+      versions of Houdini older than 15.0.
+    - Added a toggle to the Clip SOP to invert the clipping mask.
+    - Added a slider to the Scatter SOP to specify how far each point
+      may be displaced from the center of its host voxel or tile.
+      
+
+
 Version 3.2.0 - August 10, 2016
 
     Highlights:
@@ -40,15 +109,14 @@
       of arbitrary type.
     - Added tools::LevelSetPlatonic a new tool that produces narrow-band
       level sets of the five Platonic solids.
-    - Added tools::extractIsosurfaceMask() which masks voxels that intersect the
-      implicit surface defined by the given isovalue.
+    - Added tools::extractIsosurfaceMask() which masks voxels that intersect
+      the implicit surface defined by the given isovalue.
     - Added tree::LeafManager::getPreFixSum() for user-managed external buffers.
     - Added tools::Dense::print().
     - Added the math::CoordBBox::Iterator class to conveniently iterate over
       coordinates covered a CoordBBox.
-    - Added bit-wise operations to the CoordBBox class.
-    - New component wise constructor for the math::CoordBBox class as well as the
-      method math::CoordBBox::getCornerPoints.
+    - Added bit-wise operations, a component-wise constructor, and a
+      getCornerPoints() method to the CoordBBox class.
     - Added a new LeafManager constructor to create the structure from an
       existing array of leafnodes.
     - Added the templated math::MinMax class to compute the extrema of
@@ -62,7 +130,8 @@
     - Improved the performance, parallel scaling and memory usage,
       of tools::LevelSetFracture and updated to use the new segmentSDF scheme.
     - Improved the performance of tools::LevelSetAdvection by up to five times.
-    - Improved the performance of Tree::voxelizeActiveTiles by means of multi-threading.
+    - Improved the performance of Tree::voxelizeActiveTiles by means of
+      multithreading.
     - Improved the performance of tools::meshToVolume(), particularly for
       large narrow-band widths and for signed distance fields with dense
       interior regions.
@@ -80,9 +149,10 @@
       math::Mat3::setColumns Mat3::setColumns, and
       math::Mat4::setColumns.
     - Added util::NodeMask::isConstant method for faster bit processing.
-    - tools::Prune performs an improved estimate of tile values by means of medians.
-    - Added toggle to switch between cell centered and node centered transforms to
-      tools::PointPartitioner.
+    - For better robustness, tools::Prune now uses the median of voxel values
+      when replacing voxels with a tile.
+    - Added a toggle to tools::PointPartitioner to select between
+      cell-centered and node-centered transforms.
 
     Bug fixes:
     - Fixed a bug in tools::LevelSetAdvection that could cause
@@ -185,11 +255,6 @@
       count along an axis or the voxel size in world units (the only option
       in the past).
 
-    Known issues:
-    - A vector Grid/Tree (or any Grid/Tree with a non-POD ValueType) is known to 
-      be slow to construct and delete! This performance issue is easy to fix, but 
-      since it introduces an ABI incompatibility it will have to go in a future
-      major release (most likely v4.0).
 
 Version 3.1.0 - October 1, 2015
 
diff -aur openvdb.3.2.0/cmd/openvdb_print/main.cc openvdb.4.0.0/cmd/openvdb_print/main.cc
--- openvdb.3.2.0/cmd/openvdb_print/main.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/cmd/openvdb_print/main.cc	2016-10-09 10:18:58.000000000 +0200
@@ -47,7 +47,7 @@
 const char* gProgName = "";
 
 void
-usage(int exitStatus = EXIT_FAILURE)
+usage [[noreturn]] (int exitStatus = EXIT_FAILURE)
 {
     std::cerr <<
 "Usage: " << gProgName << " in.vdb [in.vdb ...] [options]\n" <<
diff -aur openvdb.3.2.0/cmd/openvdb_render/main.cc openvdb.4.0.0/cmd/openvdb_render/main.cc
--- openvdb.3.2.0/cmd/openvdb_render/main.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/cmd/openvdb_render/main.cc	2016-10-09 10:18:58.000000000 +0200
@@ -173,7 +173,7 @@
 
 
 void
-usage(int exitStatus = EXIT_FAILURE)
+usage [[noreturn]] (int exitStatus = EXIT_FAILURE)
 {
     RenderOpts opts; // default options
     const double fov = openvdb::tools::PerspectiveCamera::focalLengthToFieldOfView(
diff -aur openvdb.3.2.0/cmd/openvdb_view/main.cc openvdb.4.0.0/cmd/openvdb_view/main.cc
--- openvdb.3.2.0/cmd/openvdb_view/main.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/cmd/openvdb_view/main.cc	2016-10-09 10:18:58.000000000 +0200
@@ -43,8 +43,8 @@
 #endif
 
 
-void
-usage(const char* progName, int status)
+inline void
+usage [[noreturn]] (const char* progName, int status)
 {
     (status == EXIT_SUCCESS ? std::cout : std::cerr) <<
 "Usage: " << progName << " file.vdb [file.vdb ...] [options]\n" <<
diff -aur openvdb.3.2.0/doc/changes.txt openvdb.4.0.0/doc/changes.txt
--- openvdb.3.2.0/doc/changes.txt	2016-08-14 11:11:27.000000000 +0200
+++ openvdb.4.0.0/doc/changes.txt	2016-10-09 10:18:58.000000000 +0200
@@ -2,6 +2,95 @@
 
 @page changes Release Notes
 
+@htmlonly <a name="v4_0_0_changes"></a>@endhtmlonly
+@par
+<B>Version 4.0.0</B> - <I>In development</I>
+@par
+Highlights:
+- Vector-valued grids are now much faster to construct and destroy.<BR><BR>
+  @b Note:
+  This change and other changes in this release
+  (see @ref v4_0_0_ABI_changes "ABI changes" below) alter the grid&nbsp;ABI
+  so that it is incompatible with earlier versions of the OpenVDB library,
+  such as the ones in Houdini&nbsp;15.0 and&nbsp;15.5.
+  Define the macro @c OPENVDB_3_ABI_COMPATIBLE when compiling OpenVDB
+  to disable these changes and preserve ABI compatibility.<BR><BR>
+- Introduced some C++11 constructs.
+  A&nbsp;C++11-compatible compiler is now required.
+
+@par
+New features:
+- Added an option to the @link PointScatter.h point scattering@endlink tools
+  to specify how far each point may be displaced from the center of its
+  host voxel or tile.
+- Added a toggle to the @vdblink::tools::clip() clip@endlink tool
+  to invert the clipping mask.
+
+@par
+Improvements:
+- Vector-valued grids are now much faster to construct and destroy.
+- Changed @vdblink::math::Coord Coord@endlink's data representation
+  to facilitate C++11 uniform initialization.
+- Made many small changes to address type conversion and other warnings
+  reported by newer compilers, including Clang&nbsp;3.8.
+@par
+Bug fixes:
+- Fixed a bug that caused topology operations
+  (@vdblink::Grid::topologyUnion() union@endlink,
+  @vdblink::Grid::topologyIntersection() intersection@endlink
+  and @vdblink::Grid::topologyDifference() difference@endlink) on
+  @vdblink::MaskGrid MaskGrids@endlink to sometimes produce incorrect results.
+  (MaskGrids are used internally in a number of tools.)
+- Changed @vdblink::GridBase::copyGrid() GridBase::copyGrid@endlink and
+  @vdblink::Grid::copy() Grid::copy@endlink to close const-correctness holes.
+
+@anchor v4_0_0_ABI_changes
+@par
+ABI changes:
+- Added a @vdblink::tree::NodeUnion NodeUnion@endlink template specialization
+  for non-POD value types that significantly expedites construction and
+  destruction of vector-valued grids.
+- Changed @vdblink::math::Coord Coord@endlink's data representation
+  to facilitate C++11 uniform initialization.
+- Replaced occurrences of <TT>boost::shared_ptr</TT> with
+  <TT>std::shared_ptr</TT>.
+- Changed @vdblink::GridBase::copyGrid() GridBase::copyGrid@endlink and
+  @vdblink::Grid::copy() Grid::copy@endlink to close const-correctness holes.
+
+@par
+API changes:
+- Introduced some C++11 constructs.
+  A&nbsp;C++11-compatible compiler is now required.
+- Added a parameter to the @link PointScatter.h point scattering@endlink
+  tools that controls the displacement of each point from the center of
+  its host voxel or tile.
+  The default behavior, as before, is to allow each point to be placed
+  (randomly) anywhere within its voxel or tile.
+- Renamed @c LeafManager::getPreFixSum to
+  @vdblink::tree::LeafManager::getPrefixSum()
+  LeafManager::getPrefixSum@endlink.
+- Dropped the @c CopyPolicy enum and added
+  @vdblink::GridBase::copyGridWithNewTree() GridBase::copyGridWithNewTree@endlink
+  and @vdblink::Grid::copyWithNewTree() Grid::copyWithNewTree@endlink in order
+  to close const-correctness holes that allowed newly-constructed,
+  non-<TT>const</TT> grids to share their trees with existing
+  <TT>const</TT> grids.  (Where that behavior is still required, use a
+  @vdblink::ConstPtrCast ConstPtrCast@endlink.)
+
+@par
+Houdini:
+- Certain changes in this release (see @ref v4_0_0_ABI_changes "ABI changes"
+  above) alter the grid&nbsp;ABI so that it is incompatible with earlier
+  versions of the OpenVDB library, such as the ones in Houdini&nbsp;15.0
+  and&nbsp;15.5.
+  Define the macro @c OPENVDB_3_ABI_COMPATIBLE when compiling OpenVDB
+  to disable these changes and preserve ABI compatibility.
+- Introduced some C++11 constructs that are incompatible with
+  versions of Houdini older than&nbsp;15.0.
+- Added a toggle to the Clip SOP to invert the clipping mask.
+- Added a slider to the Scatter SOP to specify how far each point
+  may be displaced from the center of its host voxel or tile.
+
 
 @htmlonly <a name="v3_2_0_changes"></a>@endhtmlonly
 @par
@@ -57,7 +146,7 @@
 - Added @vdblink::tools::extractIsosurfaceMask() extractIsosurfaceMask@endlink
   which masks voxels that intersect the implicit surface defined by the
   given isovalue.
-- Added a @vdblink::tree::LeafManager::getPreFixSum() getPreFixSum@endlink
+- Added a @vdblink::tree::LeafManager::getPrefixSum() getPrefixSum@endlink
   method to the @vdblink::tree::LeafManager LeafManager@endlink, for
   user-managed external buffers.
 - Added a @vdblink::tools::Dense::print() print@endlink method to the
@@ -1803,7 +1892,7 @@
 - @vdblink::tools::GridTransformer tools::GridTransformer@endlink
   and @vdblink::tools::GridResampler tools::GridResampler@endlink
   now correctly (but not yet efficiently) process tiles in sparse grids.
-- Added an optional @vdblink::CopyPolicy CopyPolicy@endlink argument
+- Added an optional @c CopyPolicy argument
   to @vdblink::GridBase::copyGrid() GridBase::copyGrid@endlink
   and to @vdblink::Grid::copy() Grid::copy@endlink that specifies
   whether and how the grid&rsquo;s tree should be copied.
diff -aur openvdb.3.2.0/doc/codingstyle.txt openvdb.4.0.0/doc/codingstyle.txt
--- openvdb.3.2.0/doc/codingstyle.txt	2016-01-23 17:09:50.000000000 +0100
+++ openvdb.4.0.0/doc/codingstyle.txt	2016-10-09 10:18:58.000000000 +0200
@@ -115,7 +115,6 @@
 
 @subsection sGeneral General
 -# Code must compile without any warning messages.
-if closely related.
 -# Prefer the C++ Standard Library to the C Standard Library.
 -# Restrict variables to the smallest scopes possible, and avoid defining
 local variables before giving them values.  Prefer declarations inside
@@ -275,6 +274,7 @@
 -# Use C++ casts (<TT>static_cast&lt;int&gt;(x)</TT> or <TT>int(x)</TT>),
 not C casts (<TT>(int)x</TT>).
 -# Multiple variables of the same data type may be declared on the same line
+if closely related.
 -# Library code must never deliberately terminate the application in response
 to an error condition.
 -# Avoid using malloc/free when new/delete can be used instead.
diff -aur openvdb.3.2.0/doxygen-config openvdb.4.0.0/doxygen-config
--- openvdb.3.2.0/doxygen-config	2016-01-23 17:09:50.000000000 +0100
+++ openvdb.4.0.0/doxygen-config	2016-10-09 10:18:58.000000000 +0200
@@ -38,18 +38,19 @@
 # could be handy for archiving the generated documentation or if some version
 # control system is used.
 
-PROJECT_NUMBER         = 3.2.0
+PROJECT_NUMBER         = 4.0.0
 
-ALIASES += vdbnamespace="openvdb::v3_2_0"
-PREDEFINED = OPENVDB_VERSION_NAME=v3_2_0
+ALIASES += vdbnamespace="openvdb::v4_0_0"
+PREDEFINED = OPENVDB_VERSION_NAME=v4_0_0
 
 PREDEFINED += __declspec(x):= __attribute__(x):=
+PREDEFINED += OPENVDB_STATIC_SPECIALIZATION=""
 #EXPAND_AS_DEFINED = \
 #    OPENVDB_API \
 #    OPENVDB_HOUDINI_API \
 #    OPENVDB_EXPORT \
 #    OPENVDB_IMPORT \
-#    OPENVDB_DEPRECATED
+#    OPENVDB_DEPRECATED \
 #    OPENVDB_STATIC_SPECIALIZATION
 
 # Using the PROJECT_BRIEF tag one can provide an optional one line description
@@ -776,7 +777,6 @@
 INPUT                  = . \
                          io \
                          math \
-                         metadata \
                          python/pyopenvdb.h \
                          tools \
                          tree \
diff -aur openvdb.3.2.0/Exceptions.h openvdb.4.0.0/Exceptions.h
--- openvdb.3.2.0/Exceptions.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/Exceptions.h	2016-10-09 10:18:58.000000000 +0200
@@ -43,17 +43,21 @@
 class OPENVDB_API Exception: public std::exception
 {
 public:
-    virtual const char* what() const throw()
+    Exception(const Exception&) = default;
+    Exception(Exception&&) = default;
+    Exception& operator=(const Exception&) = default;
+    Exception& operator=(Exception&&) = default;
+    ~Exception() override = default;
+
+    const char* what() const noexcept override
     {
-        try { return mMessage.c_str(); } catch (...) {};
-        return NULL;
+        try { return mMessage.c_str(); } catch (...) {}
+        return nullptr;
     }
 
-    virtual ~Exception() throw() {}
-
 protected:
-    Exception() throw() {}
-    explicit Exception(const char* eType, const std::string* const msg = NULL) throw()
+    Exception() noexcept {}
+    explicit Exception(const char* eType, const std::string* const msg = nullptr) noexcept
     {
         try {
             if (eType) mMessage = eType;
@@ -70,8 +74,8 @@
 class OPENVDB_API _classname: public Exception \
 { \
 public: \
-    _classname() throw() : Exception( #_classname ) {} \
-    explicit _classname(const std::string &msg) throw() : Exception( #_classname , &msg) {} \
+    _classname() noexcept: Exception( #_classname ) {} \
+    explicit _classname(const std::string& msg) noexcept: Exception( #_classname , &msg) {} \
 }
 
 
diff -aur openvdb.3.2.0/Grid.h openvdb.4.0.0/Grid.h
--- openvdb.3.2.0/Grid.h	2016-04-24 10:39:49.000000000 +0200
+++ openvdb.4.0.0/Grid.h	2016-10-09 10:18:58.000000000 +0200
@@ -31,25 +31,23 @@
 #ifndef OPENVDB_GRID_HAS_BEEN_INCLUDED
 #define OPENVDB_GRID_HAS_BEEN_INCLUDED
 
+#include "Exceptions.h"
+#include "MetaMap.h"
+#include "Types.h"
+#include "math/Transform.h"
+#include "tree/Tree.h"
+#include "util/Name.h"
 #include <iostream>
 #include <set>
+#include <type_traits>
 #include <vector>
-#include <boost/static_assert.hpp>
-#include <boost/type_traits/remove_const.hpp>
-#include <boost/type_traits/is_floating_point.hpp>
-#include <openvdb/Types.h>
-#include <openvdb/util/Name.h>
-#include <openvdb/math/Transform.h>
-#include <openvdb/tree/Tree.h>
-#include <openvdb/metadata/MetaMap.h>
-#include <openvdb/Exceptions.h>
 
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
 namespace OPENVDB_VERSION_NAME {
 
-typedef tree::TreeBase TreeBase;
+using TreeBase = tree::TreeBase;
 
 template<typename> class Grid; // forward declaration
 
@@ -103,18 +101,29 @@
 class OPENVDB_API GridBase: public MetaMap
 {
 public:
-    typedef boost::shared_ptr<GridBase> Ptr;
-    typedef boost::shared_ptr<const GridBase> ConstPtr;
+    using Ptr      = SharedPtr<GridBase>;
+    using ConstPtr = SharedPtr<const GridBase>;
 
-    typedef Ptr (*GridFactory)();
+    using GridFactory = Ptr (*)();
 
 
-    virtual ~GridBase() {}
+    ~GridBase() override {}
 
+#ifdef OPENVDB_3_ABI_COMPATIBLE
     /// @brief Return a new grid of the same type as this grid and whose
     /// metadata and transform are deep copies of this grid's.
     virtual GridBase::Ptr copyGrid(CopyPolicy treePolicy = CP_SHARE) const = 0;
-
+#else
+    //@{
+    /// @brief Return a new grid of the same type as this grid whose metadata and
+    /// transform are deep copies of this grid's and whose tree is shared with this grid.
+    virtual GridBase::Ptr copyGrid() = 0;
+    virtual GridBase::ConstPtr copyGrid() const = 0;
+    //@}
+    /// @brief Return a new grid of the same type as this grid whose metadata and
+    /// transform are deep copies of this grid's and whose tree is default-constructed.
+    virtual GridBase::Ptr copyGridWithNewTree() const = 0;
+#endif
     /// Return a new grid whose metadata, transform and tree are deep copies of this grid's.
     virtual GridBase::Ptr deepCopyGrid() const = 0;
 
@@ -400,8 +409,13 @@
     /// @brief Deep copy another grid's metadata and transform.
     GridBase(const GridBase& other): MetaMap(other), mTransform(other.mTransform->copy()) {}
 
+#ifdef OPENVDB_3_ABI_COMPATIBLE
     /// @brief Copy another grid's metadata but share its transform.
     GridBase(const GridBase& other, ShallowCopy): MetaMap(other), mTransform(other.mTransform) {}
+#else
+    /// @brief Copy another grid's metadata but share its transform.
+    GridBase(GridBase& other, ShallowCopy): MetaMap(other), mTransform(other.mTransform) {}
+#endif
 
     /// Register a grid type along with a factory function.
     static void registerGrid(const Name& type, GridFactory);
@@ -417,25 +431,25 @@
 ////////////////////////////////////////
 
 
-typedef std::vector<GridBase::Ptr>      GridPtrVec;
-typedef GridPtrVec::iterator            GridPtrVecIter;
-typedef GridPtrVec::const_iterator      GridPtrVecCIter;
-typedef boost::shared_ptr<GridPtrVec>   GridPtrVecPtr;
-
-typedef std::vector<GridBase::ConstPtr> GridCPtrVec;
-typedef GridCPtrVec::iterator           GridCPtrVecIter;
-typedef GridCPtrVec::const_iterator     GridCPtrVecCIter;
-typedef boost::shared_ptr<GridCPtrVec>  GridCPtrVecPtr;
-
-typedef std::set<GridBase::Ptr>         GridPtrSet;
-typedef GridPtrSet::iterator            GridPtrSetIter;
-typedef GridPtrSet::const_iterator      GridPtrSetCIter;
-typedef boost::shared_ptr<GridPtrSet>   GridPtrSetPtr;
-
-typedef std::set<GridBase::ConstPtr>    GridCPtrSet;
-typedef GridCPtrSet::iterator           GridCPtrSetIter;
-typedef GridCPtrSet::const_iterator     GridCPtrSetCIter;
-typedef boost::shared_ptr<GridCPtrSet>  GridCPtrSetPtr;
+using GridPtrVec       = std::vector<GridBase::Ptr>;
+using GridPtrVecIter   = GridPtrVec::iterator;
+using GridPtrVecCIter  = GridPtrVec::const_iterator;
+using GridPtrVecPtr    = SharedPtr<GridPtrVec>;
+
+using GridCPtrVec      = std::vector<GridBase::ConstPtr>;
+using GridCPtrVecIter  = GridCPtrVec::iterator;
+using GridCPtrVecCIter = GridCPtrVec::const_iterator;
+using GridCPtrVecPtr   = SharedPtr<GridCPtrVec>;
+
+using GridPtrSet       = std::set<GridBase::Ptr>;
+using GridPtrSetIter   = GridPtrSet::iterator;
+using GridPtrSetCIter  = GridPtrSet::const_iterator;
+using GridPtrSetPtr    = SharedPtr<GridPtrSet>;
+
+using GridCPtrSet      = std::set<GridBase::ConstPtr>;
+using GridCPtrSetIter  = GridCPtrSet::iterator;
+using GridCPtrSetCIter = GridCPtrSet::const_iterator;
+using GridCPtrSetPtr   = SharedPtr<GridCPtrSet>;
 
 
 /// @brief Predicate functor that returns @c true for grids that have a specified name
@@ -451,7 +465,7 @@
 inline typename GridPtrContainerT::value_type
 findGridByName(const GridPtrContainerT& container, const Name& name)
 {
-    typedef typename GridPtrContainerT::value_type GridPtrT;
+    using GridPtrT = typename GridPtrContainerT::value_type;
     typename GridPtrContainerT::const_iterator it =
         std::find_if(container.begin(), container.end(), GridNamePred(name));
     return (it == container.end() ? GridPtrT() : *it);
@@ -462,7 +476,7 @@
 inline GridPtrT
 findGridByName(const std::map<KeyT, GridPtrT>& container, const Name& name)
 {
-    typedef std::map<KeyT, GridPtrT> GridPtrMapT;
+    using GridPtrMapT = std::map<KeyT, GridPtrT>;
     for (typename GridPtrMapT::const_iterator it = container.begin(), end = container.end();
         it != end; ++it)
     {
@@ -482,26 +496,26 @@
 class Grid: public GridBase
 {
 public:
-    typedef boost::shared_ptr<Grid>                       Ptr;
-    typedef boost::shared_ptr<const Grid>                 ConstPtr;
+    using Ptr                 = SharedPtr<Grid>;
+    using ConstPtr            = SharedPtr<const Grid>;
 
-    typedef _TreeType                                     TreeType;
-    typedef typename _TreeType::Ptr                       TreePtrType;
-    typedef typename _TreeType::ConstPtr                  ConstTreePtrType;
-    typedef typename _TreeType::ValueType                 ValueType;
-    typedef typename _TreeType::BuildType                 BuildType;
-
-    typedef typename _TreeType::ValueOnIter               ValueOnIter;
-    typedef typename _TreeType::ValueOnCIter              ValueOnCIter;
-    typedef typename _TreeType::ValueOffIter              ValueOffIter;
-    typedef typename _TreeType::ValueOffCIter             ValueOffCIter;
-    typedef typename _TreeType::ValueAllIter              ValueAllIter;
-    typedef typename _TreeType::ValueAllCIter             ValueAllCIter;
-
-    typedef typename tree::ValueAccessor<_TreeType, true>        Accessor;
-    typedef typename tree::ValueAccessor<const _TreeType, true>  ConstAccessor;
-    typedef typename tree::ValueAccessor<_TreeType, false>       UnsafeAccessor;
-    typedef typename tree::ValueAccessor<const _TreeType, false> ConstUnsafeAccessor;
+    using TreeType            = _TreeType;
+    using TreePtrType         = typename _TreeType::Ptr;
+    using ConstTreePtrType    = typename _TreeType::ConstPtr;
+    using ValueType           = typename _TreeType::ValueType;
+    using BuildType           = typename _TreeType::BuildType;
+
+    using ValueOnIter         = typename _TreeType::ValueOnIter;
+    using ValueOnCIter        = typename _TreeType::ValueOnCIter;
+    using ValueOffIter        = typename _TreeType::ValueOffIter;
+    using ValueOffCIter       = typename _TreeType::ValueOffCIter;
+    using ValueAllIter        = typename _TreeType::ValueAllIter;
+    using ValueAllCIter       = typename _TreeType::ValueAllCIter;
+
+    using Accessor            = typename tree::ValueAccessor<_TreeType, true>;
+    using ConstAccessor       = typename tree::ValueAccessor<const _TreeType, true>;
+    using UnsafeAccessor      = typename tree::ValueAccessor<_TreeType, false>;
+    using ConstUnsafeAccessor = typename tree::ValueAccessor<const _TreeType, false>;
 
     /// @brief ValueConverter<T>::Type is the type of a grid having the same
     /// hierarchy as this grid but a different value type, T.
@@ -511,7 +525,7 @@
     /// to write "typename SourceGrid::template ValueConverter<T>::Type".
     template<typename OtherValueType>
     struct ValueConverter {
-        typedef Grid<typename TreeType::template ValueConverter<OtherValueType>::Type> Type;
+        using Type = Grid<typename TreeType::template ValueConverter<OtherValueType>::Type>;
     };
 
     /// Return a new grid with the given background value.
@@ -543,14 +557,24 @@
     /// or if this grid's ValueType is not constructible from the other grid's ValueType.
     template<typename OtherTreeType>
     explicit Grid(const Grid<OtherTreeType>&);
+#ifdef OPENVDB_3_ABI_COMPATIBLE
     /// Deep copy another grid's metadata, but share its tree and transform.
     Grid(const Grid&, ShallowCopy);
+#else
+    /// Deep copy another grid's metadata and transform, but share its tree.
+    Grid(Grid&, ShallowCopy);
+#endif
     /// @brief Deep copy another grid's metadata and transform, but construct a new tree
     /// with background value zero.
     explicit Grid(const GridBase&);
 
-    virtual ~Grid() {}
+    ~Grid() override {}
+
+    /// Disallow assignment, since it wouldn't be obvious whether the copy is deep or shallow.
+    Grid& operator=(const Grid&) = delete;
 
+
+#ifdef OPENVDB_3_ABI_COMPATIBLE
     //@{
     /// @brief Return a new grid of the same type as this grid and whose
     /// metadata and transform are deep copies of this grid's.
@@ -558,16 +582,31 @@
     /// if @c CP_SHARE, the new grid shares this grid's tree and transform;
     /// if @c CP_COPY, the new grid's tree is a deep copy of this grid's tree and transform
     Ptr copy(CopyPolicy treePolicy = CP_SHARE) const;
-    virtual GridBase::Ptr copyGrid(CopyPolicy treePolicy = CP_SHARE) const;
+    GridBase::Ptr copyGrid(CopyPolicy treePolicy = CP_SHARE) const override;
+    //@}
+#else
+    //@{
+    /// @brief Return a new grid of the same type as this grid whose metadata and
+    /// transform are deep copies of this grid's and whose tree is shared with this grid.
+    Ptr copy();
+    ConstPtr copy() const;
     //@}
+    /// @brief Return a new grid of the same type as this grid whose metadata and
+    /// transform are deep copies of this grid's and whose tree is default-constructed.
+    Ptr copyWithNewTree() const;
+
+    GridBase::Ptr copyGrid() override;
+    GridBase::ConstPtr copyGrid() const override;
+    GridBase::Ptr copyGridWithNewTree() const override;
+#endif
     //@{
     /// Return a new grid whose metadata, transform and tree are deep copies of this grid's.
     Ptr deepCopy() const { return Ptr(new Grid(*this)); }
-    virtual GridBase::Ptr deepCopyGrid() const { return this->deepCopy(); }
+    GridBase::Ptr deepCopyGrid() const override { return this->deepCopy(); }
     //@}
 
     /// Return the name of this grid's type.
-    virtual Name type() const { return this->gridType(); }
+    Name type() const override { return this->gridType(); }
     /// Return the name of this type of grid.
     static Name gridType() { return TreeType::treeType(); }
 
@@ -576,7 +615,7 @@
     // Voxel access methods
     //
     /// Return the name of the type of a voxel's value (e.g., "float" or "vec3d").
-    virtual Name valueType() const { return tree().valueType(); }
+    Name valueType() const override { return tree().valueType(); }
 
     /// @brief Return this grid's background value.
     ///
@@ -584,9 +623,9 @@
     const ValueType& background() const { return mTree->background(); }
 
     /// Return @c true if this grid contains only inactive background voxels.
-    virtual bool empty() const { return tree().empty(); }
+    bool empty() const override { return tree().empty(); }
     /// Empty this grid, so that all voxels become inactive background voxels.
-    virtual void clear() { tree().clear(); }
+    void clear() override { tree().clear(); }
 
     /// @brief Return an accessor that provides random read and write access
     /// to this grid's voxels. The accessor is safe in the sense that
@@ -648,32 +687,28 @@
     /// representation of the filled box.  Follow fill operations with a prune()
     /// operation for optimal sparseness.
     void sparseFill(const CoordBBox& bbox, const ValueType& value, bool active = true);
-    void fill(const CoordBBox& bbox, const ValueType& value, bool active = true)
-    {
-        this->sparseFill(bbox, value, active);
-    }
+    void fill(const CoordBBox& bbox, const ValueType& value, bool active = true);
     //@}
-    
+
     /// @brief Set all voxels within a given axis-aligned box to a constant value.
     /// @param bbox    inclusive coordinates of opposite corners of an axis-aligned box.
     /// @param value   the value to which to set voxels within the box.
     /// @param active  if true, mark voxels within the box as active,
     ///                otherwise mark them as inactive.
-    ///
-    /// @note This operation generates a dense representation of the
-    ///       filled box. This implies that active tiles are voxelized, i.e. only active 
-    ///       voxels are generated from this fill operation.
+    /// @note This operation generates a dense representation of the filled box.
+    /// This implies that active tiles are voxelized, i.e., only active voxels
+    /// are generated from this fill operation.
     void denseFill(const CoordBBox& bbox, const ValueType& value, bool active = true);
 
     /// Reduce the memory footprint of this grid by increasing its sparseness.
-    virtual void pruneGrid(float tolerance = 0.0);
+    void pruneGrid(float tolerance = 0.0) override;
 
 #ifndef OPENVDB_2_ABI_COMPATIBLE
     /// @brief Clip this grid to the given index-space bounding box.
     /// @details Voxels that lie outside the bounding box are set to the background.
     /// @warning Clipping a level set will likely produce a grid that is
     /// no longer a valid level set.
-    virtual void clip(const CoordBBox&);
+    void clip(const CoordBBox&) override;
 #endif
 
     /// @brief Efficiently merge another grid into this grid using one of several schemes.
@@ -731,15 +766,15 @@
     // Statistics
     //
     /// Return the number of active voxels.
-    virtual Index64 activeVoxelCount() const { return tree().activeVoxelCount(); }
+    Index64 activeVoxelCount() const override { return tree().activeVoxelCount(); }
     /// Return the axis-aligned bounding box of all active voxels.
-    virtual CoordBBox evalActiveVoxelBoundingBox() const;
+    CoordBBox evalActiveVoxelBoundingBox() const override;
     /// Return the dimensions of the axis-aligned bounding box of all active voxels.
-    virtual Coord evalActiveVoxelDim() const;
+    Coord evalActiveVoxelDim() const override;
 
     /// Return the number of bytes of memory used by this grid.
     /// @todo Add transform().memUsage()
-    virtual Index64 memUsage() const { return tree().memUsage(); }
+    Index64 memUsage() const override { return tree().memUsage(); }
 
 
     //
@@ -751,7 +786,7 @@
     TreePtrType treePtr() { return mTree; }
     ConstTreePtrType treePtr() const { return mTree; }
     ConstTreePtrType constTreePtr() const { return mTree; }
-    virtual TreeBase::ConstPtr constBaseTreePtr() const { return mTree; }
+    TreeBase::ConstPtr constBaseTreePtr() const override { return mTree; }
     //@}
     //@{
     /// @brief Return a reference to this grid's tree, which might be
@@ -768,11 +803,11 @@
     /// @throw TypeError if the tree is not of type TreeType
     /// @note Invalidates all references previously returned by baseTree(),
     /// constBaseTree(), tree() or constTree().
-    virtual void setTree(TreeBase::Ptr);
+    void setTree(TreeBase::Ptr) override;
 
     /// @brief Associate a new, empty tree with this grid, in place of its existing tree.
     /// @note The new tree has the same background value as the existing tree.
-    virtual void newTree();
+    void newTree() override;
 
 
     //
@@ -780,28 +815,28 @@
     //
     /// @brief Read the grid topology from a stream.
     /// This will read only the grid structure, not the actual data buffers.
-    virtual void readTopology(std::istream&);
+    void readTopology(std::istream&) override;
     /// @brief Write the grid topology to a stream.
     /// This will write only the grid structure, not the actual data buffers.
-    virtual void writeTopology(std::ostream&) const;
+    void writeTopology(std::ostream&) const override;
 
     /// Read all data buffers for this grid.
-    virtual void readBuffers(std::istream&);
+    void readBuffers(std::istream&) override;
 #ifndef OPENVDB_2_ABI_COMPATIBLE
     /// Read all of this grid's data buffers that intersect the given index-space bounding box.
-    virtual void readBuffers(std::istream&, const CoordBBox&);
+    void readBuffers(std::istream&, const CoordBBox&) override;
     /// @brief Read all of this grid's data buffers that are not yet resident in memory
     /// (because delayed loading is in effect).
     /// @details If this grid was read from a memory-mapped file, this operation
     /// disconnects the grid from the file.
     /// @sa io::File::open, io::MappedFile
-    virtual void readNonresidentBuffers() const;
+    void readNonresidentBuffers() const override;
 #endif
     /// Write out all data buffers for this grid.
-    virtual void writeBuffers(std::ostream&) const;
+    void writeBuffers(std::ostream&) const override;
 
     /// Output a human-readable description of this grid.
-    virtual void print(std::ostream& = std::cout, int verboseLevel = 1) const;
+    void print(std::ostream& = std::cout, int verboseLevel = 1) const override;
 
 
     //
@@ -816,9 +851,6 @@
 
 
 private:
-    /// Disallow assignment, since it wouldn't be obvious whether the copy is deep or shallow.
-    Grid& operator=(const Grid& other);
-
     /// Helper function for use with registerGrid()
     static GridBase::Ptr factory() { return Grid::create(); }
 
@@ -897,20 +929,20 @@
 template<typename _TreeType>
 struct TreeAdapter
 {
-    typedef _TreeType                           TreeType;
-    typedef typename boost::remove_const<TreeType>::type NonConstTreeType;
-    typedef typename TreeType::Ptr              TreePtrType;
-    typedef typename TreeType::ConstPtr         ConstTreePtrType;
-    typedef typename NonConstTreeType::Ptr      NonConstTreePtrType;
-    typedef Grid<TreeType>                      GridType;
-    typedef Grid<NonConstTreeType>              NonConstGridType;
-    typedef typename GridType::Ptr              GridPtrType;
-    typedef typename NonConstGridType::Ptr      NonConstGridPtrType;
-    typedef typename GridType::ConstPtr         ConstGridPtrType;
-    typedef typename TreeType::ValueType        ValueType;
-    typedef typename tree::ValueAccessor<TreeType>         AccessorType;
-    typedef typename tree::ValueAccessor<const TreeType>   ConstAccessorType;
-    typedef typename tree::ValueAccessor<NonConstTreeType> NonConstAccessorType;
+    using TreeType             = _TreeType;
+    using NonConstTreeType     = typename std::remove_const<TreeType>::type;
+    using TreePtrType          = typename TreeType::Ptr;
+    using ConstTreePtrType     = typename TreeType::ConstPtr;
+    using NonConstTreePtrType  = typename NonConstTreeType::Ptr;
+    using GridType             = Grid<TreeType>;
+    using NonConstGridType     = Grid<NonConstTreeType>;
+    using GridPtrType          = typename GridType::Ptr;
+    using NonConstGridPtrType  = typename NonConstGridType::Ptr;
+    using ConstGridPtrType     = typename GridType::ConstPtr;
+    using ValueType            = typename TreeType::ValueType;
+    using AccessorType         = typename tree::ValueAccessor<TreeType>;
+    using ConstAccessorType    = typename tree::ValueAccessor<const TreeType>;
+    using NonConstAccessorType = typename tree::ValueAccessor<NonConstTreeType>;
 
     static TreeType& tree(TreeType& t) { return t; }
     static TreeType& tree(GridType& g) { return g.tree(); }
@@ -927,20 +959,20 @@
 template<typename _TreeType>
 struct TreeAdapter<Grid<_TreeType> >
 {
-    typedef _TreeType                           TreeType;
-    typedef typename boost::remove_const<TreeType>::type NonConstTreeType;
-    typedef typename TreeType::Ptr              TreePtrType;
-    typedef typename TreeType::ConstPtr         ConstTreePtrType;
-    typedef typename NonConstTreeType::Ptr      NonConstTreePtrType;
-    typedef Grid<TreeType>                      GridType;
-    typedef Grid<NonConstTreeType>              NonConstGridType;
-    typedef typename GridType::Ptr              GridPtrType;
-    typedef typename NonConstGridType::Ptr      NonConstGridPtrType;
-    typedef typename GridType::ConstPtr         ConstGridPtrType;
-    typedef typename TreeType::ValueType        ValueType;
-    typedef typename tree::ValueAccessor<TreeType>         AccessorType;
-    typedef typename tree::ValueAccessor<const TreeType>   ConstAccessorType;
-    typedef typename tree::ValueAccessor<NonConstTreeType> NonConstAccessorType;
+    using TreeType             = _TreeType;
+    using NonConstTreeType     = typename std::remove_const<TreeType>::type;
+    using TreePtrType          = typename TreeType::Ptr;
+    using ConstTreePtrType     = typename TreeType::ConstPtr;
+    using NonConstTreePtrType  = typename NonConstTreeType::Ptr;
+    using GridType             = Grid<TreeType>;
+    using NonConstGridType     = Grid<NonConstTreeType>;
+    using GridPtrType          = typename GridType::Ptr;
+    using NonConstGridPtrType  = typename NonConstGridType::Ptr;
+    using ConstGridPtrType     = typename GridType::ConstPtr;
+    using ValueType            = typename TreeType::ValueType;
+    using AccessorType         = typename tree::ValueAccessor<TreeType>;
+    using ConstAccessorType    = typename tree::ValueAccessor<const TreeType>;
+    using NonConstAccessorType = typename tree::ValueAccessor<NonConstTreeType>;
 
     static TreeType& tree(TreeType& t) { return t; }
     static TreeType& tree(GridType& g) { return g.tree(); }
@@ -956,20 +988,20 @@
 template<typename _TreeType>
 struct TreeAdapter<tree::ValueAccessor<_TreeType> >
 {
-    typedef _TreeType                           TreeType;
-    typedef typename boost::remove_const<TreeType>::type NonConstTreeType;
-    typedef typename TreeType::Ptr              TreePtrType;
-    typedef typename TreeType::ConstPtr         ConstTreePtrType;
-    typedef typename NonConstTreeType::Ptr      NonConstTreePtrType;
-    typedef Grid<TreeType>                      GridType;
-    typedef Grid<NonConstTreeType>              NonConstGridType;
-    typedef typename GridType::Ptr              GridPtrType;
-    typedef typename NonConstGridType::Ptr      NonConstGridPtrType;
-    typedef typename GridType::ConstPtr         ConstGridPtrType;
-    typedef typename TreeType::ValueType        ValueType;
-    typedef typename tree::ValueAccessor<TreeType>         AccessorType;
-    typedef typename tree::ValueAccessor<const TreeType>   ConstAccessorType;
-    typedef typename tree::ValueAccessor<NonConstTreeType> NonConstAccessorType;
+    using TreeType             = _TreeType;
+    using NonConstTreeType     = typename std::remove_const<TreeType>::type;
+    using TreePtrType          = typename TreeType::Ptr;
+    using ConstTreePtrType     = typename TreeType::ConstPtr;
+    using NonConstTreePtrType  = typename NonConstTreeType::Ptr;
+    using GridType             = Grid<TreeType>;
+    using NonConstGridType     = Grid<NonConstTreeType>;
+    using GridPtrType          = typename GridType::Ptr;
+    using NonConstGridPtrType  = typename NonConstGridType::Ptr;
+    using ConstGridPtrType     = typename GridType::ConstPtr;
+    using ValueType            = typename TreeType::ValueType;
+    using AccessorType         = typename tree::ValueAccessor<TreeType>;
+    using ConstAccessorType    = typename tree::ValueAccessor<const TreeType>;
+    using NonConstAccessorType = typename tree::ValueAccessor<NonConstTreeType>;
 
     static TreeType& tree(TreeType& t) { return t; }
     static TreeType& tree(GridType& g) { return g.tree(); }
@@ -993,10 +1025,10 @@
 inline typename GridType::Ptr
 GridBase::grid(const GridBase::Ptr& grid)
 {
-    // The string comparison on type names is slower than a dynamic_pointer_cast, but
-    // it is safer when pointers cross dso boundaries, as they do in many Houdini nodes.
+    // The string comparison on type names is slower than a dynamic pointer cast, but
+    // it is safer when pointers cross DSO boundaries, as they do in many Houdini nodes.
     if (grid && grid->type() == GridType::gridType()) {
-        return boost::static_pointer_cast<GridType>(grid);
+        return StaticPtrCast<GridType>(grid);
     }
     return typename GridType::Ptr();
 }
@@ -1006,8 +1038,8 @@
 inline typename GridType::ConstPtr
 GridBase::grid(const GridBase::ConstPtr& grid)
 {
-    return boost::const_pointer_cast<const GridType>(
-        GridBase::grid<GridType>(boost::const_pointer_cast<GridBase>(grid)));
+    return ConstPtrCast<const GridType>(
+        GridBase::grid<GridType>(ConstPtrCast<GridBase>(grid)));
 }
 
 
@@ -1015,7 +1047,7 @@
 inline typename GridType::ConstPtr
 GridBase::constGrid(const GridBase::Ptr& grid)
 {
-    return boost::const_pointer_cast<const GridType>(GridBase::grid<GridType>(grid));
+    return ConstPtrCast<const GridType>(GridBase::grid<GridType>(grid));
 }
 
 
@@ -1023,15 +1055,15 @@
 inline typename GridType::ConstPtr
 GridBase::constGrid(const GridBase::ConstPtr& grid)
 {
-    return boost::const_pointer_cast<const GridType>(
-        GridBase::grid<GridType>(boost::const_pointer_cast<GridBase>(grid)));
+    return ConstPtrCast<const GridType>(
+        GridBase::grid<GridType>(ConstPtrCast<GridBase>(grid)));
 }
 
 
 inline TreeBase::Ptr
 GridBase::baseTreePtr()
 {
-    return boost::const_pointer_cast<TreeBase>(this->constBaseTreePtr());
+    return ConstPtrCast<TreeBase>(this->constBaseTreePtr());
 }
 
 
@@ -1068,7 +1100,7 @@
 template<typename TreeT>
 inline Grid<TreeT>::Grid(const Grid& other):
     GridBase(other),
-    mTree(boost::static_pointer_cast<TreeType>(other.mTree->copy()))
+    mTree(StaticPtrCast<TreeType>(other.mTree->copy()))
 {
 }
 
@@ -1082,12 +1114,21 @@
 }
 
 
+#ifdef OPENVDB_3_ABI_COMPATIBLE
 template<typename TreeT>
 inline Grid<TreeT>::Grid(const Grid& other, ShallowCopy):
     GridBase(other, ShallowCopy()),
     mTree(other.mTree)
 {
 }
+#else
+template<typename TreeT>
+inline Grid<TreeT>::Grid(Grid& other, ShallowCopy):
+    GridBase(other),
+    mTree(other.mTree)
+{
+}
+#endif
 
 
 template<typename TreeT>
@@ -1137,6 +1178,8 @@
 ////////////////////////////////////////
 
 
+#ifdef OPENVDB_3_ABI_COMPATIBLE
+
 template<typename TreeT>
 inline typename Grid<TreeT>::Ptr
 Grid<TreeT>::copy(CopyPolicy treePolicy) const
@@ -1165,6 +1208,57 @@
     return this->copy(treePolicy);
 }
 
+#else // !OPENVDB_3_ABI_COMPATIBLE
+
+template<typename TreeT>
+inline typename Grid<TreeT>::ConstPtr
+Grid<TreeT>::copy() const
+{
+    return ConstPtr{new Grid{*const_cast<Grid*>(this), ShallowCopy{}}};
+}
+
+template<typename TreeT>
+inline typename Grid<TreeT>::Ptr
+Grid<TreeT>::copy()
+{
+    return Ptr{new Grid{*this, ShallowCopy{}}};
+}
+
+
+template<typename TreeT>
+inline typename Grid<TreeT>::Ptr
+Grid<TreeT>::copyWithNewTree() const
+{
+    Ptr result{new Grid{*const_cast<Grid*>(this), ShallowCopy{}}};
+    result->newTree();
+    return result;
+}
+
+
+template<typename TreeT>
+inline GridBase::Ptr
+Grid<TreeT>::copyGrid()
+{
+    return this->copy();
+}
+
+template<typename TreeT>
+inline GridBase::ConstPtr
+Grid<TreeT>::copyGrid() const
+{
+    return this->copy();
+}
+
+
+template<typename TreeT>
+inline GridBase::Ptr
+Grid<TreeT>::copyGridWithNewTree() const
+{
+    return this->copyWithNewTree();
+}
+
+#endif // OPENVDB_3_ABI_COMPATIBLE
+
 
 ////////////////////////////////////////
 
@@ -1178,7 +1272,7 @@
         OPENVDB_THROW(TypeError, "Cannot assign a tree of type "
             + tree->type() + " to a grid of type " + this->type());
     }
-    mTree = boost::static_pointer_cast<TreeType>(tree);
+    mTree = StaticPtrCast<TreeType>(tree);
 }
 
 
@@ -1200,6 +1294,14 @@
     tree().sparseFill(bbox, value, active);
 }
 
+
+template<typename TreeT>
+inline void
+Grid<TreeT>::fill(const CoordBBox& bbox, const ValueType& value, bool active)
+{
+    this->sparseFill(bbox, value, active);
+}
+
 template<typename TreeT>
 inline void
 Grid<TreeT>::denseFill(const CoordBBox& bbox, const ValueType& value, bool active)
@@ -1395,7 +1497,7 @@
 inline typename Grid<typename TreePtrType::element_type>::Ptr
 createGrid(TreePtrType tree)
 {
-    typedef typename TreePtrType::element_type TreeType;
+    using TreeType = typename TreePtrType::element_type;
     return Grid<TreeType>::create(tree);
 }
 
@@ -1404,10 +1506,11 @@
 typename GridType::Ptr
 createLevelSet(Real voxelSize, Real halfWidth)
 {
-    typedef typename GridType::ValueType ValueType;
+    using ValueType = typename GridType::ValueType;
 
     // GridType::ValueType is required to be a floating-point scalar.
-    BOOST_STATIC_ASSERT(boost::is_floating_point<ValueType>::value);
+    static_assert(std::is_floating_point<ValueType>::value,
+        "level-set grids must be floating-point-valued");
 
     typename GridType::Ptr grid = GridType::create(
         /*background=*/static_cast<ValueType>(voxelSize * halfWidth));
diff -aur openvdb.3.2.0/INSTALL openvdb.4.0.0/INSTALL
--- openvdb.3.2.0/INSTALL	2016-01-23 17:09:50.000000000 +0100
+++ openvdb.4.0.0/INSTALL	2016-10-09 10:18:58.000000000 +0200
@@ -3,13 +3,15 @@
 
 Requirements
 ------------
-- GNU GCC (gcc.gnu.org), version 4.1 or later
-  or Intel ICC (software.intel.com), version 11.1 or later
+- GNU GCC (gcc.gnu.org), version 4.8 or later,
+  Clang (clang.llvm.org), version 3.8 or later,
+  or Intel ICC (software.intel.com), version 14 or later
 
 - GNU gmake (www.gnu.org/software/make/), version 3.81 or later
 
-- Boost (www.boost.org), version 1.42.0 or later
-  (Linux: yum install boost-devel; OS X: port install boost +python26)
+- Boost (www.boost.org), version 1.53.0 or later; 1.57.0 or later
+  for the Python module
+  (Linux: yum install boost-devel; OS X: port install boost +python27)
 
 - libz (zlib.net)
   (Linux: yum install zlib-devel)
@@ -25,12 +27,12 @@
 
 Optional:
 
-- Doxygen 1.8.7 (www.stack.nl/~dimitri/doxygen/), for documentation
+- Doxygen 1.8.11 or later (www.stack.nl/~dimitri/doxygen/), for documentation
 
 - CppUnit (www.freedesktop.org/wiki/Software/cppunit), version 1.10 or later
   (Linux: yum install cppunit-devel)
 
-- Houdini HDK (ftp://ftp.sidefx.com/public/Houdini12.0), version 12.0.628
+- Houdini HDK (http://www.sidefx.com/get/download-houdini/), version 15.0
   or later
 
 - Blosc compression library (www.blosc.org), version 1.5.0 or later
@@ -191,8 +193,8 @@
     A default local build generates the following libraries and executables
     (but see the Makefile for additional targets and build options):
 
-    openvdb/libopenvdb.so.3.2.0         the OpenVDB library
-    openvdb/libopenvdb.so               symlink to libopenvdb.so.3.2.0
+    openvdb/libopenvdb.so.4.0.0         the OpenVDB library
+    openvdb/libopenvdb.so               symlink to libopenvdb.so.4.0.0
     openvdb/pyopenvdb.so                the OpenVDB Python module (if Python
                                         and Boost.Python are available)
     openvdb/vdb_print                   command-line tool that prints info
@@ -238,8 +240,8 @@
                 version.h
         lib/
             libopenvdb.so
-            libopenvdb.so.3.2
-            libopenvdb.so.3.2.0
+            libopenvdb.so.4.0
+            libopenvdb.so.4.0.0
 
         python/
             include/
@@ -248,7 +250,7 @@
             lib/
                 python$(PYTHON_VERSION)/
                     pyopenvdb.so
-                    pyopenvdb.so.3.2
+                    pyopenvdb.so.4.0
 
         share/
             doc/
diff -aur openvdb.3.2.0/io/Archive.cc openvdb.4.0.0/io/Archive.cc
--- openvdb.3.2.0/io/Archive.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/io/Archive.cc	2016-10-09 10:18:58.000000000 +0200
@@ -38,7 +38,14 @@
 #include <openvdb/util/logging.h>
 
 // Boost.Interprocess uses a header-only portion of Boost.DateTime
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunused-macros"
+#endif
 #define BOOST_DATE_TIME_NO_LIB
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
 #include <boost/interprocess/file_mapping.hpp>
 #include <boost/interprocess/mapped_region.hpp>
 #include <boost/iostreams/device/array.hpp>
@@ -136,7 +143,7 @@
         }
     }
 
-    if (existingArray >= 0 && std::cout.pword(existingArray) != NULL) {
+    if (existingArray >= 0 && std::cout.pword(existingArray) != nullptr) {
         // If a lower-numbered entry was found to contain the magic number,
         // a coexisting version of this library must have registered it.
         // In that case, the corresponding pointer should point to an existing
@@ -184,7 +191,7 @@
 {
     // Ensure that this StreamState struct can no longer be accessed.
     std::cout.iword(magicNumber) = 0;
-    std::cout.pword(magicNumber) = NULL;
+    std::cout.pword(magicNumber) = nullptr;
 }
 
 } // unnamed namespace
@@ -200,7 +207,7 @@
         , mLibraryVersion(OPENVDB_LIBRARY_MAJOR_VERSION, OPENVDB_LIBRARY_MINOR_VERSION)
         , mCompression(COMPRESS_NONE)
         , mGridClass(GRID_UNKNOWN)
-        , mBackgroundPtr(NULL)
+        , mBackgroundPtr(nullptr)
         , mHalfFloat(false)
         , mWriteGridStats(false)
     {
@@ -423,7 +430,7 @@
 
         if (void* fh = open_existing_file(filename, boost::interprocess::read_only)) {
             struct { unsigned long lo, hi; } mtime; // Windows FILETIME struct
-            if (GetFileTime(fh, NULL, NULL, &mtime)) {
+            if (GetFileTime(fh, nullptr, nullptr, &mtime)) {
                 result = (Index64(mtime.hi) << 32) | mtime.lo;
             }
             close_file(fh);
@@ -469,7 +476,7 @@
 }
 
 
-boost::shared_ptr<std::streambuf>
+SharedPtr<std::streambuf>
 MappedFile::createBuffer() const
 {
     if (!mImpl->mAutoDelete && mImpl->mLastWriteTime > 0) {
@@ -482,9 +489,9 @@
         }
     }
 
-    return boost::shared_ptr<std::streambuf>(
-        new boost::iostreams::stream_buffer<boost::iostreams::array_source>(
-            static_cast<const char*>(mImpl->mRegion.get_address()), mImpl->mRegion.get_size()));
+    return SharedPtr<std::streambuf>{
+        new boost::iostreams::stream_buffer<boost::iostreams::array_source>{
+            static_cast<const char*>(mImpl->mRegion.get_address()), mImpl->mRegion.get_size()}};
 }
 
 
@@ -498,7 +505,7 @@
 void
 MappedFile::clearNotifier()
 {
-    mImpl->mNotifier.clear();
+    mImpl->mNotifier = nullptr;
 }
 
 
@@ -716,7 +723,8 @@
             // ZLIB compression is not used on level sets or fog volumes.
             c = c & ~COMPRESS_ZIP;
             break;
-        default:
+        case GRID_STAGGERED:
+        case GRID_UNKNOWN:
             break;
     }
     io::setDataCompression(os, c);
@@ -855,7 +863,7 @@
 clearStreamMetadataPtr(std::ios_base& strm)
 {
     StreamMetadata::Ptr result = getStreamMetadataPtr(strm);
-    strm.pword(sStreamState.metadata) = NULL;
+    strm.pword(sStreamState.metadata) = nullptr;
     return result;
 }
 
@@ -966,7 +974,7 @@
 
     // 6) Generate a new random 16-byte (128-bit) uuid and write it to the stream.
     boost::mt19937 ran;
-    ran.seed(static_cast<boost::mt19937::result_type>(time(NULL)));
+    ran.seed(static_cast<boost::mt19937::result_type>(time(nullptr)));
     boost::uuids::basic_random_generator<boost::mt19937> gen(&ran);
     mUuid = gen(); // mUuid is mutable
     os << mUuid;
@@ -1026,7 +1034,7 @@
 #ifdef OPENVDB_2_ABI_COMPATIBLE
     return false;
 #else
-    return (NULL == std::getenv("OPENVDB_DISABLE_DELAYED_LOAD"));
+    return (nullptr == std::getenv("OPENVDB_DISABLE_DELAYED_LOAD"));
 #endif
 }
 
@@ -1073,7 +1081,7 @@
     io::setStreamMetadataPtr(is, streamMetadata, /*transfer=*/false);
 
     io::setGridClass(is, GRID_UNKNOWN);
-    io::setGridBackgroundValuePtr(is, NULL);
+    io::setGridBackgroundValuePtr(is, nullptr);
 
     grid->readMeta(is);
 
@@ -1295,9 +1303,9 @@
         grid->writeMeta(os);
     } else {
         // Compute and add grid statistics metadata.
-        GridBase::Ptr copyOfGrid = grid->copyGrid(); // shallow copy
-        copyOfGrid->addStatsMetadata();
-        copyOfGrid->insertMeta(GridBase::META_FILE_COMPRESSION,
+        const auto copyOfGrid = grid->copyGrid(); // shallow copy
+        ConstPtrCast<GridBase>(copyOfGrid)->addStatsMetadata();
+        ConstPtrCast<GridBase>(copyOfGrid)->insertMeta(GridBase::META_FILE_COMPRESSION,
             StringMetadata(compressionToString(getDataCompression(os))));
         copyOfGrid->writeMeta(os);
     }
diff -aur openvdb.3.2.0/io/Archive.h openvdb.4.0.0/io/Archive.h
--- openvdb.3.2.0/io/Archive.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/io/Archive.h	2016-10-09 10:18:58.000000000 +0200
@@ -31,18 +31,17 @@
 #ifndef OPENVDB_IO_ARCHIVE_HAS_BEEN_INCLUDED
 #define OPENVDB_IO_ARCHIVE_HAS_BEEN_INCLUDED
 
+#include "Compression.h" // for COMPRESS_ZIP, etc.
+#include <openvdb/Grid.h>
+#include <openvdb/MetaMap.h>
 #include <openvdb/Platform.h>
+#include <openvdb/version.h> // for VersionId
+#include <boost/uuid/uuid.hpp>
+#include <cstdint>
 #include <iosfwd>
 #include <map>
+#include <memory>
 #include <string>
-#include <boost/uuid/uuid.hpp>
-#include <boost/cstdint.hpp>
-#include <boost/scoped_ptr.hpp>
-#include <boost/shared_ptr.hpp>
-#include <openvdb/Grid.h>
-#include <openvdb/metadata/MetaMap.h>
-#include <openvdb/version.h> // for VersionId
-#include "Compression.h" // for COMPRESS_ZIP, etc.
 
 
 class TestFile;
@@ -59,12 +58,14 @@
 class OPENVDB_API Archive
 {
 public:
-    typedef boost::shared_ptr<Archive> Ptr;
-    typedef boost::shared_ptr<const Archive> ConstPtr;
+    using Ptr = SharedPtr<Archive>;
+    using ConstPtr = SharedPtr<const Archive>;
 
     static const uint32_t DEFAULT_COMPRESSION_FLAGS;
 
     Archive();
+    Archive(const Archive&) = default;
+    Archive& operator=(const Archive&) = default;
     virtual ~Archive();
 
     /// @brief Return a copy of this archive.
diff -aur openvdb.3.2.0/io/File.cc openvdb.4.0.0/io/File.cc
--- openvdb.3.2.0/io/File.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/io/File.cc	2016-10-09 10:18:58.000000000 +0200
@@ -27,15 +27,15 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
-/// @file File.cc
+
+/// @file io/File.cc
 
 #include "File.h"
 
 #include "TempFile.h"
 #include <openvdb/Exceptions.h>
 #include <openvdb/util/logging.h>
-#include <boost/cstdint.hpp>
+#include <cstdint>
 #include <boost/iostreams/copy.hpp>
 #ifndef _MSC_VER
 #include <sys/types.h>
@@ -101,7 +101,7 @@
     {
         Index64 result = DEFAULT_COPY_MAX_BYTES;
         if (const char* s = std::getenv("OPENVDB_DELAYED_LOAD_COPY_MAX_BYTES")) {
-            char* endptr = NULL;
+            char* endptr = nullptr;
             result = std::strtoul(s, &endptr, /*base=*/10);
         }
         return result;
@@ -113,9 +113,9 @@
     // The memory-mapped file
     MappedFile::Ptr mFileMapping;
     // The buffer for the input stream, if it is a memory-mapped file
-    boost::shared_ptr<std::streambuf> mStreamBuf;
+    SharedPtr<std::streambuf> mStreamBuf;
     // The file stream that is open for reading
-    boost::scoped_ptr<std::istream> mInStream;
+    std::unique_ptr<std::istream> mInStream;
     // File-level stream metadata (file format, compression, etc.)
     StreamMetadata::Ptr mStreamMetadata;
     // Flag indicating if we have read in the global information (header,
@@ -175,10 +175,10 @@
 }
 
 
-boost::shared_ptr<Archive>
+SharedPtr<Archive>
 File::copy() const
 {
-    return boost::shared_ptr<Archive>(new File(*this));
+    return SharedPtr<Archive>{new File{*this}};
 }
 
 
@@ -303,8 +303,8 @@
     mImpl->mInStream.reset();
 
     // Open the file.
-    boost::scoped_ptr<std::istream> newStream;
-    boost::shared_ptr<std::streambuf> newStreamBuf;
+    std::unique_ptr<std::istream> newStream;
+    SharedPtr<std::streambuf> newStreamBuf;
     MappedFile::Ptr newFileMapping;
     if (!delayLoad || !Archive::isDelayedLoadingEnabled()) {
         newStream.reset(new std::ifstream(
@@ -343,7 +343,7 @@
         } catch (std::exception& e) {
             std::ostringstream ostr;
             ostr << "could not open file " << filename();
-            if (e.what() != NULL) ostr << " (" << e.what() << ")";
+            if (e.what() != nullptr) ostr << " (" << e.what() << ")";
             OPENVDB_THROW(IoError, ostr.str());
         }
     }
@@ -389,8 +389,8 @@
         mImpl->mNamedGrids.clear();
 
         // Stream in the entire contents of the file and append all grids to mGrids.
-        const boost::int32_t gridCount = readGridCount(inputStream());
-        for (boost::int32_t i = 0; i < gridCount; ++i) {
+        const int32_t gridCount = readGridCount(inputStream());
+        for (int32_t i = 0; i < gridCount; ++i) {
             GridDescriptor gd;
             gd.read(inputStream());
 
@@ -531,7 +531,11 @@
         // have already been streamed in and stored in mGrids.
         for (size_t i = 0, N = mImpl->mGrids->size(); i < N; ++i) {
             // Return copies of the grids, but with empty trees.
+#ifdef OPENVDB_3_ABI_COMPATIBLE
             ret->push_back((*mImpl->mGrids)[i]->copyGrid(/*treePolicy=*/CP_NEW));
+#else
+            ret->push_back((*mImpl->mGrids)[i]->copyGridWithNewTree());
+#endif
         }
     } else {
         // Read just the metadata and transforms for all grids.
@@ -542,7 +546,11 @@
             // (As of 0.98.0, at least, it would suffice to just const cast
             // the grid pointers returned by readGridPartial(), but shallow
             // copying the grids helps to ensure future compatibility.)
+#ifdef OPENVDB_3_ABI_COMPATIBLE
             ret->push_back(grid->copyGrid(/*treePolicy=*/CP_NEW));
+#else
+            ret->push_back(grid->copyGridWithNewTree());
+#endif
         }
     }
     return ret;
@@ -571,7 +579,11 @@
         const GridDescriptor& gd = it->second;
         ret = readGridPartial(gd, /*readTopology=*/false);
     }
+#ifdef OPENVDB_3_ABI_COMPATIBLE
     return ret->copyGrid(/*treePolicy=*/CP_NEW);
+#else
+    return ret->copyGridWithNewTree();
+#endif
 }
 
 
@@ -590,7 +602,7 @@
         // Retrieve the grid from mGrids, which should already contain
         // the entire contents of the file.
         if (GridBase::Ptr grid = readGrid(name)) {
-            ret = boost::const_pointer_cast<const GridBase>(grid);
+            ret = ConstPtrCast<const GridBase>(grid);
         }
     } else {
         NameMapCIter it = findDescriptor(name);
@@ -614,8 +626,8 @@
             if (GridBase::ConstPtr parent =
                 readGridPartial(parentIt->second, /*readTopology=*/true))
             {
-                boost::const_pointer_cast<GridBase>(ret)->setTree(
-                    boost::const_pointer_cast<GridBase>(parent)->baseTreePtr());
+                ConstPtrCast<GridBase>(ret)->setTree(
+                    ConstPtrCast<GridBase>(parent)->baseTreePtr());
             }
         }
     }
@@ -751,7 +763,7 @@
 
     gridDescriptors().clear();
 
-    for (boost::int32_t i = 0, N = readGridCount(is); i < N; ++i) {
+    for (int32_t i = 0, N = readGridCount(is); i < N; ++i) {
         // Read the grid descriptor.
         GridDescriptor gd;
         gd.read(is);
diff -aur openvdb.3.2.0/io/File.h openvdb.4.0.0/io/File.h
--- openvdb.3.2.0/io/File.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/io/File.h	2016-10-09 10:18:58.000000000 +0200
@@ -38,8 +38,8 @@
 #include "GridDescriptor.h"
 #include <iosfwd>
 #include <map>
+#include <memory>
 #include <string>
-#include <boost/scoped_ptr.hpp>
 
 
 class TestFile;
@@ -54,11 +54,11 @@
 class OPENVDB_API File: public Archive
 {
 public:
-    typedef std::multimap<Name, GridDescriptor> NameMap;
-    typedef NameMap::const_iterator NameMapCIter;
+    using NameMap = std::multimap<Name, GridDescriptor>;
+    using NameMapCIter = NameMap::const_iterator;
 
     explicit File(const std::string& filename);
-    virtual ~File();
+    ~File() override;
 
     /// @brief Copy constructor
     /// @details The copy will be closed and will not reference the same
@@ -72,7 +72,7 @@
     /// @brief Return a copy of this archive.
     /// @details The copy will be closed and will not reference the same
     /// file descriptor as the original.
-    virtual boost::shared_ptr<Archive> copy() const;
+    SharedPtr<Archive> copy() const override;
 
     /// @brief Return the name of the file with which this archive is associated.
     /// @details The file does not necessarily exist on disk yet.
@@ -156,7 +156,7 @@
 
     /// @brief Write the grids in the given container to the file whose name
     /// was given in the constructor.
-    virtual void write(const GridCPtrVec&, const MetaMap& = MetaMap()) const;
+    void write(const GridCPtrVec&, const MetaMap& = MetaMap()) const override;
 
     /// @brief Write the grids in the given container to the file whose name
     /// was given in the constructor.
@@ -169,6 +169,7 @@
     {
     public:
         NameIterator(const NameMapCIter& iter): mIter(iter) {}
+        NameIterator(const NameIterator&) = default;
         ~NameIterator() {}
 
         NameIterator& operator++() { mIter++; return *this; }
@@ -242,7 +243,7 @@
     friend class ::TestStream;
 
     struct Impl;
-    boost::scoped_ptr<Impl> mImpl;
+    std::unique_ptr<Impl> mImpl;
 };
 
 
diff -aur openvdb.3.2.0/io/GridDescriptor.h openvdb.4.0.0/io/GridDescriptor.h
--- openvdb.3.2.0/io/GridDescriptor.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/io/GridDescriptor.h	2016-10-09 10:18:58.000000000 +0200
@@ -48,7 +48,8 @@
 public:
     GridDescriptor();
     GridDescriptor(const Name& name, const Name& gridType, bool saveFloatAsHalf = false);
-
+    GridDescriptor(const GridDescriptor&) = default;
+    GridDescriptor& operator=(const GridDescriptor&) = default;
     ~GridDescriptor();
 
     const Name& gridType() const { return mGridType; }
diff -aur openvdb.3.2.0/io/io.h openvdb.4.0.0/io/io.h
--- openvdb.3.2.0/io/io.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/io/io.h	2016-10-09 10:18:58.000000000 +0200
@@ -32,13 +32,13 @@
 #define OPENVDB_IO_IO_HAS_BEEN_INCLUDED
 
 #include <openvdb/Platform.h>
+#include <openvdb/Types.h> // for SharedPtr
 #include <openvdb/version.h>
 #include <boost/any.hpp>
-#include <boost/function.hpp>
-#include <boost/scoped_ptr.hpp>
-#include <boost/shared_ptr.hpp>
+#include <functional>
 #include <iosfwd> // for std::ios_base
 #include <map>
+#include <memory>
 #include <string>
 
 
@@ -56,8 +56,8 @@
 class OPENVDB_API StreamMetadata
 {
 public:
-    typedef boost::shared_ptr<StreamMetadata> Ptr;
-    typedef boost::shared_ptr<const StreamMetadata> ConstPtr;
+    using Ptr = SharedPtr<StreamMetadata>;
+    using ConstPtr = SharedPtr<const StreamMetadata>;
 
     StreamMetadata();
     StreamMetadata(const StreamMetadata&);
@@ -101,7 +101,7 @@
     const MetaMap& gridMetadata() const;
     //@}
 
-    typedef std::map<std::string, boost::any> AuxDataMap;
+    using AuxDataMap = std::map<std::string, boost::any>;
     //@{
     /// @brief Return a map that can be populated with arbitrary user data.
     AuxDataMap& auxData();
@@ -113,7 +113,7 @@
 
 private:
     struct Impl;
-    boost::scoped_ptr<Impl> mImpl;
+    std::unique_ptr<Impl> mImpl;
 }; // class StreamMetadata
 
 
@@ -132,9 +132,11 @@
 class OPENVDB_API MappedFile
 {
 public:
-    typedef boost::shared_ptr<MappedFile> Ptr;
+    using Ptr = SharedPtr<MappedFile>;
 
     ~MappedFile();
+    MappedFile(const MappedFile&) = delete; // not copyable
+    MappedFile& operator=(const MappedFile&) = delete;
 
     /// Return the filename of the mapped file.
     std::string filename() const;
@@ -143,14 +145,14 @@
     /// @details Typical usage is
     /// @code
     /// openvdb::io::MappedFile::Ptr mappedFile = ...;
-    /// boost::shared_ptr<std::streambuf> buf = mappedFile->createBuffer();
-    /// std::istream istrm(buf.get());
+    /// auto buf = mappedFile->createBuffer();
+    /// std::istream istrm{buf.get()};
     /// // Read from istrm...
     /// @endcode
     /// The buffer must persist as long as the stream is open.
-    boost::shared_ptr<std::streambuf> createBuffer() const;
+    SharedPtr<std::streambuf> createBuffer() const;
 
-    typedef boost::function<void(std::string /*filename*/)> Notifier;
+    using Notifier = std::function<void(std::string /*filename*/)>;
     /// @brief Register a function that will be called with this file's name
     /// when the file is unmapped.
     void setNotifier(const Notifier&);
@@ -162,11 +164,8 @@
 
     explicit MappedFile(const std::string& filename, bool autoDelete = false);
 
-    MappedFile(const MappedFile&); // not copyable
-    MappedFile& operator=(const MappedFile&); // not copyable
-
     class Impl;
-    boost::scoped_ptr<Impl> mImpl;
+    std::unique_ptr<Impl> mImpl;
 }; // class MappedFile
 
 
@@ -244,15 +243,15 @@
 
 /// @brief Return a shared pointer to the memory-mapped file with which the given stream
 /// is associated, or a null pointer if the stream is not associated with a memory-mapped file.
-OPENVDB_API boost::shared_ptr<MappedFile> getMappedFilePtr(std::ios_base&);
+OPENVDB_API SharedPtr<MappedFile> getMappedFilePtr(std::ios_base&);
 /// @brief Associate the given stream with (a shared pointer to) a memory-mapped file.
 /// @note The shared pointer object (not just the io::MappedFile object to which it points)
 /// must remain valid until the file is closed.
-OPENVDB_API void setMappedFilePtr(std::ios_base&, boost::shared_ptr<MappedFile>&);
+OPENVDB_API void setMappedFilePtr(std::ios_base&, SharedPtr<MappedFile>&);
 
 /// @brief Return a shared pointer to an object that stores metadata (file format,
 /// compression scheme, etc.) for use when reading from or writing to the given stream.
-OPENVDB_API boost::shared_ptr<StreamMetadata> getStreamMetadataPtr(std::ios_base&);
+OPENVDB_API SharedPtr<StreamMetadata> getStreamMetadataPtr(std::ios_base&);
 /// @brief Associate the given stream with (a shared pointer to) an object that stores
 /// metadata (file format, compression scheme, etc.) for use when reading from
 /// or writing to the stream.
@@ -261,10 +260,10 @@
 /// @note The shared pointer object (not just the io::StreamMetadata object to which it points)
 /// must remain valid until the file is closed.
 OPENVDB_API void setStreamMetadataPtr(std::ios_base&,
-    boost::shared_ptr<StreamMetadata>&, bool transfer = true);
+    SharedPtr<StreamMetadata>&, bool transfer = true);
 /// @brief Dissociate the given stream from its metadata object (if it has one)
 /// and return a shared pointer to the object.
-OPENVDB_API boost::shared_ptr<StreamMetadata> clearStreamMetadataPtr(std::ios_base&);
+OPENVDB_API SharedPtr<StreamMetadata> clearStreamMetadataPtr(std::ios_base&);
 
 } // namespace io
 } // namespace OPENVDB_VERSION_NAME
diff -aur openvdb.3.2.0/io/Queue.cc openvdb.4.0.0/io/Queue.cc
--- openvdb.3.2.0/io/Queue.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/io/Queue.cc	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file Queue.cc
 /// @author Peter Cucka
 
@@ -37,7 +37,6 @@
 #include "Stream.h"
 #include <openvdb/Exceptions.h>
 #include <openvdb/util/logging.h>
-#include <boost/bind.hpp>
 #include <tbb/atomic.h>
 #include <tbb/concurrent_hash_map.h>
 #include <tbb/mutex.h>
@@ -56,8 +55,8 @@
 
 namespace {
 
-typedef tbb::mutex Mutex;
-typedef Mutex::scoped_lock Lock;
+using Mutex = tbb::mutex;
+using Lock = Mutex::scoped_lock;
 
 
 // Abstract base class for queuable TBB tasks that adds a task completion callback
@@ -65,7 +64,7 @@
 {
 public:
     Task(Queue::Id id): mId(id) {}
-    virtual ~Task() {}
+    ~Task() override {}
 
     Queue::Id id() const { return mId; }
 
@@ -92,7 +91,7 @@
         , mMetadata(metadata)
     {}
 
-    virtual tbb::task* execute()
+    tbb::task* execute() override
     {
         Queue::Status status = Queue::FAILED;
         try {
@@ -105,12 +104,12 @@
         } catch (...) {
         }
         this->notify(status);
-        return NULL; // no successor to this task
+        return nullptr; // no successor to this task
     }
 
 private:
     GridCPtrVec mGrids;
-    boost::shared_ptr<Archive> mArchive;
+    SharedPtr<Archive> mArchive;
     MetaMap mMetadata;
 };
 
@@ -123,9 +122,9 @@
 // Private implementation details of a Queue
 struct Queue::Impl
 {
-    typedef std::map<Queue::Id, Queue::Notifier> NotifierMap;
+    using NotifierMap = std::map<Queue::Id, Queue::Notifier>;
     /// @todo Provide more information than just "succeeded" or "failed"?
-    typedef tbb::concurrent_hash_map<Queue::Id, Queue::Status> StatusMap;
+    using StatusMap = tbb::concurrent_hash_map<Queue::Id, Queue::Status>;
 
 
     Impl()
@@ -202,7 +201,8 @@
                     "unable to queue I/O task; " << mTimeout << "-second time limit expired");
             }
         }
-        Queue::Notifier notify = boost::bind(&Impl::setStatusWithNotification, this, _1, _2);
+        Queue::Notifier notify = std::bind(&Impl::setStatusWithNotification, this,
+            std::placeholders::_1, std::placeholders::_2);
         task.setNotifier(notify);
         this->setStatus(task.id(), Queue::PENDING);
         tbb::task::enqueue(task);
@@ -321,9 +321,10 @@
 Queue::Id
 Queue::writeGridVec(const GridCPtrVec& grids, const Archive& archive, const MetaMap& metadata)
 {
+    const Queue::Id taskId = mImpl->mNextId++;
     // From the "GUI Thread" chapter in the TBB Design Patterns guide
-    const Queue::Id task_id = mImpl->mNextId++;
-    OutputTask* task = new(tbb::task::allocate_root()) OutputTask(task_id, grids, archive, metadata);
+    OutputTask* task =
+        new(tbb::task::allocate_root()) OutputTask(taskId, grids, archive, metadata);
     try {
         mImpl->enqueue(*task);
     } catch (openvdb::RuntimeError&) {
@@ -331,7 +332,7 @@
         tbb::task::destroy(*task);
         throw;
     }
-    return task_id;
+    return taskId;
 }
 
 } // namespace io
diff -aur openvdb.3.2.0/io/Queue.h openvdb.4.0.0/io/Queue.h
--- openvdb.3.2.0/io/Queue.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/io/Queue.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file Queue.h
 /// @author Peter Cucka
 
@@ -36,10 +36,10 @@
 
 #include <openvdb/Types.h>
 #include <openvdb/Grid.h>
-#include <boost/function.hpp>
-#include <boost/shared_ptr.hpp>
 #include <algorithm> // for std::copy
+#include <functional>
 #include <iterator> // for std::back_inserter
+#include <memory>
 
 
 namespace openvdb {
@@ -57,10 +57,10 @@
 ///
 /// @par Example:
 /// @code
-/// #include <boost/bind.hpp>
-/// #include <tbb/concurrent_hash_map.h>
 /// #include <openvdb/openvdb.h>
 /// #include <openvdb/io/Queue.h>
+/// #include <tbb/concurrent_hash_map.h>
+/// #include <functional>
 ///
 /// using openvdb::io::Queue;
 ///
@@ -68,7 +68,7 @@
 /// {
 ///     // Use a concurrent container, because queue callback functions
 ///     // must be thread-safe.
-///     typedef tbb::concurrent_hash_map<Queue::Id, std::string> FilenameMap;
+///     using FilenameMap = tbb::concurrent_hash_map<Queue::Id, std::string>;
 ///     FilenameMap filenames;
 ///
 ///     // Callback function that prints the status of a completed task.
@@ -94,7 +94,8 @@
 ///
 ///     // Register the callback() method of the MyNotifier object
 ///     // to receive notifications of completed tasks.
-///     queue.addNotifier(boost::bind(&MyNotifier::callback, &notifier, _1, _2));
+///     queue.addNotifier(std::bind(&MyNotifier::callback, &notifier,
+///         std::placeholders::_1, std::placeholders::_2));
 ///
 ///     // Queue grids for output (e.g., for each step of a simulation).
 ///     for (int step = 1; step <= 10; ++step) {
@@ -133,7 +134,7 @@
     static const Index32 DEFAULT_TIMEOUT = 120; // seconds
 
     /// ID number of a queued task or of a registered notification callback
-    typedef Index32 Id;
+    using Id = Index32;
 
     /// Status of a queued task
     enum Status { UNKNOWN, PENDING, SUCCEEDED, FAILED };
@@ -167,7 +168,7 @@
     /// Subsequent queries of its status will return UNKNOWN.
     Status status(Id) const;
 
-    typedef boost::function<void (Id, Status)> Notifier;
+    using Notifier = std::function<void (Id, Status)>;
     /// @brief Register a function that will be called with a task's ID
     /// and status when that task completes, whether successfully or not.
     /// @return an ID that can be passed to removeNotifier() to deregister the function
@@ -243,7 +244,7 @@
     Id writeGridVec(const GridCPtrVec&, const Archive&, const MetaMap&);
 
     struct Impl;
-    boost::shared_ptr<Impl> mImpl;
+    std::unique_ptr<Impl> mImpl;
 }; // class Queue
 
 
diff -aur openvdb.3.2.0/io/Stream.cc openvdb.4.0.0/io/Stream.cc
--- openvdb.3.2.0/io/Stream.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/io/Stream.cc	2016-10-09 10:18:58.000000000 +0200
@@ -34,10 +34,10 @@
 #include "GridDescriptor.h"
 #include "TempFile.h"
 #include <openvdb/Exceptions.h>
-#include <boost/cstdint.hpp>
+#include <cstdint>
 #include <boost/iostreams/copy.hpp>
-#include <boost/bind.hpp>
 #include <cstdio> // for remove()
+#include <functional> // for std::bind()
 #include <iostream>
 #include <vector>
 
@@ -49,7 +49,7 @@
 
 struct Stream::Impl
 {
-    Impl(): mOutputStream(NULL) {}
+    Impl(): mOutputStream{nullptr} {}
     Impl(const Impl& other) { *this = other; }
     Impl& operator=(const Impl& other)
     {
@@ -65,7 +65,7 @@
     MetaMap::Ptr mMeta;
     GridPtrVecPtr mGrids;
     std::ostream* mOutputStream;
-    boost::scoped_ptr<File> mFile;
+    std::unique_ptr<File> mFile;
 };
 
 
@@ -97,7 +97,7 @@
     if (delayLoad && Archive::isDelayedLoadingEnabled()) {
         // Copy the contents of the stream to a temporary private file
         // and open the file instead.
-        boost::scoped_ptr<TempFile> tempFile;
+        std::unique_ptr<TempFile> tempFile;
         try {
             tempFile.reset(new TempFile);
         } catch (std::exception& e) {
@@ -112,7 +112,8 @@
             mImpl->mFile.reset(new File(filename));
             mImpl->mFile->setCopyMaxBytes(0); // don't make a copy of the temporary file
             /// @todo Need to pass auto-deletion flag to MappedFile.
-            mImpl->mFile->open(delayLoad, boost::bind(&removeTempFile, filename, _1));
+            mImpl->mFile->open(delayLoad,
+                std::bind(&removeTempFile, filename, std::placeholders::_1));
         }
     }
 
@@ -131,14 +132,14 @@
         mImpl->mMeta->readMeta(is);
 
         // Read in the number of grids.
-        const boost::int32_t gridCount = readGridCount(is);
+        const int32_t gridCount = readGridCount(is);
 
         // Read in all grids and insert them into mGrids.
         mImpl->mGrids.reset(new GridPtrVec);
         std::vector<GridDescriptor> descriptors;
         descriptors.reserve(gridCount);
         Archive::NamedGridMap namedGrids;
-        for (boost::int32_t i = 0; i < gridCount; ++i) {
+        for (int32_t i = 0; i < gridCount; ++i) {
             GridDescriptor gd;
             gd.read(is);
             descriptors.push_back(gd);
@@ -186,10 +187,10 @@
 }
 
 
-boost::shared_ptr<Archive>
+SharedPtr<Archive>
 Stream::copy() const
 {
-    return boost::shared_ptr<Archive>(new Stream(*this));
+    return SharedPtr<Archive>(new Stream(*this));
 }
 
 
@@ -218,7 +219,7 @@
 void
 Stream::write(const GridCPtrVec& grids, const MetaMap& metadata) const
 {
-    if (mImpl->mOutputStream == NULL) {
+    if (mImpl->mOutputStream == nullptr) {
         OPENVDB_THROW(ValueError, "no output stream was specified");
     }
     this->writeGrids(*mImpl->mOutputStream, grids, metadata);
diff -aur openvdb.3.2.0/io/Stream.h openvdb.4.0.0/io/Stream.h
--- openvdb.3.2.0/io/Stream.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/io/Stream.h	2016-10-09 10:18:58.000000000 +0200
@@ -32,8 +32,8 @@
 #define OPENVDB_IO_STREAM_HAS_BEEN_INCLUDED
 
 #include "Archive.h"
-#include <boost/scoped_ptr.hpp>
 #include <iosfwd>
+#include <memory>
 
 
 namespace openvdb {
@@ -63,10 +63,10 @@
     Stream(const Stream&);
     Stream& operator=(const Stream&);
 
-    virtual ~Stream();
+    ~Stream() override;
 
     /// @brief Return a copy of this archive.
-    virtual Archive::Ptr copy() const;
+    Archive::Ptr copy() const override;
 
     /// Return the file-level metadata in a newly created MetaMap.
     MetaMap::Ptr getMetadata() const;
@@ -76,7 +76,7 @@
 
     /// @brief Write the grids in the given container to this archive's output stream.
     /// @throw ValueError if this archive was constructed without specifying an output stream.
-    virtual void write(const GridCPtrVec&, const MetaMap& = MetaMap()) const;
+    void write(const GridCPtrVec&, const MetaMap& = MetaMap()) const override;
 
     /// @brief Write the grids in the given container to this archive's output stream.
     /// @throw ValueError if this archive was constructed without specifying an output stream.
@@ -93,7 +93,7 @@
 
 
     struct Impl;
-    boost::scoped_ptr<Impl> mImpl;
+    std::unique_ptr<Impl> mImpl;
 };
 
 
diff -aur openvdb.3.2.0/io/TempFile.cc openvdb.4.0.0/io/TempFile.cc
--- openvdb.3.2.0/io/TempFile.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/io/TempFile.cc	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file TempFile.cc
 
 #include "TempFile.h"
@@ -118,8 +118,8 @@
         return P_tmpdir;
     }
 
-    typedef boost::iostreams::file_descriptor_sink DeviceType;
-    typedef boost::iostreams::stream_buffer<boost::iostreams::file_descriptor_sink> BufferType;
+    using DeviceType = boost::iostreams::file_descriptor_sink;
+    using BufferType = boost::iostreams::stream_buffer<boost::iostreams::file_descriptor_sink>;
 
     std::string mPath;
     DeviceType mDevice;
@@ -161,7 +161,7 @@
 };
 
 
-TempFile::TempFile(): std::ostream(NULL), mImpl(new TempFileImpl(*this)) {}
+TempFile::TempFile(): std::ostream(nullptr), mImpl(new TempFileImpl(*this)) {}
 TempFile::~TempFile() { this->close(); }
 const std::string& TempFile::filename() const { return mImpl->filename(); }
 bool TempFile::is_open() const { return mImpl->is_open(); }
diff -aur openvdb.3.2.0/io/TempFile.h openvdb.4.0.0/io/TempFile.h
--- openvdb.3.2.0/io/TempFile.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/io/TempFile.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,14 +27,14 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file TempFile.h
 
 #ifndef OPENVDB_IO_TEMPFILE_HAS_BEEN_INCLUDED
 #define OPENVDB_IO_TEMPFILE_HAS_BEEN_INCLUDED
 
 #include <openvdb/version.h>
-#include <boost/scoped_ptr.hpp>
+#include <memory>
 #include <ostream>
 
 
@@ -67,7 +67,7 @@
 
 private:
     struct TempFileImpl;
-    boost::scoped_ptr<TempFileImpl> mImpl;
+    std::unique_ptr<TempFileImpl> mImpl;
 };
 
 } // namespace io
diff -aur openvdb.3.2.0/Makefile openvdb.4.0.0/Makefile
--- openvdb.3.2.0/Makefile	2016-07-24 09:29:15.000000000 +0200
+++ openvdb.4.0.0/Makefile	2016-10-09 10:18:58.000000000 +0200
@@ -51,8 +51,8 @@
 #   test                run tests
 #
 # Options:
-#   abi=2               build for compatibility with the OpenVDB 2.x Grid ABI
-#                       (some OpenVDB 3.x features will be disabled)
+#   abi=3               build for compatibility with the OpenVDB 3.x Grid ABI
+#                       (some OpenVDB 4.x features will be disabled)
 #   shared=no           link executables against static OpenVDB libraries
 #                       (default: link against shared libraries)
 #   debug=yes           build with debugging symbols and without optimization
@@ -250,7 +250,7 @@
     INCLDIRS += -isystem $(LOG4CPLUS_INCL_DIR)
 endif
 
-CXXFLAGS += -std=c++0x
+CXXFLAGS += -std=c++11
 
 CXXFLAGS += -pthread $(OPTIMIZE) $(INCLDIRS)
 ifeq (yes,$(has_blosc))
@@ -259,8 +259,8 @@
 ifeq (yes,$(has_log4cplus))
     CXXFLAGS += -DOPENVDB_USE_LOG4CPLUS
 endif
-ifeq (2,$(strip $(abi)))
-    CXXFLAGS += -DOPENVDB_2_ABI_COMPATIBLE
+ifeq (3,$(strip $(abi)))
+    CXXFLAGS += -DOPENVDB_3_ABI_COMPATIBLE
 endif
 ifneq (2,$(strip $(GLFW_MAJOR_VERSION)))
     CXXFLAGS += -DOPENVDB_USE_GLFW_3
@@ -331,9 +331,7 @@
     math/Vec3.h \
     math/Vec4.h \
     Metadata.h \
-    metadata/Metadata.h \
-    metadata/MetaMap.h \
-    metadata/StringMetadata.h \
+    MetaMap.h \
     openvdb.h \
     Platform.h \
     PlatformConfig.h \
@@ -418,8 +416,8 @@
     math/Proximity.cc \
     math/QuantizedUnitVec.cc \
     math/Transform.cc \
-    metadata/Metadata.cc \
-    metadata/MetaMap.cc \
+    Metadata.cc \
+    MetaMap.cc \
     openvdb.cc \
     Platform.cc \
     util/Formats.cc \
diff -aur openvdb.3.2.0/math/BBox.h openvdb.4.0.0/math/BBox.h
--- openvdb.3.2.0/math/BBox.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/math/BBox.h	2016-10-09 10:18:58.000000000 +0200
@@ -72,7 +72,10 @@
     explicit BBox(const ElementType* xyz, bool sorted = true);
 
     /// @brief Copy constructor
-    BBox(const BBox& other);
+    BBox(const BBox&) = default;
+
+    /// @brief Assignment operator
+    BBox& operator=(const BBox&) = default;
 
     /// @brief Sort the min/max by x,y,z component.
     void sort();
@@ -220,14 +223,6 @@
 }
 
 
-template<typename Vec3T>
-inline
-BBox<Vec3T>::BBox(const BBox& other):
-    mMin(other.mMin), mMax(other.mMax)
-{
-}
-
-
 ////////////////////////////////////////
 
 
diff -aur openvdb.3.2.0/math/ConjGradient.h openvdb.4.0.0/math/ConjGradient.h
--- openvdb.3.2.0/math/ConjGradient.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/math/ConjGradient.h	2016-10-09 10:18:58.000000000 +0200
@@ -28,10 +28,10 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 
-/// @file   ConjGradient.h
+/// @file    ConjGradient.h
 /// @authors D.J. Hill, Peter Cucka
-/// @brief  Preconditioned conjugate gradient solver (solves @e Ax = @e b using
-///         the conjugate gradient method with one of a selection of preconditioners)
+/// @brief   Preconditioned conjugate gradient solver (solves @e Ax = @e b using
+///          the conjugate gradient method with one of a selection of preconditioners)
 
 #ifndef OPENVDB_MATH_CONJGRADIENT_HAS_BEEN_INCLUDED
 #define OPENVDB_MATH_CONJGRADIENT_HAS_BEEN_INCLUDED
@@ -41,7 +41,6 @@
 #include <openvdb/util/logging.h>
 #include <openvdb/util/NullInterrupter.h>
 #include "Math.h" // for Abs(), isZero(), Max(), Sqrt()
-#include <boost/shared_ptr.hpp>
 #include <boost/scoped_array.hpp>
 #include <tbb/parallel_for.h>
 #include <tbb/parallel_reduce.h>
@@ -58,9 +57,9 @@
 namespace math {
 namespace pcg {
 
-typedef Index32 SizeType;
+using SizeType = Index32;
 
-typedef tbb::blocked_range<SizeType> SizeRange;
+using SizeRange = tbb::blocked_range<SizeType>;
 
 template<typename ValueType> class Vector;
 
@@ -166,17 +165,17 @@
 class Vector
 {
 public:
-    typedef T ValueType;
-    typedef boost::shared_ptr<Vector> Ptr;
+    using ValueType = T;
+    using Ptr = SharedPtr<Vector>;
 
     /// Construct an empty vector.
-    Vector(): mData(NULL), mSize(0) {}
+    Vector(): mData(nullptr), mSize(0) {}
     /// Construct a vector of @a n elements, with uninitialized values.
     Vector(SizeType n): mData(new T[n]), mSize(n) {}
     /// Construct a vector of @a n elements and initialize each element to the given value.
     Vector(SizeType n, const ValueType& val): mData(new T[n]), mSize(n) { this->fill(val); }
 
-    ~Vector() { mSize = 0; delete[] mData; mData = NULL; }
+    ~Vector() { mSize = 0; delete[] mData; mData = nullptr; }
 
     /// Deep copy the given vector.
     Vector(const Vector&);
@@ -252,9 +251,8 @@
     SizeType mSize;
 };
 
-typedef Vector<float> VectorS;
-typedef Vector<double> VectorD;
-//typedef Vector<double> LinearVector;
+using VectorS = Vector<float>;
+using VectorD = Vector<double>;
 
 
 ////////////////////////////////////////
@@ -266,9 +264,9 @@
 class SparseStencilMatrix
 {
 public:
-    typedef ValueType_ ValueType;
-    typedef Vector<ValueType> VectorType;
-    typedef boost::shared_ptr<SparseStencilMatrix> Ptr;
+    using ValueType = ValueType_;
+    using VectorType = Vector<ValueType>;
+    using Ptr = SharedPtr<SparseStencilMatrix>;
 
     class ConstValueIter;
     class ConstRow;
@@ -356,7 +354,7 @@
     class RowBase
     {
     public:
-        typedef DataType_ DataType;
+        using DataType = DataType_;
 
         static SizeType capacity() { return STENCIL_SIZE; }
 
@@ -405,7 +403,7 @@
         DataType mData;
     };
 
-    typedef RowBase<ConstRowData> ConstRowBase;
+    using ConstRowBase = RowBase<ConstRowData>;
 
 public:
     /// Iterator over the stored values in a row of this matrix
@@ -493,11 +491,11 @@
 class Preconditioner
 {
 public:
-    typedef T ValueType;
-    typedef boost::shared_ptr<Preconditioner> Ptr;
+    using ValueType = T;
+    using Ptr = SharedPtr<Preconditioner>;
 
     template<SizeType STENCIL_SIZE> Preconditioner(const SparseStencilMatrix<T, STENCIL_SIZE>&) {}
-    virtual ~Preconditioner() {}
+    virtual ~Preconditioner() = default;
 
     virtual bool isValid() const { return true; }
 
@@ -659,36 +657,32 @@
 template<typename T>
 struct Vector<T>::DeterministicDotProductOp
 {
-    DeterministicDotProductOp(const T* a_, const T* b_, 
-                              const SizeType binCount_, const SizeType arraySize_, T* reducetmp_): 
+    DeterministicDotProductOp(const T* a_, const T* b_,
+            const SizeType binCount_, const SizeType arraySize_, T* reducetmp_):
         a(a_), b(b_), binCount(binCount_), arraySize(arraySize_), reducetmp(reducetmp_) {}
-    
+
     void operator()(const SizeRange& range) const
     {
-        
-        const SizeType binSize = arraySize / binCount; 
-        
+        const SizeType binSize = arraySize / binCount;
+
         // Iterate over bins (array segments)
         for (SizeType n = range.begin(), N = range.end(); n < N; ++n) {
             const SizeType begin = n * binSize;
-            const SizeType end   = (n == binCount-1) ? arraySize : begin + binSize;
+            const SizeType end = (n == binCount-1) ? arraySize : begin + binSize;
 
-            // Compute the partial sum for this array segment 
+            // Compute the partial sum for this array segment
             T sum = zeroVal<T>();
-            for (SizeType i = begin; i < end; ++i) {
-                
-                sum += a[i] * b[i];
-            }
+            for (SizeType i = begin; i < end; ++i) { sum += a[i] * b[i]; }
             // Store the partial sum
             reducetmp[n] = sum;
         }
     }
 
-    
+
     const T* a;
     const T* b;
     const SizeType binCount;
-    const SizeType arraySize; 
+    const SizeType arraySize;
     T* reducetmp;
 };
 
@@ -715,21 +709,21 @@
 
     } else {
 
-        // Compute the dot product by segmenting the arrays into 
-        // a predetermined number of sub arrays in parallel and 
+        // Compute the dot product by segmenting the arrays into
+        // a predetermined number of sub arrays in parallel and
         // accumulate the finial result in series.
-        
+
         const SizeType binCount = 100;
         T partialSums[100];
-        
-        tbb::parallel_for(SizeRange(0, binCount), 
-                          DeterministicDotProductOp(aData, bData, binCount, arraySize, partialSums));
+
+        tbb::parallel_for(SizeRange(0, binCount),
+            DeterministicDotProductOp(aData, bData, binCount, arraySize, partialSums));
 
         for (SizeType n = 0; n < binCount; ++n) {
             result += partialSums[n];
         }
     }
-    
+
     return result;
 }
 
@@ -1324,10 +1318,10 @@
     struct ApplyOp;
 
 public:
-    typedef typename MatrixType::ValueType ValueType;
-    typedef Preconditioner<ValueType> BaseType;
-    typedef Vector<ValueType> VectorType;
-    typedef boost::shared_ptr<JacobiPreconditioner> Ptr;
+    using ValueType = typename MatrixType::ValueType;
+    using BaseType = Preconditioner<ValueType>;
+    using VectorType = Vector<ValueType>;
+    using Ptr = SharedPtr<JacobiPreconditioner>;
 
     JacobiPreconditioner(const MatrixType& A): BaseType(A), mDiag(A.numRows())
     {
@@ -1335,9 +1329,9 @@
         tbb::parallel_for(SizeRange(0, A.numRows()), InitOp(A, mDiag.data()));
     }
 
-    virtual ~JacobiPreconditioner() {}
+    virtual ~JacobiPreconditioner() override = default;
 
-    virtual void apply(const Vector<ValueType>& r, Vector<ValueType>& z)
+    void apply(const Vector<ValueType>& r, Vector<ValueType>& z) override
     {
         const SizeType size = mDiag.size();
 
@@ -1390,13 +1384,13 @@
     struct TransposeOp;
 
 public:
-    typedef typename MatrixType::ValueType ValueType;
-    typedef Preconditioner<ValueType> BaseType;
-    typedef Vector<ValueType> VectorType;
-    typedef boost::shared_ptr<IncompleteCholeskyPreconditioner> Ptr;
-    typedef SparseStencilMatrix<ValueType, 4>    TriangularMatrix;
-    typedef typename TriangularMatrix::ConstRow  TriangleConstRow;
-    typedef typename TriangularMatrix::RowEditor TriangleRowEditor;
+    using ValueType = typename MatrixType::ValueType;
+    using BaseType = Preconditioner<ValueType>;
+    using VectorType = Vector<ValueType>;
+    using Ptr = SharedPtr<IncompleteCholeskyPreconditioner>;
+    using TriangularMatrix = SparseStencilMatrix<ValueType, 4>;
+    using TriangleConstRow = typename TriangularMatrix::ConstRow;
+    using TriangleRowEditor = typename TriangularMatrix::RowEditor;
 
     IncompleteCholeskyPreconditioner(const MatrixType& matrix)
         : BaseType(matrix)
@@ -1491,11 +1485,11 @@
             TransposeOp(matrix, mLowerTriangular, mUpperTriangular));
     }
 
-    virtual ~IncompleteCholeskyPreconditioner() {}
+    ~IncompleteCholeskyPreconditioner() override = default;
 
-    virtual bool isValid() const { return mPassedCompatibilityCondition; }
+    bool isValid() const override { return mPassedCompatibilityCondition; }
 
-    virtual void apply(const Vector<ValueType>& rVec, Vector<ValueType>& zVec)
+    void apply(const Vector<ValueType>& rVec, Vector<ValueType>& zVec) override
     {
         if (!mPassedCompatibilityCondition) {
             OPENVDB_THROW(ArithmeticError, "invalid Cholesky decomposition");
@@ -1671,8 +1665,8 @@
     Interrupter& interrupter,
     const State& termination)
 {
-    typedef typename PositiveDefMatrix::ValueType ValueType;
-    typedef Vector<ValueType> VectorType;
+    using ValueType = typename PositiveDefMatrix::ValueType;
+    using VectorType = Vector<ValueType>;
 
     State result;
     result.success = false;
@@ -1701,7 +1695,7 @@
 
     // Compute norm of B (the source)
     const ValueType tmp = bVec.infNorm();
-    const ValueType infNormOfB = isZero(tmp) ? 1.f : tmp;
+    const ValueType infNormOfB = isZero(tmp) ? ValueType(1) : tmp;
 
     // Compute rVec: residual = b - Ax.
     VectorType rVec(size); // vector of residuals
diff -aur openvdb.3.2.0/math/Coord.h openvdb.4.0.0/math/Coord.h
--- openvdb.3.2.0/math/Coord.h	2016-07-24 09:29:15.000000000 +0200
+++ openvdb.4.0.0/math/Coord.h	2016-10-09 10:18:58.000000000 +0200
@@ -31,6 +31,7 @@
 #ifndef OPENVDB_MATH_COORD_HAS_BEEN_INCLUDED
 #define OPENVDB_MATH_COORD_HAS_BEEN_INCLUDED
 
+#include <array> // for std::array
 #include <openvdb/Platform.h>
 #include "Math.h"
 #include "Vec3.h"
@@ -55,15 +56,12 @@
     typedef Int32 ValueType;
     typedef std::numeric_limits<ValueType> Limits;
 
-    Coord() { mVec[0] = mVec[1] = mVec[2] = 0; }
-    explicit Coord(Int32 xyz) { mVec[0] = mVec[1] = mVec[2] = xyz; }
-    Coord(Int32 x, Int32 y, Int32 z) { mVec[0] = x; mVec[1] = y; mVec[2] = z; }
-    explicit Coord(const Vec3i& v) { mVec[0] = v[0]; mVec[1] = v[1]; mVec[2] = v[2]; }
-    explicit Coord(const Vec3I& v)
-    {
-        mVec[0] = Int32(v[0]); mVec[1] = Int32(v[1]); mVec[2] = Int32(v[2]);
-    }
-    explicit Coord(const Int32* v) { mVec[0] = v[0]; mVec[1] = v[1]; mVec[2] = v[2]; }
+    Coord(): mVec{{0, 0, 0}} {}
+    explicit Coord(Int32 xyz): mVec{{xyz, xyz, xyz}} {}
+    Coord(Int32 x, Int32 y, Int32 z): mVec{{x, y, z}} {}
+    explicit Coord(const Vec3i& v): mVec{{v[0], v[1], v[2]}} {}
+    explicit Coord(const Vec3I& v): mVec{{Int32(v[0]), Int32(v[1]), Int32(v[2])}} {}
+    explicit Coord(const Int32* v): mVec{{v[0], v[1], v[2]}} {}
 
     /// @brief Return the smallest possible coordinate
     static Coord min() { return Coord(Limits::min()); }
@@ -91,11 +89,15 @@
         return Coord(Int32(Ceil(xyz[0])), Int32(Ceil(xyz[1])), Int32(Ceil(xyz[2])));
     }
 
+    /// @brief Reset all three coordinates with the specified arguments
     Coord& reset(Int32 x, Int32 y, Int32 z)
     {
-        mVec[0] = x; mVec[1] = y; mVec[2] = z;
+        mVec[0] = x;
+        mVec[1] = y;
+        mVec[2] = z;
         return *this;
     }
+    /// @brief Reset all three coordinates with the same specified argument
     Coord& reset(Int32 xyz) { return this->reset(xyz, xyz, xyz); }
 
     Coord& setX(Int32 x) { mVec[0] = x; return *this; }
@@ -104,7 +106,9 @@
 
     Coord& offset(Int32 dx, Int32 dy, Int32 dz)
     {
-        mVec[0]+=dx; mVec[1]+=dy; mVec[2]+=dz;
+        mVec[0] += dx;
+        mVec[1] += dy;
+        mVec[2] += dz;
         return *this;
     }
     Coord& offset(Int32 n) { return this->offset(n, n, n); }
@@ -116,12 +120,16 @@
 
     Coord& operator+=(const Coord& rhs)
     {
-        mVec[0] += rhs[0]; mVec[1] += rhs[1]; mVec[2] += rhs[2];
+        mVec[0] += rhs[0];
+        mVec[1] += rhs[1];
+        mVec[2] += rhs[2];
         return *this;
     }
     Coord& operator-=(const Coord& rhs)
     {
-        mVec[0] -= rhs[0]; mVec[1] -= rhs[1]; mVec[2] -= rhs[2];
+        mVec[0] -= rhs[0];
+        mVec[1] -= rhs[1];
+        mVec[2] -= rhs[2];
         return *this;
     }
     Coord operator+(const Coord& rhs) const
@@ -152,13 +160,13 @@
     Int32& z() { return mVec[2]; }
     Int32& operator[](size_t i) { assert(i < 3); return mVec[i]; }
 
-    const Int32* data() const { return mVec; }
-    Int32* data() { return mVec; }
-    const Int32* asPointer() const { return mVec; }
-    Int32* asPointer() { return mVec; }
+    const Int32* data() const { return mVec.data(); }
+    Int32* data() { return mVec.data(); }
+    const Int32* asPointer() const { return mVec.data(); }
+    Int32* asPointer() { return mVec.data(); }
     Vec3d asVec3d() const { return Vec3d(double(mVec[0]), double(mVec[1]), double(mVec[2])); }
     Vec3s asVec3s() const { return Vec3s(float(mVec[0]), float(mVec[1]), float(mVec[2])); }
-    Vec3i asVec3i() const { return Vec3i(mVec); }
+    Vec3i asVec3i() const { return Vec3i(mVec.data()); }
     Vec3I asVec3I() const { return Vec3I(Index32(mVec[0]), Index32(mVec[1]), Index32(mVec[2])); }
     void asXYZ(Int32& x, Int32& y, Int32& z) const { x = mVec[0]; y = mVec[1]; z = mVec[2]; }
 
@@ -218,7 +226,7 @@
                      std::max(lhs.y(), rhs.y()),
                      std::max(lhs.z(), rhs.z()));
     }
-    
+
     /// Return true if any of the components of @a a are smaller than the
     /// corresponding components of @a b.
     static inline bool lessThan(const Coord& a, const Coord& b)
@@ -232,22 +240,21 @@
     /// @brief Return the index (0, 1 or 2) with the largest value.
     size_t maxIndex() const { return MaxIndex(mVec); }
 
-    void read(std::istream& is) { is.read(reinterpret_cast<char*>(mVec), sizeof(mVec)); }
+    void read(std::istream& is) { is.read(reinterpret_cast<char*>(mVec.data()), sizeof(mVec)); }
     void write(std::ostream& os) const
     {
-        os.write(reinterpret_cast<const char*>(mVec), sizeof(mVec));
+        os.write(reinterpret_cast<const char*>(mVec.data()), sizeof(mVec));
     }
 
 private:
-
-    Int32 mVec[3];
+    std::array<Int32, 3> mVec;
 }; // class Coord
 
 inline Coord
 Abs(const Coord& xyz)
 {
     return Coord(Abs(xyz[0]), Abs(xyz[1]), Abs(xyz[2]));
-}    
+}
 
 ////////////////////////////////////////
 
@@ -409,14 +416,14 @@
     {
         return CoordBBox(mMin.offsetBy(-padding),mMax.offsetBy(padding));
     }
-    
+
     /// Expand this bounding box to enclose point (x, y, z).
     void expand(const Coord& xyz)
     {
         mMin.minComponent(xyz);
         mMax.maxComponent(xyz);
     }
-    
+
     /// Union this bounding box with the given bounding box.
     void expand(const CoordBBox& bbox)
     {
@@ -442,10 +449,10 @@
     /// @brief Populates an array with the eight corner points of this bounding box.
     /// @details The ordering of the corner points is lexicographic.
     /// @warning It is assumed that the pointer can be incremented at
-    /// least seven times, i.e. has storage for eight Coord elements! 
+    /// least seven times, i.e. has storage for eight Coord elements!
     void getCornerPoints(Coord *p) const
     {
-        assert(p != NULL);
+        assert(p != nullptr);
         p->reset(mMin.x(), mMin.y(), mMin.z()); ++p;
         p->reset(mMin.x(), mMin.y(), mMax.z()); ++p;
         p->reset(mMin.x(), mMax.y(), mMin.z()); ++p;
@@ -467,7 +474,7 @@
     CoordBBox& operator&= (Coord::Int32 n) { mMin &= n; mMax &= n; return *this; }
     CoordBBox& operator|= (Coord::Int32 n) { mMin |= n; mMax |= n; return *this; }
     //@}
-     
+
     /// Unserialize this bounding box from the given stream.
     void read(std::istream& is) { mMin.read(is); mMax.read(is); }
     /// Serialize this bounding box to the given stream.
diff -aur openvdb.3.2.0/math/FiniteDifference.h openvdb.4.0.0/math/FiniteDifference.h
--- openvdb.3.2.0/math/FiniteDifference.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/math/FiniteDifference.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file FiniteDifference.h
 
 #ifndef OPENVDB_MATH_FINITEDIFFERENCE_HAS_BEEN_INCLUDED
@@ -336,7 +336,7 @@
     // is a reference value (squared) for the function being interpolated.  For
     // example if 'v' is of order 1000, then scale2 = 10^6 is ok.  But in practice
     // leave scale2 = 1.
-    const double eps = 1e-6 * scale2;
+    const double eps = 1.0e-6 * static_cast<double>(scale2);
     // {\tilde \omega_k} = \gamma_k / ( \beta_k + \epsilon)^2 in Shu's ICASE report)
     const double A1=0.1/math::Pow2(C*math::Pow2(v1-2*v2+v3)+0.25*math::Pow2(v1-4*v2+3.0*v3)+eps),
                  A2=0.6/math::Pow2(C*math::Pow2(v2-2*v3+v4)+0.25*math::Pow2(v2-v4)+eps),
diff -aur openvdb.3.2.0/math/Maps.cc openvdb.4.0.0/math/Maps.cc
--- openvdb.3.2.0/math/Maps.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/math/Maps.cc	2016-10-09 10:18:58.000000000 +0200
@@ -38,8 +38,8 @@
 
 namespace {
 
-typedef tbb::mutex Mutex;
-typedef Mutex::scoped_lock Lock;
+using Mutex = tbb::mutex;
+using Lock = Mutex::scoped_lock;
 
 // Declare this at file scope to ensure thread-safe initialization.
 // NOTE: Do *NOT* move this into Maps.h or else we will need to pull in
@@ -52,14 +52,14 @@
 ////////////////////////////////////////
 
 
-MapRegistry* MapRegistry::mInstance = NULL;
+MapRegistry* MapRegistry::mInstance = nullptr;
 
 
 // Caller is responsible for calling this function serially.
 MapRegistry*
 MapRegistry::staticInstance()
 {
-    if (mInstance == NULL) {
+    if (mInstance == nullptr) {
         OPENVDB_START_THREADSAFE_STATIC_WRITE
             mInstance = new MapRegistry();
         OPENVDB_FINISH_THREADSAFE_STATIC_WRITE
@@ -221,7 +221,7 @@
     }
 
     // could not simplify the general Affine map.
-    return boost::static_pointer_cast<MapBase, AffineMap>(affine);
+    return StaticPtrCast<MapBase, AffineMap>(affine);
 }
 
 
diff -aur openvdb.3.2.0/math/Maps.h openvdb.4.0.0/math/Maps.h
--- openvdb.3.2.0/math/Maps.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/math/Maps.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,8 +27,8 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
-/// @file Maps.h
+
+/// @file math/Maps.h
 
 #ifndef OPENVDB_MATH_MAPS_HAS_BEEN_INCLUDED
 #define OPENVDB_MATH_MAPS_HAS_BEEN_INCLUDED
@@ -41,7 +41,6 @@
 #include <openvdb/io/io.h> // for io::getFormatVersion()
 #include <openvdb/util/Name.h>
 #include <openvdb/Types.h>
-#include <boost/shared_ptr.hpp>
 #include <map>
 
 namespace openvdb {
@@ -66,11 +65,11 @@
 
 template<typename T1, typename T2> class CompoundMap;
 
-typedef CompoundMap<UnitaryMap, TranslationMap>                     UnitaryAndTranslationMap;
-typedef CompoundMap<CompoundMap<UnitaryMap, ScaleMap>, UnitaryMap>  SpectralDecomposedMap;
-typedef SpectralDecomposedMap                                       SymmetricMap;
-typedef CompoundMap<SymmetricMap, UnitaryAndTranslationMap>         FullyDecomposedMap;
-typedef CompoundMap<SymmetricMap, UnitaryMap>                       PolarDecomposedMap;
+using UnitaryAndTranslationMap = CompoundMap<UnitaryMap, TranslationMap>;
+using SpectralDecomposedMap    = CompoundMap<CompoundMap<UnitaryMap, ScaleMap>, UnitaryMap>;
+using SymmetricMap             = SpectralDecomposedMap;
+using FullyDecomposedMap       = CompoundMap<SymmetricMap, UnitaryAndTranslationMap>;
+using PolarDecomposedMap       = CompoundMap<SymmetricMap, UnitaryMap>;
 
 
 ////////////////////////////////////////
@@ -123,12 +122,12 @@
 
 /// @brief Create a SymmetricMap from a symmetric matrix.
 /// Decomposes the map into Rotation Diagonal Rotation^T
-OPENVDB_API boost::shared_ptr<SymmetricMap> createSymmetricMap(const Mat3d& m);
+OPENVDB_API SharedPtr<SymmetricMap> createSymmetricMap(const Mat3d& m);
 
 
 /// @brief General decomposition of a Matrix into a Unitary (e.g. rotation)
 /// following a Symmetric (e.g. stretch & shear)
-OPENVDB_API boost::shared_ptr<FullyDecomposedMap> createFullyDecomposedMap(const Mat4d& m);
+OPENVDB_API SharedPtr<FullyDecomposedMap> createFullyDecomposedMap(const Mat4d& m);
 
 
 /// @brief Decomposes a general linear into translation following polar decomposition.
@@ -141,11 +140,11 @@
 ///
 /// @note: the Symmetric is automatically decomposed into Q D Q^T, where
 /// Q is rotation and D is diagonal.
-OPENVDB_API boost::shared_ptr<PolarDecomposedMap> createPolarDecomposedMap(const Mat3d& m);
+OPENVDB_API SharedPtr<PolarDecomposedMap> createPolarDecomposedMap(const Mat3d& m);
 
 
 /// @brief reduces an AffineMap to a ScaleMap or a ScaleTranslateMap when it can
-OPENVDB_API boost::shared_ptr<MapBase> simplify(boost::shared_ptr<AffineMap> affine);
+OPENVDB_API SharedPtr<MapBase> simplify(SharedPtr<AffineMap> affine);
 
 /// @brief Returns the left pseudoInverse of the input matrix when the 3x3 part is symmetric
 /// otherwise it zeros the 3x3 and reverses the translation.
@@ -159,13 +158,14 @@
 class OPENVDB_API MapBase
 {
 public:
-    typedef boost::shared_ptr<MapBase>       Ptr;
-    typedef boost::shared_ptr<const MapBase> ConstPtr;
-    typedef Ptr (*MapFactory)();
+    using Ptr = SharedPtr<MapBase>;
+    using ConstPtr = SharedPtr<const MapBase>;
+    using MapFactory = Ptr (*)();
 
-    virtual ~MapBase(){}
+    MapBase(const MapBase&) = default;
+    virtual ~MapBase() = default;
 
-    virtual boost::shared_ptr<AffineMap> getAffineMap() const = 0;
+    virtual SharedPtr<AffineMap> getAffineMap() const = 0;
 
     /// Return the name of this map's concrete type (e.g., @c "AffineMap").
     virtual Name type() const = 0;
@@ -286,7 +286,7 @@
 class OPENVDB_API MapRegistry
 {
 public:
-    typedef std::map<Name, MapBase::MapFactory> MapDictionary;
+    using MapDictionary = std::map<Name, MapBase::MapFactory>;
 
     static MapRegistry* instance();
 
@@ -324,8 +324,8 @@
 class OPENVDB_API AffineMap: public MapBase
 {
 public:
-    typedef boost::shared_ptr<AffineMap>       Ptr;
-    typedef boost::shared_ptr<const AffineMap> ConstPtr;
+    using Ptr = SharedPtr<AffineMap>;
+    using ConstPtr = SharedPtr<const AffineMap>;
 
     AffineMap():
         mMatrix(Mat4d::identity()),
@@ -375,14 +375,14 @@
         updateAcceleration();
     }
 
-    ~AffineMap() {}
+    ~AffineMap() override = default;
 
     /// Return a MapBase::Ptr to a new AffineMap
     static MapBase::Ptr create() { return MapBase::Ptr(new AffineMap()); }
     /// Return a MapBase::Ptr to a deep copy of this map
-    MapBase::Ptr copy() const { return MapBase::Ptr(new AffineMap(*this)); }
+    MapBase::Ptr copy() const override { return MapBase::Ptr(new AffineMap(*this)); }
 
-    MapBase::Ptr inverseMap() const { return MapBase::Ptr(new AffineMap(mMatrixInv)); }
+    MapBase::Ptr inverseMap() const override { return MapBase::Ptr(new AffineMap(mMatrixInv)); }
 
     static bool isRegistered() { return MapRegistry::isRegistered(AffineMap::mapType()); }
 
@@ -393,26 +393,26 @@
             AffineMap::create);
     }
 
-    Name type() const { return mapType(); }
+    Name type() const override { return mapType(); }
     static Name mapType() { return Name("AffineMap"); }
 
     /// Return @c true (an AffineMap is always linear).
-    bool isLinear() const { return true; }
+    bool isLinear() const override { return true; }
 
     /// Return @c false ( test if this is unitary with translation )
-    bool hasUniformScale() const
+    bool hasUniformScale() const override
     {
         Mat3d mat = mMatrix.getMat3();
         const double det = mat.det();
         if (isApproxEqual(det, double(0))) {
             return false;
         } else {
-            mat *= (1.f / pow(std::abs(det),1./3.));
+            mat *= (1.0 / pow(std::abs(det), 1.0/3.0));
             return isUnitary(mat);
         }
     }
 
-    virtual bool isEqual(const MapBase& other) const { return isEqualBase(*this, other); }
+    bool isEqual(const MapBase& other) const override { return isEqualBase(*this, other); }
 
     bool operator==(const AffineMap& other) const
     {
@@ -437,25 +437,31 @@
         return *this;
     }
     /// Return the image of @c in under the map
-    Vec3d applyMap(const Vec3d& in) const { return in * mMatrix; }
+    Vec3d applyMap(const Vec3d& in) const override { return in * mMatrix; }
     /// Return the pre-image of @c in under the map
-    Vec3d applyInverseMap(const Vec3d& in) const {return in * mMatrixInv; }
+    Vec3d applyInverseMap(const Vec3d& in) const override {return in * mMatrixInv; }
 
     /// Return the Jacobian of the map applied to @a in.
-    Vec3d applyJacobian(const Vec3d& in, const Vec3d&) const { return applyJacobian(in); }
+    Vec3d applyJacobian(const Vec3d& in, const Vec3d&) const override { return applyJacobian(in); }
     /// Return the Jacobian of the map applied to @a in.
-    Vec3d applyJacobian(const Vec3d& in) const { return mMatrix.transform3x3(in); }
+    Vec3d applyJacobian(const Vec3d& in) const override { return mMatrix.transform3x3(in); }
 
-    /// Return the Inverse Jacobian of the map applied to @a in. (i.e. inverse map with out translation)
-    Vec3d applyInverseJacobian(const Vec3d& in, const Vec3d&) const { return applyInverseJacobian(in); }
-    /// Return the Inverse Jacobian of the map applied to @a in. (i.e. inverse map with out translation)
-    Vec3d applyInverseJacobian(const Vec3d& in) const { return mMatrixInv.transform3x3(in); }
+    /// @brief Return the Inverse Jacobian of the map applied to @a in
+    /// (i.e. inverse map with out translation)
+    Vec3d applyInverseJacobian(const Vec3d& in, const Vec3d&) const override {
+        return applyInverseJacobian(in);
+    }
+    /// @brief Return the Inverse Jacobian of the map applied to @a in
+    /// (i.e. inverse map with out translation)
+    Vec3d applyInverseJacobian(const Vec3d& in) const override {
+        return mMatrixInv.transform3x3(in);
+    }
 
     /// Return the Jacobian Transpose of the map applied to @a in.
     /// This tranforms range-space gradients to domain-space gradients
-    Vec3d applyJT(const Vec3d& in, const Vec3d&) const { return applyJT(in); }
+    Vec3d applyJT(const Vec3d& in, const Vec3d&) const override { return applyJT(in); }
     /// Return the Jacobian Transpose of the map applied to @a in.
-    Vec3d applyJT(const Vec3d& in) const {
+    Vec3d applyJT(const Vec3d& in) const override {
         const double* m = mMatrix.asPointer();
         return Vec3d( m[ 0] * in[0] + m[ 1] * in[1] + m[ 2] * in[2],
                       m[ 4] * in[0] + m[ 5] * in[1] + m[ 6] * in[2],
@@ -463,26 +469,26 @@
     }
 
     /// Return the transpose of the inverse Jacobian of the map applied to @a in.
-    Vec3d applyIJT(const Vec3d& in, const Vec3d&) const { return applyIJT(in); }
+    Vec3d applyIJT(const Vec3d& in, const Vec3d&) const override { return applyIJT(in); }
     /// Return the transpose of the inverse Jacobian of the map applied to @c in
-    Vec3d applyIJT(const Vec3d& in) const { return in * mJacobianInv; }
+    Vec3d applyIJT(const Vec3d& in) const override { return in * mJacobianInv; }
     /// Return the Jacobian Curvature: zero for a linear map
-    Mat3d applyIJC(const Mat3d& m) const {
+    Mat3d applyIJC(const Mat3d& m) const override {
         return mJacobianInv.transpose()* m * mJacobianInv;
     }
-    Mat3d applyIJC(const Mat3d& in, const Vec3d& , const Vec3d& ) const {
+    Mat3d applyIJC(const Mat3d& in, const Vec3d& , const Vec3d& ) const override {
         return applyIJC(in);
     }
     /// Return the determinant of the Jacobian, ignores argument
-    double determinant(const Vec3d& ) const { return determinant(); }
+    double determinant(const Vec3d& ) const override { return determinant(); }
     /// Return the determinant of the Jacobian
-    double determinant() const { return mDeterminant; }
+    double determinant() const override { return mDeterminant; }
 
     //@{
     /// @brief Return the lengths of the images of the segments
     /// (0,0,0)-(1,0,0), (0,0,0)-(0,1,0) and (0,0,0)-(0,0,1).
-    Vec3d voxelSize() const { return mVoxelSize; }
-    Vec3d voxelSize(const Vec3d&) const { return voxelSize(); }
+    Vec3d voxelSize() const override { return mVoxelSize; }
+    Vec3d voxelSize(const Vec3d&) const override { return voxelSize(); }
     //@}
 
     /// Return @c true if the underlying matrix is approximately an identity
@@ -548,20 +554,11 @@
 
 
     /// read serialization
-    void read(std::istream& is)
-    {
-        mMatrix.read(is);
-        updateAcceleration();
-    }
-
+    void read(std::istream& is) override { mMatrix.read(is); updateAcceleration(); }
     /// write serialization
-    void write(std::ostream& os) const
-    {
-        mMatrix.write(os);
-    }
-
+    void write(std::ostream& os) const override { mMatrix.write(os); }
     /// string serialization, useful for debugging
-    std::string str() const
+    std::string str() const override
     {
         std::ostringstream buffer;
         buffer << " - mat4:\n" << mMatrix.str() << std::endl;
@@ -570,13 +567,13 @@
     }
 
     /// on-demand decomposition of the affine map
-    boost::shared_ptr<FullyDecomposedMap> createDecomposedMap()
+    SharedPtr<FullyDecomposedMap> createDecomposedMap()
     {
         return createFullyDecomposedMap(mMatrix);
     }
 
     /// Return AffineMap::Ptr to  a deep copy of the current AffineMap
-    AffineMap::Ptr getAffineMap() const { return AffineMap::Ptr(new AffineMap(*this)); }
+    AffineMap::Ptr getAffineMap() const override { return AffineMap::Ptr(new AffineMap(*this)); }
 
     /// Return AffineMap::Ptr to the inverse of this map
     AffineMap::Ptr inverse() const { return AffineMap::Ptr(new AffineMap(mMatrixInv)); }
@@ -585,25 +582,25 @@
     //@{
     /// @brief  Return a MapBase::Ptr to a new map that is the result
     /// of prepending the appropraite operation.
-    MapBase::Ptr preRotate(double radians, Axis axis = X_AXIS) const
+    MapBase::Ptr preRotate(double radians, Axis axis = X_AXIS) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPreRotation(axis, radians);
         return simplify(affineMap);
     }
-    MapBase::Ptr preTranslate(const Vec3d& t) const
+    MapBase::Ptr preTranslate(const Vec3d& t) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPreTranslation(t);
-        return boost::static_pointer_cast<MapBase, AffineMap>(affineMap);
+        return StaticPtrCast<MapBase, AffineMap>(affineMap);
     }
-    MapBase::Ptr preScale(const Vec3d& s) const
+    MapBase::Ptr preScale(const Vec3d& s) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPreScale(s);
-        return boost::static_pointer_cast<MapBase, AffineMap>(affineMap);
+        return StaticPtrCast<MapBase, AffineMap>(affineMap);
     }
-    MapBase::Ptr preShear(double shear, Axis axis0, Axis axis1) const
+    MapBase::Ptr preShear(double shear, Axis axis0, Axis axis1) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPreShear(axis0, axis1, shear);
@@ -615,25 +612,25 @@
     //@{
     /// @brief  Return a MapBase::Ptr to a new map that is the result
     /// of postfixing the appropraite operation.
-    MapBase::Ptr postRotate(double radians, Axis axis = X_AXIS) const
+    MapBase::Ptr postRotate(double radians, Axis axis = X_AXIS) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPostRotation(axis, radians);
         return simplify(affineMap);
     }
-    MapBase::Ptr postTranslate(const Vec3d& t) const
+    MapBase::Ptr postTranslate(const Vec3d& t) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPostTranslation(t);
-        return boost::static_pointer_cast<MapBase, AffineMap>(affineMap);
+        return StaticPtrCast<MapBase, AffineMap>(affineMap);
     }
-    MapBase::Ptr postScale(const Vec3d& s) const
+    MapBase::Ptr postScale(const Vec3d& s) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPostScale(s);
-        return boost::static_pointer_cast<MapBase, AffineMap>(affineMap);
+        return StaticPtrCast<MapBase, AffineMap>(affineMap);
     }
-    MapBase::Ptr postShear(double shear, Axis axis0, Axis axis1) const
+    MapBase::Ptr postShear(double shear, Axis axis0, Axis axis1) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPostShear(axis0, axis1, shear);
@@ -685,8 +682,8 @@
 class OPENVDB_API ScaleMap: public MapBase
 {
 public:
-    typedef boost::shared_ptr<ScaleMap>       Ptr;
-    typedef boost::shared_ptr<const ScaleMap> ConstPtr;
+    using Ptr = SharedPtr<ScaleMap>;
+    using ConstPtr = SharedPtr<const ScaleMap>;
 
     ScaleMap(): MapBase(), mScaleValues(Vec3d(1,1,1)), mVoxelSize(Vec3d(1,1,1)),
                 mScaleValuesInverse(Vec3d(1,1,1)),
@@ -716,14 +713,16 @@
     {
     }
 
-    ~ScaleMap() {}
+    ~ScaleMap() override = default;
 
     /// Return a MapBase::Ptr to a new ScaleMap
     static MapBase::Ptr create() { return MapBase::Ptr(new ScaleMap()); }
     /// Return a MapBase::Ptr to a deep copy of this map
-    MapBase::Ptr copy() const { return MapBase::Ptr(new ScaleMap(*this)); }
+    MapBase::Ptr copy() const override { return MapBase::Ptr(new ScaleMap(*this)); }
 
-    MapBase::Ptr inverseMap() const { return MapBase::Ptr(new ScaleMap(mScaleValuesInverse)); }
+    MapBase::Ptr inverseMap() const override {
+        return MapBase::Ptr(new ScaleMap(mScaleValuesInverse));
+    }
 
     static bool isRegistered() { return MapRegistry::isRegistered(ScaleMap::mapType()); }
 
@@ -734,14 +733,14 @@
             ScaleMap::create);
     }
 
-    Name type() const { return mapType(); }
+    Name type() const override { return mapType(); }
     static Name mapType() { return Name("ScaleMap"); }
 
     /// Return @c true (a ScaleMap is always linear).
-    bool isLinear() const { return true; }
+    bool isLinear() const override { return true; }
 
     /// Return @c true if the values have the same magitude (eg. -1, 1, -1 would be a rotation).
-    bool hasUniformScale() const
+    bool hasUniformScale() const override
     {
         bool value = isApproxEqual(
             std::abs(mScaleValues.x()), std::abs(mScaleValues.y()), double(5e-7));
@@ -751,7 +750,7 @@
     }
 
     /// Return the image of @c in under the map
-    Vec3d applyMap(const Vec3d& in) const
+    Vec3d applyMap(const Vec3d& in) const override
     {
         return Vec3d(
             in.x() * mScaleValues.x(),
@@ -759,7 +758,7 @@
             in.z() * mScaleValues.z());
     }
     /// Return the pre-image of @c in under the map
-    Vec3d applyInverseMap(const Vec3d& in) const
+    Vec3d applyInverseMap(const Vec3d& in) const override
     {
         return Vec3d(
             in.x() * mScaleValuesInverse.x(),
@@ -767,30 +766,32 @@
             in.z() * mScaleValuesInverse.z());
     }
     /// Return the Jacobian of the map applied to @a in.
-    Vec3d applyJacobian(const Vec3d& in, const Vec3d&) const { return applyJacobian(in); }
+    Vec3d applyJacobian(const Vec3d& in, const Vec3d&) const override { return applyJacobian(in); }
     /// Return the Jacobian of the map applied to @a in.
-    Vec3d applyJacobian(const Vec3d& in) const { return applyMap(in); }
+    Vec3d applyJacobian(const Vec3d& in) const override { return applyMap(in); }
 
-    /// Return the Inverse Jacobian of the map applied to @a in. (i.e. inverse map with out translation)
-    Vec3d applyInverseJacobian(const Vec3d& in, const Vec3d&) const { return applyInverseJacobian(in); }
-    /// Return the Inverse Jacobian of the map applied to @a in. (i.e. inverse map with out translation)
-    Vec3d applyInverseJacobian(const Vec3d& in) const { return applyInverseMap(in); }
-
-    /// Return the Jacobian Transpose of the map applied to @a in.
-    /// This tranforms range-space gradients to domain-space gradients
-    Vec3d applyJT(const Vec3d& in, const Vec3d&) const { return applyJT(in); }
+    /// @brief Return the Inverse Jacobian of the map applied to @a in
+    /// (i.e. inverse map with out translation)
+    Vec3d applyInverseJacobian(const Vec3d& in, const Vec3d&) const override {
+        return applyInverseJacobian(in);
+    }
+    /// @brief Return the Inverse Jacobian of the map applied to @a in
+    /// (i.e. inverse map with out translation)
+    Vec3d applyInverseJacobian(const Vec3d& in) const override { return applyInverseMap(in); }
+
+    /// @brief Return the Jacobian Transpose of the map applied to @a in.
+    /// @details This tranforms range-space gradients to domain-space gradients
+    Vec3d applyJT(const Vec3d& in, const Vec3d&) const override { return applyJT(in); }
     /// Return the Jacobian Transpose of the map applied to @a in.
-    Vec3d applyJT(const Vec3d& in) const { return applyMap(in); }
-
-
+    Vec3d applyJT(const Vec3d& in) const override { return applyMap(in); }
 
     /// @brief Return the transpose of the inverse Jacobian of the map applied to @a in.
     /// @details Ignores second argument
-    Vec3d applyIJT(const Vec3d& in, const Vec3d&) const { return applyIJT(in);}
+    Vec3d applyIJT(const Vec3d& in, const Vec3d&) const override { return applyIJT(in);}
     /// Return the transpose of the inverse Jacobian of the map applied to @c in
-    Vec3d applyIJT(const Vec3d& in) const { return applyInverseMap(in); }
+    Vec3d applyIJT(const Vec3d& in) const override { return applyInverseMap(in); }
     /// Return the Jacobian Curvature: zero for a linear map
-    Mat3d applyIJC(const Mat3d& in) const
+    Mat3d applyIJC(const Mat3d& in) const override
     {
         Mat3d tmp;
         for (int i = 0; i < 3; i++) {
@@ -801,11 +802,15 @@
         }
         return tmp;
     }
-    Mat3d applyIJC(const Mat3d& in, const Vec3d&, const Vec3d&) const { return applyIJC(in); }
+    Mat3d applyIJC(const Mat3d& in, const Vec3d&, const Vec3d&) const override {
+        return applyIJC(in);
+    }
     /// Return the product of the scale values, ignores argument
-    double determinant(const Vec3d&) const { return determinant(); }
+    double determinant(const Vec3d&) const override { return determinant(); }
     /// Return the product of the scale values
-    double determinant() const { return mScaleValues.x() * mScaleValues.y() * mScaleValues.z(); }
+    double determinant() const override {
+        return mScaleValues.x() * mScaleValues.y() * mScaleValues.z();
+    }
 
     /// Return the scale values that define the map
     const Vec3d& getScale() const {return mScaleValues;}
@@ -818,16 +823,15 @@
     const Vec3d& getInvScale() const { return mScaleValuesInverse; }
 
     //@{
-    /// @brief Returns the lengths of the images
-    /// of the segments
+    /// @brief Return the lengths of the images of the segments
     /// \f$(0,0,0)-(1,0,0)\f$, \f$(0,0,0)-(0,1,0)\f$, \f$(0,0,0)-(0,0,1)\f$
-    /// this is equivalent to the absolute values of the scale values
-    Vec3d voxelSize() const { return mVoxelSize; }
-    Vec3d voxelSize(const Vec3d&) const { return voxelSize(); }
+    /// @details This is equivalent to the absolute values of the scale values
+    Vec3d voxelSize() const override { return mVoxelSize; }
+    Vec3d voxelSize(const Vec3d&) const override { return voxelSize(); }
     //@}
 
     /// read serialization
-    void read(std::istream& is)
+    void read(std::istream& is) override
     {
         mScaleValues.read(is);
         mVoxelSize.read(is);
@@ -836,7 +840,7 @@
         mInvTwiceScale.read(is);
     }
     /// write serialization
-    void write(std::ostream& os) const
+    void write(std::ostream& os) const override
     {
         mScaleValues.write(os);
         mVoxelSize.write(os);
@@ -845,7 +849,7 @@
         mInvTwiceScale.write(os);
     }
     /// string serialization, useful for debuging
-    std::string str() const
+    std::string str() const override
     {
         std::ostringstream buffer;
         buffer << " - scale: " << mScaleValues << std::endl;
@@ -853,7 +857,7 @@
         return buffer.str();
     }
 
-    virtual bool isEqual(const MapBase& other) const { return isEqualBase(*this, other); }
+    bool isEqual(const MapBase& other) const override { return isEqualBase(*this, other); }
 
     bool operator==(const ScaleMap& other) const
     {
@@ -865,7 +869,7 @@
     bool operator!=(const ScaleMap& other) const { return !(*this == other); }
 
     /// Return a AffineMap equivalent to this map
-    AffineMap::Ptr getAffineMap() const
+    AffineMap::Ptr getAffineMap() const override
     {
         return AffineMap::Ptr(new AffineMap(math::scale<Mat4d>(mScaleValues)));
     }
@@ -875,18 +879,16 @@
     //@{
     /// @brief  Return a MapBase::Ptr to a new map that is the result
     /// of prepending the appropraite operation to the existing map
-    MapBase::Ptr preRotate(double radians, Axis axis) const
+    MapBase::Ptr preRotate(double radians, Axis axis) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPreRotation(axis, radians);
         return simplify(affineMap);
     }
 
-    MapBase::Ptr preTranslate(const Vec3d& tr) const;
-
-    MapBase::Ptr preScale(const Vec3d& v) const;
-
-    MapBase::Ptr preShear(double shear, Axis axis0, Axis axis1) const
+    MapBase::Ptr preTranslate(const Vec3d&) const override;
+    MapBase::Ptr preScale(const Vec3d&) const override;
+    MapBase::Ptr preShear(double shear, Axis axis0, Axis axis1) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPreShear(axis0, axis1, shear);
@@ -898,18 +900,15 @@
     //@{
     /// @brief  Return a MapBase::Ptr to a new map that is the result
     /// of prepending the appropraite operation to the existing map.
-    MapBase::Ptr postRotate(double radians, Axis axis) const
+    MapBase::Ptr postRotate(double radians, Axis axis) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPostRotation(axis, radians);
         return simplify(affineMap);
     }
-
-    MapBase::Ptr postTranslate(const Vec3d& tr) const;
-
-    MapBase::Ptr postScale(const Vec3d& v) const;
-
-    MapBase::Ptr postShear(double shear, Axis axis0, Axis axis1) const
+    MapBase::Ptr postTranslate(const Vec3d&) const override;
+    MapBase::Ptr postScale(const Vec3d&) const override;
+    MapBase::Ptr postShear(double shear, Axis axis0, Axis axis1) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPostShear(axis0, axis1, shear);
@@ -927,20 +926,20 @@
 class OPENVDB_API UniformScaleMap: public ScaleMap
 {
 public:
-    typedef boost::shared_ptr<UniformScaleMap>       Ptr;
-    typedef boost::shared_ptr<const UniformScaleMap> ConstPtr;
+    using Ptr = SharedPtr<UniformScaleMap>;
+    using ConstPtr = SharedPtr<const UniformScaleMap>;
 
     UniformScaleMap(): ScaleMap(Vec3d(1,1,1)) {}
     UniformScaleMap(double scale): ScaleMap(Vec3d(scale, scale, scale)) {}
     UniformScaleMap(const UniformScaleMap& other): ScaleMap(other) {}
-    ~UniformScaleMap() {}
+    ~UniformScaleMap() override = default;
 
     /// Return a MapBase::Ptr to a new UniformScaleMap
     static MapBase::Ptr create() { return MapBase::Ptr(new UniformScaleMap()); }
     /// Return a MapBase::Ptr to a deep copy of this map
-    MapBase::Ptr copy() const { return MapBase::Ptr(new UniformScaleMap(*this)); }
+    MapBase::Ptr copy() const override { return MapBase::Ptr(new UniformScaleMap(*this)); }
 
-    MapBase::Ptr inverseMap() const
+    MapBase::Ptr inverseMap() const override
     {
         const Vec3d& invScale = getInvScale();
         return MapBase::Ptr(new UniformScaleMap( invScale[0]));
@@ -954,21 +953,21 @@
             UniformScaleMap::create);
     }
 
-    Name type() const { return mapType(); }
+    Name type() const override { return mapType(); }
     static Name mapType() { return Name("UniformScaleMap"); }
 
-    virtual bool isEqual(const MapBase& other) const { return isEqualBase(*this, other); }
+    bool isEqual(const MapBase& other) const override { return isEqualBase(*this, other); }
 
     bool operator==(const UniformScaleMap& other) const { return ScaleMap::operator==(other); }
     bool operator!=(const UniformScaleMap& other) const { return !(*this == other); }
 
-    /// Return a MapBase::Ptr to a UniformScaleTraslateMap that is the result of
+    /// @brief Return a MapBase::Ptr to a UniformScaleTraslateMap that is the result of
     /// pre-translation on this map
-    MapBase::Ptr preTranslate(const Vec3d& tr) const;
+    MapBase::Ptr preTranslate(const Vec3d&) const override;
 
-    /// Return a MapBase::Ptr to a UniformScaleTraslateMap that is the result of
+    /// @brief Return a MapBase::Ptr to a UniformScaleTraslateMap that is the result of
     /// post-translation on this map
-    MapBase::Ptr postTranslate(const Vec3d& tr) const;
+    MapBase::Ptr postTranslate(const Vec3d&) const override;
 
 }; // class UniformScaleMap
 
@@ -999,22 +998,24 @@
 class OPENVDB_API TranslationMap: public MapBase
 {
 public:
-    typedef boost::shared_ptr<TranslationMap>       Ptr;
-    typedef boost::shared_ptr<const TranslationMap> ConstPtr;
+    using Ptr = SharedPtr<TranslationMap>;
+    using ConstPtr = SharedPtr<const TranslationMap>;
 
     // default constructor is a translation by zero.
     TranslationMap(): MapBase(), mTranslation(Vec3d(0,0,0)) {}
     TranslationMap(const Vec3d& t): MapBase(), mTranslation(t) {}
     TranslationMap(const TranslationMap& other): MapBase(), mTranslation(other.mTranslation) {}
 
-    ~TranslationMap() {}
+    ~TranslationMap() override = default;
 
     /// Return a MapBase::Ptr to a new TranslationMap
     static MapBase::Ptr create() { return MapBase::Ptr(new TranslationMap()); }
     /// Return a MapBase::Ptr to a deep copy of this map
-    MapBase::Ptr copy() const { return MapBase::Ptr(new TranslationMap(*this)); }
+    MapBase::Ptr copy() const override { return MapBase::Ptr(new TranslationMap(*this)); }
 
-    MapBase::Ptr inverseMap() const { return MapBase::Ptr(new TranslationMap(-mTranslation)); }
+    MapBase::Ptr inverseMap() const override {
+        return MapBase::Ptr(new TranslationMap(-mTranslation));
+    }
 
     static bool isRegistered() { return MapRegistry::isRegistered(TranslationMap::mapType()); }
 
@@ -1025,72 +1026,78 @@
             TranslationMap::create);
     }
 
-    Name type() const { return mapType(); }
+    Name type() const override { return mapType(); }
     static Name mapType() { return Name("TranslationMap"); }
 
     /// Return @c true (a TranslationMap is always linear).
-    bool isLinear() const { return true; }
+    bool isLinear() const override { return true; }
 
     /// Return @c false (by convention true)
-    bool hasUniformScale() const { return true; }
+    bool hasUniformScale() const override { return true; }
 
     /// Return the image of @c in under the map
-    Vec3d applyMap(const Vec3d& in) const { return in + mTranslation; }
+    Vec3d applyMap(const Vec3d& in) const override { return in + mTranslation; }
     /// Return the pre-image of @c in under the map
-    Vec3d applyInverseMap(const Vec3d& in) const { return in - mTranslation; }
+    Vec3d applyInverseMap(const Vec3d& in) const override { return in - mTranslation; }
     /// Return the Jacobian of the map applied to @a in.
-    Vec3d applyJacobian(const Vec3d& in, const Vec3d&) const { return applyJacobian(in); }
+    Vec3d applyJacobian(const Vec3d& in, const Vec3d&) const override { return applyJacobian(in); }
     /// Return the Jacobian of the map applied to @a in.
-    Vec3d applyJacobian(const Vec3d& in) const { return in; }
+    Vec3d applyJacobian(const Vec3d& in) const override { return in; }
 
-    /// Return the Inverse Jacobian of the map applied to @a in. (i.e. inverse map with out translation)
-    Vec3d applyInverseJacobian(const Vec3d& in, const Vec3d&) const { return applyInverseJacobian(in); }
-    /// Return the Inverse Jacobian of the map applied to @a in. (i.e. inverse map with out translation)
-    Vec3d applyInverseJacobian(const Vec3d& in) const { return in; }
+    /// @brief Return the Inverse Jacobian of the map applied to @a in
+    /// (i.e. inverse map with out translation)
+    Vec3d applyInverseJacobian(const Vec3d& in, const Vec3d&) const override {
+        return applyInverseJacobian(in);
+    }
+    /// @brief Return the Inverse Jacobian of the map applied to @a in
+    /// (i.e. inverse map with out translation)
+    Vec3d applyInverseJacobian(const Vec3d& in) const override { return in; }
 
 
+    /// @brief Return the Jacobian Transpose of the map applied to @a in.
+    /// @details This tranforms range-space gradients to domain-space gradients
+    Vec3d applyJT(const Vec3d& in, const Vec3d&) const override { return applyJT(in); }
     /// Return the Jacobian Transpose of the map applied to @a in.
-    /// This tranforms range-space gradients to domain-space gradients
-    Vec3d applyJT(const Vec3d& in, const Vec3d&) const { return applyJT(in); }
-    /// Return the Jacobian Transpose of the map applied to @a in.
-    Vec3d applyJT(const Vec3d& in) const { return in; }
+    Vec3d applyJT(const Vec3d& in) const override { return in; }
 
     /// @brief Return the transpose of the inverse Jacobian (Identity for TranslationMap)
     /// of the map applied to @c in, ignores second argument
-    Vec3d applyIJT(const Vec3d& in, const Vec3d& ) const { return applyIJT(in);}
+    Vec3d applyIJT(const Vec3d& in, const Vec3d& ) const override { return applyIJT(in);}
     /// @brief Return the transpose of the inverse Jacobian (Identity for TranslationMap)
     /// of the map applied to @c in
-    Vec3d applyIJT(const Vec3d& in) const {return in;}
+    Vec3d applyIJT(const Vec3d& in) const override {return in;}
     /// Return the Jacobian Curvature: zero for a linear map
-    Mat3d applyIJC(const Mat3d& mat) const {return mat;}
-    Mat3d applyIJC(const Mat3d& mat, const Vec3d&, const Vec3d&) const { return applyIJC(mat); }
+    Mat3d applyIJC(const Mat3d& mat) const override {return mat;}
+    Mat3d applyIJC(const Mat3d& mat, const Vec3d&, const Vec3d&) const override {
+        return applyIJC(mat);
+    }
 
     /// Return @c 1
-    double determinant(const Vec3d& ) const { return determinant(); }
+    double determinant(const Vec3d& ) const override { return determinant(); }
     /// Return @c 1
-    double determinant() const { return 1.0; }
+    double determinant() const override { return 1.0; }
 
     /// Return \f$ (1,1,1) \f$
-    Vec3d voxelSize() const { return Vec3d(1,1,1);}
+    Vec3d voxelSize() const override { return Vec3d(1,1,1);}
     /// Return \f$ (1,1,1) \f$
-    Vec3d voxelSize(const Vec3d&) const { return voxelSize();}
+    Vec3d voxelSize(const Vec3d&) const override { return voxelSize();}
 
     /// Return the translation vector
     const Vec3d& getTranslation() const { return mTranslation; }
+
     /// read serialization
-    void read(std::istream& is) { mTranslation.read(is); }
+    void read(std::istream& is) override { mTranslation.read(is); }
     /// write serialization
-    void write(std::ostream& os) const { mTranslation.write(os); }
-
+    void write(std::ostream& os) const override { mTranslation.write(os); }
     /// string serialization, useful for debuging
-    std::string str() const
+    std::string str() const override
     {
         std::ostringstream buffer;
         buffer << " - translation: " << mTranslation << std::endl;
         return buffer.str();
     }
 
-    virtual bool isEqual(const MapBase& other) const { return isEqualBase(*this, other); }
+    bool isEqual(const MapBase& other) const override { return isEqualBase(*this, other); }
 
     bool operator==(const TranslationMap& other) const
     {
@@ -1101,7 +1108,7 @@
     bool operator!=(const TranslationMap& other) const { return !(*this == other); }
 
     /// Return AffineMap::Ptr to an AffineMap equivalent to *this
-    AffineMap::Ptr getAffineMap() const
+    AffineMap::Ptr getAffineMap() const override
     {
         Mat4d matrix(Mat4d::identity());
         matrix.setTranslation(mTranslation);
@@ -1113,21 +1120,21 @@
     //@{
     /// @brief Return a MapBase::Ptr to a new map that is the result
     /// of prepending the appropriate operation.
-    MapBase::Ptr preRotate(double radians, Axis axis) const
+    MapBase::Ptr preRotate(double radians, Axis axis) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPreRotation(axis, radians);
         return simplify(affineMap);
 
     }
-    MapBase::Ptr preTranslate(const Vec3d& t) const
+    MapBase::Ptr preTranslate(const Vec3d& t) const override
     {
         return MapBase::Ptr(new TranslationMap(t + mTranslation));
     }
 
-    MapBase::Ptr preScale(const Vec3d& v) const;
+    MapBase::Ptr preScale(const Vec3d& v) const override;
 
-    MapBase::Ptr preShear(double shear, Axis axis0, Axis axis1) const
+    MapBase::Ptr preShear(double shear, Axis axis0, Axis axis1) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPreShear(axis0, axis1, shear);
@@ -1138,21 +1145,21 @@
     //@{
     /// @brief Return a MapBase::Ptr to a new map that is the result
     /// of postfixing the appropriate operation.
-    MapBase::Ptr postRotate(double radians, Axis axis) const
+    MapBase::Ptr postRotate(double radians, Axis axis) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPostRotation(axis, radians);
         return simplify(affineMap);
 
     }
-    MapBase::Ptr postTranslate(const Vec3d& t) const
+    MapBase::Ptr postTranslate(const Vec3d& t) const override
     { // post and pre are the same for this
         return MapBase::Ptr(new TranslationMap(t + mTranslation));
     }
 
-    MapBase::Ptr postScale(const Vec3d& v) const;
+    MapBase::Ptr postScale(const Vec3d& v) const override;
 
-    MapBase::Ptr postShear(double shear, Axis axis0, Axis axis1) const
+    MapBase::Ptr postShear(double shear, Axis axis0, Axis axis1) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPostShear(axis0, axis1, shear);
@@ -1174,8 +1181,8 @@
 class OPENVDB_API ScaleTranslateMap: public MapBase
 {
 public:
-    typedef boost::shared_ptr<ScaleTranslateMap>       Ptr;
-    typedef boost::shared_ptr<const ScaleTranslateMap> ConstPtr;
+    using Ptr = SharedPtr<ScaleTranslateMap>;
+    using ConstPtr = SharedPtr<const ScaleTranslateMap>;
 
     ScaleTranslateMap():
         MapBase(),
@@ -1226,14 +1233,14 @@
         mInvTwiceScale(other.mInvTwiceScale)
     {}
 
-    ~ScaleTranslateMap() {}
+    ~ScaleTranslateMap() override = default;
 
     /// Return a MapBase::Ptr to a new ScaleTranslateMap
     static MapBase::Ptr create() { return MapBase::Ptr(new ScaleTranslateMap()); }
     /// Return a MapBase::Ptr to a deep copy of this map
-    MapBase::Ptr copy() const { return MapBase::Ptr(new ScaleTranslateMap(*this)); }
+    MapBase::Ptr copy() const override { return MapBase::Ptr(new ScaleTranslateMap(*this)); }
 
-    MapBase::Ptr inverseMap() const
+    MapBase::Ptr inverseMap() const override
     {
         return MapBase::Ptr(new ScaleTranslateMap(
             mScaleValuesInverse, -mScaleValuesInverse * mTranslation));
@@ -1248,15 +1255,15 @@
             ScaleTranslateMap::create);
     }
 
-    Name type() const { return mapType(); }
+    Name type() const override { return mapType(); }
     static Name mapType() { return Name("ScaleTranslateMap"); }
 
     /// Return @c true (a ScaleTranslateMap is always linear).
-    bool isLinear() const { return true; }
+    bool isLinear() const override { return true; }
 
     /// @brief Return @c true if the scale values have the same magnitude
     /// (eg. -1, 1, -1 would be a rotation).
-    bool hasUniformScale() const
+    bool hasUniformScale() const override
     {
         bool value = isApproxEqual(
             std::abs(mScaleValues.x()), std::abs(mScaleValues.y()), double(5e-7));
@@ -1266,7 +1273,7 @@
     }
 
     /// Return the image of @c under the map
-    Vec3d applyMap(const Vec3d& in) const
+    Vec3d applyMap(const Vec3d& in) const override
     {
         return Vec3d(
             in.x() * mScaleValues.x() + mTranslation.x(),
@@ -1274,7 +1281,7 @@
             in.z() * mScaleValues.z() + mTranslation.z());
     }
     /// Return the pre-image of @c under the map
-    Vec3d applyInverseMap(const Vec3d& in) const
+    Vec3d applyInverseMap(const Vec3d& in) const override
     {
         return Vec3d(
             (in.x() - mTranslation.x() ) * mScaleValuesInverse.x(),
@@ -1283,26 +1290,28 @@
     }
 
     /// Return the Jacobian of the map applied to @a in.
-    Vec3d applyJacobian(const Vec3d& in, const Vec3d&) const { return applyJacobian(in); }
+    Vec3d applyJacobian(const Vec3d& in, const Vec3d&) const override { return applyJacobian(in); }
     /// Return the Jacobian of the map applied to @a in.
-    Vec3d applyJacobian(const Vec3d& in) const { return in * mScaleValues; }
+    Vec3d applyJacobian(const Vec3d& in) const override { return in * mScaleValues; }
 
-    /// Return the Inverse Jacobian of the map applied to @a in. (i.e. inverse map with out translation)
-    Vec3d applyInverseJacobian(const Vec3d& in, const Vec3d&) const { return applyInverseJacobian(in); }
-    /// Return the Inverse Jacobian of the map applied to @a in. (i.e. inverse map with out translation)
-    Vec3d applyInverseJacobian(const Vec3d& in) const { return in * mScaleValuesInverse; }
-
-    /// Return the Jacobian Transpose of the map applied to @a in.
-    /// This tranforms range-space gradients to domain-space gradients
-    Vec3d applyJT(const Vec3d& in, const Vec3d&) const { return applyJT(in); }
+    /// @brief Return the Inverse Jacobian of the map applied to @a in
+    /// (i.e. inverse map with out translation)
+    Vec3d applyInverseJacobian(const Vec3d& in, const Vec3d&) const override { return applyInverseJacobian(in); }
+    /// @brief Return the Inverse Jacobian of the map applied to @a in
+    /// (i.e. inverse map with out translation)
+    Vec3d applyInverseJacobian(const Vec3d& in) const override { return in * mScaleValuesInverse; }
+
+    /// @brief Return the Jacobian Transpose of the map applied to @a in.
+    /// @details This tranforms range-space gradients to domain-space gradients
+    Vec3d applyJT(const Vec3d& in, const Vec3d&) const override { return applyJT(in); }
     /// Return the Jacobian Transpose of the map applied to @a in.
-    Vec3d applyJT(const Vec3d& in) const { return applyJacobian(in); }
+    Vec3d applyJT(const Vec3d& in) const override { return applyJacobian(in); }
 
     /// @brief Return the transpose of the inverse Jacobian of the map applied to @a in
     /// @details Ignores second argument
-    Vec3d applyIJT(const Vec3d& in, const Vec3d& ) const { return applyIJT(in);}
+    Vec3d applyIJT(const Vec3d& in, const Vec3d&) const override { return applyIJT(in);}
     /// Return the transpose of the inverse Jacobian of the map applied to @c in
-    Vec3d applyIJT(const Vec3d& in) const
+    Vec3d applyIJT(const Vec3d& in) const override
     {
         return Vec3d(
             in.x() * mScaleValuesInverse.x(),
@@ -1310,7 +1319,7 @@
             in.z() * mScaleValuesInverse.z());
     }
     /// Return the Jacobian Curvature: zero for a linear map
-    Mat3d applyIJC(const Mat3d& in) const
+    Mat3d applyIJC(const Mat3d& in) const override
     {
         Mat3d tmp;
         for (int i=0; i<3; i++){
@@ -1321,17 +1330,20 @@
         }
         return tmp;
     }
-    Mat3d applyIJC(const Mat3d& in, const Vec3d&, const Vec3d& ) const { return applyIJC(in); }
+    Mat3d applyIJC(const Mat3d& in, const Vec3d&, const Vec3d& ) const override {
+        return applyIJC(in);
+    }
 
     /// Return the product of the scale values, ignores argument
-    double determinant(const Vec3d& ) const { return determinant(); }
+    double determinant(const Vec3d&) const override { return determinant(); }
     /// Return the product of the scale values
-    double determinant() const { return mScaleValues.x()*mScaleValues.y()*mScaleValues.z(); }
+    double determinant() const override {
+        return mScaleValues.x() * mScaleValues.y() * mScaleValues.z();
+    }
     /// Return the absolute values of the scale values
-    Vec3d voxelSize() const { return mVoxelSize;}
-    /// Return the absolute values of the scale values, ignores
-    ///argument
-    Vec3d voxelSize(const Vec3d&) const { return voxelSize();}
+    Vec3d voxelSize() const override { return mVoxelSize;}
+    /// Return the absolute values of the scale values, ignores argument
+    Vec3d voxelSize(const Vec3d&) const override { return voxelSize();}
 
     /// Returns the scale values
     const Vec3d& getScale() const { return mScaleValues; }
@@ -1346,7 +1358,7 @@
     const Vec3d& getInvScale() const {return mScaleValuesInverse; }
 
     /// read serialization
-    void read(std::istream& is)
+    void read(std::istream& is) override
     {
         mTranslation.read(is);
         mScaleValues.read(is);
@@ -1356,7 +1368,7 @@
         mInvTwiceScale.read(is);
     }
     /// write serialization
-    void write(std::ostream& os) const
+    void write(std::ostream& os) const override
     {
         mTranslation.write(os);
         mScaleValues.write(os);
@@ -1366,7 +1378,7 @@
         mInvTwiceScale.write(os);
     }
     /// string serialization, useful for debuging
-    std::string str() const
+    std::string str() const override
     {
         std::ostringstream buffer;
         buffer << " - translation: " << mTranslation << std::endl;
@@ -1375,7 +1387,7 @@
         return buffer.str();
     }
 
-    virtual bool isEqual(const MapBase& other) const { return isEqualBase(*this, other); }
+    bool isEqual(const MapBase& other) const override { return isEqualBase(*this, other); }
 
     bool operator==(const ScaleTranslateMap& other) const
     {
@@ -1388,7 +1400,7 @@
     bool operator!=(const ScaleTranslateMap& other) const { return !(*this == other); }
 
     /// Return AffineMap::Ptr to an AffineMap equivalent to *this
-    AffineMap::Ptr getAffineMap() const
+    AffineMap::Ptr getAffineMap() const override
     {
         AffineMap::Ptr affineMap(new AffineMap(math::scale<Mat4d>(mScaleValues)));
         affineMap->accumPostTranslation(mTranslation);
@@ -1398,13 +1410,13 @@
     //@{
     /// @brief  Return a MapBase::Ptr to a new map that is the result
     /// of prepending the appropraite operation.
-    MapBase::Ptr preRotate(double radians, Axis axis) const
+    MapBase::Ptr preRotate(double radians, Axis axis) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPreRotation(axis, radians);
         return simplify(affineMap);
     }
-    MapBase::Ptr preTranslate(const Vec3d& t) const
+    MapBase::Ptr preTranslate(const Vec3d& t) const override
     {
         const Vec3d& s = mScaleValues;
         const Vec3d scaled_trans( t.x() * s.x(),
@@ -1413,9 +1425,9 @@
         return MapBase::Ptr( new ScaleTranslateMap(mScaleValues, mTranslation + scaled_trans));
     }
 
-    MapBase::Ptr preScale(const Vec3d& v) const;
+    MapBase::Ptr preScale(const Vec3d& v) const override;
 
-    MapBase::Ptr preShear(double shear, Axis axis0, Axis axis1) const
+    MapBase::Ptr preShear(double shear, Axis axis0, Axis axis1) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPreShear(axis0, axis1, shear);
@@ -1426,20 +1438,20 @@
     //@{
     /// @brief  Return a MapBase::Ptr to a new map that is the result
     /// of postfixing the appropraite operation.
-    MapBase::Ptr postRotate(double radians, Axis axis) const
+    MapBase::Ptr postRotate(double radians, Axis axis) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPostRotation(axis, radians);
         return simplify(affineMap);
     }
-    MapBase::Ptr postTranslate(const Vec3d& t) const
+    MapBase::Ptr postTranslate(const Vec3d& t) const override
     {
         return MapBase::Ptr( new ScaleTranslateMap(mScaleValues, mTranslation + t));
     }
 
-    MapBase::Ptr postScale(const Vec3d& v) const;
+    MapBase::Ptr postScale(const Vec3d& v) const override;
 
-    MapBase::Ptr postShear(double shear, Axis axis0, Axis axis1) const
+    MapBase::Ptr postShear(double shear, Axis axis0, Axis axis1) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPostShear(axis0, axis1, shear);
@@ -1477,8 +1489,8 @@
 class OPENVDB_API UniformScaleTranslateMap: public ScaleTranslateMap
 {
 public:
-    typedef boost::shared_ptr<UniformScaleTranslateMap>       Ptr;
-    typedef boost::shared_ptr<const UniformScaleTranslateMap> ConstPtr;
+    using Ptr = SharedPtr<UniformScaleTranslateMap>;
+    using ConstPtr = SharedPtr<const UniformScaleTranslateMap>;
 
     UniformScaleTranslateMap():ScaleTranslateMap(Vec3d(1,1,1), Vec3d(0,0,0)) {}
     UniformScaleTranslateMap(double scale, const Vec3d& translate):
@@ -1487,14 +1499,14 @@
         ScaleTranslateMap(scale.getScale(), translate.getTranslation()) {}
 
     UniformScaleTranslateMap(const UniformScaleTranslateMap& other):ScaleTranslateMap(other) {}
-    ~UniformScaleTranslateMap() {}
+    ~UniformScaleTranslateMap() override = default;
 
     /// Return a MapBase::Ptr to a new UniformScaleTranslateMap
     static MapBase::Ptr create() { return MapBase::Ptr(new UniformScaleTranslateMap()); }
     /// Return a MapBase::Ptr to a deep copy of this map
-    MapBase::Ptr copy() const { return MapBase::Ptr(new UniformScaleTranslateMap(*this)); }
+    MapBase::Ptr copy() const override { return MapBase::Ptr(new UniformScaleTranslateMap(*this)); }
 
-    MapBase::Ptr inverseMap() const
+    MapBase::Ptr inverseMap() const override
     {
         const Vec3d& scaleInv = getInvScale();
         const Vec3d& trans = getTranslation();
@@ -1509,14 +1521,13 @@
     static void registerMap()
     {
         MapRegistry::registerMap(
-                                 UniformScaleTranslateMap::mapType(),
-                                 UniformScaleTranslateMap::create);
+            UniformScaleTranslateMap::mapType(), UniformScaleTranslateMap::create);
     }
 
-    Name type() const { return mapType(); }
+    Name type() const override { return mapType(); }
     static Name mapType() { return Name("UniformScaleTranslateMap"); }
 
-    virtual bool isEqual(const MapBase& other) const { return isEqualBase(*this, other); }
+    bool isEqual(const MapBase& other) const override { return isEqualBase(*this, other); }
 
     bool operator==(const UniformScaleTranslateMap& other) const
     {
@@ -1526,7 +1537,7 @@
 
     /// @brief Return a MapBase::Ptr to a UniformScaleTranslateMap that is
     /// the result of prepending translation on this map.
-    MapBase::Ptr preTranslate(const Vec3d& t) const
+    MapBase::Ptr preTranslate(const Vec3d& t) const override
     {
         const double scale = this->getScale().x();
         const Vec3d  new_trans = this->getTranslation() + scale * t;
@@ -1535,7 +1546,7 @@
 
     /// @brief Return a MapBase::Ptr to a UniformScaleTranslateMap that is
     /// the result of postfixing translation on this map.
-    MapBase::Ptr postTranslate(const Vec3d& t) const
+    MapBase::Ptr postTranslate(const Vec3d& t) const override
     {
         const double scale = this->getScale().x();
         return MapBase::Ptr( new UniformScaleTranslateMap(scale, this->getTranslation() + t));
@@ -1620,8 +1631,8 @@
 class OPENVDB_API UnitaryMap: public MapBase
 {
 public:
-    typedef boost::shared_ptr<UnitaryMap>       Ptr;
-    typedef boost::shared_ptr<const UnitaryMap> ConstPtr;
+    using Ptr = SharedPtr<UnitaryMap>;
+    using ConstPtr = SharedPtr<const UnitaryMap>;
 
     /// default constructor makes an Idenity.
     UnitaryMap(): mAffineMap(Mat4d::identity())
@@ -1690,13 +1701,14 @@
     {
     }
 
-    ~UnitaryMap() {}
+    ~UnitaryMap() override = default;
+
     /// Return a MapBase::Ptr to a new UnitaryMap
     static MapBase::Ptr create() { return MapBase::Ptr(new UnitaryMap()); }
     /// Returns a MapBase::Ptr to a deep copy of *this
-    MapBase::Ptr copy() const { return MapBase::Ptr(new UnitaryMap(*this)); }
+    MapBase::Ptr copy() const override { return MapBase::Ptr(new UnitaryMap(*this)); }
 
-    MapBase::Ptr inverseMap() const
+    MapBase::Ptr inverseMap() const override
     {
         return MapBase::Ptr(new UnitaryMap(mAffineMap.getMat4().inverse()));
     }
@@ -1711,17 +1723,17 @@
     }
 
     /// Return @c UnitaryMap
-    Name type() const { return mapType(); }
+    Name type() const override { return mapType(); }
     /// Return @c UnitaryMap
     static Name mapType() { return Name("UnitaryMap"); }
 
     /// Return @c true (a UnitaryMap is always linear).
-    bool isLinear() const { return true; }
+    bool isLinear() const override { return true; }
 
     /// Return @c false (by convention true)
-    bool hasUniformScale() const { return true; }
+    bool hasUniformScale() const override { return true; }
 
-    virtual bool isEqual(const MapBase& other) const { return isEqualBase(*this, other); }
+    bool isEqual(const MapBase& other) const override { return isEqualBase(*this, other); }
 
     bool operator==(const UnitaryMap& other) const
     {
@@ -1732,130 +1744,146 @@
 
     bool operator!=(const UnitaryMap& other) const { return !(*this == other); }
     /// Return the image of @c in under the map
-    Vec3d applyMap(const Vec3d& in) const { return mAffineMap.applyMap(in); }
+    Vec3d applyMap(const Vec3d& in) const override { return mAffineMap.applyMap(in); }
     /// Return the pre-image of @c in under the map
-    Vec3d applyInverseMap(const Vec3d& in) const { return mAffineMap.applyInverseMap(in); }
+    Vec3d applyInverseMap(const Vec3d& in) const override { return mAffineMap.applyInverseMap(in); }
 
-    Vec3d applyJacobian(const Vec3d& in, const Vec3d&) const { return applyJacobian(in); }
+    Vec3d applyJacobian(const Vec3d& in, const Vec3d&) const override { return applyJacobian(in); }
     /// Return the Jacobian of the map applied to @a in.
-    Vec3d applyJacobian(const Vec3d& in) const { return mAffineMap.applyJacobian(in); }
-
-    /// Return the Inverse Jacobian of the map applied to @a in. (i.e. inverse map with out translation)
-    Vec3d applyInverseJacobian(const Vec3d& in, const Vec3d&) const { return applyInverseJacobian(in); }
-    /// Return the Inverse Jacobian of the map applied to @a in. (i.e. inverse map with out translation)
-    Vec3d applyInverseJacobian(const Vec3d& in) const { return mAffineMap.applyInverseJacobian(in); }
-
+    Vec3d applyJacobian(const Vec3d& in) const override { return mAffineMap.applyJacobian(in); }
 
+    /// @brief Return the Inverse Jacobian of the map applied to @a in
+    /// (i.e. inverse map with out translation)
+    Vec3d applyInverseJacobian(const Vec3d& in, const Vec3d&) const override {
+        return applyInverseJacobian(in);
+    }
+    /// @brief Return the Inverse Jacobian of the map applied to @a in
+    /// (i.e. inverse map with out translation)
+    Vec3d applyInverseJacobian(const Vec3d& in) const override {
+        return mAffineMap.applyInverseJacobian(in);
+    }
+
+    /// @brief Return the Jacobian Transpose of the map applied to @a in.
+    /// @details This tranforms range-space gradients to domain-space gradients
+    Vec3d applyJT(const Vec3d& in, const Vec3d&) const override { return applyJT(in); }
     /// Return the Jacobian Transpose of the map applied to @a in.
-    /// This tranforms range-space gradients to domain-space gradients
-    Vec3d applyJT(const Vec3d& in, const Vec3d&) const { return applyJT(in); }
-    /// Return the Jacobian Transpose of the map applied to @a in.
-    Vec3d applyJT(const Vec3d& in) const {
-        // The transpose of the unitary map is its inverse
-        return applyInverseMap(in);
+    Vec3d applyJT(const Vec3d& in) const override {
+        return applyInverseMap(in); // the transpose of the unitary map is its inverse
     }
 
 
     /// @brief Return the transpose of the inverse Jacobian of the map applied to @a in
     /// @details Ignores second argument
-    Vec3d applyIJT(const Vec3d& in, const Vec3d& ) const { return applyIJT(in);}
+    Vec3d applyIJT(const Vec3d& in, const Vec3d& ) const override { return applyIJT(in);}
     /// Return the transpose of the inverse Jacobian of the map applied to @c in
-    Vec3d applyIJT(const Vec3d& in) const { return mAffineMap.applyIJT(in); }
+    Vec3d applyIJT(const Vec3d& in) const override { return mAffineMap.applyIJT(in); }
     /// Return the Jacobian Curvature: zero for a linear map
-    Mat3d applyIJC(const Mat3d& in) const { return mAffineMap.applyIJC(in); }
-    Mat3d applyIJC(const Mat3d& in, const Vec3d&, const Vec3d& ) const { return applyIJC(in); }
+    Mat3d applyIJC(const Mat3d& in) const override { return mAffineMap.applyIJC(in); }
+    Mat3d applyIJC(const Mat3d& in, const Vec3d&, const Vec3d& ) const override {
+        return applyIJC(in);
+    }
+
     /// Return the determinant of the Jacobian, ignores argument
-    double determinant(const Vec3d& ) const { return determinant(); }
+    double determinant(const Vec3d&) const override { return determinant(); }
     /// Return the determinant of the Jacobian
-    double determinant() const { return mAffineMap.determinant(); }
+    double determinant() const override { return mAffineMap.determinant(); }
 
 
     /// @brief Returns the lengths of the images
     /// of the segments
     /// \f$(0,0,0)-(1,0,0)\f$, \f$(0,0,0)-(0,1,0)\f$,
     /// \f$(0,0,0)-(0,0,1)\f$
-    Vec3d voxelSize() const { return mAffineMap.voxelSize();}
-    Vec3d voxelSize(const Vec3d&) const { return voxelSize();}
+    Vec3d voxelSize() const override { return mAffineMap.voxelSize();}
+    Vec3d voxelSize(const Vec3d&) const override { return voxelSize();}
 
     /// read serialization
-    void read(std::istream& is)
+    void read(std::istream& is) override
     {
         mAffineMap.read(is);
     }
 
     /// write serialization
-    void write(std::ostream& os) const
+    void write(std::ostream& os) const override
     {
         mAffineMap.write(os);
     }
     /// string serialization, useful for debuging
-    std::string str() const
+    std::string str() const override
     {
         std::ostringstream buffer;
         buffer << mAffineMap.str();
         return buffer.str();
     }
     /// Return AffineMap::Ptr to an AffineMap equivalent to *this
-    AffineMap::Ptr getAffineMap() const { return AffineMap::Ptr(new AffineMap(mAffineMap)); }
+    AffineMap::Ptr getAffineMap() const override {
+        return AffineMap::Ptr(new AffineMap(mAffineMap));
+    }
 
-    //@{
-    /// @brief  Return a MapBase::Ptr to a new map that is the result
-    /// of prepending the appropraite operation.
-    MapBase::Ptr preRotate(double radians, Axis axis) const
+    /// @brief Return a MapBase::Ptr to a new map that is the result
+    /// of prepending the given rotation.
+    MapBase::Ptr preRotate(double radians, Axis axis) const override
     {
         UnitaryMap first(axis, radians);
         UnitaryMap::Ptr unitaryMap(new UnitaryMap(first, *this));
-        return boost::static_pointer_cast<MapBase, UnitaryMap>(unitaryMap);
+        return StaticPtrCast<MapBase, UnitaryMap>(unitaryMap);
     }
-    MapBase::Ptr preTranslate(const Vec3d& t) const
+    /// @brief Return a MapBase::Ptr to a new map that is the result
+    /// of prepending the given translation.
+    MapBase::Ptr preTranslate(const Vec3d& t) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPreTranslation(t);
         return simplify(affineMap);
     }
-    MapBase::Ptr preScale(const Vec3d& v) const
+    /// @brief Return a MapBase::Ptr to a new map that is the result
+    /// of prepending the given scale.
+    MapBase::Ptr preScale(const Vec3d& v) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPreScale(v);
         return simplify(affineMap);
     }
-    MapBase::Ptr preShear(double shear, Axis axis0, Axis axis1) const
+    /// @brief Return a MapBase::Ptr to a new map that is the result
+    /// of prepending the given shear.
+    MapBase::Ptr preShear(double shear, Axis axis0, Axis axis1) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPreShear(axis0, axis1, shear);
         return simplify(affineMap);
     }
-    //@}
-
 
-    //@{
-    /// @brief  Return a MapBase::Ptr to a new map that is the result
-    /// of postfixing the appropraite operation.
-    MapBase::Ptr postRotate(double radians, Axis axis) const
+    /// @brief Return a MapBase::Ptr to a new map that is the result
+    /// of appending the given rotation.
+    MapBase::Ptr postRotate(double radians, Axis axis) const override
     {
         UnitaryMap second(axis, radians);
         UnitaryMap::Ptr unitaryMap(new UnitaryMap(*this, second));
-        return boost::static_pointer_cast<MapBase, UnitaryMap>(unitaryMap);
+        return StaticPtrCast<MapBase, UnitaryMap>(unitaryMap);
     }
-    MapBase::Ptr postTranslate(const Vec3d& t) const
+    /// @brief Return a MapBase::Ptr to a new map that is the result
+    /// of appending the given translation.
+    MapBase::Ptr postTranslate(const Vec3d& t) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPostTranslation(t);
         return simplify(affineMap);
     }
-    MapBase::Ptr postScale(const Vec3d& v) const
+    /// @brief Return a MapBase::Ptr to a new map that is the result
+    /// of appending the given scale.
+    MapBase::Ptr postScale(const Vec3d& v) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPostScale(v);
         return simplify(affineMap);
     }
-    MapBase::Ptr postShear(double shear, Axis axis0, Axis axis1) const
+    /// @brief Return a MapBase::Ptr to a new map that is the result
+    /// of appending the given shear.
+    MapBase::Ptr postShear(double shear, Axis axis0, Axis axis1) const override
     {
         AffineMap::Ptr affineMap = getAffineMap();
         affineMap->accumPostShear(axis0, axis1, shear);
         return simplify(affineMap);
     }
-    //@}
 
 private:
     AffineMap  mAffineMap;
@@ -1874,8 +1902,8 @@
 class OPENVDB_API NonlinearFrustumMap: public MapBase
 {
 public:
-    typedef boost::shared_ptr<NonlinearFrustumMap>       Ptr;
-    typedef boost::shared_ptr<const NonlinearFrustumMap> ConstPtr;
+    using Ptr = SharedPtr<NonlinearFrustumMap>;
+    using ConstPtr = SharedPtr<const NonlinearFrustumMap>;
 
     NonlinearFrustumMap():
         MapBase(),
@@ -1996,16 +2024,17 @@
         init();
     }
 
-    ~NonlinearFrustumMap(){}
+    ~NonlinearFrustumMap() override = default;
+
     /// Return a MapBase::Ptr to a new NonlinearFrustumMap
     static MapBase::Ptr create() { return MapBase::Ptr(new NonlinearFrustumMap()); }
     /// Return a MapBase::Ptr to a deep copy of this map
-    MapBase::Ptr copy() const { return MapBase::Ptr(new NonlinearFrustumMap(*this)); }
+    MapBase::Ptr copy() const override { return MapBase::Ptr(new NonlinearFrustumMap(*this)); }
 
     /// @brief Not implemented, since there is currently no map type that can
     /// represent the inverse of a frustum
     /// @throw NotImplementedError
-    MapBase::Ptr inverseMap() const
+    MapBase::Ptr inverseMap() const override
     {
         OPENVDB_THROW(NotImplementedError,
             "inverseMap() is not implemented for NonlinearFrustumMap");
@@ -2019,15 +2048,15 @@
             NonlinearFrustumMap::create);
     }
     /// Return @c NonlinearFrustumMap
-    Name type() const { return mapType(); }
+    Name type() const override { return mapType(); }
     /// Return @c NonlinearFrustumMap
     static Name mapType() { return Name("NonlinearFrustumMap"); }
 
     /// Return @c false (a NonlinearFrustumMap is never linear).
-    bool isLinear() const { return false; }
+    bool isLinear() const override { return false; }
 
     /// Return @c false (by convention false)
-    bool hasUniformScale() const { return false; }
+    bool hasUniformScale() const override { return false; }
 
     /// Return @c true if the map is equivalent to an identity
     bool isIdentity() const
@@ -2049,7 +2078,7 @@
         return true;
     }
 
-    virtual bool isEqual(const MapBase& other) const { return isEqualBase(*this, other); }
+    bool isEqual(const MapBase& other) const override { return isEqualBase(*this, other); }
 
     bool operator==(const NonlinearFrustumMap& other) const
     {
@@ -2076,20 +2105,20 @@
     bool operator!=(const NonlinearFrustumMap& other) const { return !(*this == other); }
 
     /// Return the image of @c in under the map
-    Vec3d applyMap(const Vec3d& in) const
+    Vec3d applyMap(const Vec3d& in) const override
     {
         return mSecondMap.applyMap(applyFrustumMap(in));
     }
 
     /// Return the pre-image of @c in under the map
-    Vec3d applyInverseMap(const Vec3d& in) const
+    Vec3d applyInverseMap(const Vec3d& in) const override
     {
         return applyFrustumInverseMap(mSecondMap.applyInverseMap(in));
     }
     /// Return the Jacobian of the linear second map applied to @c in
-    Vec3d applyJacobian(const Vec3d& in) const { return mSecondMap.applyJacobian(in); }
+    Vec3d applyJacobian(const Vec3d& in) const override { return mSecondMap.applyJacobian(in); }
     /// Return the Jacobian defined at @c isloc applied to @c in
-    Vec3d applyJacobian(const Vec3d& in, const Vec3d& isloc) const
+    Vec3d applyJacobian(const Vec3d& in, const Vec3d& isloc) const override
     {
         // Move the center of the x-face of the bbox
         // to the origin in index space.
@@ -2112,10 +2141,13 @@
     }
 
 
-    /// Return the Inverse Jacobian of the map applied to @a in. (i.e. inverse map with out translation)
-    Vec3d applyInverseJacobian(const Vec3d& in) const { return mSecondMap.applyInverseJacobian(in); }
+    /// @brief Return the Inverse Jacobian of the map applied to @a in
+    /// (i.e. inverse map with out translation)
+    Vec3d applyInverseJacobian(const Vec3d& in) const override {
+        return mSecondMap.applyInverseJacobian(in);
+    }
     /// Return the Inverse Jacobian defined at @c isloc of the map applied to @a in.
-    Vec3d applyInverseJacobian(const Vec3d& in, const Vec3d& isloc) const {
+    Vec3d applyInverseJacobian(const Vec3d& in, const Vec3d& isloc) const override {
 
         // Move the center of the x-face of the bbox
         // to the origin in index space.
@@ -2140,12 +2172,9 @@
         return out;
     }
 
-
-
-    /// Return the Jacobian Transpose of the map applied to vector @c in at @c indexloc.
-    /// This tranforms range-space gradients to domain-space gradients.
-    ///
-    Vec3d applyJT(const Vec3d& in, const Vec3d& isloc) const {
+    /// @brief Return the Jacobian Transpose of the map applied to vector @c in at @c indexloc.
+    /// @details This tranforms range-space gradients to domain-space gradients.
+    Vec3d applyJT(const Vec3d& in, const Vec3d& isloc) const override {
         const Vec3d tmp = mSecondMap.applyJT(in);
         // Move the center of the x-face of the bbox
         // to the origin in index space.
@@ -2167,12 +2196,12 @@
                      mDepthOnLz * tmp.z());
     }
     /// Return the Jacobian Transpose of the second map applied to @c in.
-    Vec3d applyJT(const Vec3d& in) const {
+    Vec3d applyJT(const Vec3d& in) const override {
         return mSecondMap.applyJT(in);
     }
 
     /// Return the transpose of the inverse Jacobian of the linear second map applied to @c in
-    Vec3d applyIJT(const Vec3d& in) const { return mSecondMap.applyIJT(in); }
+    Vec3d applyIJT(const Vec3d& in) const override { return mSecondMap.applyIJT(in); }
 
     // the Jacobian of the nonlinear part of the transform is a sparse matrix
     // Jacobian^(-T) =
@@ -2182,7 +2211,7 @@
     //        (  -(x-xo)g/(sLx)   -(y-yo)g/(sLx)  Lz/(Depth Lx)   )
     /// Return the transpose of the inverse Jacobain (at @c locW applied to @c in.
     /// @c ijk is the location in the pre-image space (e.g. index space)
-    Vec3d applyIJT(const Vec3d& d1_is, const Vec3d& ijk) const
+    Vec3d applyIJT(const Vec3d& d1_is, const Vec3d& ijk) const override
     {
         const Vec3d loc = applyFrustumMap(ijk);
         const double s = mGamma * loc.z() + 1.;
@@ -2218,12 +2247,12 @@
     }
 
     /// Return the Jacobian Curvature for the linear second map
-    Mat3d applyIJC(const Mat3d& in) const { return mSecondMap.applyIJC(in); }
+    Mat3d applyIJC(const Mat3d& in) const override { return mSecondMap.applyIJC(in); }
     /// Return the Jacobian Curvature: all the second derivatives in range space
     /// @param d2_is second derivative matrix computed in index space
     /// @param d1_is gradient computed in index space
     /// @param ijk  the index space location where the result is computed
-    Mat3d applyIJC(const Mat3d& d2_is, const Vec3d& d1_is, const Vec3d& ijk) const
+    Mat3d applyIJC(const Mat3d& d2_is, const Vec3d& d1_is, const Vec3d& ijk) const override
     {
         const Vec3d loc = applyFrustumMap(ijk);
 
@@ -2293,11 +2322,11 @@
     }
 
     /// Return the determinant of the Jacobian of linear second map
-    double determinant() const {return mSecondMap.determinant();} // no implementation
+    double determinant() const override {return mSecondMap.determinant();} // no implementation
 
     /// Return the determinate of the Jacobian evaluated at @c loc
     /// @c loc is a location in the pre-image space (e.g., index space)
-    double determinant(const Vec3d& loc) const
+    double determinant(const Vec3d& loc) const override
     {
         double s = mGamma * loc.z() + 1.0;
         double frustum_determinant = s * s * mDepthOnLzLxLx;
@@ -2305,7 +2334,7 @@
     }
 
     /// Return the size of a voxel at the center of the near plane
-    Vec3d voxelSize() const
+    Vec3d voxelSize() const override
     {
         const Vec3d loc( 0.5*(mBBox.min().x() + mBBox.max().x()),
                          0.5*(mBBox.min().y() + mBBox.max().y()),
@@ -2319,7 +2348,7 @@
     /// from @a loc to @a loc + (1,0,0), from @a loc to @a loc + (0,1,0)
     /// and from @a loc to @a loc + (0,0,1)
     /// @param loc  a location in the pre-image space (e.g., index space)
-    Vec3d voxelSize(const Vec3d& loc) const
+    Vec3d voxelSize(const Vec3d& loc) const override
     {
         Vec3d out, pos = applyMap(loc);
         out(0) = (applyMap(loc + Vec3d(1,0,0)) - pos).length();
@@ -2328,7 +2357,7 @@
         return out;
     }
 
-    AffineMap::Ptr getAffineMap() const { return mSecondMap.getAffineMap(); }
+    AffineMap::Ptr getAffineMap() const override { return mSecondMap.getAffineMap(); }
 
     /// set the taper value, the ratio of nearplane width / far plane width
     void setTaper(double t) { mTaper = t; init();}
@@ -2354,7 +2383,7 @@
     bool hasSimpleAffine() const { return mHasSimpleAffine; }
 
     /// read serialization
-    void read(std::istream& is)
+    void read(std::istream& is) override
     {
         // for backward compatibility with earlier version
         if (io::getFormatVersion(is) < OPENVDB_FILE_VERSION_FLOAT_FRUSTUM_BBOX ) {
@@ -2384,7 +2413,7 @@
     }
 
     /// write serialization
-    void write(std::ostream& os) const
+    void write(std::ostream& os) const override
     {
         mBBox.write(os);
         os.write(reinterpret_cast<const char*>(&mTaper), sizeof(double));
@@ -2395,7 +2424,7 @@
     }
 
     /// string serialization, useful for debuging
-    std::string str() const
+    std::string str() const override
     {
         std::ostringstream buffer;
         buffer << " - taper: " << mTaper << std::endl;
@@ -2405,55 +2434,63 @@
         return buffer.str();
     }
 
-    //@{
     /// @brief Return a MapBase::Ptr to a new map that is the result
-    /// of prepending the appropriate operation to the linear part of this map
-    MapBase::Ptr preRotate(double radians, Axis axis = X_AXIS) const
+    /// of prepending the given rotation to the linear part of this map
+    MapBase::Ptr preRotate(double radians, Axis axis = X_AXIS) const override
     {
         return MapBase::Ptr(
             new NonlinearFrustumMap(mBBox, mTaper, mDepth, mSecondMap.preRotate(radians, axis)));
     }
-    MapBase::Ptr preTranslate(const Vec3d& t) const
+    /// @brief Return a MapBase::Ptr to a new map that is the result
+    /// of prepending the given translation to the linear part of this map
+    MapBase::Ptr preTranslate(const Vec3d& t) const override
     {
         return MapBase::Ptr(
             new NonlinearFrustumMap(mBBox, mTaper, mDepth, mSecondMap.preTranslate(t)));
     }
-    MapBase::Ptr preScale(const Vec3d& s) const
+    /// @brief Return a MapBase::Ptr to a new map that is the result
+    /// of prepending the given scale to the linear part of this map
+    MapBase::Ptr preScale(const Vec3d& s) const override
     {
         return MapBase::Ptr(
             new NonlinearFrustumMap(mBBox, mTaper, mDepth, mSecondMap.preScale(s)));
     }
-    MapBase::Ptr preShear(double shear, Axis axis0, Axis axis1) const
+    /// @brief Return a MapBase::Ptr to a new map that is the result
+    /// of prepending the given shear to the linear part of this map
+    MapBase::Ptr preShear(double shear, Axis axis0, Axis axis1) const override
     {
         return MapBase::Ptr(new NonlinearFrustumMap(
             mBBox, mTaper, mDepth, mSecondMap.preShear(shear, axis0, axis1)));
     }
-    //@}
 
-    //@{
     /// @brief Return a MapBase::Ptr to a new map that is the result
-    /// of postfixing the appropiate operation to the linear part of this map.
-    MapBase::Ptr postRotate(double radians, Axis axis = X_AXIS) const
+    /// of appending the given rotation to the linear part of this map.
+    MapBase::Ptr postRotate(double radians, Axis axis = X_AXIS) const override
     {
         return MapBase::Ptr(
             new NonlinearFrustumMap(mBBox, mTaper, mDepth, mSecondMap.postRotate(radians, axis)));
     }
-    MapBase::Ptr postTranslate(const Vec3d& t) const
+    /// @brief Return a MapBase::Ptr to a new map that is the result
+    /// of appending the given translation to the linear part of this map.
+    MapBase::Ptr postTranslate(const Vec3d& t) const override
     {
         return MapBase::Ptr(
             new NonlinearFrustumMap(mBBox, mTaper, mDepth, mSecondMap.postTranslate(t)));
     }
-    MapBase::Ptr postScale(const Vec3d& s) const
+    /// @brief Return a MapBase::Ptr to a new map that is the result
+    /// of appending the given scale to the linear part of this map.
+    MapBase::Ptr postScale(const Vec3d& s) const override
     {
         return MapBase::Ptr(
             new NonlinearFrustumMap(mBBox, mTaper, mDepth, mSecondMap.postScale(s)));
     }
-    MapBase::Ptr postShear(double shear, Axis axis0, Axis axis1) const
+    /// @brief Return a MapBase::Ptr to a new map that is the result
+    /// of appending the given shear to the linear part of this map.
+    MapBase::Ptr postShear(double shear, Axis axis0, Axis axis1) const override
     {
         return MapBase::Ptr(new NonlinearFrustumMap(
             mBBox, mTaper, mDepth, mSecondMap.postShear(shear, axis0, axis1)));
     }
-    //@}
 
 private:
     void init()
@@ -2566,10 +2603,10 @@
 class CompoundMap
 {
 public:
-    typedef CompoundMap<FirstMapType, SecondMapType>    MyType;
+    using MyType = CompoundMap<FirstMapType, SecondMapType>;
 
-    typedef boost::shared_ptr<MyType>       Ptr;
-    typedef boost::shared_ptr<const MyType> ConstPtr;
+    using Ptr = SharedPtr<MyType>;
+    using ConstPtr = SharedPtr<const MyType>;
 
 
     CompoundMap() { updateAffineMatrix(); }
diff -aur openvdb.3.2.0/math/Mat3.h openvdb.4.0.0/math/Mat3.h
--- openvdb.3.2.0/math/Mat3.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/math/Mat3.h	2016-10-09 10:18:58.000000000 +0200
@@ -152,11 +152,21 @@
 
     /// Predefined constant for identity matrix
     static const Mat3<T>& identity() {
+        static const Mat3<T> sIdentity = Mat3<T>(
+            1, 0, 0,
+            0, 1, 0,
+            0, 0, 1
+        );
         return sIdentity;
     }
 
     /// Predefined constant for zero matrix
     static const Mat3<T>& zero() {
+        static const Mat3<T> sZero = Mat3<T>(
+            0, 0, 0,
+            0, 0, 0,
+            0, 0, 0
+        );
         return sZero;
     }
 
@@ -241,7 +251,7 @@
         MyBase::mm[7] = v3[1];
         MyBase::mm[8] = v3[2];
     } // setRows
-    
+
     /// Set the columns of "this" matrix to the vectors v1, v2, v3
     void setColumns(const Vec3<T> &v1, const Vec3<T> &v2, const Vec3<T> &v3)
     {
@@ -478,7 +488,7 @@
           MyBase::mm[0] * MyBase::mm[4] - MyBase::mm[1] * MyBase::mm[3]);
     }
 
-    /// returns adjoint of "this", i.e. the transpose of the cofactor of "this" 
+    /// returns adjoint of "this", i.e. the transpose of the cofactor of "this"
     Mat3 adjoint() const
     {
         return Mat3<T>(
@@ -491,9 +501,9 @@
           MyBase::mm[3] * MyBase::mm[7] - MyBase::mm[4] * MyBase::mm[6],
           MyBase::mm[1] * MyBase::mm[6] - MyBase::mm[0] * MyBase::mm[7],
           MyBase::mm[0] * MyBase::mm[4] - MyBase::mm[1] * MyBase::mm[3]);
-        
+
     } // adjointTest
-    
+
     /// returns transpose of this
     Mat3 transpose() const
     {
@@ -577,23 +587,9 @@
         ret.mm[8] *= diag(2);
         return ret;
     }
-
-private:
-    static const Mat3<T> sIdentity;
-    static const Mat3<T> sZero;
 }; // class Mat3
 
 
-template <typename T>
-const Mat3<T> Mat3<T>::sIdentity = Mat3<T>(1, 0, 0,
-                                           0, 1, 0,
-                                           0, 0, 1);
-
-template <typename T>
-const Mat3<T> Mat3<T>::sZero = Mat3<T>(0, 0, 0,
-                                       0, 0, 0,
-                                       0, 0, 0);
-
 /// @relates Mat3
 /// @brief Equality operator, does exact floating point comparisons
 template <typename T0, typename T1>
@@ -703,19 +699,14 @@
 template <typename T>
 Mat3<T> outerProduct(const Vec3<T>& v1, const Vec3<T>& v2)
 {
-    return Mat3<T>(v1[0]*v2[0], v1[0]*v2[1], v1[0]*v2[2], 
-                   v1[1]*v2[0], v1[1]*v2[1], v1[1]*v2[2], 
+    return Mat3<T>(v1[0]*v2[0], v1[0]*v2[1], v1[0]*v2[2],
+                   v1[1]*v2[0], v1[1]*v2[1], v1[1]*v2[2],
                    v1[2]*v2[0], v1[2]*v2[1], v1[2]*v2[2]);
 }// outerProduct
 
 typedef Mat3<float>  Mat3s;
 typedef Mat3<double> Mat3d;
-
-#if DWREAL_IS_DOUBLE == 1
-typedef Mat3d    Mat3f;
-#else
-typedef Mat3s    Mat3f;
-#endif // DWREAL_IS_DOUBLE
+typedef Mat3d        Mat3f;
 
 
 /// Interpolate the rotation between m1 and m2 using Mat::powSolve.
diff -aur openvdb.3.2.0/math/Mat4.h openvdb.4.0.0/math/Mat4.h
--- openvdb.3.2.0/math/Mat4.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/math/Mat4.h	2016-10-09 10:18:58.000000000 +0200
@@ -150,11 +150,23 @@
 
     /// Predefined constant for identity matrix
     static const Mat4<T>& identity() {
+        static const Mat4<T> sIdentity = Mat4<T>(
+            1, 0, 0, 0,
+            0, 1, 0, 0,
+            0, 0, 1, 0,
+            0, 0, 0, 1
+        );
         return sIdentity;
     }
 
     /// Predefined constant for zero matrix
     static const Mat4<T>& zero() {
+        static const Mat4<T> sZero = Mat4<T>(
+            0, 0, 0, 0,
+            0, 0, 0, 0,
+            0, 0, 0, 0,
+            0, 0, 0, 0
+        );
         return sZero;
     }
 
@@ -1133,24 +1145,9 @@
             a.mm[i0row+j1]*det2(a, i1,i2, j2,j0) +
             a.mm[i0row+j2]*det2(a, i1,i2, j0,j1);
     }
-
-    static const Mat4<T> sIdentity;
-    static const Mat4<T> sZero;
 }; // class Mat4
 
 
-template <typename T>
-const Mat4<T> Mat4<T>::sIdentity = Mat4<T>(1, 0, 0, 0,
-                                           0, 1, 0, 0,
-                                           0, 0, 1, 0,
-                                           0, 0, 0, 1);
-
-template <typename T>
-const Mat4<T> Mat4<T>::sZero = Mat4<T>(0, 0, 0, 0,
-                                       0, 0, 0, 0,
-                                       0, 0, 0, 0,
-                                       0, 0, 0, 0);
-
 /// @relates Mat4
 /// @brief Equality operator, does exact floating point comparisons
 template <typename T0, typename T1>
@@ -1375,12 +1372,7 @@
 
 typedef Mat4<float>  Mat4s;
 typedef Mat4<double> Mat4d;
-
-#if DWREAL_IS_DOUBLE == 1
-typedef Mat4d    Mat4f;
-#else
-typedef Mat4s    Mat4f;
-#endif // DWREAL_IS_DOUBLE
+typedef Mat4d        Mat4f;
 
 } // namespace math
 
diff -aur openvdb.3.2.0/math/Mat.h openvdb.4.0.0/math/Mat.h
--- openvdb.3.2.0/math/Mat.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/math/Mat.h	2016-10-09 10:18:58.000000000 +0200
@@ -72,6 +72,15 @@
         }
     }
 
+    Mat& operator=(Mat const& src) {
+        if (&src != this) {
+            for (unsigned i = 0; i < numElements(); ++i) {
+                mm[i] = src.mm[i];
+            }
+        }
+        return *this;
+    }
+
     /// @return string representation of matrix
     /// Since output is multiline, optional indentation argument prefixes
     /// each newline with that much white space. It does not indent
@@ -136,6 +145,13 @@
         is.read(reinterpret_cast<char*>(&mm), sizeof(T)*SIZE*SIZE);
     }
 
+    /// Return the maximum of the absolute of all elements in this matrix
+    T absMax() const {
+        T x = static_cast<T>(std::fabs(mm[0]));
+        for (int i = 1; i < SIZE*SIZE; ++i)
+            x = std::max(x, static_cast<T>(std::fabs(mm[i])));
+        return x;
+    }
 
 protected:
     T mm[SIZE*SIZE];
@@ -771,94 +787,65 @@
 
 /// @brief Solve for A=B*B, given A.
 /// @details Denman-Beavers square root iteration
-template <typename MatType>
+template<typename MatType>
 inline void
-sqrtSolve(const MatType &aA, MatType &aB, double aTol=0.01)
+sqrtSolve(const MatType& aA, MatType& aB, double aTol=0.01)
 {
-    unsigned int iterations = (unsigned int)(log(aTol)/log(0.5));
-    MatType Y[2];
-    MatType Z[2];
-    MatType invY;
-    MatType invZ;
+    unsigned int iterations = static_cast<unsigned int>(log(aTol)/log(0.5));
 
-    unsigned int current = 0;
-
-    Y[0]=aA;
+    MatType Y[2], Z[2];
+    Y[0] = aA;
     Z[0] = MatType::identity();
 
-    unsigned int iteration;
-    for (iteration=0; iteration<iterations; iteration++)
-    {
+    unsigned int current = 0;
+    for (unsigned int iteration=0; iteration < iterations; iteration++) {
         unsigned int last = current;
         current = !current;
 
-        invY = Y[last].inverse();
-        invZ = Z[last].inverse();
+        MatType invY = Y[last].inverse();
+        MatType invZ = Z[last].inverse();
 
-        Y[current]=0.5*(Y[last]+invZ);
-        Z[current]=0.5*(Z[last]+invY);
+        Y[current] = 0.5 * (Y[last] + invZ);
+        Z[current] = 0.5 * (Z[last] + invY);
     }
-
-    MatType &R = Y[current];
-
-    aB=R;
+    aB = Y[current];
 }
 
 
-template <typename MatType>
+template<typename MatType>
 inline void
-powSolve(const MatType &aA, MatType &aB, double aPower, double aTol=0.01)
+powSolve(const MatType& aA, MatType& aB, double aPower, double aTol=0.01)
 {
-    unsigned int iterations = (unsigned int)(log(aTol)/log(0.5));
+    unsigned int iterations = static_cast<unsigned int>(log(aTol)/log(0.5));
 
-    const bool inverted = ( aPower < 0.0 );
+    const bool inverted = (aPower < 0.0);
+    if (inverted) { aPower = -aPower; }
 
-    if (inverted) {
-        aPower = -aPower;
-    }
-
-    unsigned int whole = (unsigned int)aPower;
+    unsigned int whole = static_cast<unsigned int>(aPower);
     double fraction = aPower - whole;
 
-    MatType R;
-    R = MatType::identity();
-
+    MatType R = MatType::identity();
     MatType partial = aA;
 
     double contribution = 1.0;
-
-    unsigned int iteration;
-
-    for (iteration=0; iteration< iterations; iteration++)
-    {
+    for (unsigned int iteration = 0; iteration < iterations; iteration++) {
         sqrtSolve(partial, partial, aTol);
         contribution *= 0.5;
-
-        if (fraction>=contribution)
-        {
+        if (fraction >= contribution) {
             R *= partial;
-            fraction-=contribution;
+            fraction -= contribution;
         }
     }
 
     partial = aA;
-    while (whole)
-    {
-        if (whole & 1) {
-            R *= partial;
-        }
-        whole>>=1;
-        if(whole) {
-            partial*=partial;
-        }
+    while (whole) {
+        if (whole & 1) { R *= partial; }
+        whole >>= 1;
+        if (whole) { partial *= partial; }
     }
 
-    if (inverted) {
-        aB = R.inverse();
-    }
-    else {
-        aB = R;
-    }
+    if (inverted) { aB = R.inverse(); }
+    else { aB = R; }
 }
 
 
@@ -876,8 +863,8 @@
 inline bool
 isInvertible(const MatType& m)
 {
-    typedef typename MatType::ValueType  value_type;
-    return !isApproxEqual(m.det(), (value_type)0);
+    typedef typename MatType::ValueType ValueType;
+    return !isApproxEqual(m.det(), ValueType(0));
 }
 
 
diff -aur openvdb.3.2.0/math/Operators.h openvdb.4.0.0/math/Operators.h
--- openvdb.3.2.0/math/Operators.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/math/Operators.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,8 +27,8 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
-/// @file Operators.h
+
+/// @file math/Operators.h
 
 #ifndef OPENVDB_MATH_OPERATORS_HAS_BEEN_INCLUDED
 #define OPENVDB_MATH_OPERATORS_HAS_BEEN_INCLUDED
@@ -107,8 +107,8 @@
 // This additional layer is necessary for Visual C++ to compile.
 template<typename T>
 struct ReturnValue {
-    typedef typename T::ValueType ValueType;
-    typedef math::Vec3<ValueType> Vec3Type;
+    using ValueType = typename T::ValueType;
+    using Vec3Type = math::Vec3<ValueType>;
 };
 
 } // namespace internal
@@ -125,8 +125,8 @@
     template<typename Accessor> static Vec3<typename Accessor::ValueType>
     result(const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueType;
-        typedef Vec3<ValueType>              Vec3Type;
+        using ValueType = typename Accessor::ValueType;
+        using Vec3Type = Vec3<ValueType>;
         return Vec3Type( D1<DiffScheme>::inX(grid, ijk),
                          D1<DiffScheme>::inY(grid, ijk),
                          D1<DiffScheme>::inZ(grid, ijk) );
@@ -136,8 +136,8 @@
     template<typename StencilT> static Vec3<typename StencilT::ValueType>
     result(const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType  ValueType;
-        typedef Vec3<ValueType>               Vec3Type;
+        using ValueType = typename StencilT::ValueType;
+        using Vec3Type = Vec3<ValueType>;
         return Vec3Type( D1<DiffScheme>::inX(stencil),
                          D1<DiffScheme>::inY(stencil),
                          D1<DiffScheme>::inZ(stencil) );
@@ -155,7 +155,7 @@
 
     template<typename GridType, bool IsSafe = true>
     struct ISStencil {
-        typedef SevenPointStencil<GridType, IsSafe>  StencilType;
+        using StencilType = SevenPointStencil<GridType, IsSafe>;
     };
 };
 
@@ -166,7 +166,7 @@
 
     template<typename GridType, bool IsSafe = true>
     struct ISStencil {
-        typedef SevenPointStencil<GridType, IsSafe>  StencilType;
+        using StencilType = SevenPointStencil<GridType, IsSafe>;
     };
 };
 
@@ -177,7 +177,7 @@
 
     template<typename GridType, bool IsSafe = true>
     struct ISStencil {
-        typedef ThirteenPointStencil<GridType, IsSafe>  StencilType;
+        using StencilType = ThirteenPointStencil<GridType, IsSafe>;
       };
 };
 template<> struct BIAS_SCHEME<THIRD_BIAS>
@@ -187,7 +187,7 @@
 
     template<typename GridType, bool IsSafe = true>
     struct ISStencil {
-        typedef NineteenPointStencil<GridType, IsSafe>  StencilType;
+        using StencilType = NineteenPointStencil<GridType, IsSafe>;
     };
 };
 template<> struct BIAS_SCHEME<WENO5_BIAS>
@@ -197,7 +197,7 @@
 
     template<typename GridType, bool IsSafe = true>
     struct ISStencil {
-        typedef NineteenPointStencil<GridType, IsSafe>  StencilType;
+        using StencilType = NineteenPointStencil<GridType, IsSafe>;
     };
 };
 template<> struct BIAS_SCHEME<HJWENO5_BIAS>
@@ -207,7 +207,7 @@
 
     template<typename GridType, bool IsSafe = true>
     struct ISStencil {
-        typedef NineteenPointStencil<GridType, IsSafe>  StencilType;
+        using StencilType = NineteenPointStencil<GridType, IsSafe>;
     };
 };
 
@@ -226,8 +226,8 @@
     static Vec3<typename Accessor::ValueType>
     result(const Accessor& grid, const Coord& ijk, const Vec3Bias& V)
     {
-        typedef typename Accessor::ValueType ValueType;
-        typedef Vec3<ValueType>              Vec3Type;
+        using ValueType = typename Accessor::ValueType;
+        using Vec3Type = Vec3<ValueType>;
 
         return Vec3Type(V[0]<0 ? D1<FD>::inX(grid,ijk) : D1<BD>::inX(grid,ijk),
                         V[1]<0 ? D1<FD>::inY(grid,ijk) : D1<BD>::inY(grid,ijk),
@@ -239,8 +239,8 @@
     static Vec3<typename StencilT::ValueType>
     result(const StencilT& stencil, const Vec3Bias& V)
     {
-        typedef typename StencilT::ValueType  ValueType;
-        typedef Vec3<ValueType>               Vec3Type;
+        using ValueType = typename StencilT::ValueType;
+        using Vec3Type = Vec3<ValueType>;
 
         return Vec3Type(V[0]<0 ? D1<FD>::inX(stencil) : D1<BD>::inX(stencil),
                         V[1]<0 ? D1<FD>::inY(stencil) : D1<BD>::inY(stencil),
@@ -261,8 +261,8 @@
     static typename Accessor::ValueType
     result(const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType     ValueType;
-        typedef math::Vec3<ValueType>            Vec3Type;
+        using ValueType = typename Accessor::ValueType;
+        using Vec3Type = math::Vec3<ValueType>;
 
         Vec3Type up   = ISGradient<FD>::result(grid, ijk);
         Vec3Type down = ISGradient<BD>::result(grid, ijk);
@@ -274,8 +274,8 @@
     static typename StencilT::ValueType
     result(const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType     ValueType;
-        typedef math::Vec3<ValueType>            Vec3Type;
+        using ValueType = typename StencilT::ValueType;
+        using Vec3Type = math::Vec3<ValueType>;
 
         Vec3Type up   = ISGradient<FD>::result(stencil);
         Vec3Type down = ISGradient<BD>::result(stencil);
@@ -324,7 +324,7 @@
                valueAt(ijk.offsetBy( 0, 0, 3)) - valueAt(ijk.offsetBy( 0, 0, 2)), 0),
             down = math::WENO5(v1, v2, v3, v4, v5),
             up   = math::WENO5(v6, v5, v4, v3, v2);
-        
+
         return math::GodunovsNormSqrd(grid.getValue(ijk)>0, down, up);
     }
 
@@ -332,7 +332,7 @@
     template<typename StencilT>
     static typename StencilT::ValueType result(const StencilT& s)
     {
-        typedef simd::Float4::value_type F4Val;
+        using F4Val = simd::Float4::value_type;
 
         // SSE optimized
         const simd::Float4
@@ -410,7 +410,7 @@
     template<typename Accessor>
     static typename Accessor::ValueType result(const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueT;
+        using ValueT = typename Accessor::ValueType;
         return static_cast<ValueT>(
             (-1./12.)*(
                 grid.getValue(ijk.offsetBy(2,0,0)) + grid.getValue(ijk.offsetBy(-2, 0, 0)) +
@@ -427,7 +427,7 @@
     template<typename StencilT>
     static typename StencilT::ValueType result(const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType ValueT;
+        using ValueT = typename StencilT::ValueType;
         return static_cast<ValueT>(
             (-1./12.)*(
                 stencil.template getValue< 2, 0, 0>() + stencil.template getValue<-2, 0, 0>() +
@@ -448,7 +448,7 @@
     template<typename Accessor>
     static typename Accessor::ValueType result(const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueT;
+        using ValueT = typename Accessor::ValueType;
         return static_cast<ValueT>(
             (1./90.)*(
                 grid.getValue(ijk.offsetBy(3,0,0)) + grid.getValue(ijk.offsetBy(-3, 0, 0)) +
@@ -469,7 +469,7 @@
     template<typename StencilT>
     static typename StencilT::ValueType result(const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType ValueT;
+        using ValueT = typename StencilT::ValueType;
         return static_cast<ValueT>(
             (1./90.)*(
                 stencil.template getValue< 3, 0, 0>() + stencil.template getValue<-3, 0, 0>() +
@@ -524,7 +524,7 @@
     template<typename Accessor>
     static typename Accessor::ValueType result(const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType Vec3Type;
+        using Vec3Type = typename Accessor::ValueType;
         return Vec3Type( D1Vec<DiffScheme>::inY(grid, ijk, 2) - //dw/dy - dv/dz
                          D1Vec<DiffScheme>::inZ(grid, ijk, 1),
                          D1Vec<DiffScheme>::inZ(grid, ijk, 0) - //du/dz - dw/dx
@@ -537,7 +537,7 @@
     template<typename StencilT>
     static typename StencilT::ValueType result(const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType Vec3Type;
+        using Vec3Type = typename StencilT::ValueType;
         return Vec3Type( D1Vec<DiffScheme>::inY(stencil, 2) - //dw/dy - dv/dz
                          D1Vec<DiffScheme>::inZ(stencil, 1),
                          D1Vec<DiffScheme>::inZ(stencil, 0) - //du/dz - dw/dx
@@ -563,7 +563,7 @@
                        typename Accessor::ValueType& alpha,
                        typename Accessor::ValueType& beta)
     {
-        typedef typename Accessor::ValueType ValueType;
+        using ValueType = typename Accessor::ValueType;
 
         const ValueType Dx = D1<DiffScheme1>::inX(grid, ijk);
         const ValueType Dy = D1<DiffScheme1>::inY(grid, ijk);
@@ -601,7 +601,7 @@
                        typename StencilT::ValueType& alpha,
                        typename StencilT::ValueType& beta)
     {
-        typedef typename StencilT::ValueType   ValueType;
+        using ValueType = typename StencilT::ValueType;
         const ValueType Dx = D1<DiffScheme1>::inX(stencil);
         const ValueType Dy = D1<DiffScheme1>::inY(stencil);
         const ValueType Dz = D1<DiffScheme1>::inZ(stencil);
@@ -646,7 +646,7 @@
     static typename internal::ReturnValue<Accessor>::Vec3Type
     result(const MapType& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename internal::ReturnValue<Accessor>::Vec3Type Vec3Type;
+        using Vec3Type = typename internal::ReturnValue<Accessor>::Vec3Type;
 
         Vec3d iGradient( ISGradient<DiffScheme>::result(grid, ijk) );
         return Vec3Type(map.applyIJT(iGradient, ijk.asVec3d()));
@@ -657,7 +657,7 @@
     static typename internal::ReturnValue<StencilT>::Vec3Type
     result(const MapType& map, const StencilT& stencil)
     {
-        typedef typename internal::ReturnValue<StencilT>::Vec3Type Vec3Type;
+        using Vec3Type = typename internal::ReturnValue<StencilT>::Vec3Type;
 
         Vec3d iGradient( ISGradient<DiffScheme>::result(stencil) );
         return Vec3Type(map.applyIJT(iGradient, stencil.getCenterCoord().asVec3d()));
@@ -696,8 +696,8 @@
     static typename internal::ReturnValue<Accessor>::Vec3Type
     result(const UniformScaleMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename internal::ReturnValue<Accessor>::ValueType ValueType;
-        typedef typename internal::ReturnValue<Accessor>::Vec3Type Vec3Type;
+        using ValueType = typename internal::ReturnValue<Accessor>::ValueType;
+        using Vec3Type = typename internal::ReturnValue<Accessor>::Vec3Type;
 
         Vec3Type iGradient( ISGradient<CD_2NDT>::result(grid, ijk) );
         ValueType inv2dx = ValueType(map.getInvTwiceScale()[0]);
@@ -709,8 +709,8 @@
     static typename internal::ReturnValue<StencilT>::Vec3Type
     result(const UniformScaleMap& map, const StencilT& stencil)
     {
-        typedef typename internal::ReturnValue<StencilT>::ValueType ValueType;
-        typedef typename internal::ReturnValue<StencilT>::Vec3Type Vec3Type;
+        using ValueType = typename internal::ReturnValue<StencilT>::ValueType;
+        using Vec3Type = typename internal::ReturnValue<StencilT>::Vec3Type;
 
         Vec3Type iGradient( ISGradient<CD_2NDT>::result(stencil) );
         ValueType inv2dx = ValueType(map.getInvTwiceScale()[0]);
@@ -728,8 +728,8 @@
     static typename internal::ReturnValue<Accessor>::Vec3Type
     result(const UniformScaleTranslateMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename internal::ReturnValue<Accessor>::ValueType ValueType;
-        typedef typename internal::ReturnValue<Accessor>::Vec3Type Vec3Type;
+        using ValueType = typename internal::ReturnValue<Accessor>::ValueType;
+        using Vec3Type = typename internal::ReturnValue<Accessor>::Vec3Type;
 
         Vec3Type iGradient( ISGradient<CD_2NDT>::result(grid, ijk) );
         ValueType inv2dx = ValueType(map.getInvTwiceScale()[0]);
@@ -741,8 +741,8 @@
     static typename internal::ReturnValue<StencilT>::Vec3Type
     result(const UniformScaleTranslateMap& map, const StencilT& stencil)
     {
-        typedef typename internal::ReturnValue<StencilT>::ValueType ValueType;
-        typedef typename internal::ReturnValue<StencilT>::Vec3Type Vec3Type;
+        using ValueType = typename internal::ReturnValue<StencilT>::ValueType;
+        using Vec3Type = typename internal::ReturnValue<StencilT>::Vec3Type;
 
         Vec3Type iGradient( ISGradient<CD_2NDT>::result(stencil) );
         ValueType inv2dx = ValueType(map.getInvTwiceScale()[0]);
@@ -760,8 +760,8 @@
     static typename internal::ReturnValue<Accessor>::Vec3Type
     result(const ScaleMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename internal::ReturnValue<Accessor>::ValueType ValueType;
-        typedef typename internal::ReturnValue<Accessor>::Vec3Type Vec3Type;
+        using ValueType = typename internal::ReturnValue<Accessor>::ValueType;
+        using Vec3Type = typename internal::ReturnValue<Accessor>::Vec3Type;
 
         Vec3Type iGradient( ISGradient<CD_2NDT>::result(grid, ijk) );
         return  Vec3Type(ValueType(iGradient[0] * map.getInvTwiceScale()[0]),
@@ -774,8 +774,8 @@
     static typename internal::ReturnValue<StencilT>::Vec3Type
     result(const ScaleMap& map, const StencilT& stencil)
     {
-        typedef typename internal::ReturnValue<StencilT>::ValueType ValueType;
-        typedef typename internal::ReturnValue<StencilT>::Vec3Type Vec3Type;
+        using ValueType = typename internal::ReturnValue<StencilT>::ValueType;
+        using Vec3Type = typename internal::ReturnValue<StencilT>::Vec3Type;
 
         Vec3Type iGradient( ISGradient<CD_2NDT>::result(stencil) );
         return  Vec3Type(ValueType(iGradient[0] * map.getInvTwiceScale()[0]),
@@ -794,8 +794,8 @@
     static typename internal::ReturnValue<Accessor>::Vec3Type
     result(const ScaleTranslateMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename internal::ReturnValue<Accessor>::ValueType ValueType;
-        typedef typename internal::ReturnValue<Accessor>::Vec3Type Vec3Type;
+        using ValueType = typename internal::ReturnValue<Accessor>::ValueType;
+        using Vec3Type = typename internal::ReturnValue<Accessor>::Vec3Type;
 
         Vec3Type iGradient( ISGradient<CD_2NDT>::result(grid, ijk) );
         return  Vec3Type(ValueType(iGradient[0] * map.getInvTwiceScale()[0]),
@@ -808,8 +808,8 @@
     static typename internal::ReturnValue<StencilT>::Vec3Type
     result(const ScaleTranslateMap& map, const StencilT& stencil)
     {
-        typedef typename internal::ReturnValue<StencilT>::ValueType ValueType;
-        typedef typename internal::ReturnValue<StencilT>::Vec3Type Vec3Type;
+        using ValueType = typename internal::ReturnValue<StencilT>::ValueType;
+        using Vec3Type = typename internal::ReturnValue<StencilT>::Vec3Type;
 
         Vec3Type iGradient( ISGradient<CD_2NDT>::result(stencil) );
         return  Vec3Type(ValueType(iGradient[0] * map.getInvTwiceScale()[0]),
@@ -831,8 +831,8 @@
     result(const MapType& map, const Accessor& grid, const Coord& ijk,
            const Vec3<typename Accessor::ValueType>& V)
     {
-        typedef typename Accessor::ValueType     ValueType;
-        typedef math::Vec3<ValueType>            Vec3Type;
+        using ValueType = typename Accessor::ValueType;
+        using Vec3Type = math::Vec3<ValueType>;
 
         Vec3d iGradient( ISGradientBiased<GradScheme, Vec3Type>::result(grid, ijk, V) );
         return Vec3Type(map.applyIJT(iGradient, ijk.asVec3d()));
@@ -843,8 +843,8 @@
     result(const MapType& map, const StencilT& stencil,
            const Vec3<typename StencilT::ValueType>& V)
     {
-        typedef typename StencilT::ValueType      ValueType;
-        typedef math::Vec3<ValueType>            Vec3Type;
+        using ValueType = typename StencilT::ValueType;
+        using Vec3Type = math::Vec3<ValueType>;
 
         Vec3d iGradient( ISGradientBiased<GradScheme, Vec3Type>::result(stencil, V) );
         return Vec3Type(map.applyIJT(iGradient, stencil.getCenterCoord().asVec3d()));
@@ -868,8 +868,8 @@
     static typename Accessor::ValueType
     result(const MapType& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType     ValueType;
-        typedef math::Vec3<ValueType>            Vec3Type;
+        using ValueType = typename Accessor::ValueType;
+        using Vec3Type = math::Vec3<ValueType>;
 
         Vec3Type up   = Gradient<MapType, FD>::result(map, grid, ijk);
         Vec3Type down = Gradient<MapType, BD>::result(map, grid, ijk);
@@ -881,8 +881,8 @@
     static typename StencilT::ValueType
     result(const MapType& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType     ValueType;
-        typedef math::Vec3<ValueType>            Vec3Type;
+        using ValueType = typename StencilT::ValueType;
+        using Vec3Type = math::Vec3<ValueType>;
 
         Vec3Type up   = Gradient<MapType, FD>::result(map, stencil);
         Vec3Type down = Gradient<MapType, BD>::result(map, stencil);
@@ -899,7 +899,7 @@
     static typename Accessor::ValueType
     result(const UniformScaleMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType     ValueType;
+        using ValueType = typename Accessor::ValueType;
 
         ValueType invdxdx = ValueType(map.getInvScaleSqr()[0]);
         return invdxdx * ISGradientNormSqrd<GradScheme>::result(grid, ijk);
@@ -910,7 +910,7 @@
     static typename StencilT::ValueType
     result(const UniformScaleMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType      ValueType;
+        using ValueType = typename StencilT::ValueType;
 
         ValueType invdxdx = ValueType(map.getInvScaleSqr()[0]);
         return invdxdx * ISGradientNormSqrd<GradScheme>::result(stencil);
@@ -926,7 +926,7 @@
     static typename Accessor::ValueType
     result(const UniformScaleTranslateMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType     ValueType;
+        using ValueType = typename Accessor::ValueType;
 
         ValueType invdxdx = ValueType(map.getInvScaleSqr()[0]);
         return invdxdx * ISGradientNormSqrd<GradScheme>::result(grid, ijk);
@@ -937,7 +937,7 @@
     static typename StencilT::ValueType
     result(const UniformScaleTranslateMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType      ValueType;
+        using ValueType = typename StencilT::ValueType;
 
         ValueType invdxdx = ValueType(map.getInvScaleSqr()[0]);
         return invdxdx * ISGradientNormSqrd<GradScheme>::result(stencil);
@@ -955,7 +955,7 @@
     template<typename Accessor> static typename Accessor::ValueType::value_type
     result(const MapType& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType::value_type ValueType;
+        using ValueType = typename Accessor::ValueType::value_type;
 
         ValueType div(0);
         for (int i=0; i < 3; i++) {
@@ -971,7 +971,7 @@
     template<typename StencilT> static typename StencilT::ValueType::value_type
     result(const MapType& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType::value_type ValueType;
+        using ValueType = typename StencilT::ValueType::value_type;
 
         ValueType div(0);
         for (int i=0; i < 3; i++) {
@@ -993,7 +993,7 @@
     template<typename Accessor> static typename Accessor::ValueType::value_type
     result(const TranslationMap&, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType::value_type ValueType;
+        using ValueType = typename Accessor::ValueType::value_type;
 
         ValueType div(0);
         div =ISDivergence<DiffScheme>::result(grid, ijk);
@@ -1004,7 +1004,7 @@
     template<typename StencilT> static typename StencilT::ValueType::value_type
     result(const TranslationMap&, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType::value_type ValueType;
+        using ValueType = typename StencilT::ValueType::value_type;
 
         ValueType div(0);
         div =ISDivergence<DiffScheme>::result(stencil);
@@ -1021,7 +1021,7 @@
     template<typename Accessor> static typename Accessor::ValueType::value_type
     result(const UniformScaleMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType::value_type ValueType;
+        using ValueType = typename Accessor::ValueType::value_type;
 
         ValueType div(0);
 
@@ -1034,7 +1034,7 @@
     template<typename StencilT> static typename StencilT::ValueType::value_type
     result(const UniformScaleMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType::value_type ValueType;
+        using ValueType = typename StencilT::ValueType::value_type;
 
         ValueType div(0);
 
@@ -1053,7 +1053,7 @@
     template<typename Accessor> static typename Accessor::ValueType::value_type
     result(const UniformScaleTranslateMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType::value_type ValueType;
+        using ValueType = typename Accessor::ValueType::value_type;
 
         ValueType div(0);
 
@@ -1066,7 +1066,7 @@
     template<typename StencilT> static typename StencilT::ValueType::value_type
     result(const UniformScaleTranslateMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType::value_type ValueType;
+        using ValueType = typename StencilT::ValueType::value_type;
 
         ValueType div(0);
 
@@ -1085,7 +1085,7 @@
     template<typename Accessor> static typename Accessor::ValueType::value_type
     result(const UniformScaleMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType::value_type ValueType;
+        using ValueType = typename Accessor::ValueType::value_type;
 
         ValueType div(0);
         div =ISDivergence<CD_2NDT>::result(grid, ijk);
@@ -1097,7 +1097,7 @@
     template<typename StencilT> static typename StencilT::ValueType::value_type
     result(const UniformScaleMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType::value_type ValueType;
+        using ValueType = typename StencilT::ValueType::value_type;
 
         ValueType div(0);
         div =ISDivergence<CD_2NDT>::result(stencil);
@@ -1115,7 +1115,7 @@
     template<typename Accessor> static typename Accessor::ValueType::value_type
     result(const UniformScaleTranslateMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType::value_type ValueType;
+        using ValueType = typename Accessor::ValueType::value_type;
 
         ValueType div(0);
 
@@ -1128,7 +1128,7 @@
     template<typename StencilT> static typename StencilT::ValueType::value_type
     result(const UniformScaleTranslateMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType::value_type ValueType;
+        using ValueType = typename StencilT::ValueType::value_type;
 
         ValueType div(0);
 
@@ -1147,7 +1147,7 @@
     template<typename Accessor> static typename Accessor::ValueType::value_type
     result(const ScaleMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType::value_type ValueType;
+        using ValueType = typename Accessor::ValueType::value_type;
 
         ValueType div = ValueType(
             D1Vec<DiffScheme>::inX(grid, ijk, 0) * (map.getInvScale()[0]) +
@@ -1160,7 +1160,7 @@
     template<typename StencilT> static typename StencilT::ValueType::value_type
     result(const ScaleMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType::value_type ValueType;
+        using ValueType = typename StencilT::ValueType::value_type;
 
         ValueType div(0);
         div = ValueType(
@@ -1180,7 +1180,7 @@
     template<typename Accessor> static typename Accessor::ValueType::value_type
     result(const ScaleTranslateMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType::value_type ValueType;
+        using ValueType = typename Accessor::ValueType::value_type;
 
         ValueType div = ValueType(
             D1Vec<DiffScheme>::inX(grid, ijk, 0) * (map.getInvScale()[0]) +
@@ -1193,7 +1193,7 @@
     template<typename StencilT> static typename StencilT::ValueType::value_type
     result(const ScaleTranslateMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType::value_type ValueType;
+        using ValueType = typename StencilT::ValueType::value_type;
 
         ValueType div(0);
         div = ValueType(
@@ -1213,7 +1213,7 @@
     template<typename Accessor> static typename Accessor::ValueType::value_type
     result(const ScaleMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType::value_type ValueType;
+        using ValueType = typename Accessor::ValueType::value_type;
 
         ValueType div = ValueType(
             D1Vec<CD_2NDT>::inX(grid, ijk, 0) * (map.getInvTwiceScale()[0]) +
@@ -1226,7 +1226,7 @@
     template<typename StencilT> static typename StencilT::ValueType::value_type
     result(const ScaleMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType::value_type ValueType;
+        using ValueType = typename StencilT::ValueType::value_type;
 
         ValueType div = ValueType(
             D1Vec<CD_2NDT>::inX(stencil, 0) * (map.getInvTwiceScale()[0]) +
@@ -1245,7 +1245,7 @@
     template<typename Accessor> static typename Accessor::ValueType::value_type
     result(const ScaleTranslateMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType::value_type ValueType;
+        using ValueType = typename Accessor::ValueType::value_type;
 
         ValueType div = ValueType(
             D1Vec<CD_2NDT>::inX(grid, ijk, 0) * (map.getInvTwiceScale()[0]) +
@@ -1258,7 +1258,7 @@
     template<typename StencilT> static typename StencilT::ValueType::value_type
     result(const ScaleTranslateMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType::value_type ValueType;
+        using ValueType = typename StencilT::ValueType::value_type;
 
         ValueType div = ValueType(
             D1Vec<CD_2NDT>::inX(stencil, 0) * (map.getInvTwiceScale()[0]) +
@@ -1280,7 +1280,7 @@
     template<typename Accessor> static typename Accessor::ValueType
     result(const MapType& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType Vec3Type;
+        using Vec3Type = typename Accessor::ValueType;
         Vec3Type mat[3];
         for (int i = 0; i < 3; i++) {
             Vec3d vec(
@@ -1299,7 +1299,7 @@
     template<typename StencilT> static typename StencilT::ValueType
     result(const MapType& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType Vec3Type;
+        using Vec3Type = typename StencilT::ValueType;
         Vec3Type mat[3];
         for (int i = 0; i < 3; i++) {
             Vec3d vec(
@@ -1323,8 +1323,8 @@
     template<typename Accessor> static typename Accessor::ValueType
     result(const UniformScaleMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType  Vec3Type;
-        typedef typename Vec3Type::value_type ValueType;
+        using Vec3Type = typename Accessor::ValueType;
+        using ValueType = typename Vec3Type::value_type;
         return ISCurl<DiffScheme>::result(grid, ijk) * ValueType(map.getInvScale()[0]);
     }
 
@@ -1332,8 +1332,8 @@
     template<typename StencilT> static typename StencilT::ValueType
     result(const UniformScaleMap& map, const StencilT& stencil)
     {
-         typedef typename StencilT::ValueType  Vec3Type;
-         typedef typename Vec3Type::value_type ValueType;
+         using Vec3Type = typename StencilT::ValueType;
+         using ValueType = typename Vec3Type::value_type;
          return ISCurl<DiffScheme>::result(stencil) * ValueType(map.getInvScale()[0]);
      }
 };
@@ -1346,8 +1346,8 @@
     template<typename Accessor> static typename Accessor::ValueType
     result(const UniformScaleTranslateMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType  Vec3Type;
-        typedef typename Vec3Type::value_type ValueType;
+        using Vec3Type = typename Accessor::ValueType;
+        using ValueType = typename Vec3Type::value_type;
 
         return ISCurl<DiffScheme>::result(grid, ijk) * ValueType(map.getInvScale()[0]);
     }
@@ -1356,8 +1356,8 @@
     template<typename StencilT> static typename StencilT::ValueType
     result(const UniformScaleTranslateMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType  Vec3Type;
-        typedef typename Vec3Type::value_type ValueType;
+        using Vec3Type = typename StencilT::ValueType;
+        using ValueType = typename Vec3Type::value_type;
 
         return ISCurl<DiffScheme>::result(stencil) * ValueType(map.getInvScale()[0]);
     }
@@ -1371,8 +1371,8 @@
     template<typename Accessor> static typename Accessor::ValueType
     result(const UniformScaleMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType  Vec3Type;
-        typedef typename Vec3Type::value_type ValueType;
+        using Vec3Type = typename Accessor::ValueType;
+        using ValueType = typename Vec3Type::value_type;
 
         return ISCurl<CD_2NDT>::result(grid, ijk) * ValueType(map.getInvTwiceScale()[0]);
     }
@@ -1381,8 +1381,8 @@
     template<typename StencilT> static typename StencilT::ValueType
     result(const UniformScaleMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType  Vec3Type;
-        typedef typename Vec3Type::value_type ValueType;
+        using Vec3Type = typename StencilT::ValueType;
+        using ValueType = typename Vec3Type::value_type;
 
         return ISCurl<CD_2NDT>::result(stencil) * ValueType(map.getInvTwiceScale()[0]);
     }
@@ -1396,8 +1396,8 @@
     template<typename Accessor> static typename Accessor::ValueType
     result(const UniformScaleTranslateMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType  Vec3Type;
-        typedef typename Vec3Type::value_type ValueType;
+        using Vec3Type = typename Accessor::ValueType;
+        using ValueType = typename Vec3Type::value_type;
 
         return ISCurl<CD_2NDT>::result(grid, ijk) * ValueType(map.getInvTwiceScale()[0]);
     }
@@ -1406,8 +1406,8 @@
     template<typename StencilT> static typename StencilT::ValueType
     result(const UniformScaleTranslateMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType  Vec3Type;
-        typedef typename Vec3Type::value_type ValueType;
+        using Vec3Type = typename StencilT::ValueType;
+        using ValueType = typename Vec3Type::value_type;
 
         return ISCurl<CD_2NDT>::result(stencil) * ValueType(map.getInvTwiceScale()[0]);
     }
@@ -1426,7 +1426,7 @@
     static typename Accessor::ValueType result(const MapType& map,
         const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueType;
+        using ValueType = typename Accessor::ValueType;
         // all the second derivatives in index space
         ValueType iddx  = D2<DiffScheme>::inX(grid, ijk);
         ValueType iddy  = D2<DiffScheme>::inY(grid, ijk);
@@ -1461,7 +1461,7 @@
     template<typename StencilT>
     static typename StencilT::ValueType result(const MapType& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType ValueType;
+        using ValueType = typename StencilT::ValueType;
         // all the second derivatives in index space
         ValueType iddx  = D2<DiffScheme>::inX(stencil);
         ValueType iddy  = D2<DiffScheme>::inY(stencil);
@@ -1542,7 +1542,7 @@
     template<typename Accessor> static typename Accessor::ValueType
     result(const UniformScaleMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueType;
+        using ValueType = typename Accessor::ValueType;
         ValueType invdxdx = ValueType(map.getInvScaleSqr()[0]);
         return ISLaplacian<DiffScheme>::result(grid, ijk) * invdxdx;
     }
@@ -1551,7 +1551,7 @@
     template<typename StencilT> static typename StencilT::ValueType
     result(const UniformScaleMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType ValueType;
+        using ValueType = typename StencilT::ValueType;
         ValueType invdxdx = ValueType(map.getInvScaleSqr()[0]);
         return ISLaplacian<DiffScheme>::result(stencil) * invdxdx;
     }
@@ -1565,7 +1565,7 @@
     template<typename Accessor> static typename Accessor::ValueType
     result(const UniformScaleTranslateMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueType;
+        using ValueType = typename Accessor::ValueType;
         ValueType invdxdx = ValueType(map.getInvScaleSqr()[0]);
         return ISLaplacian<DiffScheme>::result(grid, ijk) * invdxdx;
     }
@@ -1574,7 +1574,7 @@
     template<typename StencilT> static typename StencilT::ValueType
     result(const UniformScaleTranslateMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType ValueType;
+        using ValueType = typename StencilT::ValueType;
         ValueType invdxdx = ValueType(map.getInvScaleSqr()[0]);
         return ISLaplacian<DiffScheme>::result(stencil) * invdxdx;
     }
@@ -1588,7 +1588,7 @@
     template<typename Accessor> static typename Accessor::ValueType
     result(const ScaleMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueType;
+        using ValueType = typename Accessor::ValueType;
 
         // compute the second derivatives in index space
         ValueType iddx = D2<DiffScheme>::inX(grid, ijk);
@@ -1603,7 +1603,7 @@
     template<typename StencilT> static typename StencilT::ValueType
     result(const ScaleMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType ValueType;
+        using ValueType = typename StencilT::ValueType;
 
         // compute the second derivatives in index space
         ValueType iddx = D2<DiffScheme>::inX(stencil);
@@ -1623,7 +1623,7 @@
     template<typename Accessor> static typename Accessor::ValueType
     result(const ScaleTranslateMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueType;
+        using ValueType = typename Accessor::ValueType;
         // compute the second derivatives in index space
         ValueType iddx = D2<DiffScheme>::inX(grid, ijk);
         ValueType iddy = D2<DiffScheme>::inY(grid, ijk);
@@ -1637,7 +1637,7 @@
     template<typename StencilT> static typename StencilT::ValueType
     result(const ScaleTranslateMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType ValueType;
+        using ValueType = typename StencilT::ValueType;
         // compute the second derivatives in index space
         ValueType iddx = D2<DiffScheme>::inX(stencil);
         ValueType iddy = D2<DiffScheme>::inY(stencil);
@@ -1659,8 +1659,8 @@
     template<typename Accessor> static math::Vec3<typename Accessor::ValueType>
     result(const MapType& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueType;
-        typedef Vec3<ValueType>              Vec3Type;
+        using ValueType = typename Accessor::ValueType;
+        using Vec3Type = Vec3<ValueType>;
 
         // current distance
         ValueType d = grid.getValue(ijk);
@@ -1681,8 +1681,8 @@
     template<typename StencilT> static math::Vec3<typename StencilT::ValueType>
     result(const MapType& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType ValueType;
-        typedef Vec3<ValueType>              Vec3Type;
+        using ValueType = typename StencilT::ValueType;
+        using Vec3Type = Vec3<ValueType>;
 
         // current distance
         ValueType d = stencil.template getValue<0, 0, 0>();
@@ -1712,8 +1712,8 @@
     template<typename Accessor> static Vec3<typename Accessor::ValueType>
     result(const MapType& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueType;
-        typedef Vec3<ValueType>              Vec3Type;
+        using ValueType = typename Accessor::ValueType;
+        using Vec3Type = Vec3<ValueType>;
         // current distance
         ValueType d = grid.getValue(ijk);
         // compute gradient in physical space where it is a unit normal
@@ -1729,8 +1729,8 @@
     template<typename StencilT> static Vec3<typename StencilT::ValueType>
     result(const MapType& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType ValueType;
-        typedef Vec3<ValueType>              Vec3Type;
+        using ValueType = typename StencilT::ValueType;
+        using Vec3Type = Vec3<ValueType>;
         // current distance
         ValueType d = stencil.template getValue<0, 0, 0>();
         // compute gradient in physical space where it is a unit normal
@@ -1758,7 +1758,7 @@
     static bool compute(const MapType& map, const Accessor& grid, const Coord& ijk,
                         double& alpha, double& beta)
     {
-        typedef typename Accessor::ValueType ValueType;
+        using ValueType = typename Accessor::ValueType;
 
          // compute the gradient in index and world space
          Vec3d d1_is(static_cast<double>(D1<DiffScheme1>::inX(grid, ijk)),
@@ -1813,7 +1813,7 @@
     static typename Accessor::ValueType result(const MapType& map,
         const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueType;
+        using ValueType = typename Accessor::ValueType;
         double alpha, beta;
         return compute(map, grid, ijk, alpha, beta) ?
                ValueType(alpha/(2. *math::Pow3(beta))) : 0;
@@ -1823,7 +1823,7 @@
     static typename Accessor::ValueType normGrad(const MapType& map,
         const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueType;
+        using ValueType = typename Accessor::ValueType;
         double alpha, beta;
         return compute(map, grid, ijk, alpha, beta) ?
                ValueType(alpha/(2. *math::Pow2(beta))) : 0;
@@ -1837,7 +1837,7 @@
     static bool compute(const MapType& map, const StencilT& stencil,
                         double& alpha, double& beta)
     {
-        typedef typename StencilT::ValueType  ValueType;
+        using ValueType = typename StencilT::ValueType;
 
          // compute the gradient in index and world space
          Vec3d d1_is(D1<DiffScheme1>::inX(stencil),
@@ -1892,7 +1892,7 @@
     static typename StencilT::ValueType
     result(const MapType& map, const StencilT stencil)
     {
-        typedef typename StencilT::ValueType ValueType;
+        using ValueType = typename StencilT::ValueType;
         double alpha, beta;
         return compute(map, stencil, alpha, beta) ?
                ValueType(alpha/(2*math::Pow3(beta))) : 0;
@@ -1901,7 +1901,7 @@
     template<typename StencilT>
     static typename StencilT::ValueType normGrad(const MapType& map, const StencilT stencil)
     {
-        typedef typename StencilT::ValueType ValueType;
+        using ValueType = typename StencilT::ValueType;
         double alpha, beta;
         return compute(map, stencil, alpha, beta) ?
                ValueType(alpha/(2*math::Pow2(beta))) : 0;
@@ -1917,7 +1917,7 @@
     static typename Accessor::ValueType result(const TranslationMap&,
         const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueType;
+        using ValueType = typename Accessor::ValueType;
 
         ValueType alpha, beta;
         return ISMeanCurvature<DiffScheme2, DiffScheme1>::result(grid, ijk, alpha, beta) ?
@@ -1928,7 +1928,7 @@
     static typename Accessor::ValueType normGrad(const TranslationMap&,
         const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueType;
+        using ValueType = typename Accessor::ValueType;
 
         ValueType alpha, beta;
         return ISMeanCurvature<DiffScheme2, DiffScheme1>::result(grid, ijk, alpha, beta) ?
@@ -1939,7 +1939,7 @@
     template<typename StencilT>
     static typename StencilT::ValueType result(const TranslationMap&, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType ValueType;
+        using ValueType = typename StencilT::ValueType;
 
         ValueType alpha, beta;
         return ISMeanCurvature<DiffScheme2, DiffScheme1>::result(stencil, alpha, beta) ?
@@ -1949,7 +1949,7 @@
     template<typename StencilT>
     static typename StencilT::ValueType normGrad(const TranslationMap&, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType ValueType;
+        using ValueType = typename StencilT::ValueType;
 
         ValueType alpha, beta;
         return ISMeanCurvature<DiffScheme2, DiffScheme1>::result(stencil, alpha, beta) ?
@@ -1966,7 +1966,7 @@
     static typename Accessor::ValueType result(const UniformScaleMap& map,
         const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueType;
+        using ValueType = typename Accessor::ValueType;
 
         ValueType alpha, beta;
         if (ISMeanCurvature<DiffScheme2, DiffScheme1>::result(grid, ijk, alpha, beta)) {
@@ -1980,7 +1980,7 @@
     static typename Accessor::ValueType normGrad(const UniformScaleMap& map,
         const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueType;
+        using ValueType = typename Accessor::ValueType;
 
         ValueType alpha, beta;
         if (ISMeanCurvature<DiffScheme2, DiffScheme1>::result(grid, ijk, alpha, beta)) {
@@ -1994,7 +1994,7 @@
     template<typename StencilT>
     static typename StencilT::ValueType result(const UniformScaleMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType ValueType;
+        using ValueType = typename StencilT::ValueType;
 
         ValueType alpha, beta;
         if (ISMeanCurvature<DiffScheme2, DiffScheme1>::result(stencil, alpha, beta)) {
@@ -2007,7 +2007,7 @@
     template<typename StencilT>
     static typename StencilT::ValueType normGrad(const UniformScaleMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType ValueType;
+        using ValueType = typename StencilT::ValueType;
 
         ValueType alpha, beta;
         if (ISMeanCurvature<DiffScheme2, DiffScheme1>::result(stencil, alpha, beta)) {
@@ -2026,7 +2026,7 @@
     template<typename Accessor> static typename Accessor::ValueType
     result(const UniformScaleTranslateMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueType;
+        using ValueType = typename Accessor::ValueType;
 
         ValueType alpha, beta;
         if (ISMeanCurvature<DiffScheme2, DiffScheme1>::result(grid, ijk, alpha, beta)) {
@@ -2039,7 +2039,7 @@
     template<typename Accessor> static typename Accessor::ValueType
     normGrad(const UniformScaleTranslateMap& map, const Accessor& grid, const Coord& ijk)
     {
-        typedef typename Accessor::ValueType ValueType;
+        using ValueType = typename Accessor::ValueType;
 
         ValueType alpha, beta;
         if (ISMeanCurvature<DiffScheme2, DiffScheme1>::result(grid, ijk, alpha, beta)) {
@@ -2053,7 +2053,7 @@
     template<typename StencilT> static typename StencilT::ValueType
     result(const UniformScaleTranslateMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType ValueType;
+        using ValueType = typename StencilT::ValueType;
 
         ValueType alpha, beta;
         if (ISMeanCurvature<DiffScheme2, DiffScheme1>::result(stencil, alpha, beta)) {
@@ -2066,7 +2066,7 @@
     template<typename StencilT> static typename StencilT::ValueType
     normGrad(const UniformScaleTranslateMap& map, const StencilT& stencil)
     {
-        typedef typename StencilT::ValueType ValueType;
+        using ValueType = typename StencilT::ValueType;
 
         ValueType alpha, beta;
         if (ISMeanCurvature<DiffScheme2, DiffScheme1>::result(stencil, alpha, beta)) {
@@ -2089,7 +2089,7 @@
     GenericMap(const GridType& g): mMap(g.transform().baseMap()) {}
 
     GenericMap(const Transform& t): mMap(t.baseMap()) {}
-    GenericMap(MapBase::Ptr map): mMap(boost::const_pointer_cast<const MapBase>(map)) {}
+    GenericMap(MapBase::Ptr map): mMap(ConstPtrCast<const MapBase>(map)) {}
     GenericMap(MapBase::ConstPtr map): mMap(map) {}
     ~GenericMap() {}
 
diff -aur openvdb.3.2.0/math/Quat.h openvdb.4.0.0/math/Quat.h
--- openvdb.3.2.0/math/Quat.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/math/Quat.h	2016-10-09 10:18:58.000000000 +0200
@@ -164,12 +164,12 @@
              OPENVDB_THROW(ArithmeticError,
                 "A non-rotation matrix can not be used to construct a quaternion");
         }
-        if (!isApproxEqual(rot.det(), (T1)1)) { // rule out reflection
+        if (!isApproxEqual(rot.det(), T1(1))) { // rule out reflection
              OPENVDB_THROW(ArithmeticError,
                 "A reflection matrix can not be used to construct a quaternion");
         }
 
-        T trace = (T)rot.trace();
+        T trace(rot.trace());
         if (trace > 0) {
 
             T q_w = 0.5 * std::sqrt(trace+1);
@@ -581,13 +581,8 @@
 
     friend Quat slerp<>(const Quat &q1, const Quat &q2, T t, T tolerance);
 
-
-    void write(std::ostream& os) const {
-        os.write((char*)&mm, sizeof(T)*4);
-    }
-    void read(std::istream& is) {
-        is.read((char*)&mm, sizeof(T)*4);
-    }
+    void write(std::ostream& os) const { os.write(static_cast<char*>(&mm), sizeof(T) * 4); }
+    void read(std::istream& is) { is.read(static_cast<char*>(&mm), sizeof(T) * 4); }
 
 protected:
     T mm[4];
@@ -652,7 +647,6 @@
 
 #endif //OPENVDB_MATH_QUAT_H_HAS_BEEN_INCLUDED
 
-// ---------------------------------------------------------------------------
 // Copyright (c) 2012-2016 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb.3.2.0/math/Transform.cc openvdb.4.0.0/math/Transform.cc
--- openvdb.3.2.0/math/Transform.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/math/Transform.cc	2016-10-09 10:18:58.000000000 +0200
@@ -46,7 +46,7 @@
 
 
 Transform::Transform(const MapBase::Ptr& map):
-    mMap(boost::const_pointer_cast</*to=*/MapBase, /*from=*/const MapBase>(map))
+    mMap(ConstPtrCast</*to=*/MapBase, /*from=*/const MapBase>(map))
 {
     // auto-convert to simplest type
     if (!mMap->isType<UniformScaleMap>() && mMap->isLinear()) {
@@ -56,7 +56,7 @@
 }
 
 Transform::Transform(const Transform& other):
-    mMap(boost::const_pointer_cast</*to=*/MapBase, /*from=*/const MapBase>(other.baseMap()))
+    mMap(ConstPtrCast</*to=*/MapBase, /*from=*/const MapBase>(other.baseMap()))
 {
 }
 
@@ -195,8 +195,8 @@
     if (mMap->isLinear()) {
         return mMap->getAffineMap()->isIdentity();
     } else if ( mMap->isType<NonlinearFrustumMap>() ) {
-        NonlinearFrustumMap::Ptr frustum
-            = boost::static_pointer_cast<NonlinearFrustumMap, MapBase>(mMap);
+        NonlinearFrustumMap::Ptr frustum =
+            StaticPtrCast<NonlinearFrustumMap, MapBase>(mMap);
         return frustum->isIdentity();
     }
     // unknown nonlinear map type
@@ -252,18 +252,20 @@
     } else if (mMap->isType<NonlinearFrustumMap>() ) {
 
         NonlinearFrustumMap::Ptr currentFrustum =
-            boost::static_pointer_cast<NonlinearFrustumMap, MapBase>(mMap);
+            StaticPtrCast<NonlinearFrustumMap, MapBase>(mMap);
 
         const Mat4d currentMat4 = currentFrustum->secondMap().getMat4();
         const Mat4d newMat4 = m * currentMat4;
 
-        AffineMap affine(newMat4);
+        AffineMap affine{newMat4};
 
-        NonlinearFrustumMap::Ptr frustum( new NonlinearFrustumMap( currentFrustum->getBBox(),
-                                                                   currentFrustum->getTaper(),
-                                                                   currentFrustum->getDepth(),
-                                                                   affine.copy() ) );
-        mMap = boost::static_pointer_cast<MapBase, NonlinearFrustumMap>( frustum );
+        NonlinearFrustumMap::Ptr frustum{new NonlinearFrustumMap{
+            currentFrustum->getBBox(),
+            currentFrustum->getTaper(),
+            currentFrustum->getDepth(),
+            affine.copy()
+        }};
+        mMap = StaticPtrCast<MapBase, NonlinearFrustumMap>(frustum);
     }
 
 }
@@ -316,24 +318,26 @@
         const Mat4d currentMat4 = mMap->getAffineMap()->getMat4();
         const Mat4d newMat4 = currentMat4 * m;
 
-        AffineMap::Ptr affineMap( new AffineMap( newMat4) );
+        AffineMap::Ptr affineMap{new AffineMap{newMat4}};
         mMap = simplify(affineMap);
 
-    } else if (mMap->isType<NonlinearFrustumMap>() ) {
+    } else if (mMap->isType<NonlinearFrustumMap>()) {
 
         NonlinearFrustumMap::Ptr currentFrustum =
-            boost::static_pointer_cast<NonlinearFrustumMap, MapBase>(mMap);
+            StaticPtrCast<NonlinearFrustumMap, MapBase>(mMap);
 
         const Mat4d currentMat4 = currentFrustum->secondMap().getMat4();
         const Mat4d newMat4 =  currentMat4 * m;
 
-        AffineMap affine(newMat4);
+        AffineMap affine{newMat4};
 
-        NonlinearFrustumMap::Ptr frustum( new NonlinearFrustumMap( currentFrustum->getBBox(),
-                                                                   currentFrustum->getTaper(),
-                                                                   currentFrustum->getDepth(),
-                                                                   affine.copy() ) );
-        mMap = boost::static_pointer_cast<MapBase, NonlinearFrustumMap>( frustum );
+        NonlinearFrustumMap::Ptr frustum{new NonlinearFrustumMap{
+            currentFrustum->getBBox(),
+            currentFrustum->getTaper(),
+            currentFrustum->getDepth(),
+            affine.copy()
+        }};
+        mMap = StaticPtrCast<MapBase, NonlinearFrustumMap>(frustum);
     }
 
 }
diff -aur openvdb.3.2.0/math/Transform.h openvdb.4.0.0/math/Transform.h
--- openvdb.3.2.0/math/Transform.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/math/Transform.h	2016-10-09 10:18:58.000000000 +0200
@@ -66,8 +66,8 @@
 class OPENVDB_API Transform
 {
 public:
-    typedef boost::shared_ptr<Transform> Ptr;
-    typedef boost::shared_ptr<const Transform> ConstPtr;
+    using Ptr = SharedPtr<Transform>;
+    using ConstPtr = SharedPtr<const Transform>;
 
     Transform(): mMap(MapBase::Ptr(new ScaleMap())) {}
     Transform(const MapBase::Ptr&);
@@ -196,7 +196,7 @@
 Transform::map()
 {
     if (mMap->type() == MapType::mapType()) {
-        return boost::static_pointer_cast<MapType>(mMap);
+        return StaticPtrCast<MapType>(mMap);
     }
     return typename MapType::Ptr();
 }
@@ -206,7 +206,7 @@
 inline typename MapType::ConstPtr
 Transform::map() const
 {
-    return boost::const_pointer_cast<const MapType>(
+    return ConstPtrCast<const MapType>(
         const_cast<Transform*>(this)->map<MapType>());
 }
 
diff -aur openvdb.3.2.0/math/Tuple.h openvdb.4.0.0/math/Tuple.h
--- openvdb.3.2.0/math/Tuple.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/math/Tuple.h	2016-10-09 10:18:58.000000000 +0200
@@ -35,7 +35,6 @@
 #define OPENVDB_MATH_TUPLE_HAS_BEEN_INCLUDED
 
 #include <sstream>
-#include <boost/type_traits/is_integral.hpp>
 #include "Math.h"
 
 
@@ -44,6 +43,10 @@
 namespace OPENVDB_VERSION_NAME {
 namespace math {
 
+/// @brief Dummy class for tag dispatch of conversion constructors
+struct Conversion {};
+
+
 /// @class Tuple "Tuple.h"
 /// A base class for homogenous tuple types
 template<int SIZE, typename T>
@@ -54,23 +57,36 @@
 
     static const int size = SIZE;
 
-    /// Default ctor.  Does nothing.  Required because declaring a copy (or
-    /// other) constructor means the default constructor gets left out.
+    /// @brief Default ctor.  Does nothing.
+    /// @details This is required because declaring a copy (or other) constructor
+    /// prevents the compiler from synthesizing a default constructor.
     Tuple() {}
 
     /// Copy constructor.  Used when the class signature matches exactly.
-    inline Tuple(Tuple const &src) {
+    Tuple(Tuple const& src) {
         for (int i = 0; i < SIZE; ++i) {
             mm[i] = src.mm[i];
         }
     }
 
-    /// Conversion constructor.  Tuples with different value types and
-    /// different sizes can be interconverted using this member.  Converting
-    /// from a larger tuple results in truncation; converting from a smaller
-    /// tuple results in the extra data members being zeroed out.  This
-    /// function assumes that the integer 0 is convertible to the tuple's
-    /// value type.
+    /// @brief Assignment operator
+    /// @details This is required because declaring a copy (or other) constructor
+    /// prevents the compiler from synthesizing a default assignment operator.
+    Tuple& operator=(Tuple const& src) {
+        if (&src != this) {
+            for (int i = 0; i < SIZE; ++i) {
+                mm[i] = src.mm[i];
+            }
+        }
+        return *this;
+    }
+
+    /// @brief Conversion constructor.
+    /// @details Tuples with different value types and different sizes can be
+    /// interconverted using this member.  Converting from a larger tuple
+    /// results in truncation; converting from a smaller tuple results in
+    /// the extra data members being zeroed out.  This function assumes that
+    /// the integer 0 is convertible to the tuple's value type.
     template <int src_size, typename src_valtype>
     explicit Tuple(Tuple<src_size, src_valtype> const &src) {
         enum { COPY_END = (SIZE < src_size ? SIZE : src_size) };
diff -aur openvdb.3.2.0/math/Vec2.h openvdb.4.0.0/math/Vec2.h
--- openvdb.3.2.0/math/Vec2.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/math/Vec2.h	2016-10-09 10:18:58.000000000 +0200
@@ -31,10 +31,11 @@
 #ifndef OPENVDB_MATH_VEC2_HAS_BEEN_INCLUDED
 #define OPENVDB_MATH_VEC2_HAS_BEEN_INCLUDED
 
-#include <cmath>
 #include <openvdb/Exceptions.h>
 #include "Math.h"
 #include "Tuple.h"
+#include <cmath>
+#include <type_traits>
 
 
 namespace openvdb {
@@ -54,7 +55,7 @@
     /// Trivial constructor, the vector is NOT initialized
     Vec2() {}
 
-    /// Constructor with one argument, e.g.   Vec2f v(0);
+    /// @brief Construct a vector all of whose components have the given value.
     explicit Vec2(T val) { this->mm[0] = this->mm[1] = val; }
 
     /// Constructor with two arguments, e.g.   Vec2f v(1,2,3);
@@ -80,6 +81,16 @@
         this->mm[1] = static_cast<T>(t[1]);
     }
 
+    /// @brief Construct a vector all of whose components have the given value,
+    /// which may be of an arithmetic type different from this vector's value type.
+    /// @details Type conversion warnings are suppressed.
+    template<typename Other>
+    explicit Vec2(Other val,
+        typename std::enable_if<std::is_arithmetic<Other>::value, Conversion>::type = Conversion{})
+    {
+        this->mm[0] = this->mm[1] = static_cast<T>(val);
+    }
+
     /// Reference to the component, e.g.   v.x() = 4.5f;
     T& x() {return this->mm[0];}
     T& y() {return this->mm[1];}
@@ -206,12 +217,27 @@
         return *this;
     }
 
+    /// Return a reference to itself after log has been
+    /// applied to all the vector components.
+    inline const Vec2<T>& log()
+    {
+        this->mm[0] = std::log(this->mm[0]);
+        this->mm[1] = std::log(this->mm[1]);
+        return *this;
+    }
+
     /// Return the sum of all the vector components.
     inline T sum() const
     {
         return this->mm[0] + this->mm[1];
     }
 
+    /// Return the product of all the vector components.
+    inline T product() const
+    {
+        return this->mm[0] * this->mm[1];
+    }
+
     /// this = normalized this
     bool normalize(T eps=1.0e-8)
     {
@@ -240,6 +266,13 @@
         return *this / len;
     }
 
+    /// return normalized this, or (1, 0) if this is null vector
+    Vec2<T> unitSafe() const
+    {
+        T l2 = lengthSqr();
+        return l2 ? *this/static_cast<T>(sqrt(l2)) : Vec2<T>(1,0);
+    }
+
     /// Returns v, where \f$v_i *= scalar\f$ for \f$i \in [0, 1]\f$
     template <typename S>
     const Vec2<T> &operator*=(S scalar)
@@ -353,6 +386,7 @@
 
     /// Predefined constants, e.g.   Vec2f v = Vec2f::xNegAxis();
     static Vec2<T> zero() { return Vec2<T>(0, 0); }
+    static Vec2<T> ones() { return Vec2<T>(1, 1); }
 };
 
 
@@ -537,6 +571,11 @@
 template <typename T>
 inline Vec2<T> Exp(Vec2<T> v) { return v.exp(); }
 
+/// @brief Return a vector with log applied to each of
+/// the components of the input vector.
+template <typename T>
+inline Vec2<T> Log(Vec2<T> v) { return v.log(); }
+
 typedef Vec2<int32_t>   Vec2i;
 typedef Vec2<uint32_t>  Vec2ui;
 typedef Vec2<float>     Vec2s;
diff -aur openvdb.3.2.0/math/Vec3.h openvdb.4.0.0/math/Vec3.h
--- openvdb.3.2.0/math/Vec3.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/math/Vec3.h	2016-10-09 10:18:58.000000000 +0200
@@ -31,10 +31,12 @@
 #ifndef OPENVDB_MATH_VEC3_HAS_BEEN_INCLUDED
 #define OPENVDB_MATH_VEC3_HAS_BEEN_INCLUDED
 
-#include <cmath>
 #include <openvdb/Exceptions.h>
 #include "Math.h"
 #include "Tuple.h"
+#include <cmath>
+#include <type_traits>
+
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -53,7 +55,7 @@
     /// Trivial constructor, the vector is NOT initialized
     Vec3() {}
 
-    /// Constructor with one argument, e.g.   Vec3f v(0);
+    /// @brief Construct a vector all of whose components have the given value.
     explicit Vec3(T val) { this->mm[0] = this->mm[1] = this->mm[2] = val; }
 
     /// Constructor with three arguments, e.g.   Vec3d v(1,2,3);
@@ -83,6 +85,16 @@
         this->mm[2] = static_cast<T>(v[2]);
     }
 
+    /// @brief Construct a vector all of whose components have the given value,
+    /// which may be of an arithmetic type different from this vector's value type.
+    /// @details Type conversion warnings are suppressed.
+    template<typename Other>
+    explicit Vec3(Other val,
+        typename std::enable_if<std::is_arithmetic<Other>::value, Conversion>::type = Conversion{})
+    {
+        this->mm[0] = this->mm[1] = this->mm[2] = static_cast<T>(val);
+    }
+
     /// @brief Construct a Vec3 from another Vec3 with a possibly different value type.
     /// @details Type conversion warnings are suppressed.
     template<typename Other>
@@ -328,7 +340,7 @@
         return *this;
     }
 
-    /// Return a reference to itsef after the exponent has been
+    /// Return a reference to itself after the exponent has been
     /// applied to all the vector components.
     inline const Vec3<T>& exp()
     {
@@ -338,12 +350,28 @@
         return *this;
     }
 
+    /// Return a reference to itself after log has been
+    /// applied to all the vector components.
+    inline const Vec3<T>& log()
+    {
+        this->mm[0] = std::log(this->mm[0]);
+        this->mm[1] = std::log(this->mm[1]);
+        this->mm[2] = std::log(this->mm[2]);
+        return *this;
+    }
+
     /// Return the sum of all the vector components.
     inline T sum() const
     {
         return this->mm[0] + this->mm[1] + this->mm[2];
     }
 
+    /// Return the product of all the vector components.
+    inline T product() const
+    {
+        return this->mm[0] * this->mm[1] * this->mm[2];
+    }
+
     /// this = normalized this
     bool normalize(T eps = T(1.0e-7))
     {
@@ -373,6 +401,13 @@
         return *this / len;
     }
 
+    /// return normalized this, or (1, 0, 0) if this is null vector
+    Vec3<T> unitSafe() const
+    {
+        T l2 = lengthSqr();
+        return l2 ? *this / static_cast<T>(sqrt(l2)) : Vec3<T>(1, 0 ,0);
+    }
+
     // Number of cols, rows, elements
     static unsigned numRows() { return 1; }
     static unsigned numColumns() { return 3; }
@@ -411,13 +446,13 @@
             l = this->mm[0]*this->mm[0] + this->mm[2]*this->mm[2];
             l = static_cast<T>(T(1)/sqrt(double(l)));
             u.mm[0] = -this->mm[2]*l;
-            u.mm[1] = (T)0.0;
+            u.mm[1] = T(0);
             u.mm[2] = +this->mm[0]*l;
         } else {
             // W.y or W.z is the largest magnitude component, swap them
             l = this->mm[1]*this->mm[1] + this->mm[2]*this->mm[2];
             l = static_cast<T>(T(1)/sqrt(double(l)));
-            u.mm[0] = (T)0.0;
+            u.mm[0] = T(0);
             u.mm[1] = +this->mm[2]*l;
             u.mm[2] = -this->mm[1]*l;
         }
@@ -440,8 +475,25 @@
         return finite(this->mm[0]) && finite(this->mm[1]) && finite(this->mm[2]);
     }
 
+    /// Return a vector with the components of this in ascending order
+    Vec3<T> sorted() const
+    {
+        Vec3<T> r(*this);
+        if( r.mm[0] > r.mm[1] ) std::swap(r.mm[0], r.mm[1]);
+        if( r.mm[1] > r.mm[2] ) std::swap(r.mm[1], r.mm[2]);
+        if( r.mm[0] > r.mm[1] ) std::swap(r.mm[0], r.mm[1]);
+        return r;
+    }
+
+    /// Return the vector (z, y, x)
+    Vec3<T> reversed() const
+    {
+        return Vec3<T>(this->mm[2], this->mm[1], this->mm[0]);
+    }
+
     /// Predefined constants, e.g.   Vec3d v = Vec3d::xNegAxis();
     static Vec3<T> zero() { return Vec3<T>(0, 0, 0); }
+    static Vec3<T> ones() { return Vec3<T>(1, 1, 1); }
 };
 
 
@@ -645,6 +697,11 @@
 template <typename T>
 inline Vec3<T> Exp(Vec3<T> v) { return v.exp(); }
 
+/// @brief Return a vector with log applied to each of
+/// the components of the input vector.
+template <typename T>
+inline Vec3<T> Log(Vec3<T> v) { return v.log(); }
+
 typedef Vec3<int32_t>   Vec3i;
 typedef Vec3<uint32_t>  Vec3ui;
 typedef Vec3<float>     Vec3s;
diff -aur openvdb.3.2.0/math/Vec4.h openvdb.4.0.0/math/Vec4.h
--- openvdb.3.2.0/math/Vec4.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/math/Vec4.h	2016-10-09 10:18:58.000000000 +0200
@@ -31,11 +31,12 @@
 #ifndef OPENVDB_MATH_VEC4_HAS_BEEN_INCLUDED
 #define OPENVDB_MATH_VEC4_HAS_BEEN_INCLUDED
 
-#include <cmath>
 #include <openvdb/Exceptions.h>
 #include "Math.h"
 #include "Tuple.h"
 #include "Vec3.h"
+#include <cmath>
+#include <type_traits>
 
 
 namespace openvdb {
@@ -55,7 +56,7 @@
     /// Trivial constructor, the vector is NOT initialized
     Vec4() {}
 
-    /// Constructor with one argument, e.g.   Vec4f v(0);
+    /// @brief Construct a vector all of whose components have the given value.
     explicit Vec4(T val) { this->mm[0] = this->mm[1] = this->mm[2] = this->mm[3] = val; }
 
     /// Constructor with four arguments, e.g.   Vec4f v(1,2,3,4);
@@ -87,6 +88,16 @@
         this->mm[3] = static_cast<T>(v[3]);
     }
 
+    /// @brief Construct a vector all of whose components have the given value,
+    /// which may be of an arithmetic type different from this vector's value type.
+    /// @details Type conversion warnings are suppressed.
+    template<typename Other>
+    explicit Vec4(Other val,
+        typename std::enable_if<std::is_arithmetic<Other>::value, Conversion>::type = Conversion{})
+    {
+        this->mm[0] = this->mm[1] = this->mm[2] = this->mm[3] = static_cast<T>(val);
+    }
+
     /// Reference to the component, e.g.   v.x() = 4.5f;
     T& x() { return this->mm[0]; }
     T& y() { return this->mm[1]; }
@@ -236,7 +247,7 @@
             + this->mm[2]*this->mm[2] + this->mm[3]*this->mm[3]);
     }
 
-    /// Return a reference to itsef after the exponent has been
+    /// Return a reference to itself after the exponent has been
     /// applied to all the vector components.
     inline const Vec4<T>& exp()
     {
@@ -247,12 +258,28 @@
         return *this;
     }
 
+    /// Return a reference to itself after log has been
+    /// applied to all the vector components.
+    inline const Vec4<T>& log()
+    {
+        this->mm[0] = std::log(this->mm[0]);
+        this->mm[1] = std::log(this->mm[1]);
+        this->mm[2] = std::log(this->mm[2]);
+        this->mm[3] = std::log(this->mm[3]);
+        return *this;
+    }
+
     /// Return the sum of all the vector components.
     inline T sum() const
     {
         return this->mm[0] + this->mm[1] + this->mm[2] + this->mm[3];
     }
 
+    /// Return the product of all the vector components.
+    inline T product() const
+    {
+        return this->mm[0] * this->mm[1] * this->mm[2] * this->mm[3];
+    }
 
     /// this = normalized this
     bool normalize(T eps=1.0e-8)
@@ -282,6 +309,13 @@
         return *this / len;
     }
 
+    /// return normalized this, or (1, 0, 0, 0) if this is null vector
+    Vec4<T> unitSafe() const
+    {
+        T l2 = lengthSqr();
+        return l2 ? *this / static_cast<T>(sqrt(l2)) : Vec4<T>(1, 0, 0, 0);
+    }
+
     /// Returns v, where \f$v_i *= scalar\f$ for \f$i \in [0, 3]\f$
     template <typename S>
     const Vec4<T> &operator*=(S scalar)
@@ -400,6 +434,7 @@
     /// Predefined constants, e.g.   Vec4f v = Vec4f::xNegAxis();
     static Vec4<T> zero() { return Vec4<T>(0, 0, 0, 0); }
     static Vec4<T> origin() { return Vec4<T>(0, 0, 0, 1); }
+    static Vec4<T> ones() { return Vec4<T>(1, 1, 1, 1); }
 };
 
 /// Equality operator, does exact floating point comparisons
@@ -578,6 +613,11 @@
 template <typename T>
 inline Vec4<T> Exp(Vec4<T> v) { return v.exp(); }
 
+/// @brief Return a vector with log applied to each of
+/// the components of the input vector.
+template <typename T>
+inline Vec4<T> Log(Vec4<T> v) { return v.log(); }
+
 typedef Vec4<int32_t>   Vec4i;
 typedef Vec4<uint32_t>  Vec4ui;
 typedef Vec4<float>     Vec4s;
Seulement dans openvdb.3.2.0: metadata
Seulement dans openvdb.4.0.0: Metadata.cc
diff -aur openvdb.3.2.0/Metadata.h openvdb.4.0.0/Metadata.h
--- openvdb.3.2.0/Metadata.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/Metadata.h	2016-10-09 10:18:58.000000000 +0200
@@ -28,13 +28,396 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 
-#ifndef OPENVDB_METADATA_HAS_BEEN_INCLUDED
-#define OPENVDB_METADATA_HAS_BEEN_INCLUDED
+#ifndef OPENVDB_METADATA_METADATA_HAS_BEEN_INCLUDED
+#define OPENVDB_METADATA_METADATA_HAS_BEEN_INCLUDED
 
-#include <openvdb/metadata/Metadata.h>
-#include <openvdb/metadata/StringMetadata.h>
+#include "Exceptions.h"
+#include "Types.h"
+#include "math/Math.h" // for math::isZero()
+#include "util/Name.h"
+#include <cstdint>
+#include <iostream>
+#include <string>
 
-#endif // OPENVDB_METADATA_HAS_BEEN_INCLUDED
+
+namespace openvdb {
+OPENVDB_USE_VERSION_NAMESPACE
+namespace OPENVDB_VERSION_NAME {
+
+/// @brief Base class for storing metadata information in a grid.
+class OPENVDB_API Metadata
+{
+public:
+    using Ptr = SharedPtr<Metadata>;
+    using ConstPtr = SharedPtr<const Metadata>;
+
+    Metadata() {}
+    virtual ~Metadata() {}
+
+    /// Return the type name of the metadata.
+    virtual Name typeName() const = 0;
+
+    /// Return a copy of the metadata.
+    virtual Metadata::Ptr copy() const = 0;
+
+    /// Copy the given metadata into this metadata.
+    virtual void copy(const Metadata& other) = 0;
+
+    /// Return a textual representation of this metadata.
+    virtual std::string str() const = 0;
+
+    /// Return the boolean representation of this metadata (empty strings
+    /// and zeroVals evaluate to false; most other values evaluate to true).
+    virtual bool asBool() const = 0;
+
+    /// Return @c true if the given metadata is equivalent to this metadata.
+    bool operator==(const Metadata& other) const;
+    /// Return @c true if the given metadata is different from this metadata.
+    bool operator!=(const Metadata& other) const { return !(*this == other); }
+
+    /// Return the size of this metadata in bytes.
+    virtual Index32 size() const = 0;
+
+    /// Unserialize this metadata from a stream.
+    void read(std::istream&);
+    /// Serialize this metadata to a stream.
+    void write(std::ostream&) const;
+
+    /// Create new metadata of the given type.
+    static Metadata::Ptr createMetadata(const Name& typeName);
+
+    /// Return @c true if the given type is known by the metadata type registry.
+    static bool isRegisteredType(const Name& typeName);
+
+    /// Clear out the metadata registry.
+    static void clearRegistry();
+
+    /// Register the given metadata type along with a factory function.
+    static void registerType(const Name& typeName, Metadata::Ptr (*createMetadata)());
+    static void unregisterType(const Name& typeName);
+
+protected:
+    /// Read the size of the metadata from a stream.
+    static Index32 readSize(std::istream&);
+    /// Write the size of the metadata to a stream.
+    void writeSize(std::ostream&) const;
+
+    /// Read the metadata from a stream.
+    virtual void readValue(std::istream&, Index32 numBytes) = 0;
+    /// Write the metadata to a stream.
+    virtual void writeValue(std::ostream&) const = 0;
+
+private:
+    // Disallow copying of instances of this class.
+    Metadata(const Metadata&);
+    Metadata& operator=(const Metadata&);
+};
+
+
+/// @brief Subclass to read (and ignore) data of an unregistered type
+class OPENVDB_API UnknownMetadata: public Metadata
+{
+public:
+    UnknownMetadata() {}
+    virtual ~UnknownMetadata() {}
+    virtual Name typeName() const { return "<unknown>"; }
+    virtual Metadata::Ptr copy() const { OPENVDB_THROW(TypeError, "Metadata has unknown type"); }
+    virtual void copy(const Metadata&) { OPENVDB_THROW(TypeError, "Destination has unknown type"); }
+    virtual std::string str() const { return "<unknown>"; }
+    virtual bool asBool() const { return false; }
+    virtual Index32 size() const { return 0; }
+
+protected:
+    virtual void readValue(std::istream&s, Index32 numBytes);
+    virtual void writeValue(std::ostream&) const;
+};
+
+
+/// @brief Templated metadata class to hold specific types.
+template<typename T>
+class TypedMetadata: public Metadata
+{
+public:
+    using Ptr = SharedPtr<TypedMetadata<T>>;
+    using ConstPtr = SharedPtr<const TypedMetadata<T>>;
+
+    TypedMetadata();
+    TypedMetadata(const T& value);
+    TypedMetadata(const TypedMetadata<T>& other);
+    virtual ~TypedMetadata();
+
+    virtual Name typeName() const;
+    virtual Metadata::Ptr copy() const;
+    virtual void copy(const Metadata& other);
+    virtual std::string str() const;
+    virtual bool asBool() const;
+    virtual Index32 size() const { return static_cast<Index32>(sizeof(T)); }
+
+    /// Set this metadata's value.
+    void setValue(const T&);
+    /// Return this metadata's value.
+    T& value();
+    const T& value() const;
+
+    // Static specialized function for the type name. This function must be
+    // template specialized for each type T.
+    static Name staticTypeName() { return typeNameAsString<T>(); }
+
+    /// Create new metadata of this type.
+    static Metadata::Ptr createMetadata();
+
+    static void registerType();
+    static void unregisterType();
+    static bool isRegisteredType();
+
+protected:
+    virtual void readValue(std::istream&, Index32 numBytes);
+    virtual void writeValue(std::ostream&) const;
+
+private:
+    T mValue;
+};
+
+/// Write a Metadata to an output stream
+std::ostream& operator<<(std::ostream& ostr, const Metadata& metadata);
+
+
+////////////////////////////////////////
+
+
+inline void
+Metadata::writeSize(std::ostream& os) const
+{
+    const Index32 n = this->size();
+    os.write(reinterpret_cast<const char*>(&n), sizeof(Index32));
+}
+
+
+inline Index32
+Metadata::readSize(std::istream& is)
+{
+    Index32 n = 0;
+    is.read(reinterpret_cast<char*>(&n), sizeof(Index32));
+    return n;
+}
+
+
+inline void
+Metadata::read(std::istream& is)
+{
+    const Index32 numBytes = this->readSize(is);
+    this->readValue(is, numBytes);
+}
+
+
+inline void
+Metadata::write(std::ostream& os) const
+{
+    this->writeSize(os);
+    this->writeValue(os);
+}
+
+
+////////////////////////////////////////
+
+
+template <typename T>
+inline
+TypedMetadata<T>::TypedMetadata() : mValue(T())
+{
+}
+
+template <typename T>
+inline
+TypedMetadata<T>::TypedMetadata(const T &value) : mValue(value)
+{
+}
+
+template <typename T>
+inline
+TypedMetadata<T>::TypedMetadata(const TypedMetadata<T> &other) :
+    Metadata(),
+    mValue(other.mValue)
+{
+}
+
+template <typename T>
+inline
+TypedMetadata<T>::~TypedMetadata()
+{
+}
+
+template <typename T>
+inline Name
+TypedMetadata<T>::typeName() const
+{
+    return TypedMetadata<T>::staticTypeName();
+}
+
+template <typename T>
+inline void
+TypedMetadata<T>::setValue(const T& val)
+{
+    mValue = val;
+}
+
+template <typename T>
+inline T&
+TypedMetadata<T>::value()
+{
+    return mValue;
+}
+
+template <typename T>
+inline const T&
+TypedMetadata<T>::value() const
+{
+    return mValue;
+}
+
+template <typename T>
+inline Metadata::Ptr
+TypedMetadata<T>::copy() const
+{
+    Metadata::Ptr metadata(new TypedMetadata<T>());
+    metadata->copy(*this);
+    return metadata;
+}
+
+template <typename T>
+inline void
+TypedMetadata<T>::copy(const Metadata &other)
+{
+    const TypedMetadata<T>* t = dynamic_cast<const TypedMetadata<T>*>(&other);
+    if (t == nullptr) OPENVDB_THROW(TypeError, "Incompatible type during copy");
+    mValue = t->mValue;
+}
+
+
+template<typename T>
+inline void
+TypedMetadata<T>::readValue(std::istream& is, Index32 /*numBytes*/)
+{
+    //assert(this->size() == numBytes);
+    is.read(reinterpret_cast<char*>(&mValue), this->size());
+}
+
+template<typename T>
+inline void
+TypedMetadata<T>::writeValue(std::ostream& os) const
+{
+    os.write(reinterpret_cast<const char*>(&mValue), this->size());
+}
+
+template <typename T>
+inline std::string
+TypedMetadata<T>::str() const
+{
+    std::ostringstream ostr;
+    ostr << mValue;
+    return ostr.str();
+}
+
+template<typename T>
+inline bool
+TypedMetadata<T>::asBool() const
+{
+    return !math::isZero(mValue);
+}
+
+template <typename T>
+inline Metadata::Ptr
+TypedMetadata<T>::createMetadata()
+{
+    Metadata::Ptr ret(new TypedMetadata<T>());
+    return ret;
+}
+
+template <typename T>
+inline void
+TypedMetadata<T>::registerType()
+{
+    Metadata::registerType(TypedMetadata<T>::staticTypeName(),
+                           TypedMetadata<T>::createMetadata);
+}
+
+template <typename T>
+inline void
+TypedMetadata<T>::unregisterType()
+{
+    Metadata::unregisterType(TypedMetadata<T>::staticTypeName());
+}
+
+template <typename T>
+inline bool
+TypedMetadata<T>::isRegisteredType()
+{
+    return Metadata::isRegisteredType(TypedMetadata<T>::staticTypeName());
+}
+
+
+template<>
+inline std::string
+TypedMetadata<bool>::str() const
+{
+    return (mValue ? "true" : "false");
+}
+
+
+inline std::ostream&
+operator<<(std::ostream& ostr, const Metadata& metadata)
+{
+    ostr << metadata.str();
+    return ostr;
+}
+
+
+using BoolMetadata   = TypedMetadata<bool>;
+using DoubleMetadata = TypedMetadata<double>;
+using FloatMetadata  = TypedMetadata<float>;
+using Int32Metadata  = TypedMetadata<int32_t>;
+using Int64Metadata  = TypedMetadata<int64_t>;
+using StringMetadata = TypedMetadata<std::string>;
+using Vec2DMetadata  = TypedMetadata<Vec2d>;
+using Vec2IMetadata  = TypedMetadata<Vec2i>;
+using Vec2SMetadata  = TypedMetadata<Vec2s>;
+using Vec3DMetadata  = TypedMetadata<Vec3d>;
+using Vec3IMetadata  = TypedMetadata<Vec3i>;
+using Vec3SMetadata  = TypedMetadata<Vec3s>;
+using Mat4SMetadata  = TypedMetadata<Mat4s>;
+using Mat4DMetadata  = TypedMetadata<Mat4d>;
+
+
+////////////////////////////////////////
+
+
+template<>
+inline Index32
+StringMetadata::size() const
+{
+    return static_cast<Index32>(mValue.size());
+}
+
+
+template<>
+inline void
+StringMetadata::readValue(std::istream& is, Index32 size)
+{
+    mValue.resize(size, '\0');
+    is.read(&mValue[0], size);
+}
+
+template<>
+inline void
+StringMetadata::writeValue(std::ostream& os) const
+{
+    os.write(reinterpret_cast<const char*>(&mValue[0]), this->size());
+}
+
+} // namespace OPENVDB_VERSION_NAME
+} // namespace openvdb
+
+#endif // OPENVDB_METADATA_METADATA_HAS_BEEN_INCLUDED
 
 // Copyright (c) 2012-2016 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
Seulement dans openvdb.4.0.0: MetaMap.cc
Seulement dans openvdb.4.0.0: MetaMap.h
diff -aur openvdb.3.2.0/Platform.h openvdb.4.0.0/Platform.h
--- openvdb.3.2.0/Platform.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/Platform.h	2016-10-09 10:18:58.000000000 +0200
@@ -131,15 +131,14 @@
 #endif
 
 
-/// Visual C++ does not have constants like M_PI unless this is defined.
-/// @note This is needed even though the core library is built with this but
-/// hcustom 12.1 doesn't define it. So this is needed for HDK operators.
-#ifndef _USE_MATH_DEFINES
-    #define _USE_MATH_DEFINES
-#endif
-
-/// Visual C++ does not have round
 #ifdef _MSC_VER
+    /// Visual C++ does not have constants like M_PI unless this is defined.
+    /// @note This is needed even though the core library is built with this but
+    /// hcustom 12.1 doesn't define it. So this is needed for HDK operators.
+    #ifndef _USE_MATH_DEFINES
+        #define _USE_MATH_DEFINES
+    #endif
+    /// Visual C++ does not have round
     #include <boost/math/special_functions/round.hpp>
     using boost::math::round;
 #endif
diff -aur openvdb.3.2.0/python/pyFloatGrid.cc openvdb.4.0.0/python/pyFloatGrid.cc
--- openvdb.3.2.0/python/pyFloatGrid.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/python/pyFloatGrid.cc	2016-10-09 10:18:58.000000000 +0200
@@ -35,6 +35,9 @@
 #include "pyGrid.h"
 
 
+void exportFloatGrid();
+
+
 /// Create a Python wrapper for each supported Grid type.
 void
 exportFloatGrid()
diff -aur openvdb.3.2.0/python/pyGrid.h openvdb.4.0.0/python/pyGrid.h
--- openvdb.3.2.0/python/pyGrid.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/python/pyGrid.h	2016-10-09 10:18:58.000000000 +0200
@@ -67,8 +67,19 @@
 #include <sstream>
 
 namespace py = boost::python;
+
+#ifdef __clang__
+// This is a private header, so it's OK to include a "using namespace" directive.
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wheader-hygiene"
+#endif
+
 using namespace openvdb::OPENVDB_VERSION_NAME;
 
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
 
 namespace pyopenvdb {
 
@@ -214,7 +225,7 @@
 
 template<typename GridType>
 inline typename GridType::Ptr
-copyGrid(const GridType& grid)
+copyGrid(GridType& grid)
 {
     return grid.copy();
 }
@@ -774,6 +785,18 @@
 #endif
 
 
+inline py::object
+copyNumPyArray(PyArrayObject* arrayObj, NPY_ORDER order = NPY_CORDER)
+{
+#ifdef __GNUC__
+    // Silence GCC "casting between pointer-to-function and pointer-to-object" warnings.
+    __extension__
+#endif
+    auto obj = pyutil::pyBorrow(PyArray_NewCopy(arrayObj, order));
+    return obj;
+}
+
+
 // Abstract base class for helper classes that copy data between
 // NumPy arrays of various types and grids of various types
 template<typename GridType>
@@ -1253,7 +1276,7 @@
         {
             // Create a deep copy of the array (because the point vector will be
             // destroyed when this function returns).
-            pointArrayObj = pyutil::pyBorrow(PyArray_NewCopy(arrayObj, NPY_CORDER));
+            pointArrayObj = copyNumPyArray(arrayObj, NPY_CORDER);
         }
     }
 
@@ -1264,7 +1287,7 @@
         if (PyArrayObject* arrayObj = reinterpret_cast<PyArrayObject*>(
             PyArray_SimpleNewFromData(/*dims=*/2, dims, NPY_UINT32, &quads[0])))
         {
-            quadArrayObj = pyutil::pyBorrow(PyArray_NewCopy(arrayObj, NPY_CORDER));
+            quadArrayObj = copyNumPyArray(arrayObj, NPY_CORDER);
         }
     }
 
@@ -1297,7 +1320,7 @@
         {
             // Create a deep copy of the array (because the point vector will be
             // destroyed when this function returns).
-            pointArrayObj = pyutil::pyBorrow(PyArray_NewCopy(arrayObj, NPY_CORDER));
+            pointArrayObj = copyNumPyArray(arrayObj, NPY_CORDER);
         }
     }
 
@@ -1308,7 +1331,7 @@
         if (PyArrayObject* arrayObj = reinterpret_cast<PyArrayObject*>(
             PyArray_SimpleNewFromData(/*dims=*/2, dims, NPY_UINT32, &triangles[0])))
         {
-            triangleArrayObj = pyutil::pyBorrow(PyArray_NewCopy(arrayObj, NPY_CORDER));
+            triangleArrayObj = copyNumPyArray(arrayObj, NPY_CORDER);
         }
     }
 
@@ -1319,7 +1342,7 @@
         if (PyArrayObject* arrayObj = reinterpret_cast<PyArrayObject*>(
             PyArray_SimpleNewFromData(/*dims=*/2, dims, NPY_UINT32, &quads[0])))
         {
-            quadArrayObj = pyutil::pyBorrow(PyArray_NewCopy(arrayObj, NPY_CORDER));
+            quadArrayObj = copyNumPyArray(arrayObj, NPY_CORDER);
         }
     }
 
diff -aur openvdb.3.2.0/python/pyIntGrid.cc openvdb.4.0.0/python/pyIntGrid.cc
--- openvdb.3.2.0/python/pyIntGrid.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/python/pyIntGrid.cc	2016-10-09 10:18:58.000000000 +0200
@@ -34,6 +34,9 @@
 #include "pyGrid.h"
 
 
+void exportIntGrid();
+
+
 void
 exportIntGrid()
 {
diff -aur openvdb.3.2.0/python/pyMetadata.cc openvdb.4.0.0/python/pyMetadata.cc
--- openvdb.3.2.0/python/pyMetadata.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/python/pyMetadata.cc	2016-10-09 10:18:58.000000000 +0200
@@ -64,7 +64,10 @@
 } // end anonymous namespace
 
 
-void exportMetadata()
+void exportMetadata();
+
+void
+exportMetadata()
 {
     py::class_<MetadataWrap, boost::noncopyable> clss(
         /*classname=*/"Metadata",
diff -aur openvdb.3.2.0/python/pyOpenVDBModule.cc openvdb.4.0.0/python/pyOpenVDBModule.cc
--- openvdb.3.2.0/python/pyOpenVDBModule.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/python/pyOpenVDBModule.cc	2016-10-09 10:18:58.000000000 +0200
@@ -395,6 +395,14 @@
 ////////////////////////////////////////
 
 
+py::object readFromFile(const std::string&, const std::string&);
+py::tuple readAllFromFile(const std::string&);
+py::dict readFileMetadata(const std::string&);
+py::object readGridMetadataFromFile(const std::string&, const std::string&);
+py::list readAllGridMetadataFromFile(const std::string&);
+void writeToFile(const std::string&, py::object, py::object);
+
+
 py::object
 readFromFile(const std::string& filename, const std::string& gridName)
 {
@@ -579,8 +587,10 @@
 
 #ifdef DWA_OPENVDB
 #define PY_OPENVDB_MODULE_NAME  _openvdb
+extern "C" { void init_openvdb(); }
 #else
 #define PY_OPENVDB_MODULE_NAME  pyopenvdb
+extern "C" { void initpyopenvdb(); }
 #endif
 
 BOOST_PYTHON_MODULE(PY_OPENVDB_MODULE_NAME)
diff -aur openvdb.3.2.0/python/pyTransform.cc openvdb.4.0.0/python/pyTransform.cc
--- openvdb.3.2.0/python/pyTransform.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/python/pyTransform.cc	2016-10-09 10:18:58.000000000 +0200
@@ -161,9 +161,9 @@
     /// Restore the given Transform to a saved state.
     static void setstate(py::object xformObj, py::object stateObj)
     {
-        math::Transform::Ptr xform;
+        math::Transform* xform = nullptr;
         {
-            py::extract<math::Transform::Ptr> x(xformObj);
+            py::extract<math::Transform*> x(xformObj);
             if (x.check()) xform = x();
             else return;
         }
@@ -247,6 +247,8 @@
 } // namespace pyTransform
 
 
+void exportTransform();
+
 void
 exportTransform()
 {
diff -aur openvdb.3.2.0/python/pyVec3Grid.cc openvdb.4.0.0/python/pyVec3Grid.cc
--- openvdb.3.2.0/python/pyVec3Grid.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/python/pyVec3Grid.cc	2016-10-09 10:18:58.000000000 +0200
@@ -34,6 +34,9 @@
 #include "pyGrid.h"
 
 
+void exportVec3Grid();
+
+
 void
 exportVec3Grid()
 {
diff -aur openvdb.3.2.0/tools/Clip.h openvdb.4.0.0/tools/Clip.h
--- openvdb.3.2.0/tools/Clip.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tools/Clip.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file Clip.h
 ///
 /// @brief Functions to clip a grid against a bounding box or against
@@ -36,17 +36,14 @@
 #ifndef OPENVDB_TOOLS_CLIP_HAS_BEEN_INCLUDED
 #define OPENVDB_TOOLS_CLIP_HAS_BEEN_INCLUDED
 
-#include <openvdb/Types.h>// for ValueMask
 #include <openvdb/Grid.h>
-#include <openvdb/math/Math.h>// for isNegative
+#include <openvdb/math/Math.h> // for math::isNegative()
 #include <openvdb/tree/LeafManager.h>
-#include "GridTransformer.h" // for resampleToMatch()
-#include <boost/type_traits/is_same.hpp>
-#include <boost/type_traits/is_signed.hpp>
-#include <boost/utility/enable_if.hpp>
+#include "GridTransformer.h" // for tools::resampleToMatch()
+#include "Prune.h"
 #include <tbb/blocked_range.h>
 #include <tbb/parallel_reduce.h>
-#include "Prune.h"
+#include <type_traits> // for std::enable_if, std::is_same
 
 
 namespace openvdb {
@@ -56,15 +53,22 @@
 
 /// @brief Clip the given grid against a world-space bounding box
 /// and return a new grid containing the result.
+/// @param grid          the grid to be clipped
+/// @param bbox          a world-space bounding box
+/// @param keepInterior  if true, discard voxels that lie outside the bounding box;
+///     if false, discard voxels that lie inside the bounding box
 /// @warning Clipping a level set will likely produce a grid that is
 /// no longer a valid level set.
 template<typename GridType> OPENVDB_STATIC_SPECIALIZATION
-inline typename GridType::Ptr clip(const GridType& grid, const BBoxd&);
+inline typename GridType::Ptr
+clip(const GridType& grid, const BBoxd& bbox, bool keepInterior = true);
 
 /// @brief Clip a grid against the active voxels of another grid
 /// and return a new grid containing the result.
-/// @param grid  the grid to be clipped
-/// @param mask  a grid whose active voxels form a boolean clipping mask
+/// @param grid          the grid to be clipped
+/// @param mask          a grid whose active voxels form a boolean clipping mask
+/// @param keepInterior  if true, discard voxels that do not intersect the mask;
+///     if false, discard voxels that intersect the mask
 /// @details The mask grid need not have the same transform as the source grid.
 /// Also, if the mask grid is a level set, consider using tools::sdfInteriorMask
 /// to construct a new mask comprising the interior (rather than the narrow band)
@@ -72,7 +76,8 @@
 /// @warning Clipping a level set will likely produce a grid that is
 /// no longer a valid level set.
 template<typename GridType, typename MaskTreeType> OPENVDB_STATIC_SPECIALIZATION
-inline typename GridType::Ptr clip(const GridType& grid, const Grid<MaskTreeType>& mask);
+inline typename GridType::Ptr
+clip(const GridType& grid, const Grid<MaskTreeType>& mask, bool keepInterior = true);
 
 
 ////////////////////////////////////////
@@ -80,27 +85,28 @@
 
 namespace clip_internal {
 
-
-////////////////////////////////////////
+// Use either MaskGrids or BoolGrids internally.
+// (MaskGrids have a somewhat lower memory footprint.)
+using MaskValueType = ValueMask;
+//using MaskValueType = bool;
 
 
 template<typename TreeT>
 class MaskInteriorVoxels
 {
 public:
-    typedef typename TreeT::ValueType ValueT;
-    typedef typename TreeT::LeafNodeType LeafNodeT;
+    using ValueT = typename TreeT::ValueType;
+    using LeafNodeT = typename TreeT::LeafNodeType;
 
     MaskInteriorVoxels(const TreeT& tree): mAcc(tree) {}
 
-    template <typename LeafNodeType>
-    void operator()(LeafNodeType &leaf, size_t /*leafIndex*/) const
+    template<typename LeafNodeType>
+    void operator()(LeafNodeType& leaf, size_t /*leafIndex*/) const
     {
-        const LeafNodeT *refLeaf = mAcc.probeConstLeaf(leaf.origin());
+        const auto* refLeaf = mAcc.probeConstLeaf(leaf.origin());
         if (refLeaf) {
-            typename LeafNodeType::ValueOffIter iter = leaf.beginValueOff();
-            for ( ; iter; ++iter) {
-                const Index pos = iter.pos();
+            for (auto iter = leaf.beginValueOff(); iter; ++iter) {
+                const auto pos = iter.pos();
                 leaf.setActiveState(pos, math::isNegative(refLeaf->getValue(pos)));
             }
         }
@@ -118,10 +124,10 @@
 class CopyLeafNodes
 {
 public:
-    typedef typename TreeT::template ValueConverter<ValueMask>::Type MaskTreeT;
-    typedef tree::LeafManager<const MaskTreeT> MaskLeafManagerT;
+    using MaskTreeT = typename TreeT::template ValueConverter<MaskValueType>::Type;
+    using MaskLeafManagerT = tree::LeafManager<const MaskTreeT>;
 
-    CopyLeafNodes(const TreeT& tree, const MaskLeafManagerT& leafNodes);
+    CopyLeafNodes(const TreeT&, const MaskLeafManagerT&);
 
     void run(bool threaded = true);
 
@@ -170,23 +176,19 @@
 void
 CopyLeafNodes<TreeT>::operator()(const tbb::blocked_range<size_t>& range)
 {
-    typedef typename TreeT::LeafNodeType LeafT;
-    typedef typename MaskTree::LeafNodeType MaskLeafT;
-    typename MaskLeafT::ValueOnCIter it;
-
     tree::ValueAccessor<TreeT> acc(*mNewTree);
     tree::ValueAccessor<const TreeT> refAcc(*mTree);
 
-    for (size_t n = range.begin(); n != range.end(); ++n) {
-        const MaskLeafT& maskLeaf = mLeafNodes->leaf(n);
-        const Coord& ijk = maskLeaf.origin();
-        const LeafT* refLeaf = refAcc.probeConstLeaf(ijk);
+    for (auto n = range.begin(); n != range.end(); ++n) {
+        const auto& maskLeaf = mLeafNodes->leaf(n);
+        const auto& ijk = maskLeaf.origin();
+        const auto* refLeaf = refAcc.probeConstLeaf(ijk);
 
-        LeafT* newLeaf = acc.touchLeaf(ijk);
+        auto* newLeaf = acc.touchLeaf(ijk);
 
         if (refLeaf) {
-            for (it = maskLeaf.cbeginValueOn(); it; ++it) {
-                const Index pos = it.pos();
+            for (auto it = maskLeaf.cbeginValueOn(); it; ++it) {
+                const auto pos = it.pos();
                 newLeaf->setValueOnly(pos, refLeaf->getValue(pos));
                 newLeaf->setActiveState(pos, refLeaf->isValueOn(pos));
             }
@@ -194,8 +196,8 @@
             typename TreeT::ValueType value;
             bool isActive = refAcc.probeValue(ijk, value);
 
-            for (it = maskLeaf.cbeginValueOn(); it; ++it) {
-                const Index pos = it.pos();
+            for (auto it = maskLeaf.cbeginValueOn(); it; ++it) {
+                const auto pos = it.pos();
                 newLeaf->setValueOnly(pos, value);
                 newLeaf->setActiveState(pos, isActive);
             }
@@ -234,9 +236,9 @@
 template<typename FromGridT, typename ToGridT>
 struct ConvertGrid
 {
-    typedef typename FromGridT::Ptr FromGridPtrT;
-    typedef typename ToGridT::Ptr ToGridPtrT;
-    ToGridPtrT operator()(const FromGridPtrT& grid) { return ToGridPtrT(new ToGridT(*grid)); }
+    using FromGridCPtrT = typename FromGridT::ConstPtr;
+    using ToGridPtrT = typename ToGridT::Ptr;
+    ToGridPtrT operator()(const FromGridCPtrT& grid) { return ToGridPtrT(new ToGridT(*grid)); }
 };
 
 // Partial specialization that avoids copying when
@@ -244,34 +246,34 @@
 template<typename GridT>
 struct ConvertGrid<GridT, GridT>
 {
-    typedef typename GridT::Ptr GridPtrT;
-    GridPtrT operator()(const GridPtrT& grid) { return grid; }
+    using GridCPtrT = typename GridT::ConstPtr;
+    GridCPtrT operator()(const GridCPtrT& grid) { return grid; }
 };
 
 
 ////////////////////////////////////////
 
 
-// Convert a grid of arbitrary type to a mask grid and return a pointer to the new grid.
+// Convert a grid of arbitrary type to a mask grid with the same tree configuration
+// and return a pointer to the new grid.
+/// @private
 template<typename GridT>
-inline typename boost::disable_if<boost::is_same<ValueMask, typename GridT::BuildType>,
-    typename GridT::template ValueConverter<ValueMask>::Type::Ptr>::type
+inline typename std::enable_if<!std::is_same<MaskValueType, typename GridT::BuildType>::value,
+    typename GridT::template ValueConverter<MaskValueType>::Type::Ptr>::type
 convertToMaskGrid(const GridT& grid)
 {
-    typedef typename GridT::template ValueConverter<ValueMask>::Type MaskGridT;
-    typedef typename MaskGridT::Ptr MaskGridPtrT;
-
-    // Convert the input grid to a boolean mask grid (with the same tree configuration).
-    MaskGridPtrT mask = MaskGridT::create(/*background=*/false);
+    using MaskGridT = typename GridT::template ValueConverter<MaskValueType>::Type;
+    auto mask = MaskGridT::create(/*background=*/false);
     mask->topologyUnion(grid);
     mask->setTransform(grid.constTransform().copy());
     return mask;
 }
 
 // Overload that avoids any processing if the input grid is already a mask grid
+/// @private
 template<typename GridT>
-inline typename boost::enable_if<boost::is_same<ValueMask, typename GridT::BuildType>,
-                                 typename GridT::Ptr>::type
+inline typename std::enable_if<std::is_same<MaskValueType, typename GridT::BuildType>::value,
+    typename GridT::ConstPtr>::type
 convertToMaskGrid(const GridT& grid)
 {
     return grid.copy(); // shallow copy
@@ -281,26 +283,30 @@
 ////////////////////////////////////////
 
 
+/// @private
 template<typename GridType>
 inline typename GridType::Ptr
-doClip(const GridType& grid, const typename GridType::template ValueConverter<ValueMask>::Type& aMask)
+doClip(
+    const GridType& grid,
+    const typename GridType::template ValueConverter<MaskValueType>::Type& clipMask,
+    bool keepInterior)
 {
-    typedef typename GridType::TreeType TreeT;
-    typedef typename GridType::TreeType::template ValueConverter<ValueMask>::Type MaskTreeT;
+    using TreeT = typename GridType::TreeType;
+    using MaskTreeT = typename GridType::TreeType::template ValueConverter<MaskValueType>::Type;
 
-    const GridClass gridClass = grid.getGridClass();
-    const TreeT& tree = grid.tree();
+    const auto gridClass = grid.getGridClass();
+    const auto& tree = grid.tree();
 
-    MaskTreeT mask(false);
-    mask.topologyUnion(tree);
+    MaskTreeT gridMask(false);
+    gridMask.topologyUnion(tree);
 
     if (gridClass == GRID_LEVEL_SET) {
-        tree::LeafManager<MaskTreeT> leafNodes(mask);
+        tree::LeafManager<MaskTreeT> leafNodes(gridMask);
         leafNodes.foreach(MaskInteriorVoxels<TreeT>(tree));
 
         tree::ValueAccessor<const TreeT> acc(tree);
 
-        typename MaskTreeT::ValueAllIter iter(mask);
+        typename MaskTreeT::ValueAllIter iter(gridMask);
         iter.setMaxDepth(MaskTreeT::ValueAllIter::LEAF_DEPTH - 1);
 
         for ( ; iter; ++iter) {
@@ -308,12 +314,16 @@
         }
     }
 
-    mask.topologyIntersection(aMask.constTree());
+    if (keepInterior) {
+        gridMask.topologyIntersection(clipMask.constTree());
+    } else {
+        gridMask.topologyDifference(clipMask.constTree());
+    }
 
     typename GridType::Ptr outGrid;
     {
         // Copy voxel values and states.
-        tree::LeafManager<const MaskTreeT> leafNodes(mask);
+        tree::LeafManager<const MaskTreeT> leafNodes(gridMask);
         CopyLeafNodes<TreeT> maskOp(tree, leafNodes);
         maskOp.run();
         outGrid = GridType::create(maskOp.tree());
@@ -321,7 +331,7 @@
     {
         // Copy tile values and states.
         tree::ValueAccessor<const TreeT> refAcc(tree);
-        tree::ValueAccessor<const MaskTreeT> maskAcc(mask);
+        tree::ValueAccessor<const MaskTreeT> maskAcc(gridMask);
 
         typename TreeT::ValueAllIter it(outGrid->tree());
         it.setMaxDepth(TreeT::ValueAllIter::LEAF_DEPTH - 1);
@@ -350,12 +360,14 @@
 ////////////////////////////////////////
 
 
+/// @private
 template<typename GridType>
 OPENVDB_STATIC_SPECIALIZATION
 inline typename GridType::Ptr
-clip(const GridType& grid, const BBoxd& bbox)
+clip(const GridType& grid, const BBoxd& bbox, bool keepInterior)
 {
-    typedef typename GridType::template ValueConverter<ValueMask>::Type MaskGridT;
+    using MaskValueT = clip_internal::MaskValueType;
+    using MaskGridT = typename GridType::template ValueConverter<MaskValueT>::Type;
 
     // Transform the world-space bounding box into the source grid's index space.
     Vec3d idxMin, idxMax;
@@ -366,40 +378,39 @@
     MaskGridT clipMask(/*background=*/false);
     clipMask.fill(region, /*value=*/true, /*active=*/true);
 
-    return clip_internal::doClip(grid, clipMask);
+    return clip_internal::doClip(grid, clipMask, keepInterior);
 }
 
 
-template<typename GridType1, typename TreeType2>
+/// @private
+template<typename SrcGridType, typename ClipTreeType>
 OPENVDB_STATIC_SPECIALIZATION
-inline typename GridType1::Ptr
-clip(const GridType1& grid1, const Grid<TreeType2>& grid2)
+inline typename SrcGridType::Ptr
+clip(const SrcGridType& srcGrid, const Grid<ClipTreeType>& clipGrid, bool keepInterior)
 {
-    typedef typename GridType1::template ValueConverter<ValueMask>::Type MaskGridT1;
-    typedef typename MaskGridT1::Ptr MaskGridPtrT1;
-
-    typedef Grid<TreeType2> GridType2;
-    typedef typename GridType2::template ValueConverter<ValueMask>::Type MaskGridT2;
-    typedef typename MaskGridT2::Ptr MaskGridPtrT2;
-
-    // Convert the mask grid to a boolean grid with the same tree configuration.
-    MaskGridPtrT2 maskGrid = clip_internal::convertToMaskGrid( grid2 );
-
-    // Resample the boolean mask grid into the source grid's index space.
-    if (grid1.constTransform() != maskGrid->constTransform()) {
-        MaskGridPtrT2 resampledMask = MaskGridT2::create(/*background=*/false);
-        resampledMask->setTransform(grid1.constTransform().copy());
+    using MaskValueT = clip_internal::MaskValueType;
+    using ClipGridType = Grid<ClipTreeType>;
+    using SrcMaskGridType = typename SrcGridType::template ValueConverter<MaskValueT>::Type;
+    using ClipMaskGridType = typename ClipGridType::template ValueConverter<MaskValueT>::Type;
+
+    // Convert the clipping grid to a boolean-valued mask grid with the same tree configuration.
+    auto maskGrid = clip_internal::convertToMaskGrid(clipGrid);
+
+    // Resample the mask grid into the source grid's index space.
+    if (srcGrid.constTransform() != maskGrid->constTransform()) {
+        auto resampledMask = ClipMaskGridType::create(/*background=*/false);
+        resampledMask->setTransform(srcGrid.constTransform().copy());
         tools::resampleToMatch<clip_internal::BoolSampler>(*maskGrid, *resampledMask);
         tools::prune(resampledMask->tree());
         maskGrid = resampledMask;
     }
 
-    // Convert the bool mask grid to a bool grid of the same configuration as the source grid.
-    MaskGridPtrT1 clipMask =
-        clip_internal::ConvertGrid</*from=*/MaskGridT2, /*to=*/MaskGridT1>()( maskGrid );
+    // Convert the mask grid to a mask grid with the same tree configuration as the source grid.
+    auto clipMask = clip_internal::ConvertGrid<
+        /*from=*/ClipMaskGridType, /*to=*/SrcMaskGridType>()(maskGrid);
 
-    // Clip the source grid against the boolean mask grid.
-    return clip_internal::doClip(grid1, *clipMask);
+    // Clip the source grid against the mask grid.
+    return clip_internal::doClip(srcGrid, *clipMask, keepInterior);
 }
 
 } // namespace tools
diff -aur openvdb.3.2.0/tools/Dense.h openvdb.4.0.0/tools/Dense.h
--- openvdb.3.2.0/tools/Dense.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tools/Dense.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file Dense.h
 ///
 /// @brief This file defines a simple dense grid and efficient
@@ -41,10 +41,10 @@
 #include <openvdb/tree/ValueAccessor.h>
 #include <openvdb/Exceptions.h>
 #include <openvdb/util/Formats.h>
-#include <tbb/parallel_for.h>
-#include <boost/scoped_array.hpp>
-#include <boost/scoped_ptr.hpp>
 #include "Prune.h"
+#include <boost/scoped_array.hpp>
+#include <tbb/parallel_for.h>
+#include <memory>
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -206,10 +206,10 @@
 class Dense : public DenseBase<ValueT, Layout>
 {
 public:
-    typedef ValueT ValueType;
-    typedef DenseBase<ValueT, Layout> BaseT;
-    typedef boost::shared_ptr<Dense> Ptr;
-    typedef boost::shared_ptr<const Dense> ConstPtr;
+    using ValueType = ValueT;
+    using BaseT = DenseBase<ValueT, Layout>;
+    using Ptr = SharedPtr<Dense>;
+    using ConstPtr = SharedPtr<const Dense>;
 
     /// @brief Construct a dense grid with a given range of coordinates.
     ///
@@ -296,14 +296,16 @@
         mData[BaseT::coordToOffset(i,j,k)] = value;
     }
 
-    /// @brief Return a const reference to the value of the voxel at unsigned index coordinates (i, j, k).
+    /// @brief Return a const reference to the value of the voxel
+    /// at unsigned index coordinates (i, j, k).
     /// @note This is somewhat slower than using an array offset.
     inline const ValueT& getValue(size_t i, size_t j, size_t k) const
     {
         return mData[BaseT::coordToOffset(i,j,k)];
     }
 
-    /// @brief Return a non-const reference to the value of the voxel at unsigned index coordinates (i, j, k).
+    /// @brief Return a non-const reference to the value of the voxel
+    /// at unsigned index coordinates (i, j, k).
     /// @note This is somewhat slower than using an array offset.
     inline ValueT& getValue(size_t i, size_t j, size_t k)
     {
@@ -324,7 +326,8 @@
         return mData[this->coordToOffset(xyz)];
     }
 
-    /// @brief Return a non-const reference to the value of the voxel at the given signed coordinates.
+    /// @brief Return a non-const reference to the value of the voxel
+    /// at the given signed coordinates.
     /// @note This is slower than using either an array offset or unsigned index coordinates.
     inline ValueT& getValue(const Coord& xyz)
     {
@@ -377,11 +380,10 @@
         os << "  Number of voxels:       " << util::formattedInt(this->valueCount()) << "\n";
         os << "  Bounding box of voxels: " << BaseT::mBBox << "\n";
         os << "  Memory layout:          " << (Layout == LayoutZYX ? "ZYX (" : "XYZ (dis")
-           << "similar to VDB)\n";        
+           << "similar to VDB)\n";
     }
-    
-private:
 
+private:
     /// @brief Private method to initialize the dense value array.
     void init()
     {
@@ -409,9 +411,9 @@
 class CopyToDense
 {
 public:
-    typedef _DenseT                      DenseT;
-    typedef _TreeT                       TreeT;
-    typedef typename TreeT::ValueType    ValueT;
+    using DenseT = _DenseT;
+    using TreeT = _TreeT;
+    using ValueT = typename TreeT::ValueType;
 
     CopyToDense(const TreeT& tree, DenseT& dense)
         : mRoot(&(tree.root())), mDense(&dense) {}
@@ -442,8 +444,8 @@
 void
 copyToDense(const GridOrTreeT& sparse, DenseT& dense, bool serial)
 {
-    typedef TreeAdapter<GridOrTreeT> Adapter;
-    typedef typename Adapter::TreeType TreeT;
+    using Adapter = TreeAdapter<GridOrTreeT>;
+    using TreeT = typename Adapter::TreeType;
 
     CopyToDense<TreeT, DenseT> op(Adapter::constTree(sparse), dense);
     op.copy(serial);
@@ -466,18 +468,18 @@
 class CopyFromDense
 {
 public:
-    typedef _DenseT                      DenseT;
-    typedef _TreeT                       TreeT;
-    typedef typename TreeT::ValueType    ValueT;
-    typedef typename TreeT::LeafNodeType LeafT;
-    typedef tree::ValueAccessor<TreeT>   AccessorT;
+    using DenseT = _DenseT;
+    using TreeT = _TreeT;
+    using ValueT = typename TreeT::ValueType;
+    using LeafT = typename TreeT::LeafNodeType;
+    using AccessorT = tree::ValueAccessor<TreeT>;
 
     CopyFromDense(const DenseT& dense, TreeT& tree, const ValueT& tolerance)
         : mDense(&dense),
           mTree(&tree),
-          mBlocks(NULL),
+          mBlocks(nullptr),
           mTolerance(tolerance),
-          mAccessor(tree.empty() ? NULL : new AccessorT(tree))
+          mAccessor(tree.empty() ? nullptr : new AccessorT(tree))
     {
     }
     CopyFromDense(const CopyFromDense& other)
@@ -485,7 +487,7 @@
           mTree(other.mTree),
           mBlocks(other.mBlocks),
           mTolerance(other.mTolerance),
-          mAccessor(other.mAccessor.get() == NULL ? NULL : new AccessorT(*mTree))
+          mAccessor(other.mAccessor.get() == nullptr ? nullptr : new AccessorT(*mTree))
     {
     }
 
@@ -527,7 +529,7 @@
             }
         }
         delete mBlocks;
-        mBlocks = NULL;
+        mBlocks = nullptr;
 
         tools::pruneTiles(*mTree, mTolerance);//multi-threaded
     }
@@ -544,7 +546,7 @@
             Block& block = (*mBlocks)[m];
             const CoordBBox &bbox = block.bbox;
 
-            if (mAccessor.get() == NULL) {//i.e. empty target tree
+            if (mAccessor.get() == nullptr) {//i.e. empty target tree
                 leaf->fill(mTree->background(), false);
             } else {//account for existing leaf nodes in the target tree
                 if (const LeafT* target = mAccessor->probeConstLeaf(bbox.min())) {
@@ -573,14 +575,14 @@
         CoordBBox               bbox;
         LeafT*                  leaf;
         std::pair<ValueT, bool> tile;
-        Block(const CoordBBox& b) : bbox(b), leaf(NULL) {}
+        Block(const CoordBBox& b) : bbox(b), leaf(nullptr) {}
     };
 
-    const DenseT*                mDense;
-    TreeT*                       mTree;
-    std::vector<Block>*          mBlocks;
-    ValueT                       mTolerance;
-    boost::scoped_ptr<AccessorT> mAccessor;
+    const DenseT*              mDense;
+    TreeT*                     mTree;
+    std::vector<Block>*        mBlocks;
+    ValueT                     mTolerance;
+    std::unique_ptr<AccessorT> mAccessor;
 };// CopyFromDense
 
 
@@ -590,8 +592,8 @@
 copyFromDense(const DenseT& dense, GridOrTreeT& sparse,
     const typename GridOrTreeT::ValueType& tolerance, bool serial)
 {
-    typedef TreeAdapter<GridOrTreeT> Adapter;
-    typedef typename Adapter::TreeType TreeT;
+    using Adapter = TreeAdapter<GridOrTreeT>;
+    using TreeT = typename Adapter::TreeType;
 
     CopyFromDense<TreeT, DenseT> op(dense, Adapter::tree(sparse), tolerance);
     op.copy(serial);
diff -aur openvdb.3.2.0/tools/GridOperators.h openvdb.4.0.0/tools/GridOperators.h
--- openvdb.3.2.0/tools/GridOperators.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tools/GridOperators.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file GridOperators.h
 ///
 /// @brief Applies an operator on an input grid to produce an output
@@ -90,14 +90,14 @@
 typename ScalarToVectorConverter<GridType>::Type::Ptr
 cpt(const GridType& grid, bool threaded = true)
 {
-    return cpt<GridType, util::NullInterrupter>(grid, threaded, NULL);
+    return cpt<GridType, util::NullInterrupter>(grid, threaded, nullptr);
 }
 
 template<typename GridType, typename MaskT> inline
 typename ScalarToVectorConverter<GridType>::Type::Ptr
 cpt(const GridType& grid, const MaskT& mask, bool threaded = true)
 {
-    return cpt<GridType, MaskT, util::NullInterrupter>(grid, mask, threaded, NULL);
+    return cpt<GridType, MaskT, util::NullInterrupter>(grid, mask, threaded, nullptr);
 }
 
 
@@ -118,14 +118,14 @@
 typename GridType::Ptr
 curl(const GridType& grid, bool threaded = true)
 {
-    return curl<GridType, util::NullInterrupter>(grid, threaded, NULL);
+    return curl<GridType, util::NullInterrupter>(grid, threaded, nullptr);
 }
 
 template<typename GridType, typename MaskT> inline
 typename GridType::Ptr
 curl(const GridType& grid, const MaskT& mask, bool threaded = true)
 {
-    return curl<GridType, MaskT, util::NullInterrupter>(grid, mask, threaded, NULL);
+    return curl<GridType, MaskT, util::NullInterrupter>(grid, mask, threaded, nullptr);
 }
 
 
@@ -147,14 +147,14 @@
 typename VectorToScalarConverter<GridType>::Type::Ptr
 divergence(const GridType& grid, bool threaded = true)
 {
-    return divergence<GridType, util::NullInterrupter>(grid, threaded, NULL);
+    return divergence<GridType, util::NullInterrupter>(grid, threaded, nullptr);
 }
 
 template<typename GridType, typename MaskT> inline
 typename VectorToScalarConverter<GridType>::Type::Ptr
 divergence(const GridType& grid, const MaskT& mask, bool threaded = true)
 {
-    return divergence<GridType, MaskT, util::NullInterrupter>(grid, mask, threaded, NULL);
+    return divergence<GridType, MaskT, util::NullInterrupter>(grid, mask, threaded, nullptr);
 }
 
 
@@ -176,14 +176,14 @@
 typename ScalarToVectorConverter<GridType>::Type::Ptr
 gradient(const GridType& grid, bool threaded = true)
 {
-    return gradient<GridType, util::NullInterrupter>(grid, threaded, NULL);
+    return gradient<GridType, util::NullInterrupter>(grid, threaded, nullptr);
 }
 
 template<typename GridType, typename MaskT> inline
 typename ScalarToVectorConverter<GridType>::Type::Ptr
 gradient(const GridType& grid, const MaskT& mask, bool threaded = true)
 {
-    return gradient<GridType, MaskT, util::NullInterrupter>(grid, mask, threaded, NULL);
+    return gradient<GridType, MaskT, util::NullInterrupter>(grid, mask, threaded, nullptr);
 }
 
 
@@ -204,14 +204,14 @@
 typename GridType::Ptr
 laplacian(const GridType& grid, bool threaded = true)
 {
-    return laplacian<GridType, util::NullInterrupter>(grid, threaded, NULL);
+    return laplacian<GridType, util::NullInterrupter>(grid, threaded, nullptr);
 }
 
 template<typename GridType, typename MaskT> inline
 typename GridType::Ptr
 laplacian(const GridType& grid, const MaskT mask, bool threaded = true)
 {
-    return laplacian<GridType, MaskT, util::NullInterrupter>(grid, mask, threaded, NULL);
+    return laplacian<GridType, MaskT, util::NullInterrupter>(grid, mask, threaded, nullptr);
 }
 
 
@@ -232,14 +232,14 @@
 typename GridType::Ptr
 meanCurvature(const GridType& grid, bool threaded = true)
 {
-    return meanCurvature<GridType, util::NullInterrupter>(grid, threaded, NULL);
+    return meanCurvature<GridType, util::NullInterrupter>(grid, threaded, nullptr);
 }
 
 template<typename GridType, typename MaskT> inline
 typename GridType::Ptr
 meanCurvature(const GridType& grid, const MaskT& mask, bool threaded = true)
 {
-    return meanCurvature<GridType, MaskT, util::NullInterrupter>(grid, mask, threaded, NULL);
+    return meanCurvature<GridType, MaskT, util::NullInterrupter>(grid, mask, threaded, nullptr);
 }
 
 
@@ -261,14 +261,14 @@
 typename VectorToScalarConverter<GridType>::Type::Ptr
 magnitude(const GridType& grid, bool threaded = true)
 {
-    return magnitude<GridType, util::NullInterrupter>(grid, threaded, NULL);
+    return magnitude<GridType, util::NullInterrupter>(grid, threaded, nullptr);
 }
 
 template<typename GridType, typename MaskT> inline
 typename VectorToScalarConverter<GridType>::Type::Ptr
 magnitude(const GridType& grid, const MaskT& mask, bool threaded = true)
 {
-    return magnitude<GridType, MaskT, util::NullInterrupter>(grid, mask, threaded, NULL);
+    return magnitude<GridType, MaskT, util::NullInterrupter>(grid, mask, threaded, nullptr);
 }
 
 
@@ -289,14 +289,14 @@
 typename GridType::Ptr
 normalize(const GridType& grid, bool threaded = true)
 {
-    return normalize<GridType, util::NullInterrupter>(grid, threaded, NULL);
+    return normalize<GridType, util::NullInterrupter>(grid, threaded, nullptr);
 }
 
 template<typename GridType, typename MaskT> inline
 typename GridType::Ptr
 normalize(const GridType& grid, const MaskT& mask, bool threaded = true)
 {
-    return normalize<GridType, MaskT, util::NullInterrupter>(grid, mask, threaded, NULL);
+    return normalize<GridType, MaskT, util::NullInterrupter>(grid, mask, threaded, nullptr);
 }
 
 
@@ -338,12 +338,14 @@
     typedef typename tree::LeafManager<OutTreeT>  LeafManagerT;
 
     GridOperator(const InGridT& grid, const MaskGridType* mask, const MapT& map,
-        InterruptT* interrupt = NULL):
+        InterruptT* interrupt = nullptr):
         mAcc(grid.getConstAccessor()), mMap(map), mInterrupt(interrupt), mMask(mask)
     {
     }
+    GridOperator(const GridOperator&) = default;
+    GridOperator& operator=(const GridOperator&) = default;
+    virtual ~GridOperator() = default;
 
-    virtual ~GridOperator() {}
     typename OutGridT::Ptr process(bool threaded = true)
     {
         if (mInterrupt) mInterrupt->start("Processing grid");
@@ -421,12 +423,12 @@
     typedef InGridT                                         InGridType;
     typedef typename ScalarToVectorConverter<InGridT>::Type OutGridType;
 
-    Cpt(const InGridType& grid, InterruptT* interrupt = NULL):
-        mInputGrid(grid), mInterrupt(interrupt), mMask(NULL)
+    Cpt(const InGridType& grid, InterruptT* interrupt = nullptr):
+        mInputGrid(grid), mInterrupt(interrupt), mMask(nullptr)
     {
     }
 
-    Cpt(const InGridType& grid, const MaskGridType& mask, InterruptT* interrupt = NULL):
+    Cpt(const InGridType& grid, const MaskGridType& mask, InterruptT* interrupt = nullptr):
         mInputGrid(grid), mInterrupt(interrupt), mMask(&mask)
     {
     }
@@ -509,12 +511,12 @@
     typedef GridT  InGridType;
     typedef GridT  OutGridType;
 
-    Curl(const GridT& grid, InterruptT* interrupt = NULL):
-        mInputGrid(grid), mInterrupt(interrupt), mMask(NULL)
+    Curl(const GridT& grid, InterruptT* interrupt = nullptr):
+        mInputGrid(grid), mInterrupt(interrupt), mMask(nullptr)
     {
     }
 
-    Curl(const GridT& grid, const MaskGridType& mask, InterruptT* interrupt = NULL):
+    Curl(const GridT& grid, const MaskGridType& mask, InterruptT* interrupt = nullptr):
         mInputGrid(grid), mInterrupt(interrupt), mMask(&mask)
     {
     }
@@ -570,12 +572,12 @@
     typedef InGridT                                         InGridType;
     typedef typename VectorToScalarConverter<InGridT>::Type OutGridType;
 
-    Divergence(const InGridT& grid, InterruptT* interrupt = NULL):
-        mInputGrid(grid), mInterrupt(interrupt), mMask(NULL)
+    Divergence(const InGridT& grid, InterruptT* interrupt = nullptr):
+        mInputGrid(grid), mInterrupt(interrupt), mMask(nullptr)
     {
     }
 
-    Divergence(const InGridT& grid, const MaskGridType& mask, InterruptT* interrupt = NULL):
+    Divergence(const InGridT& grid, const MaskGridType& mask, InterruptT* interrupt = nullptr):
         mInputGrid(grid), mInterrupt(interrupt), mMask(&mask)
     {
     }
@@ -637,12 +639,12 @@
     typedef InGridT                                         InGridType;
     typedef typename ScalarToVectorConverter<InGridT>::Type OutGridType;
 
-    Gradient(const InGridT& grid, InterruptT* interrupt = NULL):
-        mInputGrid(grid), mInterrupt(interrupt), mMask(NULL)
+    Gradient(const InGridT& grid, InterruptT* interrupt = nullptr):
+        mInputGrid(grid), mInterrupt(interrupt), mMask(nullptr)
     {
     }
 
-    Gradient(const InGridT& grid, const MaskGridType& mask, InterruptT* interrupt = NULL):
+    Gradient(const InGridT& grid, const MaskGridType& mask, InterruptT* interrupt = nullptr):
         mInputGrid(grid), mInterrupt(interrupt), mMask(&mask)
     {
     }
@@ -697,12 +699,12 @@
     typedef GridT  InGridType;
     typedef GridT  OutGridType;
 
-    Laplacian(const GridT& grid, InterruptT* interrupt = NULL):
-        mInputGrid(grid), mInterrupt(interrupt), mMask(NULL)
+    Laplacian(const GridT& grid, InterruptT* interrupt = nullptr):
+        mInputGrid(grid), mInterrupt(interrupt), mMask(nullptr)
     {
     }
 
-    Laplacian(const GridT& grid, const MaskGridType& mask, InterruptT* interrupt = NULL):
+    Laplacian(const GridT& grid, const MaskGridType& mask, InterruptT* interrupt = nullptr):
         mInputGrid(grid), mInterrupt(interrupt), mMask(&mask)
     {
     }
@@ -756,12 +758,12 @@
     typedef GridT  InGridType;
     typedef GridT  OutGridType;
 
-    MeanCurvature(const GridT& grid, InterruptT* interrupt = NULL):
-        mInputGrid(grid), mInterrupt(interrupt), mMask(NULL)
+    MeanCurvature(const GridT& grid, InterruptT* interrupt = nullptr):
+        mInputGrid(grid), mInterrupt(interrupt), mMask(nullptr)
     {
     }
 
-    MeanCurvature(const GridT& grid, const MaskGridType& mask, InterruptT* interrupt = NULL):
+    MeanCurvature(const GridT& grid, const MaskGridType& mask, InterruptT* interrupt = nullptr):
         mInputGrid(grid), mInterrupt(interrupt), mMask(&mask)
     {
     }
@@ -815,12 +817,12 @@
     typedef InGridT                                         InGridType;
     typedef typename VectorToScalarConverter<InGridT>::Type OutGridType;
 
-    Magnitude(const InGridType& grid, InterruptT* interrupt = NULL):
-        mInputGrid(grid), mInterrupt(interrupt), mMask(NULL)
+    Magnitude(const InGridType& grid, InterruptT* interrupt = nullptr):
+        mInputGrid(grid), mInterrupt(interrupt), mMask(nullptr)
     {
     }
 
-    Magnitude(const InGridType& grid, const MaskGridType& mask, InterruptT* interrupt = NULL):
+    Magnitude(const InGridType& grid, const MaskGridType& mask, InterruptT* interrupt = nullptr):
         mInputGrid(grid), mInterrupt(interrupt), mMask(&mask)
     {
     }
@@ -879,12 +881,12 @@
     typedef GridT  InGridType;
     typedef GridT  OutGridType;
 
-    Normalize(const GridT& grid, InterruptT* interrupt = NULL):
-        mInputGrid(grid), mInterrupt(interrupt), mMask(NULL)
+    Normalize(const GridT& grid, InterruptT* interrupt = nullptr):
+        mInputGrid(grid), mInterrupt(interrupt), mMask(nullptr)
     {
     }
 
-    Normalize(const GridT& grid, const MaskGridType& mask, InterruptT* interrupt = NULL):
+    Normalize(const GridT& grid, const MaskGridType& mask, InterruptT* interrupt = nullptr):
         mInputGrid(grid), mInterrupt(interrupt), mMask(&mask)
     {
     }
diff -aur openvdb.3.2.0/tools/GridTransformer.h openvdb.4.0.0/tools/GridTransformer.h
--- openvdb.3.2.0/tools/GridTransformer.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tools/GridTransformer.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,19 +27,13 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file GridTransformer.h
 /// @author Peter Cucka
 
 #ifndef OPENVDB_TOOLS_GRIDTRANSFORMER_HAS_BEEN_INCLUDED
 #define OPENVDB_TOOLS_GRIDTRANSFORMER_HAS_BEEN_INCLUDED
 
-#include <cmath>
-#include <boost/bind.hpp>
-#include <boost/function.hpp>
-#include <boost/shared_ptr.hpp>
-#include <tbb/blocked_range.h>
-#include <tbb/parallel_reduce.h>
 #include <openvdb/Grid.h>
 #include <openvdb/Types.h>
 #include <openvdb/math/Math.h> // for isApproxEqual()
@@ -49,6 +43,10 @@
 #include "LevelSetRebuild.h" // for doLevelSetRebuild()
 #include "SignedFloodFill.h" // for signedFloodFill
 #include "Prune.h" // for pruneLevelSet
+#include <tbb/blocked_range.h>
+#include <tbb/parallel_reduce.h>
+#include <cmath>
+#include <functional>
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -120,7 +118,7 @@
 class TileSampler: public Sampler
 {
 public:
-    typedef typename TreeT::ValueType ValueT;
+    using ValueT = typename TreeT::ValueType;
 
     /// @param b        the index-space bounding box of a particular grid tile
     /// @param tileVal  the tile's value
@@ -187,8 +185,8 @@
 class GridResampler
 {
 public:
-    typedef boost::shared_ptr<GridResampler> Ptr;
-    typedef boost::function<bool (void)> InterruptFunc;
+    using Ptr = SharedPtr<GridResampler>;
+    using InterruptFunc = std::function<bool (void)>;
 
     GridResampler(): mThreaded(true), mTransformTiles(true) {}
     virtual ~GridResampler() {}
@@ -255,7 +253,7 @@
 class GridTransformer: public GridResampler
 {
 public:
-    typedef boost::shared_ptr<GridTransformer> Ptr;
+    using Ptr = SharedPtr<GridTransformer>;
 
     GridTransformer(const Mat4R& xform);
     GridTransformer(
@@ -265,7 +263,7 @@
         const Vec3R& translate,
         const std::string& xformOrder = "tsr",
         const std::string& rotationOrder = "zyx");
-    virtual ~GridTransformer() {}
+    ~GridTransformer() override = default;
 
     const Mat4R& getTransform() const { return mTransform; }
 
@@ -491,7 +489,7 @@
 
         // If the output grid is a level set, resample the input grid to have the output grid's
         // background value.  Otherwise, preserve the input grid's background value.
-        typedef typename GridType::ValueType ValueT;
+        using ValueT = typename GridType::ValueType;
         const ValueT halfWidth = ((outGrid.getGridClass() == openvdb::GRID_LEVEL_SET)
             ? ValueT(outGrid.background() * (1.0 / outGrid.voxelSize()[0]))
             : ValueT(inGrid.background() * (1.0 / inGrid.voxelSize()[0])));
@@ -673,7 +671,7 @@
 void
 GridResampler::setInterrupter(InterrupterType& interrupter)
 {
-    mInterrupt = boost::bind(&InterrupterType::wasInterrupted,
+    mInterrupt = std::bind(&InterrupterType::wasInterrupted,
         /*this=*/&interrupter, /*percent=*/-1);
 }
 
@@ -756,12 +754,12 @@
 class GridResampler::RangeProcessor
 {
 public:
-    typedef typename TreeT::LeafCIter LeafIterT;
-    typedef typename TreeT::ValueAllCIter TileIterT;
-    typedef typename tree::IteratorRange<LeafIterT> LeafRange;
-    typedef typename tree::IteratorRange<TileIterT> TileRange;
-    typedef typename tree::ValueAccessor<const TreeT> InTreeAccessor;
-    typedef typename tree::ValueAccessor<TreeT> OutTreeAccessor;
+    using LeafIterT = typename TreeT::LeafCIter;
+    using TileIterT = typename TreeT::ValueAllCIter;
+    using LeafRange = typename tree::IteratorRange<LeafIterT>;
+    using TileRange = typename tree::IteratorRange<TileIterT>;
+    using InTreeAccessor = typename tree::ValueAccessor<const TreeT>;
+    using OutTreeAccessor = typename tree::ValueAccessor<TreeT>;
 
     RangeProcessor(const Transformer& xform, const CoordBBox& b, const TreeT& inT, TreeT& outT):
         mIsRoot(true), mXform(xform), mBBox(b),
@@ -868,11 +866,11 @@
 GridResampler::applyTransform(const Transformer& xform,
     const GridT& inGrid, GridT& outGrid) const
 {
-    typedef typename GridT::TreeType TreeT;
+    using TreeT = typename GridT::TreeType;
     const TreeT& inTree = inGrid.tree();
     TreeT& outTree = outGrid.tree();
 
-    typedef RangeProcessor<Sampler, TreeT, Transformer> RangeProc;
+    using RangeProc = RangeProcessor<Sampler, TreeT, Transformer>;
 
     const GridClass gridClass = inGrid.getGridClass();
 
@@ -937,7 +935,7 @@
     const InterruptFunc& interrupt,
     const Sampler& sampler)
 {
-    typedef typename OutTreeT::ValueType ValueT;
+    using ValueT = typename OutTreeT::ValueType;
 
     // Transform the corners of the input tree's bounding box
     // and compute the enclosing bounding box in the output tree.
diff -aur openvdb.3.2.0/tools/Interpolation.h openvdb.4.0.0/tools/Interpolation.h
--- openvdb.3.2.0/tools/Interpolation.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tools/Interpolation.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file Interpolation.h
 ///
 /// Sampler classes such as PointSampler and BoxSampler that are intended for use
@@ -67,14 +67,14 @@
 #ifndef OPENVDB_TOOLS_INTERPOLATION_HAS_BEEN_INCLUDED
 #define OPENVDB_TOOLS_INTERPOLATION_HAS_BEEN_INCLUDED
 
-#include <cmath>
-#include <boost/shared_ptr.hpp>
 #include <openvdb/version.h> // for OPENVDB_VERSION_NAME
 #include <openvdb/Platform.h> // for round()
 #include <openvdb/math/Math.h>// for SmoothUnitStep
 #include <openvdb/math/Transform.h> // for Transform
 #include <openvdb/Grid.h>
 #include <openvdb/tree/ValueAccessor.h>
+#include <cmath>
+#include <type_traits>
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -89,7 +89,7 @@
 template <size_t Order, bool Staggered = false>
 struct Sampler
 {
-    BOOST_STATIC_ASSERT(Order < 3);
+    static_assert(Order < 3, "Samplers of order higher than 2 are not supported");
     static const char* name();
     static int radius();
     static bool mipmap();
@@ -165,7 +165,7 @@
     static typename TreeT::ValueType sample(const TreeT& inTree, const Vec3R& inCoord);
 
     /// @brief Import all eight values from @a inTree to support
-    /// tri-linear interpolation. 
+    /// tri-linear interpolation.
     template<class ValueT, class TreeT, size_t N>
     static inline void getValues(ValueT (&data)[N][N][N], const TreeT& inTree, Coord ijk);
 
@@ -310,11 +310,11 @@
 class GridSampler
 {
 public:
-    typedef boost::shared_ptr<GridSampler>                      Ptr;
-    typedef typename GridOrTreeType::ValueType                  ValueType;
-    typedef typename TreeAdapter<GridOrTreeType>::GridType      GridType;
-    typedef typename TreeAdapter<GridOrTreeType>::TreeType      TreeType;
-    typedef typename TreeAdapter<GridOrTreeType>::AccessorType  AccessorType;
+    using Ptr = SharedPtr<GridSampler>;
+    using ValueType = typename GridOrTreeType::ValueType;
+    using GridType = typename TreeAdapter<GridOrTreeType>::GridType;
+    using TreeType = typename TreeAdapter<GridOrTreeType>::TreeType;
+    using AccessorType = typename TreeAdapter<GridOrTreeType>::AccessorType;
 
      /// @param grid  a grid to be sampled
     explicit GridSampler(const GridType& grid)
@@ -392,11 +392,11 @@
 class GridSampler<tree::ValueAccessor<TreeT>, SamplerType>
 {
 public:
-    typedef boost::shared_ptr<GridSampler>      Ptr;
-    typedef typename TreeT::ValueType           ValueType;
-    typedef TreeT                               TreeType;
-    typedef Grid<TreeType>                      GridType;
-    typedef typename tree::ValueAccessor<TreeT> AccessorType;
+    using Ptr = SharedPtr<GridSampler>;
+    using ValueType = typename TreeT::ValueType;
+    using TreeType = TreeT;
+    using GridType = Grid<TreeType>;
+    using AccessorType = typename tree::ValueAccessor<TreeT>;
 
     /// @param acc  a ValueAccessor to be sampled
     /// @param transform is used when sampling world space locations.
@@ -472,10 +472,10 @@
 class DualGridSampler
 {
 public:
-    typedef typename GridOrTreeT::ValueType               ValueType;
-    typedef typename TreeAdapter<GridOrTreeT>::GridType   GridType;
-    typedef typename TreeAdapter<GridOrTreeT>::TreeType   TreeType;
-    typedef typename TreeAdapter<GridType>::AccessorType  AccessorType;
+    using ValueType = typename GridOrTreeT::ValueType;
+    using GridType = typename TreeAdapter<GridOrTreeT>::GridType;
+    using TreeType = typename TreeAdapter<GridOrTreeT>::TreeType;
+    using AccessorType = typename TreeAdapter<GridType>::AccessorType;
 
     /// @brief Grid and transform constructor.
     /// @param sourceGrid Source grid.
@@ -524,10 +524,10 @@
 class DualGridSampler<tree::ValueAccessor<TreeT>, SamplerT>
 {
     public:
-    typedef typename TreeT::ValueType ValueType;
-    typedef TreeT                     TreeType;
-    typedef Grid<TreeType>            GridType;
-    typedef typename tree::ValueAccessor<TreeT> AccessorType;
+    using ValueType = typename TreeT::ValueType;
+    using TreeType = TreeT;
+    using GridType = Grid<TreeType>;
+    using AccessorType = typename tree::ValueAccessor<TreeT>;
 
     /// @brief ValueAccessor and transform constructor.
     /// @param sourceAccessor ValueAccessor into the source grid.
@@ -570,11 +570,12 @@
 class AlphaMask
 {
 public:
-    BOOST_STATIC_ASSERT(boost::is_floating_point<FloatT>::value);
-    typedef GridT    GridType;
-    typedef MaskT    MaskType;
-    typedef SamplerT SamlerType;
-    typedef FloatT   FloatType;
+    static_assert(std::is_floating_point<FloatT>::value,
+        "AlphaMask requires a floating-point value type");
+    using GridType = GridT;
+    using MaskType = MaskT;
+    using SamlerType = SamplerT;
+    using FloatType = FloatT;
 
     AlphaMask(const GridT& grid, const MaskT& mask, FloatT min, FloatT max, bool invert)
         : mAcc(mask.tree())
@@ -595,7 +596,7 @@
     }
 
 protected:
-    typedef typename MaskType::ConstAccessor AccT;
+    using AccT = typename MaskType::ConstAccessor;
     AccT mAcc;
     tools::DualGridSampler<AccT, SamplerT> mSampler;
     const FloatT mMin, mInvNorm;
@@ -762,7 +763,7 @@
 BoxSampler::sample(const TreeT& inTree, const Vec3R& inCoord,
                    typename TreeT::ValueType& result)
 {
-    typedef typename TreeT::ValueType ValueT;
+    using ValueT = typename TreeT::ValueType;
 
     const Vec3i inIdx = local_util::floorVec3(inCoord);
     const Vec3R uvw = inCoord - inIdx;
@@ -783,7 +784,7 @@
 inline typename TreeT::ValueType
 BoxSampler::sample(const TreeT& inTree, const Vec3R& inCoord)
 {
-    typedef typename TreeT::ValueType ValueT;
+    using ValueT = typename TreeT::ValueType;
 
     const Vec3i inIdx = local_util::floorVec3(inCoord);
     const Vec3R uvw = inCoord - inIdx;
@@ -793,7 +794,7 @@
     ValueT data[2][2][2];
 
     BoxSampler::getValues(data, inTree, Coord(inIdx));
-   
+
     return BoxSampler::trilinearInterpolation(data, uvw);
 }
 
@@ -849,7 +850,7 @@
 QuadraticSampler::sample(const TreeT& inTree, const Vec3R& inCoord,
     typename TreeT::ValueType& result)
 {
-    typedef typename TreeT::ValueType ValueT;
+    using ValueT = typename TreeT::ValueType;
 
     const Vec3i inIdx = local_util::floorVec3(inCoord), inLoIdx = inIdx - Vec3i(1, 1, 1);
     const Vec3R uvw = inCoord - inIdx;
@@ -875,7 +876,7 @@
 inline typename TreeT::ValueType
 QuadraticSampler::sample(const TreeT& inTree, const Vec3R& inCoord)
 {
-    typedef typename TreeT::ValueType ValueT;
+    using ValueT = typename TreeT::ValueType;
 
     const Vec3i inIdx = local_util::floorVec3(inCoord), inLoIdx = inIdx - Vec3i(1, 1, 1);
     const Vec3R uvw = inCoord - inIdx;
@@ -903,7 +904,7 @@
 StaggeredPointSampler::sample(const TreeT& inTree, const Vec3R& inCoord,
                               typename TreeT::ValueType& result)
 {
-    typedef typename TreeT::ValueType ValueType;
+    using ValueType = typename TreeT::ValueType;
 
     ValueType tempX, tempY, tempZ;
     bool active = false;
@@ -923,7 +924,7 @@
 inline typename TreeT::ValueType
 StaggeredPointSampler::sample(const TreeT& inTree, const Vec3R& inCoord)
 {
-    typedef typename TreeT::ValueType ValueT;
+    using ValueT = typename TreeT::ValueType;
 
     const ValueT tempX = PointSampler::sample<TreeT>(inTree, inCoord + Vec3R(0.5, 0.0, 0.0));
     const ValueT tempY = PointSampler::sample<TreeT>(inTree, inCoord + Vec3R(0.0, 0.5, 0.0));
@@ -941,7 +942,7 @@
 StaggeredBoxSampler::sample(const TreeT& inTree, const Vec3R& inCoord,
                             typename TreeT::ValueType& result)
 {
-    typedef typename TreeT::ValueType ValueType;
+    using ValueType = typename TreeT::ValueType;
 
     ValueType tempX, tempY, tempZ;
     tempX = tempY = tempZ = zeroVal<ValueType>();
@@ -962,7 +963,7 @@
 inline typename TreeT::ValueType
 StaggeredBoxSampler::sample(const TreeT& inTree, const Vec3R& inCoord)
 {
-    typedef typename TreeT::ValueType ValueT;
+    using ValueT = typename TreeT::ValueType;
 
     const ValueT tempX = BoxSampler::sample<TreeT>(inTree, inCoord + Vec3R(0.5, 0.0, 0.0));
     const ValueT tempY = BoxSampler::sample<TreeT>(inTree, inCoord + Vec3R(0.0, 0.5, 0.0));
@@ -980,7 +981,7 @@
 StaggeredQuadraticSampler::sample(const TreeT& inTree, const Vec3R& inCoord,
     typename TreeT::ValueType& result)
 {
-    typedef typename TreeT::ValueType ValueType;
+    using ValueType = typename TreeT::ValueType;
 
     ValueType tempX, tempY, tempZ;
     bool active = false;
@@ -1000,7 +1001,7 @@
 inline typename TreeT::ValueType
 StaggeredQuadraticSampler::sample(const TreeT& inTree, const Vec3R& inCoord)
 {
-    typedef typename TreeT::ValueType ValueT;
+    using ValueT = typename TreeT::ValueType;
 
     const ValueT tempX = QuadraticSampler::sample<TreeT>(inTree, inCoord + Vec3R(0.5, 0.0, 0.0));
     const ValueT tempY = QuadraticSampler::sample<TreeT>(inTree, inCoord + Vec3R(0.0, 0.5, 0.0));
diff -aur openvdb.3.2.0/tools/LevelSetAdvect.h openvdb.4.0.0/tools/LevelSetAdvect.h
--- openvdb.3.2.0/tools/LevelSetAdvect.h	2016-05-29 16:45:07.000000000 +0200
+++ openvdb.4.0.0/tools/LevelSetAdvect.h	2016-10-09 10:18:58.000000000 +0200
@@ -46,7 +46,7 @@
 #include "VelocityFields.h" // for EnrightField
 #include <openvdb/math/FiniteDifference.h>
 #include <boost/math/constants/constants.hpp>
-#include <openvdb/util/CpuTimer.h>
+//#include <openvdb/util/CpuTimer.h>
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -76,7 +76,7 @@
 /// typically depends on the transformation of that grid. This design
 /// is chosen for performance reasons. Finally we will assume that the
 /// functor method is NOT threadsafe (typically uses a ValueAccessor)
-/// and that its lightweight enough that we can copy it per thread.    
+/// and that its lightweight enough that we can copy it per thread.
 ///
 /// The @c InterruptType template argument below refers to any class
 /// with the following interface:
@@ -117,34 +117,41 @@
 
     virtual ~LevelSetAdvection() {}
 
-    /// @return the spatial finite difference scheme
+    /// @brief Return the spatial finite difference scheme
     math::BiasedGradientScheme getSpatialScheme() const { return mSpatialScheme; }
     /// @brief Set the spatial finite difference scheme
     void setSpatialScheme(math::BiasedGradientScheme scheme) { mSpatialScheme = scheme; }
 
-    /// @return the temporal integration scheme
+    /// @brief Return the temporal integration scheme
     math::TemporalIntegrationScheme getTemporalScheme() const { return mTemporalScheme; }
     /// @brief Set the spatial finite difference scheme
     void setTemporalScheme(math::TemporalIntegrationScheme scheme) { mTemporalScheme = scheme; }
 
-    /// @return the spatial finite difference scheme
-    math::BiasedGradientScheme getTrackerSpatialScheme() const { return mTracker.getSpatialScheme(); }
+    /// @brief Return the spatial finite difference scheme
+    math::BiasedGradientScheme getTrackerSpatialScheme() const {
+        return mTracker.getSpatialScheme();
+    }
     /// @brief Set the spatial finite difference scheme
-    void setTrackerSpatialScheme(math::BiasedGradientScheme scheme) { mTracker.setSpatialScheme(scheme); }
-
-    /// @return the temporal integration scheme
-    math::TemporalIntegrationScheme getTrackerTemporalScheme() const { return mTracker.getTemporalScheme(); }
+    void setTrackerSpatialScheme(math::BiasedGradientScheme scheme) {
+        mTracker.setSpatialScheme(scheme);
+    }
+    /// @brief Return the temporal integration scheme
+    math::TemporalIntegrationScheme getTrackerTemporalScheme() const {
+        return mTracker.getTemporalScheme();
+    }
     /// @brief Set the spatial finite difference scheme
-    void setTrackerTemporalScheme(math::TemporalIntegrationScheme scheme) { mTracker.setTemporalScheme(scheme); }
+    void setTrackerTemporalScheme(math::TemporalIntegrationScheme scheme) {
+        mTracker.setTemporalScheme(scheme);
+    }
 
-    /// @return The number of normalizations performed per track or
+    /// @brief Return The number of normalizations performed per track or
     /// normalize call.
     int  getNormCount() const { return mTracker.getNormCount(); }
     /// @brief Set the number of normalizations performed per track or
     /// normalize call.
     void setNormCount(int n) { mTracker.setNormCount(n); }
 
-    /// @return the grain-size used for multi-threading
+    /// @brief Return the grain-size used for multi-threading
     int  getGrainSize() const { return mTracker.getGrainSize(); }
     /// @brief Set the grain-size used for multi-threading.
     /// @note A grain size of 0 or less disables multi-threading!
@@ -157,7 +164,6 @@
     size_t advect(ValueType time0, ValueType time1);
 
 private:
-
     // disallow copy construction and copy by assinment!
     LevelSetAdvection(const LevelSetAdvection&);// not implemented
     LevelSetAdvection& operator=(const LevelSetAdvection&);// not implemented
@@ -212,7 +218,7 @@
         typename boost::function<void (Advect*, const LeafRange&)> mTask;
         const bool         mIsMaster;
     }; // end of private Advect struct
-    
+
     template<math::BiasedGradientScheme SpatialScheme>
     size_t advect1(ValueType time0, ValueType time1);
 
@@ -233,6 +239,7 @@
 
 };//end of LevelSetAdvection
 
+
 template<typename GridT, typename FieldT, typename InterruptT>
 inline size_t
 LevelSetAdvection<GridT, FieldT, InterruptT>::advect(ValueType time0, ValueType time1)
@@ -254,6 +261,7 @@
     return 0;
 }
 
+
 template<typename GridT, typename FieldT, typename InterruptT>
 template<math::BiasedGradientScheme SpatialScheme>
 inline size_t
@@ -272,9 +280,9 @@
     return 0;
 }
 
+
 template<typename GridT, typename FieldT, typename InterruptT>
-template<math::BiasedGradientScheme SpatialScheme,
-         math::TemporalIntegrationScheme TemporalScheme>
+template<math::BiasedGradientScheme SpatialScheme, math::TemporalIntegrationScheme TemporalScheme>
 inline size_t
 LevelSetAdvection<GridT, FieldT, InterruptT>::advect2(ValueType time0, ValueType time1)
 {
@@ -282,7 +290,8 @@
     if (trans.mapType() == math::UniformScaleMap::mapType()) {
         return this->advect3<SpatialScheme, TemporalScheme, math::UniformScaleMap>(time0, time1);
     } else if (trans.mapType() == math::UniformScaleTranslateMap::mapType()) {
-        return this->advect3<SpatialScheme, TemporalScheme, math::UniformScaleTranslateMap>(time0, time1);
+        return this->advect3<SpatialScheme, TemporalScheme, math::UniformScaleTranslateMap>(
+            time0, time1);
     } else if (trans.mapType() == math::UnitaryMap::mapType()) {
         return this->advect3<SpatialScheme, TemporalScheme, math::UnitaryMap    >(time0, time1);
     } else if (trans.mapType() == math::TranslationMap::mapType()) {
@@ -293,10 +302,12 @@
     return 0;
 }
 
+
 template<typename GridT, typename FieldT, typename InterruptT>
-template<math::BiasedGradientScheme SpatialScheme,
-         math::TemporalIntegrationScheme TemporalScheme,
-         typename MapT>
+template<
+    math::BiasedGradientScheme SpatialScheme,
+    math::TemporalIntegrationScheme TemporalScheme,
+    typename MapT>
 inline size_t
 LevelSetAdvection<GridT, FieldT, InterruptT>::advect3(ValueType time0, ValueType time1)
 {
@@ -309,8 +320,10 @@
 
 
 template<typename GridT, typename FieldT, typename InterruptT>
-template <typename MapT, math::BiasedGradientScheme SpatialScheme,
-          math::TemporalIntegrationScheme TemporalScheme>
+template<
+    typename MapT,
+    math::BiasedGradientScheme SpatialScheme,
+    math::TemporalIntegrationScheme TemporalScheme>
 inline
 LevelSetAdvection<GridT, FieldT, InterruptT>::
 Advect<MapT, SpatialScheme, TemporalScheme>::
@@ -324,9 +337,12 @@
 {
 }
 
+
 template<typename GridT, typename FieldT, typename InterruptT>
-template <typename MapT, math::BiasedGradientScheme SpatialScheme,
-          math::TemporalIntegrationScheme TemporalScheme>
+template<
+    typename MapT,
+    math::BiasedGradientScheme SpatialScheme,
+    math::TemporalIntegrationScheme TemporalScheme>
 inline
 LevelSetAdvection<GridT, FieldT, InterruptT>::
 Advect<MapT, SpatialScheme, TemporalScheme>::
@@ -339,10 +355,13 @@
     , mIsMaster(false)
 {
 }
-   
+
+
 template<typename GridT, typename FieldT, typename InterruptT>
-template <typename MapT, math::BiasedGradientScheme SpatialScheme,
-          math::TemporalIntegrationScheme TemporalScheme>
+template<
+    typename MapT,
+    math::BiasedGradientScheme SpatialScheme,
+    math::TemporalIntegrationScheme TemporalScheme>
 inline size_t
 LevelSetAdvection<GridT, FieldT, InterruptT>::
 Advect<MapT, SpatialScheme, TemporalScheme>::
@@ -357,7 +376,7 @@
         //timer.start( "\nallocate buffers" );
         mParent.mTracker.leafs().rebuildAuxBuffers(TemporalScheme == math::TVD_RK3 ? 2 : 1);
         //timer.stop();
-        
+
         const ValueType dt = this->sampleField(time0, time1);
         if ( math::isZero(dt) ) break;//V is essentially zero so terminate
 
@@ -412,7 +431,7 @@
             OPENVDB_THROW(ValueError, "Temporal integration scheme not supported!");
         }//end of compile-time resolved switch
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
-            
+
         time0 += isForward ? dt : -dt;
         ++countCFL;
         mParent.mTracker.leafs().removeAuxBuffers();
@@ -423,9 +442,12 @@
     return countCFL;//number of CLF propagation steps
 }
 
+
 template<typename GridT, typename FieldT, typename InterruptT>
-template<typename MapT, math::BiasedGradientScheme SpatialScheme,
-	math::TemporalIntegrationScheme TemporalScheme>
+template<
+    typename MapT,
+    math::BiasedGradientScheme SpatialScheme,
+    math::TemporalIntegrationScheme TemporalScheme>
 inline typename GridT::ValueType
 LevelSetAdvection<GridT, FieldT, InterruptT>::
 Advect<MapT, SpatialScheme, TemporalScheme>::
@@ -435,8 +457,8 @@
     const size_t leafCount = mParent.mTracker.leafs().leafCount();
     if (leafCount==0) return ValueType(0.0);
 
-    // Compute the pre-fix sum of offsets to active voxels
-    size_t size=0, voxelCount=mParent.mTracker.leafs().getPreFixSum(mOffsets, size, grainSize);
+    // Compute the prefix sum of offsets to active voxels
+    size_t size=0, voxelCount=mParent.mTracker.leafs().getPrefixSum(mOffsets, size, grainSize);
 
     // Sample the velocity field
     if (mParent.mField.transform() == mParent.mTracker.grid().transform()) {
@@ -451,7 +473,9 @@
     // Find the extrema of the magnitude of the velocities
     ValueType maxAbsV = 0;
     VectorType* v = mVelocity;
-    for (size_t i=0; i<voxelCount; ++i, ++v) maxAbsV = math::Max(maxAbsV, ValueType(v->lengthSqr()));
+    for (size_t i = 0; i < voxelCount; ++i, ++v) {
+        maxAbsV = math::Max(maxAbsV, ValueType(v->lengthSqr()));
+    }
 
     // Compute the CFL number
     if (math::isApproxZero(maxAbsV, math::Delta<ValueType>::value())) return ValueType(0);
@@ -465,10 +489,13 @@
     return math::Min(dt, ValueType(CFL*dx/math::Sqrt(maxAbsV)));
 }
 
+
 template<typename GridT, typename FieldT, typename InterruptT>
-template <typename MapT, math::BiasedGradientScheme SpatialScheme,
-          math::TemporalIntegrationScheme TemporalScheme>
-template <bool Aligned>
+template<
+    typename MapT,
+    math::BiasedGradientScheme SpatialScheme,
+    math::TemporalIntegrationScheme TemporalScheme>
+template<bool Aligned>
 inline void
 LevelSetAdvection<GridT, FieldT, InterruptT>::
 Advect<MapT, SpatialScheme, TemporalScheme>::
@@ -489,23 +516,29 @@
     }
 }
 
+
 template<typename GridT, typename FieldT, typename InterruptT>
-template <typename MapT, math::BiasedGradientScheme SpatialScheme,
-          math::TemporalIntegrationScheme TemporalScheme>
+template<
+    typename MapT,
+    math::BiasedGradientScheme SpatialScheme,
+    math::TemporalIntegrationScheme TemporalScheme>
 inline void
 LevelSetAdvection<GridT, FieldT, InterruptT>::
 Advect<MapT, SpatialScheme, TemporalScheme>::
 clearField()
 {
-    delete [] mOffsets; 
+    delete [] mOffsets;
     delete [] mVelocity;
     mOffsets  = NULL;
     mVelocity = NULL;
 }
 
+
 template<typename GridT, typename FieldT, typename InterruptT>
-template <typename MapT, math::BiasedGradientScheme SpatialScheme,
-          math::TemporalIntegrationScheme TemporalScheme>
+template<
+    typename MapT,
+    math::BiasedGradientScheme SpatialScheme,
+    math::TemporalIntegrationScheme TemporalScheme>
 inline void
 LevelSetAdvection<GridT, FieldT, InterruptT>::
 Advect<MapT, SpatialScheme, TemporalScheme>::
@@ -523,11 +556,14 @@
     mParent.mTracker.endInterrupter();
 }
 
+
 // Convex combination of Phi and a forward Euler advection steps:
 // Phi(result) = alpha * Phi(phi) + (1-alpha) * (Phi(0) - dt * V.Grad(0));
 template<typename GridT, typename FieldT, typename InterruptT>
-template<typename MapT, math::BiasedGradientScheme SpatialScheme,
-         math::TemporalIntegrationScheme TemporalScheme>
+template<
+    typename MapT,
+    math::BiasedGradientScheme SpatialScheme,
+    math::TemporalIntegrationScheme TemporalScheme>
 template <int Nominator, int Denominator>
 inline void
 LevelSetAdvection<GridT, FieldT, InterruptT>::
@@ -552,7 +588,8 @@
         for (VoxelIterT voxelIter = leafIter->cbeginValueOn(); voxelIter; ++voxelIter, ++vel) {
             const Index i = voxelIter.pos();
             stencil.moveTo(voxelIter);
-            const ValueType a = stencil.getValue() - dt * vel->dot(GradT::result(map, stencil, *vel));
+            const ValueType a =
+                stencil.getValue() - dt * vel->dot(GradT::result(map, stencil, *vel));
             result[i] = Nominator ? Alpha * phi[i] + Beta * a : a;
         }//loop over active voxels in the leaf of the mask
     }//loop over leafs of the level set
diff -aur openvdb.3.2.0/tools/LevelSetFilter.h openvdb.4.0.0/tools/LevelSetFilter.h
--- openvdb.3.2.0/tools/LevelSetFilter.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tools/LevelSetFilter.h	2016-10-09 10:18:58.000000000 +0200
@@ -75,7 +75,7 @@
     /// @brief Main constructor from a grid
     /// @param grid The level set to be filtered.
     /// @param interrupt Optional interrupter.
-    LevelSetFilter(GridType& grid, InterruptT* interrupt = NULL)
+    LevelSetFilter(GridType& grid, InterruptT* interrupt = nullptr)
         : BaseType(grid, interrupt)
         , mMinMask(0)
         , mMaxMask(1)
@@ -114,14 +114,14 @@
 
     /// @brief One iteration of mean-curvature flow of the level set.
     /// @param mask Optional alpha mask.
-    void meanCurvature(const MaskType* mask = NULL)
+    void meanCurvature(const MaskType* mask = nullptr)
     {
         Filter f(this, mask); f.meanCurvature();
     }
 
     /// @brief One iteration of Laplacian flow of the level set.
     /// @param mask Optional alpha mask.
-    void laplacian(const MaskType* mask = NULL)
+    void laplacian(const MaskType* mask = nullptr)
     {
         Filter f(this, mask); f.laplacian();
     }
@@ -132,7 +132,7 @@
     ///
     /// @note This is approximated as 4 iterations of a separable mean filter
     /// which typically leads an approximation that's better than 95%!
-    void gaussian(int width = 1, const MaskType* mask = NULL)
+    void gaussian(int width = 1, const MaskType* mask = nullptr)
     {
         Filter f(this, mask); f.gaussian(width);
     }
@@ -140,7 +140,7 @@
     /// @brief Offset the level set by the specified (world) distance.
     /// @param offset Value of the offset.
     /// @param mask Optional alpha mask.
-    void offset(ValueType offset, const MaskType* mask = NULL)
+    void offset(ValueType offset, const MaskType* mask = nullptr)
     {
         Filter f(this, mask); f.offset(offset);
     }
@@ -151,7 +151,7 @@
     ///
     /// @warning This filter is not separable and is hence relatively
     /// slow!
-    void median(int width = 1, const MaskType* mask = NULL)
+    void median(int width = 1, const MaskType* mask = nullptr)
     {
         Filter f(this, mask); f.median(width);
     }
@@ -161,7 +161,7 @@
     /// @param mask Optional alpha mask.
     ///
     /// @note This filter is separable so it's fast!
-    void mean(int width = 1, const MaskType* mask = NULL)
+    void mean(int width = 1, const MaskType* mask = nullptr)
     {
         Filter f(this, mask); f.mean(width);
     }
@@ -183,6 +183,7 @@
         typedef tools::AlphaMask<GridT, MaskT>                   AlphaMaskT;
 
         Filter(LevelSetFilter* parent, const MaskType* mask) : mParent(parent), mMask(mask) {}
+        Filter(const Filter&) = default;
         virtual ~Filter() {}
 
         void box(int width);
diff -aur openvdb.3.2.0/tools/LevelSetFracture.h openvdb.4.0.0/tools/LevelSetFracture.h
--- openvdb.3.2.0/tools/LevelSetFracture.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tools/LevelSetFracture.h	2016-10-09 10:18:58.000000000 +0200
@@ -192,7 +192,7 @@
 
 
         math::Transform::Ptr originalCutterTransform = cutter.transform().copy();
-        GridType cutterGrid(cutter, ShallowCopy());
+        GridType cutterGrid(*const_cast<GridType*>(&cutter), ShallowCopy());
 
         const bool hasInstanceRotations =
             points && rotations && points->size() == rotations->size();
diff -aur openvdb.3.2.0/tools/LevelSetMorph.h openvdb.4.0.0/tools/LevelSetMorph.h
--- openvdb.3.2.0/tools/LevelSetMorph.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tools/LevelSetMorph.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,9 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
-///////////////////////////////////////////////////////////////////////////
-//
+
 /// @author Ken Museth
 ///
 /// @file LevelSetMorph.h
@@ -60,9 +58,9 @@
 /// class Interrupter {
 ///   ...
 /// public:
-///   void start(const char* name = NULL)// called when computations begin
-///   void end()                         // called when computations end
-///   bool wasInterrupted(int percent=-1)// return true to break computation
+///   void start(const char* name = nullptr) // called when computations begin
+///   void end()                             // called when computations end
+///   bool wasInterrupted(int percent=-1)    // return true to break computation
 /// };
 /// @endcode
 ///
@@ -83,12 +81,10 @@
     typedef typename TrackerT::ValueType       ValueType;
 
     /// Main constructor
-    LevelSetMorphing(GridT& sourceGrid,
-                     const GridT& targetGrid,
-                     InterruptT* interrupt = NULL)
+    LevelSetMorphing(GridT& sourceGrid, const GridT& targetGrid, InterruptT* interrupt = nullptr)
         : mTracker(sourceGrid, interrupt)
         , mTarget(&targetGrid)
-        , mMask(NULL)
+        , mMask(nullptr)
         , mSpatialScheme(math::HJWENO5_BIAS)
         , mTemporalScheme(math::TVD_RK2)
         , mMinMask(0)
@@ -280,6 +276,10 @@
     //return this->advect1<math::WENO5_BIAS  >(time0, time1);
     case math::HJWENO5_BIAS:
         return this->advect1<math::HJWENO5_BIAS>(time0, time1);
+    case math::SECOND_BIAS:
+    case math::THIRD_BIAS:
+    case math::WENO5_BIAS:
+    case math::UNKNOWN_BIAS:
     default:
         OPENVDB_THROW(ValueError, "Spatial difference scheme not supported!");
     }
@@ -298,6 +298,7 @@
         return this->advect2<SpatialScheme, math::TVD_RK2>(time0, time1);
     case math::TVD_RK3:
         return this->advect2<SpatialScheme, math::TVD_RK3>(time0, time1);
+    case math::UNKNOWN_TIS:
     default:
         OPENVDB_THROW(ValueError, "Temporal integration scheme not supported!");
     }
@@ -449,6 +450,7 @@
             // Cook and swap buffer 0 and 2 such that Phi_t3(0) and Phi_t2(2)
             this->cook(PARALLEL_FOR, 2);
             break;
+        case math::UNKNOWN_TIS:
         default:
             OPENVDB_THROW(ValueError, "Temporal integration scheme not supported!");
         }//end of compile-time resolved switch
@@ -479,7 +481,7 @@
 
     const math::Transform& xform  = mParent->mTracker.grid().transform();
     if (mParent->mTarget->transform() == xform &&
-        (mParent->mMask == NULL || mParent->mMask->transform() == xform)) {
+        (mParent->mMask == nullptr || mParent->mMask->transform() == xform)) {
         mTask = boost::bind(&Morph::sampleAlignedSpeed, _1, _2, speedBuffer);
     } else {
         mTask = boost::bind(&Morph::sampleXformedSpeed, _1, _2, speedBuffer);
@@ -508,7 +510,7 @@
 
     typename GridT::ConstAccessor targetAcc = mParent->mTarget->getAccessor();
     SamplerT target(targetAcc, mParent->mTarget->transform());
-    if (mParent->mMask == NULL) {
+    if (mParent->mMask == nullptr) {
         for (typename LeafRange::Iterator leafIter = range.begin(); leafIter; ++leafIter) {
             ValueType* speed = leafIter.buffer(speedBuffer).data();
             bool isZero = true;
@@ -555,7 +557,7 @@
 
     typename GridT::ConstAccessor target = mParent->mTarget->getAccessor();
 
-    if (mParent->mMask == NULL) {
+    if (mParent->mMask == nullptr) {
         for (typename LeafRange::Iterator leafIter = range.begin(); leafIter; ++leafIter) {
             ValueType* speed = leafIter.buffer(speedBuffer).data();
             bool isZero = true;
diff -aur openvdb.3.2.0/tools/LevelSetPlatonic.h openvdb.4.0.0/tools/LevelSetPlatonic.h
--- openvdb.3.2.0/tools/LevelSetPlatonic.h	2016-04-24 10:39:49.000000000 +0200
+++ openvdb.4.0.0/tools/LevelSetPlatonic.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-///
+
 /// @author Ken Museth
 ///
 /// @file LevelSetPlatonic.h
@@ -71,12 +71,13 @@
 /// @note @c GridType::ValueType must be a floating-point scalar.
 template<typename GridType, typename InterruptT>
 typename GridType::Ptr
-createLevelSetPlatonic(int faceCount,// 4, 6, 8, 12 or 20
-                       float scale = 1.0f,
-                       const Vec3f& center = Vec3f(0.0f),
-                       float voxelSize = 0.1f,
-                       float halfWidth = float(LEVEL_SET_HALF_WIDTH),
-                       InterruptT* interrupt = NULL);
+createLevelSetPlatonic(
+    int faceCount, // 4, 6, 8, 12 or 20
+    float scale = 1.0f,
+    const Vec3f& center = Vec3f(0.0f),
+    float voxelSize = 0.1f,
+    float halfWidth = float(LEVEL_SET_HALF_WIDTH),
+    InterruptT* interrupt = nullptr);
 
 /// @brief Return a grid of type @c GridType containing a narrow-band level set
 /// representation of a platonic solid.
@@ -92,11 +93,12 @@
 /// @note @c GridType::ValueType must be a floating-point scalar.
 template<typename GridType>
 typename GridType::Ptr
-createLevelSetPlatonic(int faceCount,// 4, 6, 8, 12 or 20
-                       float scale = 1.0f,
-                       const Vec3f& center = Vec3f(0.0f),
-                       float voxelSize = 0.1f,
-                       float halfWidth = float(LEVEL_SET_HALF_WIDTH))
+createLevelSetPlatonic(
+    int faceCount,// 4, 6, 8, 12 or 20
+    float scale = 1.0f,
+    const Vec3f& center = Vec3f(0.0f),
+    float voxelSize = 0.1f,
+    float halfWidth = float(LEVEL_SET_HALF_WIDTH))
 {
     util::NullInterrupter tmp;
     return createLevelSetPlatonic<GridType>(faceCount, scale, center, voxelSize, halfWidth, &tmp);
@@ -116,14 +118,15 @@
 /// @note @c GridType::ValueType must be a floating-point scalar.
 template<typename GridType, typename InterruptT>
 typename GridType::Ptr
-createLevelSetTetrahedron(float scale = 1.0f,
-                          const Vec3f& center = Vec3f(0.0f),
-                          float voxelSize = 0.1f,
-                          float halfWidth = float(LEVEL_SET_HALF_WIDTH),
-                          InterruptT* interrupt =  NULL)
+createLevelSetTetrahedron(
+    float scale = 1.0f,
+    const Vec3f& center = Vec3f(0.0f),
+    float voxelSize = 0.1f,
+    float halfWidth = float(LEVEL_SET_HALF_WIDTH),
+    InterruptT* interrupt =  nullptr)
 {
-    return createLevelSetPlatonic<GridType, InterruptT>(4, scale, center,
-                                                        voxelSize, halfWidth, interrupt);
+    return createLevelSetPlatonic<GridType, InterruptT>(
+        4, scale, center, voxelSize, halfWidth, interrupt);
 }
 
 /// @brief Return a grid of type @c GridType containing a narrow-band level set
@@ -137,10 +140,11 @@
 /// @note @c GridType::ValueType must be a floating-point scalar.
 template<typename GridType>
 typename GridType::Ptr
-createLevelSetTetrahedron(float scale = 1.0f,
-                          const Vec3f& center = Vec3f(0.0f),
-                          float voxelSize = 0.1f,
-                          float halfWidth = float(LEVEL_SET_HALF_WIDTH))
+createLevelSetTetrahedron(
+    float scale = 1.0f,
+    const Vec3f& center = Vec3f(0.0f),
+    float voxelSize = 0.1f,
+    float halfWidth = float(LEVEL_SET_HALF_WIDTH))
 {
     util::NullInterrupter tmp;
     return createLevelSetPlatonic<GridType>(4, scale, center, voxelSize, halfWidth, &tmp);
@@ -160,11 +164,12 @@
 /// @note @c GridType::ValueType must be a floating-point scalar.
 template<typename GridType, typename InterruptT>
 typename GridType::Ptr
-createLevelSetCube(float scale = 1.0f,
-                   const Vec3f& center = Vec3f(0.0f),
-                   float voxelSize = 0.1f,
-                   float halfWidth = float(LEVEL_SET_HALF_WIDTH),
-                   InterruptT* interrupt =  NULL)
+createLevelSetCube(
+    float scale = 1.0f,
+    const Vec3f& center = Vec3f(0.0f),
+    float voxelSize = 0.1f,
+    float halfWidth = float(LEVEL_SET_HALF_WIDTH),
+    InterruptT* interrupt =  nullptr)
 {
     return createLevelSetPlatonic<GridType>(6, scale, center, voxelSize, halfWidth, interrupt);
 }
@@ -180,10 +185,11 @@
 /// @note @c GridType::ValueType must be a floating-point scalar.
 template<typename GridType>
 typename GridType::Ptr
-createLevelSetCube(float scale = 1.0f,
-                   const Vec3f& center = Vec3f(0.0f),
-                   float voxelSize = 0.1f,
-                   float halfWidth = float(LEVEL_SET_HALF_WIDTH))
+createLevelSetCube(
+    float scale = 1.0f,
+    const Vec3f& center = Vec3f(0.0f),
+    float voxelSize = 0.1f,
+    float halfWidth = float(LEVEL_SET_HALF_WIDTH))
 {
     util::NullInterrupter tmp;
     return createLevelSetPlatonic<GridType>(6, scale, center, voxelSize, halfWidth, &tmp);
@@ -203,11 +209,12 @@
 /// @note @c GridType::ValueType must be a floating-point scalar.
 template<typename GridType, typename InterruptT>
 typename GridType::Ptr
-createLevelSetOctahedron(float scale = 1.0f,
-                         const Vec3f& center = Vec3f(0.0f),
-                         float voxelSize = 0.1f,
-                         float halfWidth = float(LEVEL_SET_HALF_WIDTH),
-                         InterruptT* interrupt =  NULL)
+createLevelSetOctahedron(
+    float scale = 1.0f,
+    const Vec3f& center = Vec3f(0.0f),
+    float voxelSize = 0.1f,
+    float halfWidth = float(LEVEL_SET_HALF_WIDTH),
+    InterruptT* interrupt = nullptr)
 {
     return createLevelSetPlatonic<GridType>(8, scale, center, voxelSize, halfWidth, interrupt);
 }
@@ -223,10 +230,11 @@
 /// @note @c GridType::ValueType must be a floating-point scalar.
 template<typename GridType>
 typename GridType::Ptr
-createLevelSetOctahedron(float scale = 1.0f,
-                         const Vec3f& center = Vec3f(0.0f),
-                         float voxelSize = 0.1f,
-                         float halfWidth = float(LEVEL_SET_HALF_WIDTH))
+createLevelSetOctahedron(
+    float scale = 1.0f,
+    const Vec3f& center = Vec3f(0.0f),
+    float voxelSize = 0.1f,
+    float halfWidth = float(LEVEL_SET_HALF_WIDTH))
 {
     util::NullInterrupter tmp;
     return createLevelSetPlatonic<GridType>(8, scale, center, voxelSize, halfWidth, &tmp);
@@ -246,11 +254,12 @@
 /// @note @c GridType::ValueType must be a floating-point scalar.
 template<typename GridType, typename InterruptT>
 typename GridType::Ptr
-createLevelSetDodecahedron(float scale = 1.0f,
-                           const Vec3f& center = Vec3f(0.0f),
-                           float voxelSize = 0.1f,
-                           float halfWidth = float(LEVEL_SET_HALF_WIDTH),
-                           InterruptT* interrupt =  NULL)
+createLevelSetDodecahedron(
+    float scale = 1.0f,
+    const Vec3f& center = Vec3f(0.0f),
+    float voxelSize = 0.1f,
+    float halfWidth = float(LEVEL_SET_HALF_WIDTH),
+    InterruptT* interrupt = nullptr)
 {
     return createLevelSetPlatonic<GridType>(12, scale, center, voxelSize, halfWidth, interrupt);
 }
@@ -266,10 +275,11 @@
 /// @note @c GridType::ValueType must be a floating-point scalar.
 template<typename GridType>
 typename GridType::Ptr
-createLevelSetDodecahedron(float scale = 1.0f,
-                           const Vec3f& center = Vec3f(0.0f),
-                           float voxelSize = 0.1f,
-                           float halfWidth = float(LEVEL_SET_HALF_WIDTH))
+createLevelSetDodecahedron(
+    float scale = 1.0f,
+    const Vec3f& center = Vec3f(0.0f),
+    float voxelSize = 0.1f,
+    float halfWidth = float(LEVEL_SET_HALF_WIDTH))
 {
     util::NullInterrupter tmp;
     return createLevelSetPlatonic<GridType>(12, scale, center, voxelSize, halfWidth, &tmp);
@@ -289,11 +299,12 @@
 /// @note @c GridType::ValueType must be a floating-point scalar.
 template<typename GridType, typename InterruptT>
 typename GridType::Ptr
-createLevelSetIcosahedron(float scale = 1.0f,
-                          const Vec3f& center = Vec3f(0.0f),
-                          float voxelSize = 0.1f,
-                          float halfWidth = float(LEVEL_SET_HALF_WIDTH),
-                          InterruptT* interrupt =  NULL)
+createLevelSetIcosahedron(
+    float scale = 1.0f,
+    const Vec3f& center = Vec3f(0.0f),
+    float voxelSize = 0.1f,
+    float halfWidth = float(LEVEL_SET_HALF_WIDTH),
+    InterruptT* interrupt = nullptr)
 {
     return createLevelSetPlatonic<GridType>(20, scale, center, voxelSize, halfWidth, interrupt);
 }
@@ -309,10 +320,11 @@
 /// @note @c GridType::ValueType must be a floating-point scalar.
 template<typename GridType>
 typename GridType::Ptr
-createLevelSetIcosahedron(float scale = 1.0f,
-                          const Vec3f& center = Vec3f(0.0f),
-                          float voxelSize = 0.1f,
-                          float halfWidth = float(LEVEL_SET_HALF_WIDTH))
+createLevelSetIcosahedron(
+    float scale = 1.0f,
+    const Vec3f& center = Vec3f(0.0f),
+    float voxelSize = 0.1f,
+    float halfWidth = float(LEVEL_SET_HALF_WIDTH))
 {
     util::NullInterrupter tmp;
     return createLevelSetPlatonic<GridType>(20, scale, center, voxelSize, halfWidth, &tmp);
@@ -323,7 +335,7 @@
 template<typename GridType, typename InterruptT>
 typename GridType::Ptr
 createLevelSetPlatonic(int faceCount,float scale, const Vec3f& center,
-                       float voxelSize, float halfWidth, InterruptT *interrupt)
+    float voxelSize, float halfWidth, InterruptT *interrupt)
 {
     // GridType::ValueType is required to be a floating-point scalar.
     BOOST_STATIC_ASSERT(boost::is_floating_point<typename GridType::ValueType>::value);
@@ -338,7 +350,7 @@
 
         vtx.push_back( Vec3f( 0.0f,          1.0f,         0.0f) );
         vtx.push_back( Vec3f(-0.942810297f, -0.333329707f, 0.0f) );
-        vtx.push_back( Vec3f( 0.471405149f, -0.333329707f, 0.816497624) );
+        vtx.push_back( Vec3f( 0.471405149f, -0.333329707f, 0.816497624f) );
         vtx.push_back( Vec3f( 0.471405149f, -0.333329707f, -0.816497624f) );
 
         tri.push_back( Vec3I(0, 2, 3) );
@@ -475,7 +487,7 @@
 
     typename GridType::Ptr grid;
 
-    if (interrupt == NULL) {
+    if (interrupt == nullptr) {
         util::NullInterrupter tmp;
         grid = meshToLevelSet<GridType>(tmp, *xform, vtx, tri, qua, halfWidth);
     } else {
diff -aur openvdb.3.2.0/tools/LevelSetTracker.h openvdb.4.0.0/tools/LevelSetTracker.h
--- openvdb.3.2.0/tools/LevelSetTracker.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tools/LevelSetTracker.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @author Ken Museth
 ///
 /// @file LevelSetTracker.h
@@ -42,7 +42,7 @@
 #include <tbb/parallel_for.h>
 #include <boost/bind.hpp>
 #include <boost/function.hpp>
-#include <boost/type_traits/is_floating_point.hpp>
+#include <type_traits>
 #include <openvdb/Types.h>
 #include <openvdb/math/Math.h>
 #include <openvdb/math/FiniteDifference.h>
@@ -75,7 +75,8 @@
     typedef typename LeafManagerType::LeafRange  LeafRange;
     typedef typename LeafManagerType::BufferType BufferType;
     typedef typename TreeType::template ValueConverter<ValueMask>::Type MaskTreeType;
-    BOOST_STATIC_ASSERT(boost::is_floating_point<ValueType>::value);
+    static_assert(std::is_floating_point<ValueType>::value,
+        "LevelSetTracker requires a level set grid with floating-point values");
 
     /// Lightweight struct that stores the state of the LevelSetTracker
     struct State {
@@ -91,7 +92,7 @@
 
     /// @brief Main constructor
     /// @throw RuntimeError if the grid is not a level set
-    LevelSetTracker(GridT& grid, InterruptT* interrupt = NULL);
+    LevelSetTracker(GridT& grid, InterruptT* interrupt = nullptr);
 
     virtual ~LevelSetTracker() { delete mLeafs; }
 
@@ -101,7 +102,7 @@
     void normalize(const MaskType* mask);
 
     /// @brief Iterative normalization, i.e. solving the Eikonal equation
-    void normalize() { this->normalize<MaskTreeType>(NULL); }
+    void normalize() { this->normalize<MaskTreeType>(nullptr); }
 
     /// @brief Track the level set interface, i.e. rebuild and normalize the
     /// narrow band of the level set.
@@ -397,6 +398,7 @@
         this->normalize1<math::WENO5_BIAS,   MaskT>(mask); break;
     case math::HJWENO5_BIAS:
         this->normalize1<math::HJWENO5_BIAS, MaskT>(mask); break;
+    case math::UNKNOWN_BIAS:
     default:
         OPENVDB_THROW(ValueError, "Spatial difference scheme not supported!");
     }
@@ -415,6 +417,7 @@
         this->normalize2<SpatialScheme, math::TVD_RK2, MaskT>(mask); break;
     case math::TVD_RK3:
         this->normalize2<SpatialScheme, math::TVD_RK3, MaskT>(mask); break;
+    case math::UNKNOWN_TIS:
     default:
         OPENVDB_THROW(ValueError, "Temporal integration scheme not supported!");
     }
@@ -551,6 +554,7 @@
             // Cook and swap buffer 0 and 2 such that Phi_t3(0) and Phi_t2(2)
             this->cook("Normalizing level set using TVD_RK3 (step 3 of 3)", 2);
             break;
+        case math::UNKNOWN_TIS:
         default:
             OPENVDB_THROW(ValueError, "Temporal integration scheme not supported!");
         }
@@ -623,7 +627,7 @@
     for (typename LeafRange::Iterator leafIter = range.begin(); leafIter; ++leafIter) {
         const ValueType* phi = leafIter.buffer(phiBuffer).data();
         ValueType* result = leafIter.buffer(resultBuffer).data();
-        if (mMask == NULL) {
+        if (mMask == nullptr) {
             for (VoxelIterT iter = leafIter->cbeginValueOn(); iter; ++iter) {
                 stencil.moveTo(iter);
                 this->eval<Nominator, Denominator>(stencil, phi, result, iter.pos());
diff -aur openvdb.3.2.0/tools/LevelSetUtil.h openvdb.4.0.0/tools/LevelSetUtil.h
--- openvdb.3.2.0/tools/LevelSetUtil.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tools/LevelSetUtil.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file tools/LevelSetUtil.h
 ///
 /// @brief  Miscellaneous utility methods that operate primarily
@@ -35,7 +35,6 @@
 ///
 /// @author Mihai Alden
 
-
 #ifndef OPENVDB_TOOLS_LEVEL_SET_UTIL_HAS_BEEN_INCLUDED
 #define OPENVDB_TOOLS_LEVEL_SET_UTIL_HAS_BEEN_INCLUDED
 
@@ -44,12 +43,11 @@
 
 #include <openvdb/Types.h>
 #include <openvdb/Grid.h>
-
+#include <boost/scoped_array.hpp>
 #include <tbb/blocked_range.h>
 #include <tbb/parallel_for.h>
 #include <tbb/parallel_reduce.h>
 #include <tbb/parallel_sort.h>
-
 #include <limits>
 
 namespace openvdb {
@@ -139,12 +137,15 @@
 ///                     cavity will be ignored.
 template<typename GridOrTreeType>
 inline typename GridOrTreeType::template ValueConverter<bool>::Type::Ptr
-extractEnclosedRegion(const GridOrTreeType& volume,
+extractEnclosedRegion(
+    const GridOrTreeType& volume,
     typename GridOrTreeType::ValueType isovalue = lsutilGridZero<GridOrTreeType>(),
-    const typename TreeAdapter<GridOrTreeType>::TreeType::template ValueConverter<bool>::Type* fillMask = NULL);
+    const typename TreeAdapter<GridOrTreeType>::TreeType::template ValueConverter<bool>::Type*
+        fillMask = nullptr);
 
 
-/// @brief Return a mask of the voxels that intersect the implicit surface with the given @a isovalue.
+/// @brief Return a mask of the voxels that intersect the implicit surface with
+/// the given @a isovalue.
 ///
 /// @param volume       Signed distance field / level set volume.
 /// @param isovalue     The crossing point that is considered the surface.
@@ -173,7 +174,8 @@
 ///                     descending order based on the active voxel count.
 template<typename GridOrTreeType>
 inline void
-segmentActiveVoxels(const GridOrTreeType& volume, std::vector<typename GridOrTreeType::Ptr>& segments);
+segmentActiveVoxels(const GridOrTreeType& volume,
+    std::vector<typename GridOrTreeType::Ptr>& segments);
 
 
 /// @brief  Separates disjoint SDF surfaces into distinct grids or trees.
@@ -201,8 +203,8 @@
 template<typename LeafNodeType>
 struct MaskInteriorVoxels {
 
-    typedef typename LeafNodeType::ValueType                ValueType;
-    typedef tree::LeafNode<bool, LeafNodeType::LOG2DIM>     BoolLeafNodeType;
+    using ValueType = typename LeafNodeType::ValueType;
+    using BoolLeafNodeType = tree::LeafNode<bool, LeafNodeType::LOG2DIM>;
 
     MaskInteriorVoxels(
         ValueType isovalue, const LeafNodeType ** nodes, BoolLeafNodeType ** maskNodes)
@@ -212,11 +214,11 @@
 
     void operator()(const tbb::blocked_range<size_t>& range) const {
 
-        BoolLeafNodeType * maskNodePt = NULL;
+        BoolLeafNodeType * maskNodePt = nullptr;
 
         for (size_t n = range.begin(), N = range.end(); n < N; ++n) {
 
-            mMaskNodes[n] = NULL;
+            mMaskNodes[n] = nullptr;
             const LeafNodeType& node = *mNodes[n];
 
             if (!maskNodePt) {
@@ -232,7 +234,7 @@
 
             if (maskNodePt->onVoxelCount() > 0) {
                 mMaskNodes[n] = maskNodePt;
-                maskNodePt = NULL;
+                maskNodePt = nullptr;
             }
         }
 
@@ -248,7 +250,7 @@
 template<typename TreeType, typename InternalNodeType>
 struct MaskInteriorTiles {
 
-    typedef typename TreeType::ValueType    ValueType;
+    using ValueType = typename TreeType::ValueType;
 
     MaskInteriorTiles(ValueType isovalue, const TreeType& tree, InternalNodeType ** maskNodes)
         : mTree(&tree), mMaskNodes(maskNodes), mIsovalue(isovalue) { }
@@ -275,8 +277,8 @@
 template<typename TreeType>
 struct PopulateTree {
 
-    typedef typename TreeType::ValueType    ValueType;
-    typedef typename TreeType::LeafNodeType LeafNodeType;
+    using ValueType = typename TreeType::ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
 
     PopulateTree(TreeType& tree, LeafNodeType** leafnodes,
         const size_t * nodexIndexMap, ValueType background)
@@ -302,7 +304,7 @@
         if (mNodeIndexMap) {
             for (size_t n = range.begin(), N = range.end(); n < N; ++n) {
                 for (size_t i = mNodeIndexMap[n], I = mNodeIndexMap[n + 1]; i < I; ++i) {
-                    if (mNodes[i] != NULL) acc.addLeaf(mNodes[i]);
+                    if (mNodes[i] != nullptr) acc.addLeaf(mNodes[i]);
                 }
             }
         } else {
@@ -326,8 +328,8 @@
 template<typename LeafNodeType>
 struct LabelBoundaryVoxels {
 
-    typedef typename LeafNodeType::ValueType                ValueType;
-    typedef tree::LeafNode<char, LeafNodeType::LOG2DIM>     CharLeafNodeType;
+    using ValueType = typename LeafNodeType::ValueType;
+    using CharLeafNodeType = tree::LeafNode<char, LeafNodeType::LOG2DIM>;
 
     LabelBoundaryVoxels(
         ValueType isovalue, const LeafNodeType ** nodes, CharLeafNodeType ** maskNodes)
@@ -337,11 +339,11 @@
 
     void operator()(const tbb::blocked_range<size_t>& range) const {
 
-        CharLeafNodeType * maskNodePt = NULL;
+        CharLeafNodeType * maskNodePt = nullptr;
 
         for (size_t n = range.begin(), N = range.end(); n < N; ++n) {
 
-            mMaskNodes[n] = NULL;
+            mMaskNodes[n] = nullptr;
             const LeafNodeType& node = *mNodes[n];
 
             if (!maskNodePt) {
@@ -357,7 +359,7 @@
 
             if (maskNodePt->onVoxelCount() > 0) {
                 mMaskNodes[n] = maskNodePt;
-                maskNodePt = NULL;
+                maskNodePt = nullptr;
             }
         }
 
@@ -372,7 +374,7 @@
 
 template<typename LeafNodeType>
 struct FlipRegionSign {
-    typedef typename LeafNodeType::ValueType ValueType;
+    using ValueType = typename LeafNodeType::ValueType;
 
     FlipRegionSign(LeafNodeType ** nodes) : mNodes(nodes) { }
 
@@ -392,7 +394,7 @@
 template<typename LeafNodeType>
 struct FindMinVoxelValue {
 
-    typedef typename LeafNodeType::ValueType    ValueType;
+    using ValueType = typename LeafNodeType::ValueType;
 
     FindMinVoxelValue(LeafNodeType const * const * const leafnodes)
         : minValue(std::numeric_limits<ValueType>::max())
@@ -426,7 +428,7 @@
 template<typename InternalNodeType>
 struct FindMinTileValue {
 
-    typedef typename InternalNodeType::ValueType    ValueType;
+    using ValueType = typename InternalNodeType::ValueType;
 
     FindMinTileValue(InternalNodeType const * const * const nodes)
         : minValue(std::numeric_limits<ValueType>::max())
@@ -460,7 +462,7 @@
 template<typename LeafNodeType>
 struct SDFVoxelsToFogVolume {
 
-    typedef typename LeafNodeType::ValueType ValueType;
+    using ValueType = typename LeafNodeType::ValueType;
 
     SDFVoxelsToFogVolume(LeafNodeType ** nodes, ValueType cutoffDistance)
         : mNodes(nodes), mWeight(ValueType(1.0) / cutoffDistance)
@@ -482,7 +484,7 @@
 
             if (node.onVoxelCount() == 0) {
                 delete mNodes[n];
-                mNodes[n] = NULL;
+                mNodes[n] = nullptr;
             }
         }
     }
@@ -500,7 +502,7 @@
 
     void operator()(const tbb::blocked_range<size_t>& range) const {
 
-        typedef typename TreeType::ValueType ValueType;
+        using ValueType = typename TreeType::ValueType;
         tree::ValueAccessor<const TreeType> acc(*mTree);
 
         for (size_t n = range.begin(), N = range.end(); n < N; ++n) {
@@ -522,14 +524,18 @@
 template<typename TreeType>
 struct FillMaskBoundary {
 
-    typedef typename TreeType::ValueType                            ValueType;
-    typedef typename TreeType::LeafNodeType                         LeafNodeType;
-    typedef typename TreeType::template ValueConverter<bool>::Type  BoolTreeType;
-    typedef typename BoolTreeType::LeafNodeType                     BoolLeafNodeType;
+    using ValueType = typename TreeType::ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using BoolTreeType = typename TreeType::template ValueConverter<bool>::Type;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
 
     FillMaskBoundary(const TreeType& tree, ValueType isovalue, const BoolTreeType& fillMask,
         const BoolLeafNodeType ** fillNodes, BoolLeafNodeType ** newNodes)
-        : mTree(&tree), mFillMask(&fillMask), mFillNodes(fillNodes), mNewNodes(newNodes), mIsovalue(isovalue)
+        : mTree(&tree)
+        , mFillMask(&fillMask)
+        , mFillNodes(fillNodes)
+        , mNewNodes(newNodes)
+        , mIsovalue(isovalue)
     {
     }
 
@@ -542,7 +548,7 @@
 
         for (size_t n = range.begin(), N = range.end(); n < N; ++n) {
 
-            mNewNodes[n] = NULL;
+            mNewNodes[n] = nullptr;
             const BoolLeafNodeType& node = *mFillNodes[n];
             const Coord& origin = node.origin();
 
@@ -553,7 +559,8 @@
 
                 int denseNeighbors = 0;
 
-                const BoolLeafNodeType* neighborNode = maskAcc.probeConstLeaf(origin.offsetBy(-1, 0, 0));
+                const BoolLeafNodeType* neighborNode =
+                    maskAcc.probeConstLeaf(origin.offsetBy(-1, 0, 0));
                 if (neighborNode && neighborNode->isDense()) ++denseNeighbors;
 
                 neighborNode = maskAcc.probeConstLeaf(origin.offsetBy(BoolLeafNodeType::DIM, 0, 0));
@@ -589,7 +596,9 @@
                     evalInternalNeighborsN(valueMask.get(), node, *distNode);
                 } else if (distAcc.getValue(origin) > mIsovalue) {
                     earlyTermination = evalInternalNeighborsP(valueMask.get(), node);
-                    if (!earlyTermination) earlyTermination = evalInternalNeighborsN(valueMask.get(), node);
+                    if (!earlyTermination) {
+                        earlyTermination = evalInternalNeighborsN(valueMask.get(), node);
+                    }
                 }
             }
 
@@ -621,11 +630,10 @@
     }
 
 private:
-
     // Check internal voxel neighbors in positive {x, y, z} directions.
-
-    void evalInternalNeighborsP(char* valueMask, const BoolLeafNodeType& node, const LeafNodeType& distNode) const {
-
+    void evalInternalNeighborsP(char* valueMask, const BoolLeafNodeType& node,
+        const LeafNodeType& distNode) const
+    {
         for (Index x = 0; x < BoolLeafNodeType::DIM; ++x) {
             const Index xPos = x << (2 * BoolLeafNodeType::LOG2DIM);
             for (Index y = 0; y < BoolLeafNodeType::DIM; ++y) {
@@ -669,7 +677,9 @@
                     if (valueMask[pos] != 0 || !node.isValueOn(pos)) continue;
 
                     if (!node.isValueOn(pos + BoolLeafNodeType::DIM * BoolLeafNodeType::DIM) &&
-                        distNode.getValue(pos + BoolLeafNodeType::DIM * BoolLeafNodeType::DIM)  > mIsovalue) {
+                        (distNode.getValue(pos + BoolLeafNodeType::DIM * BoolLeafNodeType::DIM)
+                             > mIsovalue))
+                    {
                         valueMask[pos] = 1;
                     }
                 }
@@ -730,8 +740,9 @@
 
     // Check internal voxel neighbors in negative {x, y, z} directions.
 
-    void evalInternalNeighborsN(char* valueMask, const BoolLeafNodeType& node, const LeafNodeType& distNode) const {
-
+    void evalInternalNeighborsN(char* valueMask, const BoolLeafNodeType& node,
+        const LeafNodeType& distNode) const
+    {
         for (Index x = 0; x < BoolLeafNodeType::DIM; ++x) {
             const Index xPos = x << (2 * BoolLeafNodeType::LOG2DIM);
             for (Index y = 0; y < BoolLeafNodeType::DIM; ++y) {
@@ -775,7 +786,9 @@
                     if (valueMask[pos] != 0 || !node.isValueOn(pos)) continue;
 
                     if (!node.isValueOn(pos - BoolLeafNodeType::DIM * BoolLeafNodeType::DIM) &&
-                        distNode.getValue(pos - BoolLeafNodeType::DIM * BoolLeafNodeType::DIM)  > mIsovalue) {
+                        (distNode.getValue(pos - BoolLeafNodeType::DIM * BoolLeafNodeType::DIM)
+                             > mIsovalue))
+                    {
                         valueMask[pos] = 1;
                     }
                 }
@@ -956,20 +969,16 @@
 computeEnclosedRegionMask(const TreeType& tree, typename TreeType::ValueType isovalue,
     const typename TreeType::template ValueConverter<bool>::Type* fillMask)
 {
-    typedef typename TreeType::LeafNodeType                                         LeafNodeType;
-    typedef typename TreeType::RootNodeType                                         RootNodeType;
-    typedef typename RootNodeType::NodeChainType                                    NodeChainType;
-    typedef typename boost::mpl::at<NodeChainType, boost::mpl::int_<1> >::type      InternalNodeType;
-
-    typedef typename TreeType::template ValueConverter<char>::Type                  CharTreeType;
-    typedef typename CharTreeType::LeafNodeType                                     CharLeafNodeType;
-    typedef typename CharTreeType::RootNodeType                                     CharRootNodeType;
-    typedef typename CharRootNodeType::NodeChainType                                CharNodeChainType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using RootNodeType = typename TreeType::RootNodeType;
+    using NodeChainType = typename RootNodeType::NodeChainType;
+    using InternalNodeType = typename boost::mpl::at<NodeChainType, boost::mpl::int_<1>>::type;
 
-    typedef typename TreeType::template ValueConverter<bool>::Type                  BoolTreeType;
-    typedef typename BoolTreeType::LeafNodeType                                     BoolLeafNodeType;
+    using CharTreeType = typename TreeType::template ValueConverter<char>::Type;
+    using CharLeafNodeType = typename CharTreeType::LeafNodeType;
 
-    /////
+    using BoolTreeType = typename TreeType::template ValueConverter<bool>::Type;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
 
     const TreeType* treePt = &tree;
 
@@ -1021,16 +1030,18 @@
         std::vector<const BoolLeafNodeType*> fillMaskNodes;
         fillMask->getNodes(fillMaskNodes);
 
-        boost::scoped_array<BoolLeafNodeType*> boundaryMaskNodes(new BoolLeafNodeType*[fillMaskNodes.size()]);
+        boost::scoped_array<BoolLeafNodeType*> boundaryMaskNodes(
+            new BoolLeafNodeType*[fillMaskNodes.size()]);
 
         tbb::parallel_for(tbb::blocked_range<size_t>(0, fillMaskNodes.size()),
-            FillMaskBoundary<TreeType>(tree, isovalue, *fillMask, &fillMaskNodes[0], boundaryMaskNodes.get()));
+            FillMaskBoundary<TreeType>(tree, isovalue, *fillMask, &fillMaskNodes[0],
+                boundaryMaskNodes.get()));
 
         tree::ValueAccessor<CharTreeType> maskAcc(*maskTree);
 
         for (size_t n = 0, N = fillMaskNodes.size(); n < N; ++n) {
 
-            if (boundaryMaskNodes[n] == NULL) continue;
+            if (boundaryMaskNodes[n] == nullptr) continue;
 
             const BoolLeafNodeType& boundaryNode = *boundaryMaskNodes[n];
             const Coord& origin = boundaryNode.origin();
@@ -1076,16 +1087,17 @@
 inline typename TreeType::template ValueConverter<bool>::Type::Ptr
 computeInteriorMask(const TreeType& tree, typename TreeType::ValueType iso)
 {
-    typedef typename TreeType::LeafNodeType                                         LeafNodeType;
-    typedef typename TreeType::RootNodeType                                         RootNodeType;
-    typedef typename RootNodeType::NodeChainType                                    NodeChainType;
-    typedef typename boost::mpl::at<NodeChainType, boost::mpl::int_<1> >::type      InternalNodeType;
-
-    typedef typename TreeType::template ValueConverter<bool>::Type                  BoolTreeType;
-    typedef typename BoolTreeType::LeafNodeType                                     BoolLeafNodeType;
-    typedef typename BoolTreeType::RootNodeType                                     BoolRootNodeType;
-    typedef typename BoolRootNodeType::NodeChainType                                BoolNodeChainType;
-    typedef typename boost::mpl::at<BoolNodeChainType, boost::mpl::int_<1> >::type  BoolInternalNodeType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using RootNodeType = typename TreeType::RootNodeType;
+    using NodeChainType = typename RootNodeType::NodeChainType;
+    using InternalNodeType = typename boost::mpl::at<NodeChainType, boost::mpl::int_<1> >::type;
+
+    using BoolTreeType = typename TreeType::template ValueConverter<bool>::Type;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
+    using BoolRootNodeType = typename BoolTreeType::RootNodeType;
+    using BoolNodeChainType = typename BoolRootNodeType::NodeChainType;
+    using BoolInternalNodeType =
+        typename boost::mpl::at<BoolNodeChainType, boost::mpl::int_<1>>::type;
 
     /////
     size_t numLeafNodes = 0, numInternalNodes = 0;
@@ -1155,10 +1167,10 @@
 template<typename InputTreeType>
 struct MaskIsovalueCrossingVoxels
 {
-    typedef typename InputTreeType::ValueType                               InputValueType;
-    typedef typename InputTreeType::LeafNodeType                            InputLeafNodeType;
-    typedef typename InputTreeType::template ValueConverter<bool>::Type     BoolTreeType;
-    typedef typename BoolTreeType::LeafNodeType                             BoolLeafNodeType;
+    using InputValueType = typename InputTreeType::ValueType;
+    using InputLeafNodeType = typename InputTreeType::LeafNodeType;
+    using BoolTreeType = typename InputTreeType::template ValueConverter<bool>::Type;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
 
     MaskIsovalueCrossingVoxels(
         const InputTreeType& inputTree,
@@ -1166,7 +1178,7 @@
         BoolTreeType& maskTree,
         InputValueType iso)
         : mInputAccessor(inputTree)
-        , mInputNodes(!inputLeafNodes.empty() ? &inputLeafNodes.front() : NULL)
+        , mInputNodes(!inputLeafNodes.empty() ? &inputLeafNodes.front() : nullptr)
         , mMaskTree(false)
         , mMaskAccessor(maskTree)
         , mIsovalue(iso)
@@ -1187,7 +1199,7 @@
         const InputValueType iso = mIsovalue;
         Coord ijk(0, 0, 0);
 
-        BoolLeafNodeType* maskNodePt = NULL;
+        BoolLeafNodeType* maskNodePt = nullptr;
 
         for (size_t n = range.begin(); mInputNodes && (n != range.end()); ++n) {
 
@@ -1246,7 +1258,7 @@
 
             if (collectedData) {
                 mMaskAccessor.addLeaf(maskNodePt);
-                maskNodePt = NULL;
+                maskNodePt = nullptr;
             }
         }
 
@@ -1274,8 +1286,8 @@
 template<typename NodeType>
 struct NodeMaskSegment
 {
-    typedef boost::shared_ptr<NodeMaskSegment>  Ptr;
-    typedef typename NodeType::NodeMaskType     NodeMaskType;
+    using Ptr = SharedPtr<NodeMaskSegment>;
+    using NodeMaskType = typename NodeType::NodeMaskType;
 
     NodeMaskSegment() : connections(), mask(false), origin(0,0,0), visited(false) {}
 
@@ -1291,9 +1303,9 @@
 nodeMaskSegmentation(const NodeType& node,
     std::vector<typename NodeMaskSegment<NodeType>::Ptr>& segments)
 {
-    typedef typename NodeType::NodeMaskType     NodeMaskType;
-    typedef NodeMaskSegment<NodeType>           NodeMaskSegmentType;
-    typedef typename NodeMaskSegmentType::Ptr   NodeMaskSegmentTypePtr;
+    using NodeMaskType = typename NodeType::NodeMaskType;
+    using NodeMaskSegmentType = NodeMaskSegment<NodeType>;
+    using NodeMaskSegmentTypePtr = typename NodeMaskSegmentType::Ptr;
 
     NodeMaskType nodeMask(node.getValueMask());
     std::deque<Index> indexList;
@@ -1365,12 +1377,12 @@
 template<typename NodeType>
 struct SegmentNodeMask
 {
-    typedef NodeMaskSegment<NodeType>                       NodeMaskSegmentType;
-    typedef typename NodeMaskSegmentType::Ptr               NodeMaskSegmentTypePtr;
-    typedef typename std::vector<NodeMaskSegmentTypePtr>    NodeMaskSegmentVector;
+    using NodeMaskSegmentType = NodeMaskSegment<NodeType>;
+    using NodeMaskSegmentTypePtr = typename NodeMaskSegmentType::Ptr;
+    using NodeMaskSegmentVector = typename std::vector<NodeMaskSegmentTypePtr>;
 
     SegmentNodeMask(std::vector<NodeType*>& nodes, NodeMaskSegmentVector* nodeMaskArray)
-        : mNodes(!nodes.empty() ? &nodes.front() : NULL)
+        : mNodes(!nodes.empty() ? &nodes.front() : nullptr)
         , mNodeMaskArray(nodeMaskArray)
     {
     }
@@ -1394,10 +1406,10 @@
 template<typename TreeType, typename NodeType>
 struct ConnectNodeMaskSegments
 {
-    typedef typename NodeType::NodeMaskType                 NodeMaskType;
-    typedef NodeMaskSegment<NodeType>                       NodeMaskSegmentType;
-    typedef typename NodeMaskSegmentType::Ptr               NodeMaskSegmentTypePtr;
-    typedef typename std::vector<NodeMaskSegmentTypePtr>    NodeMaskSegmentVector;
+    using NodeMaskType = typename NodeType::NodeMaskType;
+    using NodeMaskSegmentType = NodeMaskSegment<NodeType>;
+    using NodeMaskSegmentTypePtr = typename NodeMaskSegmentType::Ptr;
+    using NodeMaskSegmentVector = typename std::vector<NodeMaskSegmentTypePtr>;
 
     ConnectNodeMaskSegments(const TreeType& tree, NodeMaskSegmentVector* nodeMaskArray)
         : mTree(&tree)
@@ -1527,7 +1539,7 @@
     static inline NodeMaskSegmentType*
     findNodeMaskSegment(NodeMaskSegmentVector& segments, Index pos)
     {
-        NodeMaskSegmentType* segment = NULL;
+        NodeMaskSegmentType* segment = nullptr;
 
         for (size_t n = 0, N = segments.size(); n < N; ++n) {
             if (segments[n]->mask.isOn(pos)) {
@@ -1556,12 +1568,12 @@
 template<typename TreeType>
 struct MaskSegmentGroup
 {
-    typedef typename TreeType::LeafNodeType     LeafNodeType;
-    typedef typename TreeType::Ptr              TreeTypePtr;
-    typedef NodeMaskSegment<LeafNodeType>       NodeMaskSegmentType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using TreeTypePtr = typename TreeType::Ptr;
+    using NodeMaskSegmentType = NodeMaskSegment<LeafNodeType>;
 
     MaskSegmentGroup(const std::vector<NodeMaskSegmentType*>& segments)
-        : mSegments(!segments.empty() ? &segments.front() : NULL)
+        : mSegments(!segments.empty() ? &segments.front() : nullptr)
         , mTree(new TreeType(false))
     {
     }
@@ -1599,19 +1611,20 @@
 template<typename TreeType>
 struct ExpandLeafNodeRegion
 {
-    typedef typename TreeType::ValueType                            ValueType;
-    typedef typename TreeType::LeafNodeType                         LeafNodeType;
-    typedef typename LeafNodeType::NodeMaskType                     NodeMaskType;
+    using ValueType = typename TreeType::ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using NodeMaskType = typename LeafNodeType::NodeMaskType;
 
-    typedef typename TreeType::template ValueConverter<bool>::Type  BoolTreeType;
-    typedef typename BoolTreeType::LeafNodeType                     BoolLeafNodeType;
+    using BoolTreeType = typename TreeType::template ValueConverter<bool>::Type;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
 
     /////
 
-    ExpandLeafNodeRegion(const TreeType& distTree, BoolTreeType& maskTree, std::vector<BoolLeafNodeType*>& maskNodes)
+    ExpandLeafNodeRegion(const TreeType& distTree, BoolTreeType& maskTree,
+        std::vector<BoolLeafNodeType*>& maskNodes)
         : mDistTree(&distTree)
         , mMaskTree(&maskTree)
-        , mMaskNodes(!maskNodes.empty() ? &maskNodes.front() : NULL)
+        , mMaskNodes(!maskNodes.empty() ? &maskNodes.front() : nullptr)
         , mNewMaskTree(false)
     {
     }
@@ -1630,7 +1643,7 @@
 
     void operator()(const tbb::blocked_range<size_t>& range) {
 
-        typedef LeafNodeType    NodeType;
+        using NodeType = LeafNodeType;
 
         tree::ValueAccessor<const TreeType>         distAcc(*mDistTree);
         tree::ValueAccessor<const BoolTreeType>     maskAcc(*mMaskTree);
@@ -1648,9 +1661,9 @@
             const LeafNodeType* distNode = distAcc.probeConstLeaf(ijk);
             if (!distNode) continue;
 
-            const ValueType *dataZUp = NULL, *dataZDown = NULL,
-                            *dataYUp = NULL, *dataYDown = NULL,
-                            *dataXUp = NULL, *dataXDown = NULL;
+            const ValueType *dataZUp = nullptr, *dataZDown = nullptr,
+                            *dataYUp = nullptr, *dataYDown = nullptr,
+                            *dataXUp = nullptr, *dataXDown = nullptr;
 
             ijk[2] += NodeType::DIM;
             getData(ijk, distAcc, maskAcc, maskZUp, dataZUp);
@@ -1722,7 +1735,8 @@
 
     static inline void
     getData(const Coord& ijk, tree::ValueAccessor<const TreeType>& distAcc,
-        tree::ValueAccessor<const BoolTreeType>& maskAcc, NodeMaskType& mask, const ValueType*& data)
+        tree::ValueAccessor<const BoolTreeType>& maskAcc, NodeMaskType& mask,
+        const ValueType*& data)
     {
         const LeafNodeType* node = distAcc.probeConstLeaf(ijk);
         if (node) {
@@ -1744,13 +1758,13 @@
 template<typename TreeType>
 struct FillLeafNodeVoxels
 {
-    typedef typename TreeType::ValueType                    ValueType;
-    typedef typename TreeType::LeafNodeType                 LeafNodeType;
-    typedef typename LeafNodeType::NodeMaskType             NodeMaskType;
-    typedef tree::LeafNode<bool, LeafNodeType::LOG2DIM>     BoolLeafNodeType;
+    using ValueType = typename TreeType::ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using NodeMaskType = typename LeafNodeType::NodeMaskType;
+    using BoolLeafNodeType = tree::LeafNode<bool, LeafNodeType::LOG2DIM>;
 
     FillLeafNodeVoxels(const TreeType& tree, std::vector<BoolLeafNodeType*>& maskNodes)
-        : mTree(&tree), mMaskNodes(!maskNodes.empty() ? &maskNodes.front() : NULL)
+        : mTree(&tree), mMaskNodes(!maskNodes.empty() ? &maskNodes.front() : nullptr)
     {
     }
 
@@ -1800,7 +1814,9 @@
                 }
 
                 npos = pos + 1;
-                if (ijk[2] != (LeafNodeType::DIM - 1) && mask.isOn(npos) && std::abs(data[npos]) > dist) {
+                if ((ijk[2] != (LeafNodeType::DIM - 1)) && mask.isOn(npos)
+                    && std::abs(data[npos]) > dist)
+                {
                     mask.setOff(npos);
                     indexList.push_back(npos);
                 }
@@ -1812,7 +1828,9 @@
                 }
 
                 npos = pos + LeafNodeType::DIM;
-                if (ijk[1] != (LeafNodeType::DIM - 1) && mask.isOn(npos) && std::abs(data[npos]) > dist) {
+                if ((ijk[1] != (LeafNodeType::DIM - 1)) && mask.isOn(npos)
+                    && std::abs(data[npos]) > dist)
+                {
                     mask.setOff(npos);
                     indexList.push_back(npos);
                 }
@@ -1824,7 +1842,9 @@
                 }
 
                 npos = pos + LeafNodeType::DIM * LeafNodeType::DIM;
-                if (ijk[0] != (LeafNodeType::DIM - 1) && mask.isOn(npos) && std::abs(data[npos]) > dist) {
+                if ((ijk[0] != (LeafNodeType::DIM - 1)) && mask.isOn(npos)
+                    && std::abs(data[npos]) > dist)
+                {
                     mask.setOff(npos);
                     indexList.push_back(npos);
                 }
@@ -1840,12 +1860,12 @@
 template<typename TreeType>
 struct ExpandNarrowbandMask
 {
-    typedef typename TreeType::template ValueConverter<bool>::Type  BoolTreeType;
-    typedef typename BoolTreeType::LeafNodeType                     BoolLeafNodeType;
-    typedef typename BoolTreeType::Ptr                              BoolTreeTypePtr;
+    using BoolTreeType = typename TreeType::template ValueConverter<bool>::Type;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
+    using BoolTreeTypePtr = typename BoolTreeType::Ptr;
 
     ExpandNarrowbandMask(const TreeType& tree, std::vector<BoolTreeTypePtr>& segments)
-        : mTree(&tree), mSegments(!segments.empty() ? &segments.front() : NULL)
+        : mTree(&tree), mSegments(!segments.empty() ? &segments.front() : nullptr)
     {
     }
 
@@ -1891,16 +1911,16 @@
 template<typename TreeType>
 struct FloodFillSign
 {
-    typedef typename TreeType::Ptr                                              TreeTypePtr;
-    typedef typename TreeType::ValueType                                        ValueType;
-    typedef typename TreeType::LeafNodeType                                     LeafNodeType;
-    typedef typename TreeType::RootNodeType                                     RootNodeType;
-    typedef typename RootNodeType::NodeChainType                                NodeChainType;
-    typedef typename boost::mpl::at<NodeChainType, boost::mpl::int_<1> >::type  InternalNodeType;
+    using TreeTypePtr = typename TreeType::Ptr;
+    using ValueType = typename TreeType::ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using RootNodeType = typename TreeType::RootNodeType;
+    using NodeChainType = typename RootNodeType::NodeChainType;
+    using InternalNodeType = typename boost::mpl::at<NodeChainType, boost::mpl::int_<1> >::type;
 
     FloodFillSign(const TreeType& tree, std::vector<TreeTypePtr>& segments)
         : mTree(&tree)
-        , mSegments(!segments.empty() ? &segments.front() : NULL)
+        , mSegments(!segments.empty() ? &segments.front() : nullptr)
         , mMinValue(ValueType(0.0))
     {
         ValueType minSDFValue = std::numeric_limits<ValueType>::max();
@@ -1948,18 +1968,19 @@
 template<typename TreeType>
 struct MaskedCopy
 {
-    typedef typename TreeType::Ptr                                  TreeTypePtr;
-    typedef typename TreeType::ValueType                            ValueType;
-    typedef typename TreeType::LeafNodeType                         LeafNodeType;
-
-    typedef typename TreeType::template ValueConverter<bool>::Type  BoolTreeType;
-    typedef typename BoolTreeType::Ptr                              BoolTreeTypePtr;
-    typedef typename BoolTreeType::LeafNodeType                     BoolLeafNodeType;
+    using TreeTypePtr = typename TreeType::Ptr;
+    using ValueType = typename TreeType::ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+
+    using BoolTreeType = typename TreeType::template ValueConverter<bool>::Type;
+    using BoolTreeTypePtr = typename BoolTreeType::Ptr;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
 
-    MaskedCopy(const TreeType& tree, std::vector<TreeTypePtr>& segments, std::vector<BoolTreeTypePtr>& masks)
+    MaskedCopy(const TreeType& tree, std::vector<TreeTypePtr>& segments,
+        std::vector<BoolTreeTypePtr>& masks)
         : mTree(&tree)
-        , mSegments(!segments.empty() ? &segments.front() : NULL)
-        , mMasks(!masks.empty() ? &masks.front() : NULL)
+        , mSegments(!segments.empty() ? &segments.front() : nullptr)
+        , mMasks(!masks.empty() ? &masks.front() : nullptr)
     {
     }
 
@@ -1985,7 +2006,7 @@
     struct Copy {
         Copy(const TreeType& inputTree, std::vector<const BoolLeafNodeType*>& maskNodes)
             : mInputTree(&inputTree)
-            , mMaskNodes(!maskNodes.empty() ? &maskNodes.front() : NULL)
+            , mMaskNodes(!maskNodes.empty() ? &maskNodes.front() : nullptr)
             , mOutputTreePtr(new TreeType(inputTree.background()))
         {
         }
@@ -2018,7 +2039,9 @@
 
                     LeafNodeType* outputNode = outputAcc.touchLeaf(ijk);
 
-                    for (typename BoolLeafNodeType::ValueOnCIter it = maskNode.cbeginValueOn(); it; ++it) {
+                    for (typename BoolLeafNodeType::ValueOnCIter it = maskNode.cbeginValueOn();
+                        it; ++it)
+                    {
                         const Index idx = it.pos();
                         outputNode->setValueOn(idx, inputNode->getValue(idx));
                     }
@@ -2051,7 +2074,7 @@
 struct ComputeActiveVoxelCount
 {
     ComputeActiveVoxelCount(std::vector<VolumePtrType>& segments, size_t *countArray)
-        : mSegments(!segments.empty() ? &segments.front() : NULL)
+        : mSegments(!segments.empty() ? &segments.front() : nullptr)
         , mCountArray(countArray)
     {
     }
@@ -2085,10 +2108,11 @@
 template<typename TreeType>
 struct GridOrTreeConstructor
 {
-    typedef typename TreeType::Ptr TreeTypePtr;
-    typedef typename TreeType::template ValueConverter<bool>::Type::Ptr BoolTreePtrType;
+    using TreeTypePtr = typename TreeType::Ptr;
+    using BoolTreePtrType = typename TreeType::template ValueConverter<bool>::Type::Ptr;
 
-    static BoolTreePtrType constructMask(const TreeType&, BoolTreePtrType& maskTree) { return maskTree; }
+    static BoolTreePtrType constructMask(const TreeType&, BoolTreePtrType& maskTree)
+        { return maskTree; }
     static TreeTypePtr construct(const TreeType&, TreeTypePtr& tree) { return tree; }
 };
 
@@ -2096,14 +2120,14 @@
 template<typename TreeType>
 struct GridOrTreeConstructor<Grid<TreeType> >
 {
-    typedef Grid<TreeType>                                          GridType;
-    typedef typename Grid<TreeType>::Ptr                             GridTypePtr;
-    typedef typename TreeType::Ptr TreeTypePtr;
-
-    typedef typename TreeType::template ValueConverter<bool>::Type  BoolTreeType;
-    typedef typename BoolTreeType::Ptr                              BoolTreePtrType;
-    typedef Grid<BoolTreeType>                                      BoolGridType;
-    typedef typename BoolGridType::Ptr                              BoolGridPtrType;
+    using GridType = Grid<TreeType>;
+    using GridTypePtr = typename Grid<TreeType>::Ptr;
+    using TreeTypePtr = typename TreeType::Ptr;
+
+    using BoolTreeType = typename TreeType::template ValueConverter<bool>::Type;
+    using BoolTreePtrType = typename BoolTreeType::Ptr;
+    using BoolGridType = Grid<BoolTreeType>;
+    using BoolGridPtrType = typename BoolGridType::Ptr;
 
     static BoolGridPtrType constructMask(const GridType& grid, BoolTreePtrType& maskTree) {
         BoolGridPtrType maskGrid(BoolGridType::create(maskTree));
@@ -2130,12 +2154,12 @@
 inline void
 sdfToFogVolume(GridType& grid, typename GridType::ValueType cutoffDistance)
 {
-    typedef typename GridType::ValueType                                            ValueType;
-    typedef typename GridType::TreeType                                             TreeType;
-    typedef typename TreeType::LeafNodeType                                         LeafNodeType;
-    typedef typename TreeType::RootNodeType                                         RootNodeType;
-    typedef typename RootNodeType::NodeChainType                                    NodeChainType;
-    typedef typename boost::mpl::at<NodeChainType, boost::mpl::int_<1> >::type      InternalNodeType;
+    using ValueType = typename GridType::ValueType;
+    using TreeType = typename GridType::TreeType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using RootNodeType = typename TreeType::RootNodeType;
+    using NodeChainType = typename RootNodeType::NodeChainType;
+    using InternalNodeType = typename boost::mpl::at<NodeChainType, boost::mpl::int_<1>>::type;
 
     //////////
 
@@ -2195,7 +2219,8 @@
     // Populate a new tree with the remaining leafnodes
     typename TreeType::Ptr newTree(new TreeType(ValueType(0.0)));
 
-    level_set_util_internal::PopulateTree<TreeType> populate(*newTree, &nodes[0], &leafnodeCount[0], 0);
+    level_set_util_internal::PopulateTree<TreeType> populate(
+        *newTree, &nodes[0], &leafnodeCount[0], 0);
     tbb::parallel_reduce(tbb::blocked_range<size_t>(0, numInternalNodes), populate);
 
     // Transform tile values (Negative valued tiles are set to 1.0 with active state.)
@@ -2203,7 +2228,8 @@
     newTree->getNodes(internalNodes);
 
     tbb::parallel_for(tbb::blocked_range<size_t>(0, internalNodes.size()),
-        level_set_util_internal::SDFTilesToFogVolume<TreeType, InternalNodeType>(tree, &internalNodes[0]));
+        level_set_util_internal::SDFTilesToFogVolume<TreeType, InternalNodeType>(
+            tree, &internalNodes[0]));
 
     {
         tree::ValueAccessor<const TreeType> acc(tree);
@@ -2226,7 +2252,8 @@
         it.setMaxDepth(TreeType::ValueAllIter::ROOT_DEPTH);
         for ( ; it; ++it) {
             if (it.getValue() <  ValueType(0.0)) {
-                newTree->addTile(TreeType::ValueAllIter::ROOT_LEVEL, it.getCoord(), ValueType(1.0), true);
+                newTree->addTile(TreeType::ValueAllIter::ROOT_LEVEL, it.getCoord(),
+                    ValueType(1.0), true);
             }
         }
     }
@@ -2243,13 +2270,14 @@
 inline typename GridOrTreeType::template ValueConverter<bool>::Type::Ptr
 sdfInteriorMask(const GridOrTreeType& volume, typename GridOrTreeType::ValueType isovalue)
 {
-    typedef typename TreeAdapter<GridOrTreeType>::TreeType TreeType;
+    using TreeType = typename TreeAdapter<GridOrTreeType>::TreeType;
     const TreeType& tree = TreeAdapter<GridOrTreeType>::tree(volume);
 
-    typedef typename TreeType::template ValueConverter<bool>::Type::Ptr BoolTreePtrType;
+    using BoolTreePtrType = typename TreeType::template ValueConverter<bool>::Type::Ptr;
     BoolTreePtrType mask = level_set_util_internal::computeInteriorMask(tree, isovalue);
 
-    return level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::constructMask(volume, mask);
+    return level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::constructMask(
+        volume, mask);
 }
 
 
@@ -2257,18 +2285,21 @@
 inline typename GridOrTreeType::template ValueConverter<bool>::Type::Ptr
 extractEnclosedRegion(const GridOrTreeType& volume,
     typename GridOrTreeType::ValueType isovalue,
-    const typename TreeAdapter<GridOrTreeType>::TreeType::template ValueConverter<bool>::Type* fillMask)
+    const typename TreeAdapter<GridOrTreeType>::TreeType::template ValueConverter<bool>::Type*
+        fillMask)
 {
-    typedef typename TreeAdapter<GridOrTreeType>::TreeType TreeType;
+    using TreeType = typename TreeAdapter<GridOrTreeType>::TreeType;
     const TreeType& tree = TreeAdapter<GridOrTreeType>::tree(volume);
 
-    typedef typename TreeType::template ValueConverter<char>::Type::Ptr CharTreePtrType;
-    CharTreePtrType regionMask = level_set_util_internal::computeEnclosedRegionMask(tree, isovalue, fillMask);
+    using CharTreePtrType = typename TreeType::template ValueConverter<char>::Type::Ptr;
+    CharTreePtrType regionMask = level_set_util_internal::computeEnclosedRegionMask(
+        tree, isovalue, fillMask);
 
-    typedef typename TreeType::template ValueConverter<bool>::Type::Ptr BoolTreePtrType;
+    using BoolTreePtrType = typename TreeType::template ValueConverter<bool>::Type::Ptr;
     BoolTreePtrType mask = level_set_util_internal::computeInteriorMask(*regionMask, 0);
 
-    return level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::constructMask(volume, mask);
+    return level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::constructMask(
+        volume, mask);
 }
 
 
@@ -2279,19 +2310,20 @@
 inline typename GridOrTreeType::template ValueConverter<bool>::Type::Ptr
 extractIsosurfaceMask(const GridOrTreeType& volume, typename GridOrTreeType::ValueType isovalue)
 {
-    typedef typename TreeAdapter<GridOrTreeType>::TreeType TreeType;
+    using TreeType = typename TreeAdapter<GridOrTreeType>::TreeType;
     const TreeType& tree = TreeAdapter<GridOrTreeType>::tree(volume);
 
     std::vector<const typename TreeType::LeafNodeType*> nodes;
     tree.getNodes(nodes);
 
-    typedef typename TreeType::template ValueConverter<bool>::Type BoolTreeType;
+    using BoolTreeType = typename TreeType::template ValueConverter<bool>::Type;
     typename BoolTreeType::Ptr mask(new BoolTreeType(false));
 
     level_set_util_internal::MaskIsovalueCrossingVoxels<TreeType> op(tree, nodes, *mask, isovalue);
     tbb::parallel_reduce(tbb::blocked_range<size_t>(0, nodes.size()), op);
 
-    return level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::constructMask(volume, mask);
+    return level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::constructMask(
+        volume, mask);
 }
 
 
@@ -2303,15 +2335,15 @@
 extractActiveVoxelSegmentMasks(const GridOrTreeType& volume,
     std::vector<typename GridOrTreeType::template ValueConverter<bool>::Type::Ptr>& masks)
 {
-    typedef typename TreeAdapter<GridOrTreeType>::TreeType              TreeType;
-    typedef typename TreeType::template ValueConverter<bool>::Type      BoolTreeType;
-    typedef typename BoolTreeType::Ptr                                  BoolTreePtrType;
-    typedef typename BoolTreeType::LeafNodeType                         BoolLeafNodeType;
-
-    typedef level_set_util_internal::NodeMaskSegment<BoolLeafNodeType>  NodeMaskSegmentType;
-    typedef typename NodeMaskSegmentType::Ptr                           NodeMaskSegmentPtrType;
-    typedef typename std::vector<NodeMaskSegmentPtrType>                NodeMaskSegmentPtrVector;
-    typedef typename std::vector<NodeMaskSegmentType*>                  NodeMaskSegmentRawPtrVector;
+    using TreeType = typename TreeAdapter<GridOrTreeType>::TreeType;
+    using BoolTreeType = typename TreeType::template ValueConverter<bool>::Type;
+    using BoolTreePtrType = typename BoolTreeType::Ptr;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
+
+    using NodeMaskSegmentType = level_set_util_internal::NodeMaskSegment<BoolLeafNodeType>;
+    using NodeMaskSegmentPtrType = typename NodeMaskSegmentType::Ptr;
+    using NodeMaskSegmentPtrVector = typename std::vector<NodeMaskSegmentPtrType>;
+    using NodeMaskSegmentRawPtrVector = typename std::vector<NodeMaskSegmentType*>;
 
     /////
 
@@ -2331,10 +2363,12 @@
     // 1. Split node masks into disjoint segments
     // Note: The LeafNode origin coord is modified to record the 'leafnodes' array offset.
 
-    boost::scoped_array<NodeMaskSegmentPtrVector> nodeSegmentArray(new NodeMaskSegmentPtrVector[leafnodes.size()]);
+    boost::scoped_array<NodeMaskSegmentPtrVector> nodeSegmentArray(
+        new NodeMaskSegmentPtrVector[leafnodes.size()]);
 
     tbb::parallel_for(tbb::blocked_range<size_t>(0, leafnodes.size()),
-        level_set_util_internal::SegmentNodeMask<BoolLeafNodeType>(leafnodes, nodeSegmentArray.get()));
+        level_set_util_internal::SegmentNodeMask<BoolLeafNodeType>(
+            leafnodes, nodeSegmentArray.get()));
 
 
     // 2. Compute segment connectivity
@@ -2364,7 +2398,7 @@
 
         std::deque<NodeMaskSegmentType*> segmentQueue;
         segmentQueue.push_back(nextSegment);
-        nextSegment = NULL;
+        nextSegment = nullptr;
 
         while (!segmentQueue.empty()) {
 
@@ -2403,7 +2437,8 @@
         }
 
         masks.push_back(
-            level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::constructMask(volume, mask));
+            level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::constructMask(
+                volume, mask));
 
     } else if (nodeSegmentGroups.size() > 1) {
 
@@ -2415,7 +2450,8 @@
             tbb::parallel_reduce(tbb::blocked_range<size_t>(0, segmentGroup.size()), op);
 
             masks.push_back(
-                level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::constructMask(volume, op.mask()));
+                level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::constructMask(
+                    volume, op.mask()));
         }
     }
 
@@ -2432,10 +2468,12 @@
         }
 
         tbb::parallel_for(tbb::blocked_range<size_t>(0, segmentCount),
-            level_set_util_internal::ComputeActiveVoxelCount<BoolTreePtrType>(masks, voxelCountArray.get()));
+            level_set_util_internal::ComputeActiveVoxelCount<BoolTreePtrType>(
+                masks, voxelCountArray.get()));
 
         size_t *begin = segmentOrderArray.get();
-        tbb::parallel_sort(begin, begin + masks.size(), level_set_util_internal::GreaterCount(voxelCountArray.get()));
+        tbb::parallel_sort(begin, begin + masks.size(), level_set_util_internal::GreaterCount(
+            voxelCountArray.get()));
 
         std::vector<BoolTreePtrType> orderedMasks;
         orderedMasks.reserve(masks.size());
@@ -2452,12 +2490,13 @@
 
 template<typename GridOrTreeType>
 inline void
-segmentActiveVoxels(const GridOrTreeType& volume, std::vector<typename GridOrTreeType::Ptr>& segments)
+segmentActiveVoxels(const GridOrTreeType& volume,
+    std::vector<typename GridOrTreeType::Ptr>& segments)
 {
-    typedef typename TreeAdapter<GridOrTreeType>::TreeType          TreeType;
-    typedef typename TreeType::Ptr                                  TreePtrType;
-    typedef typename TreeType::template ValueConverter<bool>::Type  BoolTreeType;
-    typedef typename BoolTreeType::Ptr                              BoolTreePtrType;
+    using TreeType = typename TreeAdapter<GridOrTreeType>::TreeType;
+    using TreePtrType = typename TreeType::Ptr;
+    using BoolTreeType = typename TreeType::template ValueConverter<bool>::Type;
+    using BoolTreePtrType = typename BoolTreeType::Ptr;
 
     const TreeType& inputTree = TreeAdapter<GridOrTreeType>::tree(volume);
 
@@ -2471,7 +2510,8 @@
         // single segment early-out
         TreePtrType segment(new TreeType(inputTree));
         segments.push_back(
-            level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::construct(volume, segment));
+            level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::construct(
+                volume, segment));
         return;
     }
 
@@ -2481,11 +2521,13 @@
     std::vector<TreePtrType> outputSegmentArray(numSegments);
 
     tbb::parallel_for(segmentRange,
-        level_set_util_internal::MaskedCopy<TreeType>(inputTree, outputSegmentArray, maskSegmentArray));
+        level_set_util_internal::MaskedCopy<TreeType>(inputTree, outputSegmentArray,
+            maskSegmentArray));
 
     for (size_t n = 0, N = numSegments; n < N; ++n) {
         segments.push_back(
-            level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::construct(volume, outputSegmentArray[n]));
+            level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::construct(
+                volume, outputSegmentArray[n]));
     }
 }
 
@@ -2494,10 +2536,10 @@
 inline void
 segmentSDF(const GridOrTreeType& volume, std::vector<typename GridOrTreeType::Ptr>& segments)
 {
-    typedef typename TreeAdapter<GridOrTreeType>::TreeType          TreeType;
-    typedef typename TreeType::Ptr                                  TreePtrType;
-    typedef typename TreeType::template ValueConverter<bool>::Type  BoolTreeType;
-    typedef typename BoolTreeType::Ptr                              BoolTreePtrType;
+    using TreeType = typename TreeAdapter<GridOrTreeType>::TreeType;
+    using TreePtrType = typename TreeType::Ptr;
+    using BoolTreeType = typename TreeType::template ValueConverter<bool>::Type;
+    using BoolTreePtrType = typename BoolTreeType::Ptr;
 
     const TreeType& inputTree = TreeAdapter<GridOrTreeType>::tree(volume);
 
@@ -2514,7 +2556,8 @@
         // single segment early-out
         TreePtrType segment(new TreeType(inputTree));
         segments.push_back(
-            level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::construct(volume, segment));
+            level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::construct(
+                volume, segment));
         return;
     }
 
@@ -2528,8 +2571,8 @@
     // 4. Export sdf segments
     std::vector<TreePtrType> outputSegmentArray(numSegments);
 
-    tbb::parallel_for(segmentRange,
-        level_set_util_internal::MaskedCopy<TreeType>(inputTree, outputSegmentArray, maskSegmentArray));
+    tbb::parallel_for(segmentRange, level_set_util_internal::MaskedCopy<TreeType>(
+        inputTree, outputSegmentArray, maskSegmentArray));
 
     tbb::parallel_for(segmentRange,
         level_set_util_internal::FloodFillSign<TreeType>(inputTree, outputSegmentArray));
@@ -2537,11 +2580,11 @@
 
     for (size_t n = 0, N = numSegments; n < N; ++n) {
         segments.push_back(
-            level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::construct(volume, outputSegmentArray[n]));
+            level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::construct(
+                volume, outputSegmentArray[n]));
     }
 }
 
-
 } // namespace tools
 } // namespace OPENVDB_VERSION_NAME
 } // namespace openvdb
@@ -2551,4 +2594,3 @@
 // Copyright (c) 2012-2016 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
-
diff -aur openvdb.3.2.0/tools/MeshToVolume.h openvdb.4.0.0/tools/MeshToVolume.h
--- openvdb.3.2.0/tools/MeshToVolume.h	2016-05-29 16:45:07.000000000 +0200
+++ openvdb.4.0.0/tools/MeshToVolume.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file   MeshToVolume.h
 ///
 /// @brief  Convert polygonal meshes that consist of quads and/or triangles
@@ -40,7 +40,6 @@
 ///
 /// @author Mihai Alden
 
-
 #ifndef OPENVDB_TOOLS_MESH_TO_VOLUME_HAS_BEEN_INCLUDED
 #define OPENVDB_TOOLS_MESH_TO_VOLUME_HAS_BEEN_INCLUDED
 
@@ -63,15 +62,16 @@
 #include <tbb/task_group.h>
 #include <tbb/task_scheduler_init.h>
 
-#include <boost/integer_traits.hpp> // const_max
-#include <boost/math/special_functions/fpclassify.hpp> // for isfinite
+#include <boost/integer_traits.hpp> // for const_max
 #include <boost/scoped_array.hpp>
 
-#include <algorithm> // for std::sort
+#include <algorithm> // for std::sort()
+#include <cmath> // for std::isfinite(), std::isnan()
 #include <deque>
 #include <limits>
-#include <memory> // for auto_ptr/unique_ptr
+#include <memory>
 #include <sstream>
+#include <type_traits>
 #include <vector>
 
 namespace openvdb {
@@ -144,7 +144,7 @@
   float exteriorBandWidth = 3.0f,
   float interiorBandWidth = 3.0f,
   int flags = 0,
-  typename GridType::template ValueConverter<Int32>::Type * polygonIndexGrid = NULL);
+  typename GridType::template ValueConverter<Int32>::Type * polygonIndexGrid = nullptr);
 
 
 /// @brief  Convert polygonal meshes that consist of quads and/or triangles into
@@ -171,7 +171,7 @@
     float exteriorBandWidth = 3.0f,
     float interiorBandWidth = 3.0f,
     int flags = 0,
-    typename GridType::template ValueConverter<Int32>::Type * polygonIndexGrid = NULL);
+    typename GridType::template ValueConverter<Int32>::Type * polygonIndexGrid = nullptr);
 
 
 ////////////////////////////////////////
@@ -192,9 +192,9 @@
 
     QuadAndTriangleDataAdapter(const std::vector<PointType>& points,
         const std::vector<PolygonType>& polygons)
-        : mPointArray(points.empty() ? NULL : &points[0])
+        : mPointArray(points.empty() ? nullptr : &points[0])
         , mPointArraySize(points.size())
-        , mPolygonArray(polygons.empty() ? NULL : &polygons[0])
+        , mPolygonArray(polygons.empty() ? nullptr : &polygons[0])
         , mPolygonArraySize(polygons.size())
     {
     }
@@ -492,8 +492,8 @@
         Index32 mXPrim, mYPrim, mZPrim;
     };
 
-    typedef tree::Tree4<EdgeData, 5, 4, 3>::Type    TreeType;
-    typedef tree::ValueAccessor<TreeType>           Accessor;
+    using TreeType = tree::Tree4<EdgeData, 5, 4, 3>::Type;
+    using Accessor = tree::ValueAccessor<TreeType>;
 
 
     //////////
@@ -536,18 +536,6 @@
 
 namespace mesh_to_volume_internal {
 
-
-template<typename T>
-struct UniquePtr
-{
-#ifdef OPENVDB_HAS_CXX11
-    typedef std::unique_ptr<T>  type;
-#else
-    typedef std::auto_ptr<T>    type;
-#endif
-};
-
-
 template<typename PointType>
 struct TransformPoints {
 
@@ -599,10 +587,10 @@
 {
 public:
 
-    typedef typename TreeType::template ValueConverter<Int32>::Type     Int32TreeType;
+    using Int32TreeType = typename TreeType::template ValueConverter<Int32>::Type;
 
-    typedef typename TreeType::LeafNodeType         LeafNodeType;
-    typedef typename Int32TreeType::LeafNodeType    Int32LeafNodeType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using Int32LeafNodeType = typename Int32TreeType::LeafNodeType;
 
     CombineLeafNodes(TreeType& lhsDistTree, Int32TreeType& lhsIdxTree,
         LeafNodeType ** rhsDistNodes, Int32LeafNodeType ** rhsIdxNodes)
@@ -618,8 +606,8 @@
         tree::ValueAccessor<TreeType> distAcc(*mDistTree);
         tree::ValueAccessor<Int32TreeType> idxAcc(*mIdxTree);
 
-        typedef typename LeafNodeType::ValueType DistValueType;
-        typedef typename Int32LeafNodeType::ValueType IndexValueType;
+        using DistValueType = typename LeafNodeType::ValueType;
+        using IndexValueType = typename Int32LeafNodeType::ValueType;
 
         for (size_t n = range.begin(), N = range.end(); n < N; ++n) {
 
@@ -673,10 +661,10 @@
 template<typename TreeType>
 struct StashOriginAndStoreOffset
 {
-    typedef typename TreeType::LeafNodeType LeafNodeType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
 
     StashOriginAndStoreOffset(std::vector<LeafNodeType*>& nodes, Coord* coordinates)
-        : mNodes(nodes.empty() ? NULL : &nodes[0]), mCoordinates(coordinates)
+        : mNodes(nodes.empty() ? nullptr : &nodes[0]), mCoordinates(coordinates)
     {
     }
 
@@ -696,10 +684,10 @@
 template<typename TreeType>
 struct RestoreOrigin
 {
-    typedef typename TreeType::LeafNodeType LeafNodeType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
 
     RestoreOrigin(std::vector<LeafNodeType*>& nodes, const Coord* coordinates)
-        : mNodes(nodes.empty() ? NULL : &nodes[0]), mCoordinates(coordinates)
+        : mNodes(nodes.empty() ? nullptr : &nodes[0]), mCoordinates(coordinates)
     {
     }
 
@@ -719,7 +707,7 @@
 class ComputeNodeConnectivity
 {
 public:
-    typedef typename TreeType::LeafNodeType LeafNodeType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
 
     ComputeNodeConnectivity(const TreeType& tree, const Coord* coordinates,
         size_t* offsets, size_t numNodes, const CoordBBox& bbox)
@@ -731,6 +719,11 @@
     {
     }
 
+    ComputeNodeConnectivity(const ComputeNodeConnectivity&) = default;
+
+    // Disallow assignment
+    ComputeNodeConnectivity& operator=(const ComputeNodeConnectivity&) = delete;
+
     void operator()(const tbb::blocked_range<size_t>& range) const {
 
         size_t* offsetsNextX = mOffsets;
@@ -754,8 +747,9 @@
         }
     }
 
-    size_t findNeighbourNode(tree::ValueAccessor<const TreeType>& acc, const Coord& start, const Coord& step) const {
-
+    size_t findNeighbourNode(tree::ValueAccessor<const TreeType>& acc,
+        const Coord& start, const Coord& step) const
+    {
         Coord ijk = start + step;
         CoordBBox bbox(mBBox);
 
@@ -770,9 +764,6 @@
 
 
 private:
-    // Disallow assignment
-    ComputeNodeConnectivity& operator=(const ComputeNodeConnectivity&);
-
     TreeType    const * const mTree;
     Coord       const * const mCoordinates;
     size_t            * const mOffsets;
@@ -787,11 +778,11 @@
 
     enum { INVALID_OFFSET = boost::integer_traits<size_t>::const_max };
 
-    typedef typename TreeType::LeafNodeType LeafNodeType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
 
     LeafNodeConnectivityTable(TreeType& tree)
         : mLeafNodes()
-        , mOffsets(NULL)
+        , mOffsets(nullptr)
     {
         mLeafNodes.reserve(tree.leafCount());
         tree.getNodes(mLeafNodes);
@@ -806,14 +797,15 @@
         // stash the leafnode origin coordinate and temporarily store the
         // linear offset in the origin.x variable.
         boost::scoped_array<Coord> coordinates(new Coord[mLeafNodes.size()]);
-        tbb::parallel_for(range, StashOriginAndStoreOffset<TreeType>(mLeafNodes, coordinates.get()));
+        tbb::parallel_for(range,
+            StashOriginAndStoreOffset<TreeType>(mLeafNodes, coordinates.get()));
 
         // build the leafnode offset table
         mOffsets.reset(new size_t[mLeafNodes.size() * 6]);
 
 
-        tbb::parallel_for(range,
-            ComputeNodeConnectivity<TreeType>(tree, coordinates.get(), mOffsets.get(), mLeafNodes.size(), bbox));
+        tbb::parallel_for(range, ComputeNodeConnectivity<TreeType>(
+            tree, coordinates.get(), mOffsets.get(), mLeafNodes.size(), bbox));
 
         // restore the leafnode origin coordinate
         tbb::parallel_for(range, RestoreOrigin<TreeType>(mLeafNodes, coordinates.get()));
@@ -847,12 +839,13 @@
 
     enum Axis { X_AXIS = 0, Y_AXIS = 1, Z_AXIS = 2 };
 
-    typedef typename TreeType::ValueType            ValueType;
-    typedef typename TreeType::LeafNodeType         LeafNodeType;
-    typedef LeafNodeConnectivityTable<TreeType>     ConnectivityTable;
-
-    SweepExteriorSign(Axis axis, const std::vector<size_t>& startNodeIndices, ConnectivityTable& connectivity)
-        : mStartNodeIndices(startNodeIndices.empty() ? NULL : &startNodeIndices[0])
+    using ValueType = typename TreeType::ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using ConnectivityTable = LeafNodeConnectivityTable<TreeType>;
+
+    SweepExteriorSign(Axis axis, const std::vector<size_t>& startNodeIndices,
+        ConnectivityTable& connectivity)
+        : mStartNodeIndices(startNodeIndices.empty() ? nullptr : &startNodeIndices[0])
         , mConnectivity(&connectivity)
         , mAxis(axis)
     {
@@ -972,8 +965,8 @@
 inline void
 seedFill(LeafNodeType& node)
 {
-    typedef typename LeafNodeType::ValueType ValueType;
-    typedef std::deque<Index> Queue;
+    using ValueType = typename LeafNodeType::ValueType;
+    using Queue = std::deque<Index>;
 
 
     ValueType* data = node.buffer().data();
@@ -1050,7 +1043,7 @@
 {
     bool updatedNode = false;
 
-    typedef typename LeafNodeType::ValueType ValueType;
+    using ValueType = typename LeafNodeType::ValueType;
     ValueType* data = node.buffer().data();
 
     Coord ijk(0, 0, 0);
@@ -1084,17 +1077,23 @@
                     dist = ValueType(-dist);
 
                 // i, j + 1, k
-                } else if (ijk[1] != (LeafNodeType::DIM - 1) && data[pos + LeafNodeType::DIM] < ValueType(0.0)) {
+                } else if (ijk[1] != (LeafNodeType::DIM - 1)
+                    && data[pos + LeafNodeType::DIM] < ValueType(0.0))
+                {
                     updatedSign = true;
                     dist = ValueType(-dist);
 
                 // i - 1, j, k
-                } else if (ijk[0] != 0 && data[pos - LeafNodeType::DIM * LeafNodeType::DIM] < ValueType(0.0)) {
+                } else if (ijk[0] != 0
+                    && data[pos - LeafNodeType::DIM * LeafNodeType::DIM] < ValueType(0.0))
+                {
                     updatedSign = true;
                     dist = ValueType(-dist);
 
                 // i + 1, j, k
-                } else if (ijk[0] != (LeafNodeType::DIM - 1) && data[pos + LeafNodeType::DIM * LeafNodeType::DIM] < ValueType(0.0)) {
+                } else if (ijk[0] != (LeafNodeType::DIM - 1)
+                    && data[pos + LeafNodeType::DIM * LeafNodeType::DIM] < ValueType(0.0))
+                {
                     updatedSign = true;
                     dist = ValueType(-dist);
                 }
@@ -1112,11 +1111,11 @@
 class SeedFillExteriorSign
 {
 public:
-    typedef typename TreeType::ValueType            ValueType;
-    typedef typename TreeType::LeafNodeType         LeafNodeType;
+    using ValueType = typename TreeType::ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
 
     SeedFillExteriorSign(std::vector<LeafNodeType*>& nodes, bool* changedNodeMask)
-        : mNodes(nodes.empty() ? NULL : &nodes[0])
+        : mNodes(nodes.empty() ? nullptr : &nodes[0])
         , mChangedNodeMask(changedNodeMask)
     {
     }
@@ -1166,11 +1165,12 @@
 class SyncVoxelMask
 {
 public:
-    typedef typename TreeType::ValueType            ValueType;
-    typedef typename TreeType::LeafNodeType         LeafNodeType;
+    using ValueType = typename TreeType::ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
 
-    SyncVoxelMask(std::vector<LeafNodeType*>& nodes, const bool* changedNodeMask,  bool* changedVoxelMask)
-        : mNodes(nodes.empty() ? NULL : &nodes[0])
+    SyncVoxelMask(std::vector<LeafNodeType*>& nodes,
+        const bool* changedNodeMask,  bool* changedVoxelMask)
+        : mNodes(nodes.empty() ? nullptr : &nodes[0])
         , mChangedNodeMask(changedNodeMask)
         , mChangedVoxelMask(changedVoxelMask)
     {
@@ -1204,11 +1204,12 @@
 class SeedPoints
 {
 public:
-    typedef typename TreeType::ValueType            ValueType;
-    typedef typename TreeType::LeafNodeType         LeafNodeType;
-    typedef LeafNodeConnectivityTable<TreeType>     ConnectivityTable;
+    using ValueType = typename TreeType::ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using ConnectivityTable = LeafNodeConnectivityTable<TreeType>;
 
-    SeedPoints(ConnectivityTable& connectivity, bool* changedNodeMask, bool* nodeMask, bool* changedVoxelMask)
+    SeedPoints(ConnectivityTable& connectivity,
+        bool* changedNodeMask, bool* nodeMask, bool* changedVoxelMask)
         : mConnectivity(&connectivity)
         , mChangedNodeMask(changedNodeMask)
         , mNodeMask(nodeMask)
@@ -1241,7 +1242,8 @@
 
     bool processZ(const size_t n, bool firstFace) const
     {
-        const size_t offset = firstFace ? mConnectivity->offsetsPrevZ()[n] : mConnectivity->offsetsNextZ()[n];
+        const size_t offset =
+            firstFace ? mConnectivity->offsetsPrevZ()[n] : mConnectivity->offsetsNextZ()[n];
         if (offset != ConnectivityTable::INVALID_OFFSET && mChangedNodeMask[offset]) {
 
             bool* mask = &mChangedVoxelMask[n * LeafNodeType::SIZE];
@@ -1250,7 +1252,8 @@
             const ValueType* rhsData = mConnectivity->nodes()[offset]->buffer().data();
 
             const Index lastOffset = LeafNodeType::DIM - 1;
-            const Index lhsOffset = firstFace ? 0 : lastOffset, rhsOffset = firstFace ? lastOffset : 0;
+            const Index lhsOffset =
+                firstFace ? 0 : lastOffset, rhsOffset = firstFace ? lastOffset : 0;
 
             Index tmpPos(0), pos(0);
             bool changedValue = false;
@@ -1277,7 +1280,8 @@
 
     bool processY(const size_t n, bool firstFace) const
     {
-        const size_t offset = firstFace ? mConnectivity->offsetsPrevY()[n] : mConnectivity->offsetsNextY()[n];
+        const size_t offset =
+            firstFace ? mConnectivity->offsetsPrevY()[n] : mConnectivity->offsetsNextY()[n];
         if (offset != ConnectivityTable::INVALID_OFFSET && mChangedNodeMask[offset]) {
 
             bool* mask = &mChangedVoxelMask[n * LeafNodeType::SIZE];
@@ -1286,7 +1290,8 @@
             const ValueType* rhsData = mConnectivity->nodes()[offset]->buffer().data();
 
             const Index lastOffset = LeafNodeType::DIM * (LeafNodeType::DIM - 1);
-            const Index lhsOffset = firstFace ? 0 : lastOffset, rhsOffset = firstFace ? lastOffset : 0;
+            const Index lhsOffset =
+                firstFace ? 0 : lastOffset, rhsOffset = firstFace ? lastOffset : 0;
 
             Index tmpPos(0), pos(0);
             bool changedValue = false;
@@ -1313,7 +1318,8 @@
 
     bool processX(const size_t n, bool firstFace) const
     {
-        const size_t offset = firstFace ? mConnectivity->offsetsPrevX()[n] : mConnectivity->offsetsNextX()[n];
+        const size_t offset =
+            firstFace ? mConnectivity->offsetsPrevX()[n] : mConnectivity->offsetsNextX()[n];
         if (offset != ConnectivityTable::INVALID_OFFSET && mChangedNodeMask[offset]) {
 
             bool* mask = &mChangedVoxelMask[n * LeafNodeType::SIZE];
@@ -1321,8 +1327,9 @@
             const ValueType* lhsData = mConnectivity->nodes()[n]->buffer().data();
             const ValueType* rhsData = mConnectivity->nodes()[offset]->buffer().data();
 
-            const Index lastOffset =  LeafNodeType::DIM * LeafNodeType::DIM * (LeafNodeType::DIM - 1);
-            const Index lhsOffset = firstFace ? 0 : lastOffset, rhsOffset = firstFace ? lastOffset : 0;
+            const Index lastOffset =  LeafNodeType::DIM * LeafNodeType::DIM * (LeafNodeType::DIM-1);
+            const Index lhsOffset =
+                firstFace ? 0 : lastOffset, rhsOffset = firstFace ? lastOffset : 0;
 
             Index tmpPos(0), pos(0);
             bool changedValue = false;
@@ -1359,20 +1366,20 @@
 template<typename TreeType, typename MeshDataAdapter>
 struct ComputeIntersectingVoxelSign
 {
-    typedef typename TreeType::ValueType                            ValueType;
-    typedef typename TreeType::LeafNodeType                         LeafNodeType;
-    typedef typename TreeType::template ValueConverter<Int32>::Type Int32TreeType;
-    typedef typename Int32TreeType::LeafNodeType                    Int32LeafNodeType;
+    using ValueType = typename TreeType::ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using Int32TreeType = typename TreeType::template ValueConverter<Int32>::Type;
+    using Int32LeafNodeType = typename Int32TreeType::LeafNodeType;
 
-    typedef std::pair<boost::shared_array<Vec3d>, boost::shared_array<bool> >   LocalData;
-    typedef tbb::enumerable_thread_specific<LocalData>                          LocalDataTable;
+    using LocalData = std::pair<boost::shared_array<Vec3d>, boost::shared_array<bool> >;
+    using LocalDataTable = tbb::enumerable_thread_specific<LocalData>;
 
     ComputeIntersectingVoxelSign(
         std::vector<LeafNodeType*>& distNodes,
         const TreeType& distTree,
         const Int32TreeType& indexTree,
         const MeshDataAdapter& mesh)
-        : mDistNodes(distNodes.empty() ? NULL : &distNodes[0])
+        : mDistNodes(distNodes.empty() ? nullptr : &distNodes[0])
         , mDistTree(&distTree)
         , mIndexTree(&indexTree)
         , mMesh(&mesh)
@@ -1437,14 +1444,15 @@
 
                 for (nijk[0] = bbox.min()[0]; nijk[0] <= bbox.max()[0] && !flipSign; ++nijk[0]) {
                     xPos = (nijk[0] & (LeafNodeType::DIM - 1u)) << (2 * LeafNodeType::LOG2DIM);
-                    for (nijk[1] = bbox.min()[1]; nijk[1] <= bbox.max()[1] && !flipSign; ++nijk[1]) {
-                        yPos = xPos + ((nijk[1] & (LeafNodeType::DIM - 1u)) << LeafNodeType::LOG2DIM);
+                    for (nijk[1]=bbox.min()[1]; nijk[1] <= bbox.max()[1] && !flipSign; ++nijk[1]) {
+                        yPos = xPos + ((nijk[1] & (LeafNodeType::DIM-1u)) << LeafNodeType::LOG2DIM);
                         for (nijk[2] = bbox.min()[2]; nijk[2] <= bbox.max()[2]; ++nijk[2]) {
                             pos = yPos + (nijk[2] & (LeafNodeType::DIM - 1u));
 
                             const Int32& polyIdx = idxData[pos];
 
-                            if (polyIdx == Int32(util::INVALID_IDX) || !(data[pos] < -0.75)) continue;
+                            if (polyIdx == Int32(util::INVALID_IDX) || !(data[pos] < -0.75))
+                                continue;
 
                             const Index pointIndex = pos * 2;
 
@@ -1482,7 +1490,7 @@
                     for (Int32 m = 0; m < 26; ++m) {
                         nijk = ijk + util::COORD_OFFSETS[m];
 
-                        if (!bbox.isInside(nijk) && distAcc.probeValue(nijk, nval) && nval < -0.75) {
+                        if (!bbox.isInside(nijk) && distAcc.probeValue(nijk, nval) && nval<-0.75) {
                             nxyz[0] = double(nijk[0]);
                             nxyz[1] = double(nijk[1]);
                             nxyz[2] = double(nijk[2]);
@@ -1540,7 +1548,7 @@
     Int32TreeType   const * const mIndexTree;
     MeshDataAdapter const * const mMesh;
 
-    boost::shared_ptr<LocalDataTable> mLocalDataTable;
+    SharedPtr<LocalDataTable> mLocalDataTable;
 }; // ComputeIntersectingVoxelSign
 
 
@@ -1551,7 +1559,7 @@
 inline void
 maskNodeInternalNeighbours(const Index pos, bool (&mask)[26])
 {
-    typedef LeafNodeType NodeT;
+    using NodeT = LeafNodeType;
 
     const Coord ijk = NodeT::offsetToLocalCoord(pos);
 
@@ -1619,7 +1627,7 @@
 inline bool
 checkNeighbours(const Index pos, const typename LeafNodeType::ValueType * data, bool (&mask)[26])
 {
-    typedef LeafNodeType NodeT;
+    using NodeT = LeafNodeType;
 
     // i, j, k - 1
     if (mask[5] && Compare::check(data[pos - 1]))                                         return true;
@@ -1695,14 +1703,14 @@
 template<typename TreeType>
 struct ValidateIntersectingVoxels
 {
-    typedef typename TreeType::ValueType            ValueType;
-    typedef typename TreeType::LeafNodeType         LeafNodeType;
+    using ValueType = typename TreeType::ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
 
     struct IsNegative { static bool check(const ValueType v) { return v < ValueType(0.0); } };
 
     ValidateIntersectingVoxels(TreeType& tree, std::vector<LeafNodeType*>& nodes)
         : mTree(&tree)
-        , mNodes(nodes.empty() ? NULL : &nodes[0])
+        , mNodes(nodes.empty() ? nullptr : &nodes[0])
     {
     }
 
@@ -1747,15 +1755,15 @@
 template<typename TreeType>
 struct RemoveSelfIntersectingSurface
 {
-    typedef typename TreeType::ValueType            ValueType;
-    typedef typename TreeType::LeafNodeType         LeafNodeType;
-    typedef typename TreeType::template ValueConverter<Int32>::Type Int32TreeType;
+    using ValueType = typename TreeType::ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using Int32TreeType = typename TreeType::template ValueConverter<Int32>::Type;
 
     struct Comp { static bool check(const ValueType v) { return !(v > ValueType(0.75)); } };
 
     RemoveSelfIntersectingSurface(std::vector<LeafNodeType*>& nodes,
         TreeType& distTree, Int32TreeType& indexTree)
-        : mNodes(nodes.empty() ? NULL : &nodes[0])
+        : mNodes(nodes.empty() ? nullptr : &nodes[0])
         , mDistTree(&distTree)
         , mIndexTree(&indexTree)
     {
@@ -1787,7 +1795,7 @@
 
                 const bool hasBoundaryNeighbour =
                     checkNeighbours<Comp, LeafNodeType>(pos, data, neighbourMask) ||
-                    checkNeighbours<Comp>(distNode.offsetToGlobalCoord(pos), distAcc, neighbourMask);
+                    checkNeighbours<Comp>(distNode.offsetToGlobalCoord(pos),distAcc,neighbourMask);
 
                 if (!hasBoundaryNeighbour) {
                     distNode.setValueOff(pos);
@@ -1813,7 +1821,7 @@
 
     void operator()(const tbb::blocked_range<size_t>& range) const {
 
-        typedef typename NodeType::NodeMaskType NodeMaskType;
+        using NodeMaskType = typename NodeType::NodeMaskType;
 
         for (size_t n = range.begin(), N = range.end(); n < N; ++n) {
             const_cast<NodeMaskType&>(mNodes[n]->getChildMask()).setOff();
@@ -1828,22 +1836,22 @@
 inline void
 releaseLeafNodes(TreeType& tree)
 {
-    typedef typename TreeType::RootNodeType         RootNodeType;
-    typedef typename RootNodeType::NodeChainType    NodeChainType;
-    typedef typename boost::mpl::at<NodeChainType, boost::mpl::int_<1> >::type InternalNodeType;
+    using RootNodeType = typename TreeType::RootNodeType;
+    using NodeChainType = typename RootNodeType::NodeChainType;
+    using InternalNodeType = typename boost::mpl::at<NodeChainType, boost::mpl::int_<1> >::type;
 
     std::vector<InternalNodeType*> nodes;
     tree.getNodes(nodes);
 
     tbb::parallel_for(tbb::blocked_range<size_t>(0, nodes.size()),
-        ReleaseChildNodes<InternalNodeType>(nodes.empty() ? NULL : &nodes[0]));
+        ReleaseChildNodes<InternalNodeType>(nodes.empty() ? nullptr : &nodes[0]));
 }
 
 
 template<typename TreeType>
 struct StealUniqueLeafNodes
 {
-    typedef typename TreeType::LeafNodeType LeafNodeType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
 
     StealUniqueLeafNodes(TreeType& lhsTree, TreeType& rhsTree,
         std::vector<LeafNodeType*>& overlappingNodes)
@@ -1885,8 +1893,8 @@
 combineData(DistTreeType& lhsDist, IndexTreeType& lhsIdx,
     DistTreeType& rhsDist, IndexTreeType& rhsIdx)
 {
-    typedef typename DistTreeType::LeafNodeType     DistLeafNodeType;
-    typedef typename IndexTreeType::LeafNodeType    IndexLeafNodeType;
+    using DistLeafNodeType = typename DistTreeType::LeafNodeType;
+    using IndexLeafNodeType = typename IndexTreeType::LeafNodeType;
 
     std::vector<DistLeafNodeType*>  overlappingDistNodes;
     std::vector<IndexLeafNodeType*> overlappingIdxNodes;
@@ -1900,7 +1908,8 @@
     // Combine overlapping leaf nodes
     if (!overlappingDistNodes.empty() && !overlappingIdxNodes.empty()) {
         tbb::parallel_for(tbb::blocked_range<size_t>(0, overlappingDistNodes.size()),
-            CombineLeafNodes<DistTreeType>(lhsDist, lhsIdx, &overlappingDistNodes[0], &overlappingIdxNodes[0]));
+            CombineLeafNodes<DistTreeType>(lhsDist, lhsIdx,
+                &overlappingDistNodes[0], &overlappingIdxNodes[0]));
     }
 }
 
@@ -1913,15 +1922,15 @@
 template<typename TreeType>
 struct VoxelizationData {
 
-    typedef boost::scoped_ptr<VoxelizationData>                         Ptr;
-    typedef typename TreeType::ValueType                                ValueType;
+    using Ptr = std::unique_ptr<VoxelizationData>;
+    using ValueType = typename TreeType::ValueType;
 
-    typedef typename TreeType::template ValueConverter<Int32>::Type         Int32TreeType;
-    typedef typename TreeType::template ValueConverter<unsigned char>::Type UCharTreeType;
+    using Int32TreeType = typename TreeType::template ValueConverter<Int32>::Type;
+    using UCharTreeType = typename TreeType::template ValueConverter<unsigned char>::Type;
 
-    typedef tree::ValueAccessor<TreeType>       FloatTreeAcc;
-    typedef tree::ValueAccessor<Int32TreeType>  Int32TreeAcc;
-    typedef tree::ValueAccessor<UCharTreeType>  UCharTreeAcc;
+    using FloatTreeAcc = tree::ValueAccessor<TreeType>;
+    using Int32TreeAcc = tree::ValueAccessor<Int32TreeType>;
+    using UCharTreeAcc = tree::ValueAccessor<UCharTreeType>;
 
 
     VoxelizationData()
@@ -1967,12 +1976,12 @@
 {
 public:
 
-    typedef VoxelizationData<TreeType>                                          VoxelizationDataType;
-    typedef tbb::enumerable_thread_specific<typename VoxelizationDataType::Ptr> DataTable;
+    using VoxelizationDataType = VoxelizationData<TreeType>;
+    using DataTable = tbb::enumerable_thread_specific<typename VoxelizationDataType::Ptr>;
 
     VoxelizePolygons(DataTable& dataTable,
         const MeshDataAdapter& mesh,
-        Interrupter* interrupter = NULL)
+        Interrupter* interrupter = nullptr)
         : mDataTable(&dataTable)
         , mMesh(&mesh)
         , mInterrupter(interrupter)
@@ -2024,7 +2033,8 @@
     {
         enum { POLYGON_LIMIT = 1000 };
 
-        SubTask(const Triangle& prim, DataTable& dataTable, int subdivisionCount, size_t polygonCount)
+        SubTask(const Triangle& prim, DataTable& dataTable,
+            int subdivisionCount, size_t polygonCount)
             : mLocalDataTable(&dataTable)
             , mPrim(prim)
             , mSubdivisionCount(subdivisionCount)
@@ -2069,7 +2079,8 @@
     void evalTriangle(const Triangle& prim, VoxelizationDataType& data) const
     {
         const size_t polygonCount = mMesh->polygonCount();
-        const int subdivisionCount = polygonCount < SubTask::POLYGON_LIMIT ? evalSubdivisionCount(prim) : 0;
+        const int subdivisionCount =
+            polygonCount < SubTask::POLYGON_LIMIT ? evalSubdivisionCount(prim) : 0;
 
         if (subdivisionCount <= 0) {
             voxelizeTriangle(prim, data);
@@ -2147,10 +2158,10 @@
     {
         Vec3d uvw, voxelCenter(ijk[0], ijk[1], ijk[2]);
 
-        typedef typename TreeType::ValueType ValueType;
+        using ValueType = typename TreeType::ValueType;
 
         const ValueType dist = ValueType((voxelCenter -
-                closestPointOnTriangleToPoint(prim.a, prim.c, prim.b, voxelCenter, uvw)).lengthSqr());
+            closestPointOnTriangleToPoint(prim.a, prim.c, prim.b, voxelCenter, uvw)).lengthSqr());
 
         const ValueType oldDist = data.distAcc.getValue(ijk);
 
@@ -2178,15 +2189,15 @@
 template<typename TreeType>
 struct DiffLeafNodeMask
 {
-    typedef typename tree::ValueAccessor<TreeType>  AccessorType;
-    typedef typename TreeType::LeafNodeType         LeafNodeType;
+    using AccessorType = typename tree::ValueAccessor<TreeType>;
+    using LeafNodeType = typename TreeType::LeafNodeType;
 
-    typedef typename TreeType::template ValueConverter<bool>::Type  BoolTreeType;
-    typedef typename BoolTreeType::LeafNodeType                     BoolLeafNodeType;
+    using BoolTreeType = typename TreeType::template ValueConverter<bool>::Type;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
 
     DiffLeafNodeMask(const TreeType& rhsTree,
         std::vector<BoolLeafNodeType*>& lhsNodes)
-        : mRhsTree(&rhsTree), mLhsNodes(lhsNodes.empty() ? NULL : &lhsNodes[0])
+        : mRhsTree(&rhsTree), mLhsNodes(lhsNodes.empty() ? nullptr : &lhsNodes[0])
     {
     }
 
@@ -2213,8 +2224,8 @@
 struct UnionValueMasks
 {
     UnionValueMasks(std::vector<LeafNodeTypeA*>& nodesA, std::vector<LeafNodeTypeB*>& nodesB)
-        : mNodesA(nodesA.empty() ? NULL : &nodesA[0])
-        , mNodesB(nodesB.empty() ? NULL : &nodesB[0])
+        : mNodesA(nodesA.empty() ? nullptr : &nodesA[0])
+        , mNodesB(nodesB.empty() ? nullptr : &nodesB[0])
     {
     }
 
@@ -2233,14 +2244,15 @@
 template<typename TreeType>
 struct ConstructVoxelMask
 {
-    typedef typename TreeType::LeafNodeType                         LeafNodeType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
 
-    typedef typename TreeType::template ValueConverter<bool>::Type  BoolTreeType;
-    typedef typename BoolTreeType::LeafNodeType                     BoolLeafNodeType;
+    using BoolTreeType = typename TreeType::template ValueConverter<bool>::Type;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
 
-    ConstructVoxelMask(BoolTreeType& maskTree, const TreeType& tree, std::vector<LeafNodeType*>& nodes)
+    ConstructVoxelMask(BoolTreeType& maskTree, const TreeType& tree,
+        std::vector<LeafNodeType*>& nodes)
         : mTree(&tree)
-        , mNodes(nodes.empty() ? NULL : &nodes[0])
+        , mNodes(nodes.empty() ? nullptr : &nodes[0])
         , mLocalMaskTree(false)
         , mMaskTree(&maskTree)
     {
@@ -2256,7 +2268,7 @@
 
     void operator()(const tbb::blocked_range<size_t>& range)
     {
-        typedef typename LeafNodeType::ValueOnCIter Iterator;
+        using Iterator = typename LeafNodeType::ValueOnCIter;
 
         tree::ValueAccessor<const TreeType> acc(*mTree);
         tree::ValueAccessor<BoolTreeType> maskAcc(*mMaskTree);
@@ -2345,13 +2357,13 @@
 template<typename TreeType, typename MeshDataAdapter>
 struct ExpandNarrowband
 {
-    typedef typename TreeType::ValueType                            ValueType;
-    typedef typename TreeType::LeafNodeType                         LeafNodeType;
-    typedef typename LeafNodeType::NodeMaskType                     NodeMaskType;
-    typedef typename TreeType::template ValueConverter<Int32>::Type Int32TreeType;
-    typedef typename Int32TreeType::LeafNodeType                    Int32LeafNodeType;
-    typedef typename TreeType::template ValueConverter<bool>::Type  BoolTreeType;
-    typedef typename BoolTreeType::LeafNodeType                     BoolLeafNodeType;
+    using ValueType = typename TreeType::ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using NodeMaskType = typename LeafNodeType::NodeMaskType;
+    using Int32TreeType = typename TreeType::template ValueConverter<Int32>::Type;
+    using Int32LeafNodeType = typename Int32TreeType::LeafNodeType;
+    using BoolTreeType = typename TreeType::template ValueConverter<bool>::Type;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
 
     struct Fragment
     {
@@ -2379,7 +2391,7 @@
         ValueType exteriorBandWidth,
         ValueType interiorBandWidth,
         ValueType voxelSize)
-        : mMaskNodes(maskNodes.empty() ? NULL : &maskNodes[0])
+        : mMaskNodes(maskNodes.empty() ? nullptr : &maskNodes[0])
         , mMaskTree(&maskTree)
         , mDistTree(&distTree)
         , mIndexTree(&indexTree)
@@ -2435,8 +2447,8 @@
         std::vector<Fragment> fragments;
         fragments.reserve(256);
 
-        typename UniquePtr<LeafNodeType>::type      newDistNodePt;
-        typename UniquePtr<Int32LeafNodeType>::type newIndexNodePt;
+        std::unique_ptr<LeafNodeType> newDistNodePt;
+        std::unique_ptr<Int32LeafNodeType> newIndexNodePt;
 
         for (size_t n = range.begin(), N = range.end(); n < N; ++n) {
 
@@ -2671,7 +2683,7 @@
     bool
     updateVoxel(const Coord& ijk, const Int32 manhattanLimit,
         const std::vector<Fragment>& fragments,
-        LeafNodeType& distLeaf, Int32LeafNodeType& idxLeaf, bool* updatedLeafNodes = NULL)
+        LeafNodeType& distLeaf, Int32LeafNodeType& idxLeaf, bool* updatedLeafNodes = nullptr)
     {
         Int32 closestPrimIdx = 0;
         const ValueType distance = computeDistance(ijk, manhattanLimit, fragments, closestPrimIdx);
@@ -2716,7 +2728,7 @@
 
 template<typename TreeType>
 struct AddNodes {
-    typedef typename TreeType::LeafNodeType LeafNodeType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
 
     AddNodes(TreeType& tree, std::vector<LeafNodeType*>& nodes)
         : mTree(&tree) , mNodes(&nodes)
@@ -2774,8 +2786,8 @@
 template<typename TreeType>
 struct TransformValues
 {
-    typedef typename TreeType::LeafNodeType   LeafNodeType;
-    typedef typename TreeType::ValueType      ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using ValueType = typename TreeType::ValueType;
 
     TransformValues(std::vector<LeafNodeType*>& nodes,
         ValueType voxelSize, bool unsignedDist)
@@ -2812,12 +2824,12 @@
 template<typename TreeType>
 struct InactivateValues
 {
-    typedef typename TreeType::LeafNodeType   LeafNodeType;
-    typedef typename TreeType::ValueType      ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using ValueType = typename TreeType::ValueType;
 
     InactivateValues(std::vector<LeafNodeType*>& nodes,
         ValueType exBandWidth, ValueType inBandWidth)
-        : mNodes(nodes.empty() ? NULL : &nodes[0])
+        : mNodes(nodes.empty() ? nullptr : &nodes[0])
         , mExBandWidth(exBandWidth)
         , mInBandWidth(inBandWidth)
     {
@@ -2857,11 +2869,11 @@
 template<typename TreeType>
 struct OffsetValues
 {
-    typedef typename TreeType::LeafNodeType   LeafNodeType;
-    typedef typename TreeType::ValueType      ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using ValueType = typename TreeType::ValueType;
 
     OffsetValues(std::vector<LeafNodeType*>& nodes, ValueType offset)
-        : mNodes(nodes.empty() ? NULL : &nodes[0]), mOffset(offset)
+        : mNodes(nodes.empty() ? nullptr : &nodes[0]), mOffset(offset)
     {
     }
 
@@ -2889,12 +2901,13 @@
 template<typename TreeType>
 struct Renormalize
 {
-    typedef typename TreeType::LeafNodeType     LeafNodeType;
-    typedef typename TreeType::ValueType        ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using ValueType = typename TreeType::ValueType;
 
-    Renormalize(const TreeType& tree, const std::vector<LeafNodeType*>& nodes, ValueType* buffer, ValueType voxelSize)
+    Renormalize(const TreeType& tree, const std::vector<LeafNodeType*>& nodes,
+        ValueType* buffer, ValueType voxelSize)
         : mTree(&tree)
-        , mNodes(nodes.empty() ? NULL : &nodes[0])
+        , mNodes(nodes.empty() ? nullptr : &nodes[0])
         , mBuffer(buffer)
         , mVoxelSize(voxelSize)
     {
@@ -2902,7 +2915,7 @@
 
     void operator()(const tbb::blocked_range<size_t>& range) const
     {
-        typedef math::Vec3<ValueType>   Vec3Type;
+        using Vec3Type = math::Vec3<ValueType>;
 
         tree::ValueAccessor<const TreeType> acc(*mTree);
 
@@ -2952,11 +2965,11 @@
 template<typename TreeType>
 struct MinCombine
 {
-    typedef typename TreeType::LeafNodeType   LeafNodeType;
-    typedef typename TreeType::ValueType      ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using ValueType = typename TreeType::ValueType;
 
     MinCombine(std::vector<LeafNodeType*>& nodes, const ValueType* buffer)
-        : mNodes(nodes.empty() ? NULL : &nodes[0]), mBuffer(buffer)
+        : mNodes(nodes.empty() ? nullptr : &nodes[0]), mBuffer(buffer)
     {
     }
 
@@ -2993,7 +3006,7 @@
 inline void
 traceExteriorBoundaries(FloatTreeT& tree)
 {
-    typedef mesh_to_volume_internal::LeafNodeConnectivityTable<FloatTreeT> ConnectivityTable;
+    using ConnectivityTable = mesh_to_volume_internal::LeafNodeConnectivityTable<FloatTreeT>;
 
     ConnectivityTable nodeConnectivity(tree);
 
@@ -3013,7 +3026,7 @@
         }
     }
 
-    typedef mesh_to_volume_internal::SweepExteriorSign<FloatTreeT> SweepingOp;
+    using SweepingOp = mesh_to_volume_internal::SweepExteriorSign<FloatTreeT>;
 
     tbb::parallel_for(tbb::blocked_range<size_t>(0, zStartNodes.size()),
         SweepingOp(SweepingOp::Z_AXIS, zStartNodes, nodeConnectivity));
@@ -3041,8 +3054,9 @@
         tbb::parallel_for(nodeRange, mesh_to_volume_internal::SeedFillExteriorSign<FloatTreeT>(
             nodeConnectivity.nodes(), changedNodeMaskA.get()));
 
-        tbb::parallel_for(nodeRange, mesh_to_volume_internal::SeedPoints<FloatTreeT>(nodeConnectivity,
-            changedNodeMaskA.get(), changedNodeMaskB.get(), changedVoxelMask.get()));
+        tbb::parallel_for(nodeRange, mesh_to_volume_internal::SeedPoints<FloatTreeT>(
+            nodeConnectivity, changedNodeMaskA.get(), changedNodeMaskB.get(),
+            changedVoxelMask.get()));
 
         changedNodeMaskA.swap(changedNodeMaskB);
 
@@ -3075,15 +3089,15 @@
   int flags,
   typename GridType::template ValueConverter<Int32>::Type * polygonIndexGrid)
 {
-    typedef typename GridType::Ptr              GridTypePtr;
-    typedef typename GridType::TreeType         TreeType;
-    typedef typename TreeType::LeafNodeType     LeafNodeType;
-    typedef typename GridType::ValueType        ValueType;
+    using GridTypePtr = typename GridType::Ptr;
+    using TreeType = typename GridType::TreeType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using ValueType = typename GridType::ValueType;
 
-    typedef typename GridType::template ValueConverter<Int32>::Type  Int32GridType;
-    typedef typename Int32GridType::TreeType                         Int32TreeType;
+    using Int32GridType = typename GridType::template ValueConverter<Int32>::Type;
+    using Int32TreeType = typename Int32GridType::TreeType;
 
-    typedef typename TreeType::template ValueConverter<bool>::Type   BoolTreeType;
+    using BoolTreeType = typename TreeType::template ValueConverter<bool>::Type;
 
     //////////
 
@@ -3097,7 +3111,7 @@
 
     // Note: inf interior width is all right, this value makes the converter fill
     // interior regions with distance values.
-    if (!boost::math::isfinite(exteriorWidth) || boost::math::isnan(interiorWidth)) {
+    if (!std::isfinite(exteriorWidth) || std::isnan(interiorWidth)) {
         std::stringstream msg;
         msg << "Illegal narrow band width: exterior = " << exteriorWidth
             << ", interior = " << interiorWidth;
@@ -3107,7 +3121,7 @@
 
     const ValueType voxelSize = ValueType(transform.voxelSize()[0]);
 
-    if (!boost::math::isfinite(voxelSize) || math::isZero(voxelSize)) {
+    if (!std::isfinite(voxelSize) || math::isZero(voxelSize)) {
         std::stringstream msg;
         msg << "Illegal transform, voxel size = " << voxelSize;
         OPENVDB_LOG_DEBUG(msg.str());
@@ -3127,7 +3141,7 @@
     const bool renormalizeValues = (flags & DISABLE_RENORMALIZATION) == 0;
     const bool trimNarrowBand = (flags & DISABLE_NARROW_BAND_TRIMMING) == 0;
 
-    Int32GridType* indexGrid = NULL;
+    Int32GridType* indexGrid = nullptr;
 
     typename Int32GridType::Ptr temporaryIndexGrid;
 
@@ -3157,11 +3171,12 @@
     // Voxelize mesh
 
     {
-        typedef mesh_to_volume_internal::VoxelizationData<TreeType> VoxelizationDataType;
-        typedef tbb::enumerable_thread_specific<typename VoxelizationDataType::Ptr> DataTable;
+        using VoxelizationDataType = mesh_to_volume_internal::VoxelizationData<TreeType>;
+        using DataTable = tbb::enumerable_thread_specific<typename VoxelizationDataType::Ptr>;
 
         DataTable data;
-        typedef mesh_to_volume_internal::VoxelizePolygons<TreeType, MeshDataAdapter, Interrupter> Voxelizer;
+        using Voxelizer =
+            mesh_to_volume_internal::VoxelizePolygons<TreeType, MeshDataAdapter, Interrupter>;
 
         const tbb::blocked_range<size_t> polygonRange(0, mesh.polygonCount());
 
@@ -3194,7 +3209,8 @@
 
         const tbb::blocked_range<size_t> nodeRange(0, nodes.size());
 
-        typedef mesh_to_volume_internal::ComputeIntersectingVoxelSign<TreeType, MeshDataAdapter> SignOp;
+        using SignOp =
+            mesh_to_volume_internal::ComputeIntersectingVoxelSign<TreeType, MeshDataAdapter>;
 
         tbb::parallel_for(nodeRange, SignOp(nodes, distTree, indexTree, mesh));
 
@@ -3385,8 +3401,8 @@
 
 /// @internal This overload is enabled only for grids with a scalar, floating-point ValueType.
 template<typename GridType, typename Interrupter>
-inline typename boost::enable_if<boost::is_floating_point<typename GridType::ValueType>,
-typename GridType::Ptr>::type
+inline typename std::enable_if<std::is_floating_point<typename GridType::ValueType>::value,
+    typename GridType::Ptr>::type
 doMeshConversion(
     Interrupter& interrupter,
     const openvdb::math::Transform& xform,
@@ -3448,15 +3464,16 @@
     QuadAndTriangleDataAdapter<Vec3s, Vec4I>
         mesh(indexSpacePoints.get(), numPoints, prims.get(), numPrimitives);
 
-    return meshToVolume<GridType>(interrupter, mesh, xform, exBandWidth, inBandWidth, conversionFlags);
+    return meshToVolume<GridType>(interrupter, mesh, xform,
+        exBandWidth, inBandWidth, conversionFlags);
 }
 
 
 /// @internal This overload is enabled only for grids that do not have a scalar,
 /// floating-point ValueType.
 template<typename GridType, typename Interrupter>
-inline typename boost::disable_if<boost::is_floating_point<typename GridType::ValueType>,
-typename GridType::Ptr>::type
+inline typename std::enable_if<!std::is_floating_point<typename GridType::ValueType>::value,
+    typename GridType::Ptr>::type
 doMeshConversion(
     Interrupter&,
     const math::Transform& /*xform*/,
@@ -3689,7 +3706,7 @@
     const std::vector<Vec4I>& mPolygonList;
 
     // Used internally for acceleration
-    typedef TreeType::ValueConverter<Int32>::Type IntTreeT;
+    using IntTreeT = TreeType::ValueConverter<Int32>::Type;
     IntTreeT mLastPrimTree;
     tree::ValueAccessor<IntTreeT> mLastPrimAccessor;
 }; // class MeshToVoxelEdgeData::GenEdgeData
@@ -3735,10 +3752,10 @@
 inline void
 MeshToVoxelEdgeData::GenEdgeData::join(GenEdgeData& rhs)
 {
-    typedef TreeType::RootNodeType       RootNodeType;
-    typedef RootNodeType::NodeChainType  NodeChainType;
-    BOOST_STATIC_ASSERT(boost::mpl::size<NodeChainType>::value > 1);
-    typedef boost::mpl::at<NodeChainType, boost::mpl::int_<1> >::type InternalNodeType;
+    using RootNodeType = TreeType::RootNodeType;
+    using NodeChainType = RootNodeType::NodeChainType;
+    static_assert(boost::mpl::size<NodeChainType>::value > 1, "expected tree height > 1");
+    using InternalNodeType = boost::mpl::at<NodeChainType, boost::mpl::int_<1> >::type;
 
     Coord ijk;
     Index offset;
diff -aur openvdb.3.2.0/tools/Morphology.h openvdb.4.0.0/tools/Morphology.h
--- openvdb.3.2.0/tools/Morphology.h	2016-04-24 10:39:49.000000000 +0200
+++ openvdb.4.0.0/tools/Morphology.h	2016-10-09 10:18:58.000000000 +0200
@@ -291,8 +291,8 @@
         LeafType* leaf;//null if a tile
         bool      init;//true if initialization is required
         bool      isOn;//true if an active tile
-        Neighbor() : leaf(NULL), init(true) {}
-        inline void clear() { leaf = NULL; init = true; }
+        Neighbor() : leaf(nullptr), init(true) {}
+        inline void clear() { leaf = nullptr; init = true; }
         template<int DX, int DY, int DZ>
         void scatter(AccessorType& acc, const Coord &xyz, int indx, Word mask)
         {
@@ -300,7 +300,7 @@
                 init = false;
                 Coord orig = xyz.offsetBy(DX*LEAF_DIM, DY*LEAF_DIM, DZ*LEAF_DIM);
                 leaf = acc.probeLeaf(orig);
-                if (leaf==NULL && !acc.isValueOn(orig)) leaf = acc.touchLeaf(orig);
+                if ((leaf == nullptr) && !acc.isValueOn(orig)) leaf = acc.touchLeaf(orig);
             }
 #ifndef _MSC_VER // Visual C++ doesn't guarantee thread-safe initialization of local statics
             static
@@ -336,7 +336,7 @@
         }
         ~LeafCache() { delete [] leafs; }
         LeafType*& operator[](int offset) { return leafs[offset]; }
-        inline void clear() { for (size_t i=0; i<size; ++i) leafs[i]=NULL; }
+        inline void clear() { for (size_t i = 0; i < size; ++i) leafs[i] = nullptr; }
         inline void setOrigin(const Coord& xyz) { origin = &xyz; }
         inline void scatter(int n, int indx)
         {
@@ -462,6 +462,7 @@
         case NN_FACE_EDGE_VERTEX:
             this->dilateVoxels26();
             break;
+        case NN_FACE:
         default:
             this->dilateVoxels6();
         }
@@ -707,6 +708,7 @@
     case NN_FACE_EDGE_VERTEX:
         mTask = boost::bind(&ErodeVoxelsOp::erode26, _1, _2);
         break;
+    case NN_FACE:
     default:
         mTask = boost::bind(&ErodeVoxelsOp::erode6, _1, _2);
     }
@@ -999,7 +1001,7 @@
 public:
 
     DilationOp(TreeT &tree, int iterations, NearestNeighbors nn, TilePolicy mode)
-        : mIter(iterations), mNN(nn), mPool(NULL), mLeafs(NULL)
+        : mIter(iterations), mNN(nn), mPool(nullptr), mLeafs(nullptr)
     {
         const size_t numLeafs = this->init( tree, mode );
         const size_t numThreads = size_t(tbb::task_scheduler_init::default_num_threads());
diff -aur openvdb.3.2.0/tools/MultiResGrid.h openvdb.4.0.0/tools/MultiResGrid.h
--- openvdb.3.2.0/tools/MultiResGrid.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tools/MultiResGrid.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,11 +27,10 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-///////////////////////////////////////////////////////////////////////////
-///
+
 /// @file MultiResGrid.h
 ///
-/// @brief Ken Museth
+/// @author Ken Museth
 ///
 /// @warning This class is fairly new and as such has not seen a lot of
 /// use in production. Please report any issues or request for new
@@ -46,7 +45,6 @@
 ///
 /// @note Prolongation means interpolation from coarse -> fine
 /// @note Restriction means interpolation (or remapping) from fine -> coarse
-///
 
 #ifndef OPENVDB_TOOLS_MULTIRESGRID_HAS_BEEN_INCLUDED
 #define OPENVDB_TOOLS_MULTIRESGRID_HAS_BEEN_INCLUDED
@@ -56,22 +54,19 @@
 #include <openvdb/math/Math.h>
 #include <openvdb/math/Operators.h>
 #include <openvdb/math/Stencils.h>
-#include <openvdb/metadata/StringMetadata.h>
-#include <openvdb/tools/Interpolation.h>
-#include <openvdb/tools/Morphology.h>
-#include <openvdb/tools/Prune.h>
-#include <openvdb/tools/SignedFloodFill.h>
-#include <openvdb/tools/ValueTransformer.h>
+#include <openvdb/Metadata.h>
 #include <openvdb/tree/LeafManager.h>
 #include <openvdb/tree/NodeManager.h>
+#include "Interpolation.h"
+#include "Morphology.h"
+#include "Prune.h"
+#include "SignedFloodFill.h"
+#include "ValueTransformer.h"
 
 #include <tbb/enumerable_thread_specific.h>
 #include <tbb/task_scheduler_init.h>
 #include <tbb/tbb_thread.h>
 
-#include <boost/type_traits/is_floating_point.hpp>
-#include <boost/utility/enable_if.hpp>
-
 #include <iostream>
 #include <sstream>
 #include <string>
@@ -112,7 +107,7 @@
     /// @param levels The number of trees in this MultiResGrid
     /// @param grid High-resolution input grid
     /// @param useInjection Use restriction by injection, vs
-    /// full-weighting. It defaults to false and should rarely to used.
+    /// full-weighting. It defaults to false and should rarely be used.
     /// @note This constructor will perform a deep copy of the input
     /// grid and use it as the highest level grid.
     MultiResGrid(size_t levels, const Grid<TreeType> &grid, bool useInjection = false);
@@ -122,7 +117,7 @@
     /// @param levels The number of trees in this MultiResGrid
     /// @param grid High-resolution input grid
     /// @param useInjection Use restriction by injection, vs
-    /// full-weighting. It defaults to false and should rarely to used.
+    /// full-weighting. It defaults to false and should rarely be used.
     /// @note This constructor will steal the input input
     /// grid and use it as the highest level grid. On output the grid
     /// is empty.
diff -aur openvdb.3.2.0/tools/ParticleAtlas.h openvdb.4.0.0/tools/ParticleAtlas.h
--- openvdb.3.2.0/tools/ParticleAtlas.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tools/ParticleAtlas.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file     ParticleAtlas.h
 ///
 /// @brief    Space-partitioning acceleration structure for particles, points with
@@ -49,7 +49,6 @@
 ///
 /// @author   Mihai Alden
 
-
 #ifndef OPENVDB_TOOLS_PARTICLE_ATLAS_HAS_BEEN_INCLUDED
 #define OPENVDB_TOOLS_PARTICLE_ATLAS_HAS_BEEN_INCLUDED
 
@@ -65,7 +64,13 @@
 #include <tbb/blocked_range.h>
 #include <tbb/parallel_for.h>
 #include <tbb/parallel_reduce.h>
+#include <algorithm> // for std::min(), std::max()
+#include <cmath> // for std::sqrt()
 #include <deque>
+#include <limits>
+#include <memory>
+#include <utility> // for std::pair
+#include <vector>
 
 
 namespace openvdb {
@@ -86,8 +91,8 @@
 /// struct ParticleArray
 /// {
 ///     // The type used to represent world-space positions
-///     typedef VectorType                      PosType;
-///     typedef typename PosType::value_type    ScalarType;
+///     using PosType = VectorType;
+///     using ScalarType = typename PosType::value_type;
 ///
 ///     // Return the number of particles in the array
 ///     size_t size() const;
@@ -105,11 +110,11 @@
 template<typename PointIndexGridType = PointIndexGrid>
 struct ParticleAtlas
 {
-    typedef boost::shared_ptr<ParticleAtlas>            Ptr;
-    typedef boost::shared_ptr<const ParticleAtlas>      ConstPtr;
+    using Ptr = SharedPtr<ParticleAtlas>;
+    using ConstPtr = SharedPtr<const ParticleAtlas>;
 
-    typedef typename PointIndexGridType::Ptr            PointIndexGridPtr;
-    typedef typename PointIndexGridType::ValueType      IndexType;
+    using PointIndexGridPtr = typename PointIndexGridType::Ptr;
+    using IndexType = typename PointIndexGridType::ValueType;
 
     struct Iterator;
 
@@ -131,7 +136,8 @@
     /// @param minVoxelSize     minimum voxel size limit
     /// @param maxLevels        maximum number of resolution levels
     template<typename ParticleArrayType>
-    static Ptr create(const ParticleArrayType& particles, double minVoxelSize, size_t maxLevels = 50);
+    static Ptr create(const ParticleArrayType& particles,
+        double minVoxelSize, size_t maxLevels = 50);
 
     /// @brief Returns the number of resolution levels.
     size_t levels() const { return mIndexGridArray.size(); }
@@ -158,7 +164,7 @@
 }; // struct ParticleAtlas
 
 
-typedef ParticleAtlas<PointIndexGrid> ParticleIndexAtlas;
+using ParticleIndexAtlas = ParticleAtlas<PointIndexGrid>;
 
 
 ////////////////////////////////////////
@@ -172,9 +178,9 @@
 template<typename PointIndexGridType>
 struct ParticleAtlas<PointIndexGridType>::Iterator
 {
-    typedef typename PointIndexGridType::TreeType   TreeType;
-    typedef tree::ValueAccessor<const TreeType>     ConstAccessor;
-    typedef boost::scoped_ptr<ConstAccessor>        ConstAccessorPtr;
+    using TreeType = typename PointIndexGridType::TreeType;
+    using ConstAccessor = tree::ValueAccessor<const TreeType>;
+    using ConstAccessorPtr = std::unique_ptr<ConstAccessor>;
 
     /////
 
@@ -187,7 +193,8 @@
     /// @param radius    world-space search radius
     /// @param particles container conforming to the ParticleArray interface
     template<typename ParticleArrayType>
-    void worldSpaceSearchAndUpdate(const Vec3d& center, double radius, const ParticleArrayType& particles);
+    void worldSpaceSearchAndUpdate(const Vec3d& center, double radius,
+        const ParticleArrayType& particles);
 
     /// @brief Clear the iterator and update it with the result of the given
     ///        world-space radial query.
@@ -238,10 +245,10 @@
 
     void clear();
 
-    typedef std::pair<const IndexType*, const IndexType*> Range;
-    typedef std::deque<Range>                             RangeDeque;
-    typedef typename RangeDeque::const_iterator           RangeDequeCIter;
-    typedef boost::scoped_array<IndexType>                IndexArray;
+    using Range = std::pair<const IndexType*, const IndexType*>;
+    using RangeDeque = std::deque<Range>;
+    using RangeDequeCIter = typename RangeDeque::const_iterator;
+    using IndexArray = boost::scoped_array<IndexType>;
 
     ParticleAtlas const * const mAtlas;
     boost::scoped_array<ConstAccessorPtr> mAccessorList;
@@ -265,9 +272,10 @@
 
 
 template<typename ParticleArrayT>
-struct ComputeExtremas {
-    typedef typename ParticleArrayT::PosType    PosType;
-    typedef typename PosType::value_type        ScalarType;
+struct ComputeExtremas
+{
+    using PosType = typename ParticleArrayT::PosType;
+    using ScalarType = typename PosType::value_type;
 
     ComputeExtremas(const ParticleArrayT& particles)
         : particleArray(&particles)
@@ -310,12 +318,12 @@
 template<typename ParticleArrayT, typename PointIndex>
 struct SplittableParticleArray
 {
-    typedef boost::shared_ptr<SplittableParticleArray>          Ptr;
-    typedef boost::shared_ptr<const SplittableParticleArray>    ConstPtr;
-    typedef ParticleArrayT                                      ParticleArray;
+    using Ptr = SharedPtr<SplittableParticleArray>;
+    using ConstPtr = SharedPtr<const SplittableParticleArray>;
+    using ParticleArray = ParticleArrayT;
 
-    typedef typename ParticleArray::PosType                     PosType;
-    typedef typename PosType::value_type                        ScalarType;
+    using PosType = typename ParticleArray::PosType;
+    using ScalarType = typename PosType::value_type;
 
     SplittableParticleArray(const ParticleArrayT& particles)
         : mIndexMap(), mParticleArray(&particles), mSize(particles.size())
@@ -334,8 +342,10 @@
 
     size_t size() const { return mSize; }
 
-    void getPos(size_t n, PosType& xyz) const { return mParticleArray->getPos(getGlobalIndex(n), xyz); }
-    void getRadius(size_t n, ScalarType& radius) const { return mParticleArray->getRadius(getGlobalIndex(n), radius); }
+    void getPos(size_t n, PosType& xyz) const
+        { return mParticleArray->getPos(getGlobalIndex(n), xyz); }
+    void getRadius(size_t n, ScalarType& radius) const
+        { return mParticleArray->getRadius(getGlobalIndex(n), radius); }
 
     ScalarType minRadius() const { return mMinRadius; }
     ScalarType maxRadius() const { return mMaxRadius; }
@@ -379,7 +389,8 @@
     SplittableParticleArray& operator=(const SplittableParticleArray&);
 
     // Masked copy constructor
-    SplittableParticleArray(const SplittableParticleArray& other, const boost::scoped_array<bool>& mask)
+    SplittableParticleArray(const SplittableParticleArray& other,
+        const boost::scoped_array<bool>& mask)
         : mIndexMap(), mParticleArray(&other.particleArray()), mSize(0)
     {
         for (size_t n = 0, N = other.size(); n < N; ++n) {
@@ -427,14 +438,16 @@
     void setIndexMap(boost::scoped_array<PointIndex>& newIndexMap,
         const boost::scoped_array<bool>& mask, bool maskValue) const
     {
-        if (mIndexMap.get() != NULL) {
+        if (mIndexMap.get() != nullptr) {
                 const PointIndex* indices = mIndexMap.get();
             for (size_t idx = 0, n = 0, N = mSize; n < N; ++n) {
                 if (mask[n] == maskValue) newIndexMap[idx++] = indices[n];
             }
         } else {
             for (size_t idx = 0, n = 0, N = mSize; n < N; ++n) {
-                if (mask[n] == maskValue) newIndexMap[idx++] = PointIndex(n);
+                if (mask[n] == maskValue) {
+                    newIndexMap[idx++] = PointIndex(static_cast<typename PointIndex::IntType>(n));
+                }
             }
         }
     }
@@ -454,12 +467,13 @@
 
     RemapIndices(const ParticleArrayType& particles, std::vector<PointIndexLeafNodeType*> nodes)
         : mParticles(&particles)
-        , mNodes(nodes.empty() ? NULL : &nodes.front())
+        , mNodes(nodes.empty() ? nullptr : &nodes.front())
     {
     }
 
-    void operator()(const tbb::blocked_range<size_t>& range) const {
-        typedef typename PointIndexLeafNodeType::ValueType PointIndexType;
+    void operator()(const tbb::blocked_range<size_t>& range) const
+    {
+        using PointIndexType = typename PointIndexLeafNodeType::ValueType;
         for (size_t n = range.begin(), N = range.end(); n != N; ++n) {
 
             PointIndexLeafNodeType& node = *mNodes[n];
@@ -470,7 +484,8 @@
                 const PointIndexType* end = begin + numIndices;
 
                 while (begin < end) {
-                    *begin = PointIndexType(mParticles->getGlobalIndex(*begin));
+                    *begin = PointIndexType(static_cast<typename PointIndexType::IntType>(
+                        mParticles->getGlobalIndex(*begin)));
                     ++begin;
                 }
             }
@@ -485,12 +500,12 @@
 template<typename ParticleArrayType, typename IndexT>
 struct RadialRangeFilter
 {
-    typedef typename ParticleArrayType::PosType             PosType;
-    typedef typename PosType::value_type                    ScalarType;
+    using PosType = typename ParticleArrayType::PosType;
+    using ScalarType = typename PosType::value_type;
 
-    typedef std::pair<const IndexT*, const IndexT*>         Range;
-    typedef std::deque<Range>                               RangeDeque;
-    typedef std::deque<IndexT>                              IndexDeque;
+    using Range = std::pair<const IndexT*, const IndexT*>;
+    using RangeDeque = std::deque<Range>;
+    using IndexDeque = std::deque<IndexT>;
 
     RadialRangeFilter(RangeDeque& ranges, IndexDeque& indices, const PosType& xyz,
         ScalarType radius, const ParticleArrayType& particles, bool hasUniformRadius = false)
@@ -573,12 +588,12 @@
 template<typename ParticleArrayType, typename IndexT>
 struct BBoxFilter
 {
-    typedef typename ParticleArrayType::PosType     PosType;
-    typedef typename PosType::value_type            ScalarType;
+    using PosType = typename ParticleArrayType::PosType;
+    using ScalarType = typename PosType::value_type;
 
-    typedef std::pair<const IndexT*, const IndexT*> Range;
-    typedef std::deque<Range>                       RangeDeque;
-    typedef std::deque<IndexT>                      IndexDeque;
+    using Range = std::pair<const IndexT*, const IndexT*>;
+    using RangeDeque = std::deque<Range>;
+    using IndexDeque = std::deque<IndexT>;
 
     BBoxFilter(RangeDeque& ranges, IndexDeque& indices,
         const BBoxd& bbox, const ParticleArrayType& particles, bool hasUniformRadius = false)
@@ -701,10 +716,10 @@
 ParticleAtlas<PointIndexGridType>::construct(
     const ParticleArrayType& particles, double minVoxelSize, size_t maxLevels)
 {
-    typedef typename particle_atlas_internal::
-        SplittableParticleArray<ParticleArrayType, IndexType>   SplittableParticleArray;
-    typedef typename SplittableParticleArray::Ptr               SplittableParticleArrayPtr;
-    typedef typename ParticleArrayType::ScalarType              ScalarType;
+    using SplittableParticleArray =
+        typename particle_atlas_internal::SplittableParticleArray<ParticleArrayType, IndexType>;
+    using SplittableParticleArrayPtr = typename SplittableParticleArray::Ptr;
+    using ScalarType = typename ParticleArrayType::ScalarType;
 
     /////
 
@@ -729,7 +744,8 @@
             const double particleRadiusLimit = voxelSizeArray.back() * double(2.0);
             if (maxParticleRadius < particleRadiusLimit) break;
 
-            SplittableParticleArrayPtr newLevel = levels.back()->split(ScalarType(particleRadiusLimit));
+            SplittableParticleArrayPtr newLevel =
+                levels.back()->split(ScalarType(particleRadiusLimit));
             if (!newLevel) break;
 
             levels.push_back(newLevel);
@@ -738,8 +754,8 @@
 
         size_t numPoints = 0;
 
-        typedef typename PointIndexGridType::TreeType       PointIndexTreeType;
-        typedef typename PointIndexTreeType::LeafNodeType   PointIndexLeafNodeType;
+        using PointIndexTreeType = typename PointIndexGridType::TreeType;
+        using PointIndexLeafNodeType = typename PointIndexTreeType::LeafNodeType;
 
         std::vector<PointIndexLeafNodeType*> nodes;
 
@@ -752,14 +768,15 @@
             mMinRadiusArray.push_back(double(particleArray.minRadius()));
             mMaxRadiusArray.push_back(double(particleArray.maxRadius()));
 
-            PointIndexGridPtr grid = createPointIndexGrid<PointIndexGridType>(particleArray, voxelSizeArray[n]);
+            PointIndexGridPtr grid =
+                createPointIndexGrid<PointIndexGridType>(particleArray, voxelSizeArray[n]);
 
             nodes.clear();
             grid->tree().getNodes(nodes);
 
             tbb::parallel_for(tbb::blocked_range<size_t>(0, nodes.size()),
-                particle_atlas_internal::RemapIndices<SplittableParticleArray, PointIndexLeafNodeType>
-                (particleArray, nodes));
+                particle_atlas_internal::RemapIndices<SplittableParticleArray,
+                    PointIndexLeafNodeType>(particleArray, nodes));
 
             mIndexGridArray.push_back(grid);
         }
@@ -794,7 +811,7 @@
 ParticleAtlas<PointIndexGridType>::Iterator::Iterator(const ParticleAtlas& atlas)
     : mAtlas(&atlas)
     , mAccessorList()
-    , mRange(static_cast<IndexType*>(NULL), static_cast<IndexType*>(NULL))
+    , mRange(static_cast<IndexType*>(nullptr), static_cast<IndexType*>(nullptr))
     , mRangeList()
     , mIter(mRangeList.begin())
     , mIndexArray()
@@ -821,8 +838,8 @@
         mRange.first = mIndexArray.get();
         mRange.second = mRange.first + mIndexArraySize;
     } else {
-        mRange.first = static_cast<IndexType*>(NULL);
-        mRange.second = static_cast<IndexType*>(NULL);
+        mRange.first = static_cast<IndexType*>(nullptr);
+        mRange.second = static_cast<IndexType*>(nullptr);
     }
 }
 
@@ -874,8 +891,8 @@
 inline void
 ParticleAtlas<PointIndexGridType>::Iterator::clear()
 {
-    mRange.first = static_cast<IndexType*>(NULL);
-    mRange.second = static_cast<IndexType*>(NULL);
+    mRange.first = static_cast<IndexType*>(nullptr);
+    mRange.second = static_cast<IndexType*>(nullptr);
     mRangeList.clear();
     mIter = mRangeList.end();
     mIndexArray.reset();
@@ -887,8 +904,8 @@
 inline void
 ParticleAtlas<PointIndexGridType>::Iterator::updateFromLevel(size_t level)
 {
-    typedef typename PointIndexGridType::TreeType   TreeType;
-    typedef typename TreeType::LeafNodeType         LeafNodeType;
+    using TreeType = typename PointIndexGridType::TreeType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
 
     this->clear();
 
@@ -923,8 +940,8 @@
 ParticleAtlas<PointIndexGridType>::Iterator::worldSpaceSearchAndUpdate(
     const Vec3d& center, double radius, const ParticleArrayType& particles)
 {
-    typedef typename ParticleArrayType::PosType     PosType;
-    typedef typename ParticleArrayType::ScalarType  ScalarType;
+    using PosType = typename ParticleArrayType::PosType;
+    using ScalarType = typename ParticleArrayType::ScalarType;
 
     /////
 
@@ -969,9 +986,10 @@
             xform.worldToIndexCellCentered(bMax + maxRadius));
 
         inscribedRegion.expand(1);
-        point_index_grid_internal::constructExclusiveRegions(searchRegions, region, inscribedRegion);
+        point_index_grid_internal::constructExclusiveRegions(
+            searchRegions, region, inscribedRegion);
 
-        typedef particle_atlas_internal::RadialRangeFilter<ParticleArrayType, IndexType> FilterType;
+        using FilterType = particle_atlas_internal::RadialRangeFilter<ParticleArrayType, IndexType>;
         FilterType filter(mRangeList, filteredIndices, pos, dist, particles, uniformRadius);
 
         for (size_t i = 0, I = searchRegions.size(); i < I; ++i) {
@@ -991,11 +1009,6 @@
 ParticleAtlas<PointIndexGridType>::Iterator::worldSpaceSearchAndUpdate(
     const BBoxd& bbox, const ParticleArrayType& particles)
 {
-    typedef typename ParticleArrayType::PosType     PosType;
-    typedef typename ParticleArrayType::ScalarType  ScalarType;
-
-    /////
-
     this->clear();
 
     std::deque<IndexType> filteredIndices;
@@ -1025,9 +1038,10 @@
             xform.worldToIndexCellCentered(bbox.max() + maxRadius));
 
         inscribedRegion.expand(1);
-        point_index_grid_internal::constructExclusiveRegions(searchRegions, region, inscribedRegion);
+        point_index_grid_internal::constructExclusiveRegions(
+            searchRegions, region, inscribedRegion);
 
-        typedef particle_atlas_internal::BBoxFilter<ParticleArrayType, IndexType> FilterType;
+        using FilterType = particle_atlas_internal::BBoxFilter<ParticleArrayType, IndexType>;
         FilterType filter(mRangeList, filteredIndices, bbox, particles, uniformRadius);
 
         for (size_t i = 0, I = searchRegions.size(); i < I; ++i) {
diff -aur openvdb.3.2.0/tools/ParticlesToLevelSet.h openvdb.4.0.0/tools/ParticlesToLevelSet.h
--- openvdb.3.2.0/tools/ParticlesToLevelSet.h	2016-04-24 10:39:49.000000000 +0200
+++ openvdb.4.0.0/tools/ParticlesToLevelSet.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @author Ken Museth
 ///
 /// @file ParticlesToLevelSet.h
@@ -57,7 +57,7 @@
 ///
 ///   // Return the total number of particles in list.
 ///   // Always required!
-///   size_t         size()          const;
+///   size_t size() const;
 ///
 ///   // Get the world space position of the nth particle.
 ///   // Required by ParticledToLevelSet::rasterizeSphere(*this,radius).
@@ -85,9 +85,9 @@
 /// class Interrupter {
 ///   ...
 /// public:
-///   void start(const char* name = NULL)// called when computations begin
-///   void end()                         // called when computations end
-///   bool wasInterrupted(int percent=-1)// return true to break computation
+///   void start(const char* name = nullptr) // called when computations begin
+///   void end()                             // called when computations end
+///   bool wasInterrupted(int percent=-1)    // return true to break computation
 /// };
 /// @endcode
 ///
@@ -166,7 +166,7 @@
     /// band level sets. Finally the default NullInterrupter should
     /// compile out interruption checks during optimization, thus
     /// incurring no run-time overhead.
-    explicit ParticlesToLevelSet(SdfGridT& grid, InterrupterT* interrupt = NULL);
+    explicit ParticlesToLevelSet(SdfGridT& grid, InterrupterT* interrupt = nullptr);
 
     /// Destructor
     ~ParticlesToLevelSet() { delete mBlindGrid; }
@@ -185,7 +185,7 @@
     /// (optional) attribute.
     ///
     /// @warning If attribute transfer was disabled, i.e. AttributeT =
-    /// void, or finalize() was not called the pointer is NULL!
+    /// void, or finalize() was not called the pointer is nullptr!
     typename AttGridType::Ptr attributeGrid() { return mAttGrid; }
 
     /// @brief Return the size of a voxel in world units
@@ -273,7 +273,7 @@
 inline ParticlesToLevelSet<SdfGridT, AttributeT, InterrupterT>::
 ParticlesToLevelSet(SdfGridT& grid, InterrupterT* interrupter) :
     mSdfGrid(&grid),
-    mBlindGrid(NULL),
+    mBlindGrid(nullptr),
     mInterrupter(interrupter),
     mDx(grid.voxelSize()[0]),
     mHalfWidth(grid.background()/mDx),
@@ -345,7 +345,7 @@
 inline void
 ParticlesToLevelSet<SdfGridT, AttributeT, InterrupterT>::finalize(bool prune)
 {
-    if (mBlindGrid==NULL) {
+    if (mBlindGrid == nullptr) {
         if (prune) tools::pruneLevelSet(mSdfGrid->tree());
         return;
     } else {
@@ -794,12 +794,8 @@
     BlindData() {}
     explicit BlindData(VisibleT v) : mVisible(v), mBlind(zeroVal<BlindType>()) {}
     BlindData(VisibleT v, BlindT b) : mVisible(v), mBlind(b) {}
-    BlindData& operator=(const BlindData& rhs)
-    {
-        mVisible = rhs.mVisible;
-        mBlind = rhs.mBlind;
-        return *this;
-    }
+    BlindData(const BlindData&) = default;
+    BlindData& operator=(const BlindData&) = default;
     const VisibleT& visible() const { return mVisible; }
     const BlindT&   blind()   const { return mBlind; }
     OPENVDB_NO_FP_EQUALITY_WARNING_BEGIN
@@ -845,4 +841,3 @@
 // Copyright (c) 2012-2016 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
-
diff -aur openvdb.3.2.0/tools/PointIndexGrid.h openvdb.4.0.0/tools/PointIndexGrid.h
--- openvdb.3.2.0/tools/PointIndexGrid.h	2016-06-05 09:21:57.000000000 +0200
+++ openvdb.4.0.0/tools/PointIndexGrid.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file   PointIndexGrid.h
 ///
 /// @brief  Space-partitioning acceleration structure for points. Partitions
@@ -54,11 +54,16 @@
 #include <openvdb/tree/Tree.h>
 
 #include <boost/scoped_array.hpp>
-#include <deque>
-#include <iostream>
 #include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/parallel_for.h>
+#include <algorithm> // for std::min(), std::max()
+#include <cmath> // for std::sqrt()
+#include <deque>
+#include <iostream>
+#include <type_traits> // for std::is_same
+#include <utility> // for std::pair
+#include <vector>
 
 
 namespace openvdb {
@@ -74,11 +79,11 @@
 template<typename T, Index Log2Dim> struct PointIndexLeafNode; // forward declaration
 
 /// Point index tree configured to match the default OpenVDB tree configuration
-typedef tree::Tree<tree::RootNode<tree::InternalNode<tree::InternalNode
-    <PointIndexLeafNode<PointIndex32, 3>, 4>, 5> > > PointIndexTree;
+using PointIndexTree = tree::Tree<tree::RootNode<tree::InternalNode<tree::InternalNode
+    <PointIndexLeafNode<PointIndex32, 3>, 4>, 5>>>;
 
 /// Point index grid
-typedef Grid<PointIndexTree> PointIndexGrid;
+using PointIndexGrid = Grid<PointIndexTree>;
 
 
 ////////////////////////////////////////
@@ -91,7 +96,7 @@
 /// struct PointArray
 /// {
 ///     // The type used to represent world-space point positions
-///     typedef VectorType  PosType;
+///     using PosType = VectorType;
 ///
 ///     // Return the number of points in the array
 ///     size_t size() const;
@@ -153,9 +158,9 @@
 template<typename TreeType = PointIndexTree>
 struct PointIndexIterator
 {
-    typedef tree::ValueAccessor<const TreeType> ConstAccessor;
-    typedef typename TreeType::LeafNodeType     LeafNodeType;
-    typedef typename TreeType::ValueType        ValueType;
+    using ConstAccessor = tree::ValueAccessor<const TreeType>;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using ValueType = typename TreeType::ValueType;
 
 
     PointIndexIterator();
@@ -276,10 +281,10 @@
 
 
 private:
-    typedef std::pair<const ValueType*, const ValueType*> Range;
-    typedef std::deque<Range>                             RangeDeque;
-    typedef typename RangeDeque::const_iterator           RangeDequeCIter;
-    typedef boost::scoped_array<ValueType>                IndexArray;
+    using Range = std::pair<const ValueType*, const ValueType*>;
+    using RangeDeque = std::deque<Range>;
+    using RangeDequeCIter = typename RangeDeque::const_iterator;
+    using IndexArray = boost::scoped_array<ValueType>;
 
     void clear();
 
@@ -300,7 +305,7 @@
 /// @code
 /// template<typename T>
 /// struct WeightedAverageAccumulator {
-///   typedef T ValueType;
+///   using ValueType = T;
 ///
 ///   WeightedAverageAccumulator(T const * const array, const T radius)
 ///     : mValues(array), mInvRadius(1.0/radius), mWeightSum(0.0), mValueSum(0.0) {}
@@ -325,9 +330,9 @@
 template<typename PointArray, typename TreeType = PointIndexTree>
 struct PointIndexFilter
 {
-    typedef typename PointArray::PosType        PosType;
-    typedef typename PosType::value_type        ScalarType;
-    typedef tree::ValueAccessor<const TreeType> ConstAccessor;
+    using PosType = typename PointArray::PosType;
+    using ScalarType = typename PosType::value_type;
+    using ConstAccessor = tree::ValueAccessor<const TreeType>;
 
     /// @brief Constructor
     /// @param points   world-space point array conforming to the PointArray interface
@@ -381,15 +386,17 @@
             return;
         }
 
-        typedef typename LeafT::IndexArray          IndexArrayT;
-        typedef typename IndexArrayT::value_type    IndexT;
-        typedef typename PointArrayT::PosType       PosType;
+        using IndexArrayT = typename LeafT::IndexArray;
+        using IndexT = typename IndexArrayT::value_type;
+        using PosType = typename PointArrayT::PosType;
 
         typename LeafT::ValueOnCIter iter;
         Coord voxelCoord;
         PosType point;
 
-        const IndexT *begin = static_cast<IndexT*>(NULL), *end = static_cast<IndexT*>(NULL);
+        const IndexT
+            *begin = static_cast<IndexT*>(nullptr),
+            *end = static_cast<IndexT*>(nullptr);
 
         for (iter = leaf.cbeginValueOn(); iter; ++iter) {
 
@@ -421,8 +428,8 @@
 template<typename LeafNodeT>
 struct PopulateLeafNodesOp
 {
-    typedef uint32_t IndexT;
-    typedef PointPartitioner<IndexT, LeafNodeT::LOG2DIM> Partitioner;
+    using IndexT = uint32_t;
+    using Partitioner = PointPartitioner<IndexT, LeafNodeT::LOG2DIM>;
 
     PopulateLeafNodesOp(boost::scoped_array<LeafNodeT*>& leafNodes,
         const Partitioner& partitioner)
@@ -433,7 +440,7 @@
 
     void operator()(const tbb::blocked_range<size_t>& range) const {
 
-        typedef typename Partitioner::VoxelOffsetType VoxelOffsetT;
+        using VoxelOffsetT = typename Partitioner::VoxelOffsetType;
 
         size_t maxPointCount = 0;
         for (size_t n = range.begin(), N = range.end(); n != N; ++n) {
@@ -509,7 +516,7 @@
 inline void
 constructPointTree(TreeType& tree, const math::Transform& xform, const PointArray& points)
 {
-    typedef typename TreeType::LeafNodeType LeafType;
+    using LeafType = typename TreeType::LeafNodeType;
 
     boost::scoped_array<LeafType*> leafNodes;
     size_t leafNodeCount = 0;
@@ -609,11 +616,11 @@
 template<typename PointArray, typename IndexT>
 struct BBoxFilter
 {
-    typedef typename PointArray::PosType            PosType;
-    typedef typename PosType::value_type            ScalarType;
-    typedef std::pair<const IndexT*, const IndexT*> Range;
-    typedef std::deque<Range>                       RangeDeque;
-    typedef std::deque<IndexT>                      IndexDeque;
+    using PosType = typename PointArray::PosType;
+    using ScalarType = typename PosType::value_type;
+    using Range = std::pair<const IndexT*, const IndexT*>;
+    using RangeDeque = std::deque<Range>;
+    using IndexDeque = std::deque<IndexT>;
 
     BBoxFilter(RangeDeque& ranges, IndexDeque& indices, const BBoxd& bbox,
         const PointArray& points, const math::Transform& xform)
@@ -629,7 +636,9 @@
     void filterLeafNode(const LeafNodeType& leaf)
     {
         typename LeafNodeType::ValueOnCIter iter;
-        const IndexT *begin = static_cast<IndexT*>(NULL), *end = static_cast<IndexT*>(NULL);
+        const IndexT
+            *begin = static_cast<IndexT*>(nullptr),
+            *end = static_cast<IndexT*>(nullptr);
         for (iter = leaf.cbeginValueOn(); iter; ++iter) {
             leaf.getIndices(iter.pos(), begin, end);
             filterVoxel(iter.getCoord(), begin, end);
@@ -661,11 +670,11 @@
 template<typename PointArray, typename IndexT>
 struct RadialRangeFilter
 {
-    typedef typename PointArray::PosType            PosType;
-    typedef typename PosType::value_type            ScalarType;
-    typedef std::pair<const IndexT*, const IndexT*> Range;
-    typedef std::deque<Range>                       RangeDeque;
-    typedef std::deque<IndexT>                      IndexDeque;
+    using PosType = typename PointArray::PosType;
+    using ScalarType = typename PosType::value_type;
+    using Range = std::pair<const IndexT*, const IndexT*>;
+    using RangeDeque = std::deque<Range>;
+    using IndexDeque = std::deque<IndexT>;
 
     RadialRangeFilter(RangeDeque& ranges, IndexDeque& indices, const Vec3d& xyz, double radius,
         const PointArray& points, const math::Transform& xform,
@@ -726,7 +735,9 @@
         }
 
         typename LeafNodeType::ValueOnCIter iter;
-        const IndexT *begin = static_cast<IndexT*>(NULL), *end = static_cast<IndexT*>(NULL);
+        const IndexT
+            *begin = static_cast<IndexT*>(nullptr),
+            *end = static_cast<IndexT*>(nullptr);
         for (iter = leaf.cbeginValueOn(); iter; ++iter) {
             leaf.getIndices(iter.pos(), begin, end);
             filterVoxel(iter.getCoord(), begin, end);
@@ -785,7 +796,7 @@
 filteredPointIndexSearchVoxels(RangeFilterType& filter,
     const LeafNodeType& leaf, const Coord& min, const Coord& max)
 {
-    typedef typename LeafNodeType::ValueType PointIndexT;
+    using PointIndexT = typename LeafNodeType::ValueType;
     Index xPos(0), yPos(0), pos(0);
     Coord ijk(0);
 
@@ -815,7 +826,7 @@
 inline void
 filteredPointIndexSearch(RangeFilterType& filter, ConstAccessor& acc, const CoordBBox& bbox)
 {
-    typedef typename ConstAccessor::TreeType::LeafNodeType LeafNodeType;
+    using LeafNodeType = typename ConstAccessor::TreeType::LeafNodeType;
     Coord ijk(0), ijkMax(0), ijkA(0), ijkB(0);
     const Coord leafMin = bbox.min() & ~(LeafNodeType::DIM - 1);
     const Coord leafMax = bbox.max() & ~(LeafNodeType::DIM - 1);
@@ -852,9 +863,9 @@
 pointIndexSearchVoxels(RangeDeque& rangeList,
     const LeafNodeType& leaf, const Coord& min, const Coord& max)
 {
-    typedef typename LeafNodeType::ValueType PointIndexT;
-    typedef typename PointIndexT::IntType    IntT;
-    typedef typename RangeDeque::value_type  Range;
+    using PointIndexT = typename LeafNodeType::ValueType;
+    using IntT = typename PointIndexT::IntType;
+    using Range = typename RangeDeque::value_type;
 
     Index xPos(0), pos(0), zStride = Index(max[2] - min[2]);
     const PointIndexT* dataPtr = &leaf.indices().front();
@@ -891,9 +902,9 @@
 inline void
 pointIndexSearch(RangeDeque& rangeList, ConstAccessor& acc, const CoordBBox& bbox)
 {
-    typedef typename ConstAccessor::TreeType::LeafNodeType LeafNodeType;
-    typedef typename LeafNodeType::ValueType PointIndexT;
-    typedef typename RangeDeque::value_type  Range;
+    using LeafNodeType = typename ConstAccessor::TreeType::LeafNodeType;
+    using PointIndexT = typename LeafNodeType::ValueType;
+    using Range = typename RangeDeque::value_type;
 
     Coord ijk(0), ijkMax(0), ijkA(0), ijkB(0);
     const Coord leafMin = bbox.min() & ~(LeafNodeType::DIM - 1);
@@ -933,7 +944,7 @@
 template<typename TreeType>
 inline
 PointIndexIterator<TreeType>::PointIndexIterator()
-    : mRange(static_cast<ValueType*>(NULL), static_cast<ValueType*>(NULL))
+    : mRange(static_cast<ValueType*>(nullptr), static_cast<ValueType*>(nullptr))
     , mRangeList()
     , mIter(mRangeList.begin())
     , mIndexArray()
@@ -981,7 +992,7 @@
 template<typename TreeType>
 inline
 PointIndexIterator<TreeType>::PointIndexIterator(const Coord& ijk, ConstAccessor& acc)
-    : mRange(static_cast<ValueType*>(NULL), static_cast<ValueType*>(NULL))
+    : mRange(static_cast<ValueType*>(nullptr), static_cast<ValueType*>(nullptr))
     , mRangeList()
     , mIter(mRangeList.begin())
     , mIndexArray()
@@ -998,7 +1009,7 @@
 template<typename TreeType>
 inline
 PointIndexIterator<TreeType>::PointIndexIterator(const CoordBBox& bbox, ConstAccessor& acc)
-    : mRange(static_cast<ValueType*>(NULL), static_cast<ValueType*>(NULL))
+    : mRange(static_cast<ValueType*>(nullptr), static_cast<ValueType*>(nullptr))
     , mRangeList()
     , mIter(mRangeList.begin())
     , mIndexArray()
@@ -1024,8 +1035,8 @@
         mRange.first = mIndexArray.get();
         mRange.second = mRange.first + mIndexArraySize;
     } else {
-        mRange.first = static_cast<ValueType*>(NULL);
-        mRange.second = static_cast<ValueType*>(NULL);
+        mRange.first = static_cast<ValueType*>(nullptr);
+        mRange.second = static_cast<ValueType*>(nullptr);
     }
 }
 
@@ -1076,8 +1087,8 @@
 inline void
 PointIndexIterator<TreeType>::clear()
 {
-    mRange.first = static_cast<ValueType*>(NULL);
-    mRange.second = static_cast<ValueType*>(NULL);
+    mRange.first = static_cast<ValueType*>(nullptr);
+    mRange.second = static_cast<ValueType*>(nullptr);
     mRangeList.clear();
     mIter = mRangeList.end();
     mIndexArray.reset();
@@ -1192,7 +1203,7 @@
     std::deque<ValueType> filteredIndices;
     const double leafNodeDim = double(TreeType::LeafNodeType::DIM);
 
-    typedef point_index_grid_internal::RadialRangeFilter<PointArray, ValueType> FilterT;
+    using FilterT = point_index_grid_internal::RadialRangeFilter<PointArray, ValueType>;
 
     FilterT filter(mRangeList, filteredIndices,
         center, radius, points, xform, leafNodeDim, subvoxelAccuracy);
@@ -1369,11 +1380,11 @@
 template<typename T, Index Log2Dim>
 struct PointIndexLeafNode : public tree::LeafNode<T, Log2Dim>
 {
-    typedef PointIndexLeafNode<T, Log2Dim>          LeafNodeType;
-    typedef boost::shared_ptr<PointIndexLeafNode>   Ptr;
+    using LeafNodeType = PointIndexLeafNode<T, Log2Dim>;
+    using Ptr = SharedPtr<PointIndexLeafNode>;
 
-    typedef T                       ValueType;
-    typedef std::vector<ValueType>  IndexArray;
+    using ValueType = T;
+    using IndexArray = std::vector<ValueType>;
 
 
     IndexArray& indices() { return mIndices; }
@@ -1396,8 +1407,8 @@
     // to make the derived PointIndexLeafNode class compatible with the tree structure.
 
 public:
-    typedef tree::LeafNode<T, Log2Dim>  BaseLeaf;
-    typedef util::NodeMask<Log2Dim>     NodeMaskType;
+    using BaseLeaf = tree::LeafNode<T, Log2Dim>;
+    using NodeMaskType = util::NodeMask<Log2Dim>;
 
     using BaseLeaf::LOG2DIM;
     using BaseLeaf::TOTAL;
@@ -1469,7 +1480,7 @@
     NodeT* probeNodeAndCache(const Coord&, AccessorT&)
     {
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN
-        if (!(boost::is_same<NodeT,PointIndexLeafNode>::value)) return NULL;
+        if (!(std::is_same<NodeT, PointIndexLeafNode>::value)) return nullptr;
         return reinterpret_cast<NodeT*>(this);
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
     }
@@ -1490,7 +1501,7 @@
     const NodeT* probeConstNodeAndCache(const Coord&, AccessorT&) const
     {
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN
-        if (!(boost::is_same<NodeT,PointIndexLeafNode>::value)) return NULL;
+        if (!(std::is_same<NodeT, PointIndexLeafNode>::value)) return nullptr;
         return reinterpret_cast<const NodeT*>(this);
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
     }
@@ -1576,16 +1587,16 @@
     void negate() { assertNonmodifiable(); }
 
 protected:
-    typedef typename BaseLeaf::ValueOn ValueOn;
-    typedef typename BaseLeaf::ValueOff ValueOff;
-    typedef typename BaseLeaf::ValueAll ValueAll;
-    typedef typename BaseLeaf::ChildOn ChildOn;
-    typedef typename BaseLeaf::ChildOff ChildOff;
-    typedef typename BaseLeaf::ChildAll ChildAll;
-
-    typedef typename NodeMaskType::OnIterator    MaskOnIterator;
-    typedef typename NodeMaskType::OffIterator   MaskOffIterator;
-    typedef typename NodeMaskType::DenseIterator MaskDenseIterator;
+    using ValueOn = typename BaseLeaf::ValueOn;
+    using ValueOff = typename BaseLeaf::ValueOff;
+    using ValueAll = typename BaseLeaf::ValueAll;
+    using ChildOn = typename BaseLeaf::ChildOn;
+    using ChildOff = typename BaseLeaf::ChildOff;
+    using ChildAll = typename BaseLeaf::ChildAll;
+
+    using MaskOnIterator = typename NodeMaskType::OnIterator;
+    using MaskOffIterator = typename NodeMaskType::OffIterator;
+    using MaskDenseIterator = typename NodeMaskType::DenseIterator;
 
     // During topology-only construction, access is needed
     // to protected/private members of other template instances.
@@ -1596,32 +1607,30 @@
     friend class tree::IteratorBase<MaskDenseIterator, PointIndexLeafNode>;
 
 public:
-
-
-    typedef typename BaseLeaf::template ValueIter<
-        MaskOnIterator, PointIndexLeafNode, const ValueType, ValueOn> ValueOnIter;
-    typedef typename BaseLeaf::template ValueIter<
-        MaskOnIterator, const PointIndexLeafNode, const ValueType, ValueOn> ValueOnCIter;
-    typedef typename BaseLeaf::template ValueIter<
-        MaskOffIterator, PointIndexLeafNode, const ValueType, ValueOff> ValueOffIter;
-    typedef typename BaseLeaf::template ValueIter<
-        MaskOffIterator,const PointIndexLeafNode,const ValueType,ValueOff> ValueOffCIter;
-    typedef typename BaseLeaf::template ValueIter<
-        MaskDenseIterator, PointIndexLeafNode, const ValueType, ValueAll> ValueAllIter;
-    typedef typename BaseLeaf::template ValueIter<
-        MaskDenseIterator,const PointIndexLeafNode,const ValueType,ValueAll> ValueAllCIter;
-    typedef typename BaseLeaf::template ChildIter<
-        MaskOnIterator, PointIndexLeafNode, ChildOn> ChildOnIter;
-    typedef typename BaseLeaf::template ChildIter<
-        MaskOnIterator, const PointIndexLeafNode, ChildOn> ChildOnCIter;
-    typedef typename BaseLeaf::template ChildIter<
-        MaskOffIterator, PointIndexLeafNode, ChildOff> ChildOffIter;
-    typedef typename BaseLeaf::template ChildIter<
-        MaskOffIterator, const PointIndexLeafNode, ChildOff> ChildOffCIter;
-    typedef typename BaseLeaf::template DenseIter<
-        PointIndexLeafNode, ValueType, ChildAll> ChildAllIter;
-    typedef typename BaseLeaf::template DenseIter<
-        const PointIndexLeafNode, const ValueType, ChildAll> ChildAllCIter;
+    using ValueOnIter = typename BaseLeaf::template ValueIter<
+        MaskOnIterator, PointIndexLeafNode, const ValueType, ValueOn>;
+    using ValueOnCIter = typename BaseLeaf::template ValueIter<
+        MaskOnIterator, const PointIndexLeafNode, const ValueType, ValueOn>;
+    using ValueOffIter = typename BaseLeaf::template ValueIter<
+        MaskOffIterator, PointIndexLeafNode, const ValueType, ValueOff>;
+    using ValueOffCIter = typename BaseLeaf::template ValueIter<
+        MaskOffIterator,const PointIndexLeafNode,const ValueType, ValueOff>;
+    using ValueAllIter = typename BaseLeaf::template ValueIter<
+        MaskDenseIterator, PointIndexLeafNode, const ValueType, ValueAll>;
+    using ValueAllCIter = typename BaseLeaf::template ValueIter<
+        MaskDenseIterator,const PointIndexLeafNode,const ValueType, ValueAll>;
+    using ChildOnIter = typename BaseLeaf::template ChildIter<
+        MaskOnIterator, PointIndexLeafNode, ChildOn>;
+    using ChildOnCIter = typename BaseLeaf::template ChildIter<
+        MaskOnIterator, const PointIndexLeafNode, ChildOn>;
+    using ChildOffIter = typename BaseLeaf::template ChildIter<
+        MaskOffIterator, PointIndexLeafNode, ChildOff>;
+    using ChildOffCIter = typename BaseLeaf::template ChildIter<
+        MaskOffIterator, const PointIndexLeafNode, ChildOff>;
+    using ChildAllIter = typename BaseLeaf::template DenseIter<
+        PointIndexLeafNode, ValueType, ChildAll>;
+    using ChildAllCIter = typename BaseLeaf::template DenseIter<
+        const PointIndexLeafNode, const ValueType, ChildAll>;
 
 #define VMASK_ this->getValueMask()
     ValueOnCIter  cbeginValueOn() const  { return ValueOnCIter(VMASK_.beginOn(), this); }
diff -aur openvdb.3.2.0/tools/PointPartitioner.h openvdb.4.0.0/tools/PointPartitioner.h
--- openvdb.3.2.0/tools/PointPartitioner.h	2016-06-05 09:21:57.000000000 +0200
+++ openvdb.4.0.0/tools/PointPartitioner.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file    PointPartitioner.h
 ///
 /// @brief   Spatially partitions points using a parallel radix-based
@@ -45,25 +45,24 @@
 #ifndef OPENVDB_TOOLS_POINT_PARTITIONER_HAS_BEEN_INCLUDED
 #define OPENVDB_TOOLS_POINT_PARTITIONER_HAS_BEEN_INCLUDED
 
-
 #include <openvdb/Types.h>
 #include <openvdb/math/Transform.h>
 
-#include <deque>
-#include <map>
-#include <set>
-#include <utility> // std::pair
-#include <vector>
-
 #include <boost/integer.hpp> // boost::int_t<N>::least
 #include <boost/scoped_array.hpp>
 #include <boost/shared_ptr.hpp>
-#include <boost/math/special_functions/fpclassify.hpp> // boost::math::isfinite
 
 #include <tbb/blocked_range.h>
 #include <tbb/parallel_for.h>
 #include <tbb/task_scheduler_init.h>
 
+#include <cmath> // for std::isfinite()
+#include <deque>
+#include <map>
+#include <set>
+#include <utility> // std::pair
+#include <vector>
+
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -84,7 +83,7 @@
 /// struct PointArray
 /// {
 ///     // The type used to represent world-space point positions
-///     typedef VectorType  PosType;
+///     using PosType = VectorType;
 ///
 ///     // Return the number of points in the array
 ///     size_t size() const;
@@ -109,12 +108,12 @@
 public:
     enum { LOG2DIM = BucketLog2Dim };
 
-    typedef boost::shared_ptr<PointPartitioner>                     Ptr;
-    typedef boost::shared_ptr<const PointPartitioner>               ConstPtr;
+    using Ptr = SharedPtr<PointPartitioner>;
+    using ConstPtr = SharedPtr<const PointPartitioner>;
 
-    typedef PointIndexType                                          IndexType;
-    typedef typename boost::int_t<1 + (3 * BucketLog2Dim)>::least   VoxelOffsetType;
-    typedef boost::scoped_array<VoxelOffsetType>                    VoxelOffsetArray;
+    using IndexType = PointIndexType;
+    using VoxelOffsetType = typename boost::int_t<1 + (3 * BucketLog2Dim)>::least;
+    using VoxelOffsetArray = boost::scoped_array<VoxelOffsetType>;
 
     class IndexIterator;
 
@@ -133,7 +132,8 @@
     ///                               on the image of the index-space lattice points.
     template<typename PointArray>
     void construct(const PointArray& points, const math::Transform& xform,
-        bool voxelOrder = false, bool recordVoxelOffsets = false, bool cellCenteredTransform = true);
+        bool voxelOrder = false, bool recordVoxelOffsets = false,
+        bool cellCenteredTransform = true);
 
 
     /// @brief  Partitions point indices into @c BucketLog2Dim aligned buckets.
@@ -147,7 +147,8 @@
     ///                               on the image of the index-space lattice points.
     template<typename PointArray>
     static Ptr create(const PointArray& points, const math::Transform& xform,
-        bool voxelOrder = false, bool recordVoxelOffsets = false, bool cellCenteredTransform = true);
+        bool voxelOrder = false, bool recordVoxelOffsets = false,
+        bool cellCenteredTransform = true);
 
 
     /// @brief Returns the number of buckets.
@@ -197,16 +198,16 @@
 }; // class PointPartitioner
 
 
-typedef PointPartitioner<uint32_t, 3> UInt32PointPartitioner;
+using UInt32PointPartitioner = PointPartitioner<uint32_t, 3>;
 
 
 template<typename PointIndexType, Index BucketLog2Dim>
 class PointPartitioner<PointIndexType, BucketLog2Dim>::IndexIterator
 {
 public:
-    typedef PointIndexType     IndexType;
+    using IndexType = PointIndexType;
 
-    IndexIterator(IndexType* begin = NULL, IndexType* end = NULL)
+    IndexIterator(IndexType* begin = nullptr, IndexType* end = nullptr)
         : mBegin(begin), mEnd(end), mItem(begin) {}
 
     /// @brief Rewind to first item.
@@ -216,8 +217,8 @@
     size_t size() const { return mEnd - mBegin; }
 
     /// @brief  Returns the item to which this iterator is currently pointing.
-    IndexType& operator*() { assert(mItem != NULL); return *mItem; }
-    const IndexType& operator*() const { assert(mItem != NULL); return *mItem; }
+    IndexType& operator*() { assert(mItem != nullptr); return *mItem; }
+    const IndexType& operator*() const { assert(mItem != nullptr); return *mItem; }
 
     /// @brief  Return @c true if this iterator is not yet exhausted.
     operator bool() const { return mItem < mEnd; }
@@ -298,9 +299,9 @@
 template<typename PointIndexType, Index BucketLog2Dim>
 struct VoxelOrderOp
 {
-    typedef typename boost::int_t<1 + (3 * BucketLog2Dim)>::least     VoxelOffsetType;
-    typedef boost::scoped_array<VoxelOffsetType>                VoxelOffsetArray;
-    typedef boost::scoped_array<PointIndexType>                 IndexArray;
+    using VoxelOffsetType = typename boost::int_t<1 + (3 * BucketLog2Dim)>::least;
+    using VoxelOffsetArray = boost::scoped_array<VoxelOffsetType>;
+    using IndexArray = boost::scoped_array<PointIndexType>;
 
     VoxelOrderOp(IndexArray& indices, const IndexArray& pages,const VoxelOffsetArray& offsets)
         : mIndices(indices.get())
@@ -368,8 +369,8 @@
 template<typename PointArray, typename PointIndexType>
 struct LeafNodeOriginOp
 {
-    typedef boost::scoped_array<PointIndexType>     IndexArray;
-    typedef boost::scoped_array<Coord>              CoordArray;
+    using IndexArray = boost::scoped_array<PointIndexType>;
+    using CoordArray = boost::scoped_array<Coord>;
 
     LeafNodeOriginOp(CoordArray& coordinates,
         const IndexArray& indices, const IndexArray& pages,
@@ -386,7 +387,7 @@
 
     void operator()(const tbb::blocked_range<size_t>& range) const {
 
-        typedef typename PointArray::PosType  PosType;
+        using PosType = typename PointArray::PosType;
 
         const bool cellCentered = mCellCenteredTransform;
         const int mask = ~((1 << mLog2Dim) - 1);
@@ -397,10 +398,7 @@
 
             mPoints->getPos(mIndices[mPages[n]], pos);
 
-            if (boost::math::isfinite(pos[0]) &&
-                boost::math::isfinite(pos[1]) &&
-                boost::math::isfinite(pos[2])) {
-
+            if (std::isfinite(pos[0]) && std::isfinite(pos[1]) && std::isfinite(pos[2])) {
                 ijk = cellCentered ? mXForm.worldToIndexCellCentered(pos) :
                     mXForm.worldToIndexNodeCentered(pos);
 
@@ -429,7 +427,7 @@
 template<typename T>
 struct Array
 {
-    typedef boost::shared_ptr<Array> Ptr;
+    using Ptr = SharedPtr<Array>;
 
     Array(size_t size) : mSize(size), mData(new T[size]) { }
 
@@ -449,8 +447,8 @@
 template<typename PointIndexType>
 struct MoveSegmentDataOp
 {
-    typedef Array<PointIndexType>   Segment;
-    typedef typename Segment::Ptr   SegmentPtr;
+    using Segment = Array<PointIndexType>;
+    using SegmentPtr = typename Segment::Ptr;
 
     MoveSegmentDataOp(std::vector<PointIndexType*>& indexLists, SegmentPtr* segments)
         : mIndexLists(&indexLists[0]), mSegments(segments)
@@ -493,14 +491,14 @@
 template<typename PointIndexType>
 struct MergeBinsOp
 {
-    typedef Array<PointIndexType>                       Segment;
-    typedef typename Segment::Ptr                       SegmentPtr;
+    using Segment = Array<PointIndexType>;
+    using SegmentPtr = typename Segment::Ptr;
 
-    typedef std::pair<PointIndexType, PointIndexType>   IndexPair;
-    typedef std::deque<IndexPair>                       IndexPairList;
-    typedef boost::shared_ptr<IndexPairList>            IndexPairListPtr;
-    typedef std::map<Coord, IndexPairListPtr>           IndexPairListMap;
-    typedef boost::shared_ptr<IndexPairListMap>         IndexPairListMapPtr;
+    using IndexPair = std::pair<PointIndexType, PointIndexType>;
+    using IndexPairList = std::deque<IndexPair>;
+    using IndexPairListPtr = SharedPtr<IndexPairList>;
+    using IndexPairListMap = std::map<Coord, IndexPairListPtr>;
+    using IndexPairListMapPtr = SharedPtr<IndexPairListMap>;
 
     MergeBinsOp(IndexPairListMapPtr* bins,
         SegmentPtr* indexSegments,
@@ -578,7 +576,7 @@
 
         void operator()(const tbb::blocked_range<size_t>& range) const {
 
-            typedef typename IndexPairList::const_iterator CIter;
+            using CIter = typename IndexPairList::const_iterator;
 
             for (size_t n = range.begin(), N = range.end(); n != N; ++n) {
 
@@ -615,12 +613,12 @@
 template<typename PointArray, typename PointIndexType, typename VoxelOffsetType>
 struct BinPointIndicesOp
 {
-    typedef typename PointArray::PosType                PosType;
-    typedef std::pair<PointIndexType, PointIndexType>   IndexPair;
-    typedef std::deque<IndexPair>                       IndexPairList;
-    typedef boost::shared_ptr<IndexPairList>            IndexPairListPtr;
-    typedef std::map<Coord, IndexPairListPtr>           IndexPairListMap;
-    typedef boost::shared_ptr<IndexPairListMap>         IndexPairListMapPtr;
+    using PosType = typename PointArray::PosType;
+    using IndexPair = std::pair<PointIndexType, PointIndexType>;
+    using IndexPairList = std::deque<IndexPair>;
+    using IndexPairListPtr = SharedPtr<IndexPairList>;
+    using IndexPairListMap = std::map<Coord, IndexPairListPtr>;
+    using IndexPairListMapPtr = SharedPtr<IndexPairListMap>;
 
     BinPointIndicesOp(IndexPairListMapPtr* data,
         const PointArray& points,
@@ -653,7 +651,7 @@
         const Index binMask = (1u << (log2dim + binLog2dim)) - 1u;
         const Index invBinMask = ~binMask;
 
-        IndexPairList * idxList = NULL;
+        IndexPairList * idxList = nullptr;
         Coord ijk(0, 0, 0), loc(0, 0, 0), binCoord(0, 0, 0), lastBinCoord(1, 2, 3);
         PosType pos;
 
@@ -680,10 +678,7 @@
 
                 mPoints->getPos(i, pos);
 
-                if (boost::math::isfinite(pos[0]) &&
-                    boost::math::isfinite(pos[1]) &&
-                    boost::math::isfinite(pos[2])) {
-
+                if (std::isfinite(pos[0]) && std::isfinite(pos[1]) && std::isfinite(pos[2])) {
                     ijk = cellCentered ? mXForm.worldToIndexCellCentered(pos) :
                         mXForm.worldToIndexNodeCentered(pos);
 
@@ -691,7 +686,8 @@
                         loc[0] = ijk[0] & bucketMask;
                         loc[1] = ijk[1] & bucketMask;
                         loc[2] = ijk[2] & bucketMask;
-                        voxelOffset = VoxelOffsetType((loc[0] << log2dim2) + (loc[1] << log2dim) + loc[2]);
+                        voxelOffset = VoxelOffsetType(
+                            (loc[0] << log2dim2) + (loc[1] << log2dim) + loc[2]);
                     }
 
                     binCoord[0] = ijk[0] & invBinMask;
@@ -706,7 +702,8 @@
                     ijk[1] >>= log2dim;
                     ijk[2] >>= log2dim;
 
-                    bucketOffset = PointIndexType((ijk[0] << binLog2dim2) + (ijk[1] << binLog2dim) + ijk[2]);
+                    bucketOffset = PointIndexType(
+                        (ijk[0] << binLog2dim2) + (ijk[1] << binLog2dim) + ijk[2]);
 
                     if (lastBinCoord != binCoord) {
                         lastBinCoord = binCoord;
@@ -736,8 +733,8 @@
 template<typename PointIndexType>
 struct OrderSegmentsOp
 {
-    typedef boost::scoped_array<PointIndexType>     IndexArray;
-    typedef typename Array<PointIndexType>::Ptr     SegmentPtr;
+    using IndexArray = boost::scoped_array<PointIndexType>;
+    using SegmentPtr = typename Array<PointIndexType>::Ptr;
 
     OrderSegmentsOp(SegmentPtr* indexSegments, SegmentPtr* offestSegments,
         IndexArray* pageOffsetArrays, Index binVolume)
@@ -830,14 +827,14 @@
     size_t& segmentCount,
     const Index binLog2Dim,
     const Index bucketLog2Dim,
-    VoxelOffsetType* voxelOffsets = NULL,
+    VoxelOffsetType* voxelOffsets = nullptr,
     bool cellCenteredTransform = true)
 {
-    typedef std::pair<PointIndexType, PointIndexType>   IndexPair;
-    typedef std::deque<IndexPair>                       IndexPairList;
-    typedef boost::shared_ptr<IndexPairList>            IndexPairListPtr;
-    typedef std::map<Coord, IndexPairListPtr>           IndexPairListMap;
-    typedef boost::shared_ptr<IndexPairListMap>         IndexPairListMapPtr;
+    using IndexPair = std::pair<PointIndexType, PointIndexType>;
+    using IndexPairList = std::deque<IndexPair>;
+    using IndexPairListPtr = SharedPtr<IndexPairList>;
+    using IndexPairListMap = std::map<Coord, IndexPairListPtr>;
+    using IndexPairListMapPtr = SharedPtr<IndexPairListMap>;
 
     size_t numTasks = 1, numThreads = size_t(tbb::task_scheduler_init::default_num_threads());
     if (points.size() > (numThreads * 2)) numTasks = numThreads * 2;
@@ -845,7 +842,7 @@
 
     boost::scoped_array<IndexPairListMapPtr> bins(new IndexPairListMapPtr[numTasks]);
 
-    typedef BinPointIndicesOp<PointArray, PointIndexType, VoxelOffsetType> BinOp;
+    using BinOp = BinPointIndicesOp<PointArray, PointIndexType, VoxelOffsetType>;
 
     tbb::parallel_for(tbb::blocked_range<size_t>(0, numTasks),
         BinOp(bins.get(), points, voxelOffsets, xform, binLog2Dim, bucketLog2Dim,
@@ -865,12 +862,12 @@
 
     segmentCount = coords.size();
 
-    typedef typename Array<PointIndexType>::Ptr SegmentPtr;
+    using SegmentPtr = typename Array<PointIndexType>::Ptr;
 
     indexSegments.reset(new SegmentPtr[segmentCount]);
     offsetSegments.reset(new SegmentPtr[segmentCount]);
 
-    typedef MergeBinsOp<PointIndexType> MergeOp;
+    using MergeOp = MergeBinsOp<PointIndexType>;
 
     tbb::parallel_for(tbb::blocked_range<size_t>(0, segmentCount),
         MergeOp(bins.get(), indexSegments.get(), offsetSegments.get(), &coords[0], numTasks));
@@ -909,7 +906,7 @@
 
     const tbb::blocked_range<size_t> segmentRange(0, numSegments);
 
-    typedef boost::scoped_array<PointIndexType> IndexArray;
+    using IndexArray = boost::scoped_array<PointIndexType>;
     boost::scoped_array<IndexArray> pageOffsetArrays(new IndexArray[numSegments]);
 
     const Index binVolume = 1u << (3u * binLog2Dim);
@@ -951,7 +948,8 @@
         index += offestSegments[n]->size();
     }
 
-    tbb::parallel_for(segmentRange, MoveSegmentDataOp<PointIndexType>(indexArray, offestSegments.get()));
+    tbb::parallel_for(segmentRange,
+        MoveSegmentDataOp<PointIndexType>(indexArray, offestSegments.get()));
 }
 
 
@@ -963,10 +961,10 @@
 
 template<typename PointIndexType, Index BucketLog2Dim>
 inline PointPartitioner<PointIndexType, BucketLog2Dim>::PointPartitioner()
-    : mPointIndices(NULL)
-    , mVoxelOffsets(NULL)
-    , mPageOffsets(NULL)
-    , mPageCoordinates(NULL)
+    : mPointIndices(nullptr)
+    , mVoxelOffsets(nullptr)
+    , mPageOffsets(nullptr)
+    , mPageCoordinates(nullptr)
     , mPageCount(0)
     , mUsingCellCenteredTransform(true)
 {
@@ -1019,8 +1017,12 @@
 template<typename PointIndexType, Index BucketLog2Dim>
 template<typename PointArray>
 inline void
-PointPartitioner<PointIndexType, BucketLog2Dim>::construct(const PointArray& points,
-    const math::Transform& xform, bool voxelOrder, bool recordVoxelOffsets, bool cellCenteredTransform)
+PointPartitioner<PointIndexType, BucketLog2Dim>::construct(
+    const PointArray& points,
+    const math::Transform& xform,
+    bool voxelOrder,
+    bool recordVoxelOffsets,
+    bool cellCenteredTransform)
 {
     mUsingCellCenteredTransform = cellCenteredTransform;
 
@@ -1050,8 +1052,12 @@
 template<typename PointIndexType, Index BucketLog2Dim>
 template<typename PointArray>
 inline typename PointPartitioner<PointIndexType, BucketLog2Dim>::Ptr
-PointPartitioner<PointIndexType, BucketLog2Dim>::create(const PointArray& points, const math::Transform& xform,
-     bool voxelOrder, bool recordVoxelOffsets, bool cellCenteredTransform)
+PointPartitioner<PointIndexType, BucketLog2Dim>::create(
+    const PointArray& points,
+    const math::Transform& xform,
+    bool voxelOrder,
+    bool recordVoxelOffsets,
+    bool cellCenteredTransform)
 {
     Ptr ret(new PointPartitioner());
     ret->construct(points, xform, voxelOrder, recordVoxelOffsets, cellCenteredTransform);
diff -aur openvdb.3.2.0/tools/PointScatter.h openvdb.4.0.0/tools/PointScatter.h
--- openvdb.3.2.0/tools/PointScatter.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tools/PointScatter.h	2016-10-09 10:18:58.000000000 +0200
@@ -33,13 +33,13 @@
 /// @file PointScatter.h
 ///
 /// @brief We offer three different algorithms (each in its own class)
-///        for scattering of point in active voxels:
+///        for scattering of points in active voxels:
 ///
 /// 1) UniformPointScatter. Has two modes: Either randomly distributes
-///    a fixed number of points in the active voxels, or the user can
+///    a fixed number of points into the active voxels, or the user can
 ///    specify a fixed probability of having a points per unit of volume.
 ///
-/// 2) DenseUniformPointScatter. Randomly distributes points in active
+/// 2) DenseUniformPointScatter. Randomly distributes points into active
 ///    voxels using a fixed number of points per voxel.
 ///
 /// 3) NonIniformPointScatter. Define the local probability of having
@@ -99,7 +99,7 @@
 /// interrupter calls are no-ops (i.e. incurs no computational overhead).
 
 
-/// @brief Uniform scatters of point in the active voxels.
+/// @brief Uniformly scatters points in the active voxels.
 /// The point count is either explicitly defined or implicitly
 /// through the specification of a global density (=points-per-volume)
 ///
@@ -119,8 +119,9 @@
     UniformPointScatter(PointAccessorType& points,
                         Index64 pointCount,
                         RandomGenerator& randGen,
+                        double spread = 1.0,
                         InterruptType* interrupt = NULL)
-        : BaseT(points, randGen, interrupt)
+        : BaseT(points, randGen, spread, interrupt)
         , mTargetPointCount(pointCount)
         , mPointsPerVolume(0.0f)
     {
@@ -128,8 +129,9 @@
     UniformPointScatter(PointAccessorType& points,
                         float pointsPerVolume,
                         RandomGenerator& randGen,
+                        double spread = 1.0,
                         InterruptType* interrupt = NULL)
-        : BaseT(points, randGen, interrupt)
+        : BaseT(points, randGen, spread, interrupt)
         , mTargetPointCount(0)
         , mPointsPerVolume(pointsPerVolume)
     {
@@ -157,10 +159,11 @@
         math::RandInt<Index64, RandomGenerator> rand(BaseT::mRand01.engine(), 0, mVoxelCount-1);
         for (Index64 i=0; i<mTargetPointCount; ++i) list[i] = rand();
         tbb::parallel_sort(list.get(), list.get() + mTargetPointCount);
-
+        
         CoordBBox bbox;
         const Vec3R offset(0.5, 0.5, 0.5);
         typename GridT::ValueOnCIter valueIter = grid.cbeginValueOn();
+        
         for (Index64 i=0, n=valueIter.getVoxelCount() ; i != mTargetPointCount; ++i) {
             if (BaseT::interrupt()) return false;
             const Index64 voxelId = list[i];
@@ -172,9 +175,10 @@
                 BaseT::addPoint(grid, valueIter.getCoord() - offset);
             } else {// tiles contain multiple (virtual) voxels
                 valueIter.getBoundingBox(bbox);
-                BaseT::addPoint(grid, bbox.min() - offset, bbox.extents());
+                BaseT::addPoint(grid, bbox.min() - offset, bbox.extents()); 
             }
-        }//loop over all the active voxels and tiles
+        }//loop over all the active voxels and tiles 
+        //}
 
         BaseT::end();
         return true;
@@ -216,8 +220,9 @@
     DenseUniformPointScatter(PointAccessorType& points,
                              float pointsPerVoxel,
                              RandomGenerator& randGen,
+                             double spread = 1.0,
                              InterruptType* interrupt = NULL)
-        : BaseT(points, randGen, interrupt)
+        : BaseT(points, randGen, spread, interrupt)
         , mPointsPerVoxel(pointsPerVoxel)
     {
     }
@@ -237,13 +242,13 @@
         const int ppv = math::Floor(mPointsPerVoxel);
         const double delta = mPointsPerVoxel - ppv;
         const bool fractional = !math::isApproxZero(delta, 1.0e-6);
-
+        
         for (ValueIter iter = grid.cbeginValueOn(); iter; ++iter) {
             if (BaseT::interrupt()) return false;
             if (iter.isVoxelValue()) {// a majority is expected to be voxels
                 const Vec3R dmin = iter.getCoord() - offset;
                 for (int n = 0; n != ppv; ++n) BaseT::addPoint(grid, dmin);
-                if (fractional && BaseT::getRand() < delta) BaseT::addPoint(grid, dmin);
+                if (fractional && BaseT::getRand01() < delta) BaseT::addPoint(grid, dmin);
             } else {// tiles contain multiple (virtual) voxels
                 iter.getBoundingBox(bbox);
                 const Coord size(bbox.extents());
@@ -251,10 +256,10 @@
                 const double d = mPointsPerVoxel * iter.getVoxelCount();
                 const int m = math::Floor(d);
                 for (int n = 0; n != m; ++n)  BaseT::addPoint(grid, dmin, size);
-                if (BaseT::getRand() < d - m) BaseT::addPoint(grid, dmin, size);
+                if (BaseT::getRand01() < d - m) BaseT::addPoint(grid, dmin, size);
             }
         }//loop over all the active voxels and tiles
-
+        //}
         BaseT::end();
         return true;
     }
@@ -297,8 +302,9 @@
     NonUniformPointScatter(PointAccessorType& points,
                            float pointsPerVolume,
                            RandomGenerator& randGen,
+                           double spread = 1.0,
                            InterruptType* interrupt = NULL)
-        : BaseT(points, randGen, interrupt)
+        : BaseT(points, randGen, spread, interrupt)
         , mPointsPerVolume(pointsPerVolume)//note this is merely a
                                            //multiplier for the local point density
     {
@@ -324,13 +330,13 @@
             if (iter.isVoxelValue()) { // a majority is expected to be voxels
                 const Vec3R dmin =iter.getCoord() - offset;
                 for (int i = 0; i < n; ++i) BaseT::addPoint(grid, dmin);
-                if (BaseT::getRand() < (d - n)) BaseT::addPoint(grid, dmin);
+                if (BaseT::getRand01() < (d - n)) BaseT::addPoint(grid, dmin);
             } else { // tiles contain multiple (virtual) voxels
                 iter.getBoundingBox(bbox);
                 const Coord size(bbox.extents());
                 const Vec3R dmin = bbox.min() - offset;
                 for (int i = 0; i < n; ++i) BaseT::addPoint(grid, dmin, size);
-                if (BaseT::getRand() < (d - n)) BaseT::addPoint(grid, dmin, size);
+                if (BaseT::getRand01() < (d - n)) BaseT::addPoint(grid, dmin, size);
             }
         }//loop over all the active voxels and tiles
         BaseT::end();
@@ -367,26 +373,29 @@
 
 protected:
 
+    PointAccessorType&        mPoints;
+    InterruptType*            mInterrupter;
+    Index64                   mPointCount;
+    Index64                   mVoxelCount; 
+    Index64                   mInterruptCount;
+    const double              mSpread;
+    math::Rand01<double, RandomGenerator> mRand01;
+
     /// This is a base class so the constructor is protected
     BasePointScatter(PointAccessorType& points,
                      RandomGenerator& randGen,
+                     double spread,
                      InterruptType* interrupt = NULL)
         : mPoints(points)
         , mInterrupter(interrupt)
         , mPointCount(0)
         , mVoxelCount(0)
         , mInterruptCount(0)
+        , mSpread(math::Clamp01(spread))
         , mRand01(randGen)
     {
     }
 
-    PointAccessorType&        mPoints;
-    InterruptType*            mInterrupter;
-    Index64                   mPointCount;
-    Index64                   mVoxelCount;
-    Index64                   mInterruptCount;
-    math::Rand01<double, RandomGenerator> mRand01;
-
     inline void start(const char* name)
     {
         if (mInterrupter) mInterrupter->start(name);
@@ -403,8 +412,12 @@
         return !(mInterruptCount++ & ((1<<5)-1)) && util::wasInterrupted(mInterrupter);
     }
 
-    inline double getRand() { return mRand01(); }
+    /// @brief Return a random floating point number between zero and one
+    inline double getRand01() { return mRand01(); }
 
+    /// @brief Return a random floating point number between 0.5 -+ mSpread/2
+    inline double getRand() { return 0.5 + mSpread * (mRand01() - 0.5); }
+   
     template <typename GridT>
     inline void addPoint(const GridT &grid, const Vec3R &dmin)
     {
@@ -414,7 +427,7 @@
         mPoints.add(grid.indexToWorld(pos));
         ++mPointCount;
     }
-
+   
     template <typename GridT>
     inline void addPoint(const GridT &grid, const Vec3R &dmin, const Coord &size)
     {
diff -aur openvdb.3.2.0/tools/PointsToMask.h openvdb.4.0.0/tools/PointsToMask.h
--- openvdb.3.2.0/tools/PointsToMask.h	2016-04-24 10:39:49.000000000 +0200
+++ openvdb.4.0.0/tools/PointsToMask.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,10 +27,10 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @author Ken Museth
 ///
-/// @file PointsToMask.h
+/// @file tools/PointsToMask.h
 ///
 /// @brief This tool produces a grid where every voxel that contains a
 /// point is active. It employes thread-local storage for best performance.
@@ -60,9 +60,9 @@
 /// class Interrupter {
 ///   ...
 /// public:
-///   void start(const char* name = NULL)// called when computations begin
-///   void end()                         // called when computations end
-///   bool wasInterrupted(int percent=-1)// return true to break computation
+///   void start(const char* name = nullptr) // called when computations begin
+///   void end()                             // called when computations end
+///   bool wasInterrupted(int percent = -1)  // return true to break computation
 /// };
 /// @endcode
 ///
@@ -70,21 +70,19 @@
 /// the util::NullInterrupter is used which implies that all
 /// interrupter calls are no-ops (i.e. incurs no computational overhead).
 
-#ifndef OPENVDB_TOOLS_POINT_MASK_GRID_HAS_BEEN_INCLUDED
-#define OPENVDB_TOOLS_POINT_MASK_GRID_HAS_BEEN_INCLUDED
+#ifndef OPENVDB_TOOLS_POINTSTOMASK_HAS_BEEN_INCLUDED
+#define OPENVDB_TOOLS_POINTSTOMASK_HAS_BEEN_INCLUDED
 
-#include <tbb/tbb_thread.h>
-#include <tbb/task_scheduler_init.h>
 #include <tbb/enumerable_thread_specific.h>
 #include <tbb/parallel_for.h>
 #include <tbb/parallel_reduce.h>
 #include <tbb/blocked_range.h>
-
-#include <openvdb/openvdb.h>
+#include <openvdb/openvdb.h> // for MaskGrid
 #include <openvdb/Grid.h>
 #include <openvdb/Types.h>
 #include <openvdb/util/NullInterrupter.h>
 
+
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
 namespace OPENVDB_VERSION_NAME {
@@ -102,7 +100,7 @@
 inline void
 maskPoints(const PointListT& points, GridT& grid)
 {
-    PointsToMask<GridT, util::NullInterrupter> tmp(grid, NULL);
+    PointsToMask<GridT, util::NullInterrupter> tmp(grid, nullptr);
     tmp.addPoints(points);
 }
 
@@ -136,7 +134,7 @@
     ///
     /// @param grid        Grid whoes voxels will have their state activated by points.
     /// @param interrupter Optional interrupter to prematurely terminate execution.
-    explicit PointsToMask(GridT& grid, InterrupterT* interrupter = NULL)
+    explicit PointsToMask(GridT& grid, InterrupterT* interrupter = nullptr)
         : mGrid(&grid)
         , mInterrupter(interrupter)
     {
@@ -151,8 +149,12 @@
     void addPoints(const PointListT& points, size_t grainSize = 1024)
     {
         if (mInterrupter) mInterrupter->start("PointsToMask: adding points");
-        if (grainSize>0) {
-            typename GridT::Ptr examplar = mGrid->copy( CP_NEW );
+        if (grainSize > 0) {
+#ifdef OPENVDB_3_ABI_COMPATIBLE
+            typename GridT::Ptr examplar = mGrid->copy(CP_NEW);
+#else
+            typename GridT::Ptr examplar = mGrid->copyWithNewTree();
+#endif
             PoolType pool( *examplar );//thread local storage pool of grids
             AddPoints<PointListT> tmp(points, pool, grainSize, *this );
             if ( this->interrupt() ) return;
@@ -276,7 +278,7 @@
 } // namespace OPENVDB_VERSION_NAME
 } // namespace openvdb
 
-#endif //OPENVDB_TOOLS_POINT_MASK_GRID_HAS_BEEN_INCLUDED
+#endif // OPENVDB_TOOLS_POINTSTOMASK_HAS_BEEN_INCLUDED
 
 // Copyright (c) 2012-2016 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
diff -aur openvdb.3.2.0/tools/RayTracer.h openvdb.4.0.0/tools/RayTracer.h
--- openvdb.3.2.0/tools/RayTracer.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tools/RayTracer.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-///
+
 /// @file RayTracer.h
 ///
 /// @author Ken Museth
@@ -51,11 +51,12 @@
 #include <openvdb/math/Math.h>
 #include <openvdb/tools/RayIntersector.h>
 #include <openvdb/tools/Interpolation.h>
-#include <boost/scoped_ptr.hpp>
 #include <boost/scoped_array.hpp>
+#include <deque>
 #include <fstream>
+#include <memory>
+#include <type_traits>
 #include <vector>
-#include <deque>
 
 #ifdef OPENVDB_TOOLS_RAYTRACER_USE_EXR
 #include <OpenEXR/ImfPixelType.h>
@@ -102,9 +103,9 @@
 class LevelSetRayTracer
 {
 public:
-    typedef GridT                           GridType;
-    typedef typename IntersectorT::Vec3Type Vec3Type;
-    typedef typename IntersectorT::RayType  RayType;
+    using GridType = GridT;
+    using Vec3Type = typename IntersectorT::Vec3Type;
+    using RayType = typename IntersectorT::RayType;
 
     /// @brief Constructor based on an instance of the grid to be rendered.
     LevelSetRayTracer(const GridT& grid,
@@ -163,7 +164,7 @@
     const bool                          mIsMaster;
     double*                             mRand;
     IntersectorT                        mInter;
-    boost::scoped_ptr<const BaseShader> mShader;
+    std::unique_ptr<const BaseShader>   mShader;
     BaseCamera*                         mCamera;
     size_t                              mSubPixels;
 };// LevelSetRayTracer
@@ -180,12 +181,13 @@
 {
 public:
 
-    typedef typename IntersectorT::GridType  GridType;
-    typedef typename IntersectorT::RayType   RayType;
-    typedef typename GridType::ValueType     ValueType;
-    typedef typename GridType::ConstAccessor AccessorType;
-    typedef tools::GridSampler<AccessorType, SamplerT> SamplerType;
-    BOOST_STATIC_ASSERT(boost::is_floating_point<ValueType>::value);
+    using GridType = typename IntersectorT::GridType;
+    using RayType = typename IntersectorT::RayType;
+    using ValueType = typename GridType::ValueType;
+    using AccessorType = typename GridType::ConstAccessor;
+    using SamplerType = tools::GridSampler<AccessorType, SamplerT>;
+    static_assert(std::is_floating_point<ValueType>::value,
+        "VolumeRender requires a floating-point-valued grid");
 
     /// @brief Constructor taking an intersector and a base camera.
     VolumeRender(const IntersectorT& inter, BaseCamera& camera);
@@ -243,7 +245,7 @@
 
     AccessorType mAccessor;
     BaseCamera*  mCamera;
-    boost::scoped_ptr<IntersectorT> mPrimary, mShadow;
+    std::unique_ptr<IntersectorT> mPrimary, mShadow;
     Real  mPrimaryStep, mShadowStep, mCutOff, mLightGain;
     Vec3R mLightDir, mLightColor, mAbsorption, mScattering;
 };//VolumeRender
@@ -259,13 +261,19 @@
     /// @details This is our preferred representation for color processing.
     struct RGBA
     {
-        typedef float ValueT;
+        using ValueT = float;
 
         RGBA() : r(0), g(0), b(0), a(1) {}
         explicit RGBA(ValueT intensity) : r(intensity), g(intensity), b(intensity), a(1) {}
         RGBA(ValueT _r, ValueT _g, ValueT _b, ValueT _a = static_cast<ValueT>(1.0)):
             r(_r), g(_g), b(_b), a(_a)
         {}
+        RGBA(double _r, double _g, double _b, double _a = 1.0)
+            : r(static_cast<ValueT>(_r))
+            , g(static_cast<ValueT>(_g))
+            , b(static_cast<ValueT>(_b))
+            , a(static_cast<ValueT>(_a))
+        {}
 
         RGBA  operator* (ValueT scale)  const { return RGBA(r*scale, g*scale, b*scale);}
         RGBA  operator+ (const RGBA& rhs) const { return RGBA(r+rhs.r, g+rhs.g, b+rhs.b);}
@@ -342,7 +350,7 @@
         }
 
         os << "P6\n" << mWidth << " " << mHeight << "\n255\n";
-        os.write((const char *)&(*tmp), 3*mSize*sizeof(unsigned char));
+        os.write(reinterpret_cast<const char*>(&(*tmp)), 3 * mSize * sizeof(unsigned char));
     }
 
 #ifdef OPENVDB_TOOLS_RAYTRACER_USE_EXR
@@ -487,13 +495,13 @@
     {
     }
 
-    virtual ~PerspectiveCamera() {}
+    ~PerspectiveCamera() override = default;
 
     /// @brief Return a Ray in world space given the pixel indices and
     /// optional offsets in the range [0,1]. An offset of 0.5 corresponds
     /// to the center of the pixel.
-    virtual math::Ray<double> getRay(
-        size_t i, size_t j, double iOffset = 0.5, double jOffset = 0.5) const
+    math::Ray<double> getRay(
+        size_t i, size_t j, double iOffset = 0.5, double jOffset = 0.5) const override
     {
         math::Ray<double> ray(mRay);
         Vec3R dir = BaseCamera::rasterToScreen(Real(i) + iOffset, Real(j) + jOffset, -1.0);
@@ -543,10 +551,10 @@
         : BaseCamera(film, rotation, translation, 0.5*frameWidth, nearPlane, farPlane)
     {
     }
-    virtual ~OrthographicCamera() {}
+    ~OrthographicCamera() override = default;
 
-    virtual math::Ray<double> getRay(
-        size_t i, size_t j, double iOffset = 0.5, double jOffset = 0.5) const
+    math::Ray<double> getRay(
+        size_t i, size_t j, double iOffset = 0.5, double jOffset = 0.5) const override
     {
         math::Ray<double> ray(mRay);
         Vec3R eye = BaseCamera::rasterToScreen(Real(i) + iOffset, Real(j) + jOffset, 0.0);
@@ -563,9 +571,10 @@
 class BaseShader
 {
 public:
-    typedef math::Ray<Real> RayT;
+    using RayT = math::Ray<Real>;
     BaseShader() {}
-    virtual ~BaseShader() {}
+    BaseShader(const BaseShader&) = default;
+    virtual ~BaseShader() = default;
     /// @brief Defines the interface of the virtual function that returns a RGB color.
     /// @param xyz World position of the intersection point.
     /// @param nml Normal in world space at the intersection point.
@@ -581,40 +590,40 @@
 /// Film::RGBA which is the default) or defined in a separate Vec3
 /// color grid. Use SamplerType to define the order of interpolation
 /// (default is zero order, i.e. closes-point).
-template <typename GridT = Film::RGBA,
-          typename SamplerType = tools::PointSampler>
+template<typename GridT = Film::RGBA,
+         typename SamplerType = tools::PointSampler>
 class MatteShader: public BaseShader
 {
 public:
     MatteShader(const GridT& grid) : mAcc(grid.getAccessor()), mXform(&grid.transform()) {}
-    virtual ~MatteShader() {}
-    virtual Film::RGBA operator()(const Vec3R& xyz, const Vec3R&, const Vec3R&) const
+    MatteShader(const MatteShader&) = default;
+    ~MatteShader() override = default;
+    Film::RGBA operator()(const Vec3R& xyz, const Vec3R&, const Vec3R&) const override
     {
         typename GridT::ValueType v = zeroVal<typename GridT::ValueType>();
         SamplerType::sample(mAcc, mXform->worldToIndex(xyz), v);
-        return Film::RGBA(
-            static_cast<Film::RGBA::ValueT>(v[0]),
-            static_cast<Film::RGBA::ValueT>(v[1]),
-            static_cast<Film::RGBA::ValueT>(v[2]));
+        return Film::RGBA(v[0], v[1], v[2]);
     }
-    virtual BaseShader* copy() const { return new MatteShader<GridT, SamplerType>(*this); }
+    BaseShader* copy() const override { return new MatteShader<GridT, SamplerType>(*this); }
 
 private:
     typename GridT::ConstAccessor mAcc;
     const math::Transform* mXform;
 };
+
 // Template specialization using a constant color of the material.
-template <typename SamplerType>
+template<typename SamplerType>
 class MatteShader<Film::RGBA, SamplerType>: public BaseShader
 {
 public:
     MatteShader(const Film::RGBA& c = Film::RGBA(1.0f)): mRGBA(c) {}
-    virtual ~MatteShader() {}
-    virtual Film::RGBA operator()(const Vec3R&, const Vec3R&, const Vec3R&) const
+    MatteShader(const MatteShader&) = default;
+    ~MatteShader() override = default;
+    Film::RGBA operator()(const Vec3R&, const Vec3R&, const Vec3R&) const override
     {
         return mRGBA;
     }
-    virtual BaseShader* copy() const { return new MatteShader<Film::RGBA, SamplerType>(*this); }
+    BaseShader* copy() const override { return new MatteShader<Film::RGBA, SamplerType>(*this); }
 
 private:
     const Film::RGBA mRGBA;
@@ -628,37 +637,40 @@
 /// Film::RGBA which is the default) or defined in a separate Vec3
 /// color grid. Use SamplerType to define the order of interpolation
 /// (default is zero order, i.e. closes-point).
-template <typename GridT = Film::RGBA,
-          typename SamplerType = tools::PointSampler>
+template<typename GridT = Film::RGBA,
+         typename SamplerType = tools::PointSampler>
 class NormalShader: public BaseShader
 {
 public:
     NormalShader(const GridT& grid) : mAcc(grid.getAccessor()), mXform(&grid.transform()) {}
-    virtual ~NormalShader() {}
-    virtual Film::RGBA operator()(const Vec3R& xyz, const Vec3R& normal, const Vec3R&) const
+    NormalShader(const NormalShader&) = default;
+    ~NormalShader() override = default;
+    Film::RGBA operator()(const Vec3R& xyz, const Vec3R& normal, const Vec3R&) const override
     {
         typename GridT::ValueType v = zeroVal<typename GridT::ValueType>();
         SamplerType::sample(mAcc, mXform->worldToIndex(xyz), v);
-        return Film::RGBA(v[0]*(normal[0]+1.0f), v[1]*(normal[1]+1.0f), v[2]*(normal[2]+1.0f));
+        return Film::RGBA(v[0]*(normal[0]+1.0), v[1]*(normal[1]+1.0), v[2]*(normal[2]+1.0));
     }
-    virtual BaseShader* copy() const { return new NormalShader<GridT, SamplerType>(*this); }
+    BaseShader* copy() const override { return new NormalShader<GridT, SamplerType>(*this); }
 
 private:
     typename GridT::ConstAccessor mAcc;
     const math::Transform* mXform;
 };
+
 // Template specialization using a constant color of the material.
-template <typename SamplerType>
+template<typename SamplerType>
 class NormalShader<Film::RGBA, SamplerType>: public BaseShader
 {
 public:
     NormalShader(const Film::RGBA& c = Film::RGBA(1.0f)) : mRGBA(c*0.5f) {}
-    virtual ~NormalShader() {}
-    virtual Film::RGBA operator()(const Vec3R&, const Vec3R& normal, const Vec3R&) const
+    NormalShader(const NormalShader&) = default;
+    ~NormalShader() override = default;
+    Film::RGBA operator()(const Vec3R&, const Vec3R& normal, const Vec3R&) const override
     {
-        return mRGBA*Film::RGBA(normal[0]+1.0f, normal[1]+1.0f, normal[2]+1.0f);
+        return mRGBA * Film::RGBA(normal[0] + 1.0, normal[1] + 1.0, normal[2] + 1.0);
     }
-    virtual BaseShader* copy() const { return new NormalShader<Film::RGBA, SamplerType>(*this); }
+    BaseShader* copy() const override { return new NormalShader<Film::RGBA, SamplerType>(*this); }
 
 private:
     const Film::RGBA mRGBA;
@@ -672,8 +684,8 @@
 /// Film::RGBA which is the default) or defined in a separate Vec3
 /// color grid. Use SamplerType to define the order of interpolation
 /// (default is zero order, i.e. closes-point).
-template <typename GridT = Film::RGBA,
-          typename SamplerType = tools::PointSampler>
+template<typename GridT = Film::RGBA,
+         typename SamplerType = tools::PointSampler>
 class PositionShader: public BaseShader
 {
 public:
@@ -684,41 +696,45 @@
         , mXform(&grid.transform())
     {
     }
-    virtual ~PositionShader() {}
-    virtual Film::RGBA operator()(const Vec3R& xyz, const Vec3R&, const Vec3R&) const
+    PositionShader(const PositionShader&) = default;
+    ~PositionShader() override = default;
+    Film::RGBA operator()(const Vec3R& xyz, const Vec3R&, const Vec3R&) const override
     {
         typename GridT::ValueType v = zeroVal<typename GridT::ValueType>();
         SamplerType::sample(mAcc, mXform->worldToIndex(xyz), v);
-        const Vec3R rgb = (xyz - mMin)*mInvDim;
+        const Vec3R rgb = (xyz - mMin) * mInvDim;
         return Film::RGBA(v[0],v[1],v[2]) * Film::RGBA(rgb[0], rgb[1], rgb[2]);
     }
-    virtual BaseShader* copy() const { return new PositionShader<GridT, SamplerType>(*this); }
+    BaseShader* copy() const override { return new PositionShader<GridT, SamplerType>(*this); }
 
 private:
     const Vec3R mMin, mInvDim;
     typename GridT::ConstAccessor mAcc;
     const math::Transform* mXform;
 };
+
 // Template specialization using a constant color of the material.
-template <typename SamplerType>
+template<typename SamplerType>
 class PositionShader<Film::RGBA, SamplerType>: public BaseShader
 {
 public:
     PositionShader(const math::BBox<Vec3R>& bbox, const Film::RGBA& c = Film::RGBA(1.0f))
         : mMin(bbox.min()), mInvDim(1.0/bbox.extents()), mRGBA(c) {}
-    virtual ~PositionShader() {}
-    virtual Film::RGBA operator()(const Vec3R& xyz, const Vec3R&, const Vec3R&) const
+    PositionShader(const PositionShader&) = default;
+    ~PositionShader() override = default;
+    Film::RGBA operator()(const Vec3R& xyz, const Vec3R&, const Vec3R&) const override
     {
         const Vec3R rgb = (xyz - mMin)*mInvDim;
         return mRGBA*Film::RGBA(rgb[0], rgb[1], rgb[2]);
     }
-    virtual BaseShader* copy() const { return new PositionShader<Film::RGBA, SamplerType>(*this); }
+    BaseShader* copy() const override { return new PositionShader<Film::RGBA, SamplerType>(*this); }
 
 private:
     const Vec3R mMin, mInvDim;
     const Film::RGBA mRGBA;
 };
 
+
 /// @brief Simple diffuse Lambertian surface shader.
 ///
 /// @details The diffuse color can either be constant (if GridT =
@@ -728,35 +744,39 @@
 /// surface normal and the direction of the light source. Use
 /// SamplerType to define the order of interpolation (default is
 /// zero order, i.e. closes-point).
-template <typename GridT = Film::RGBA,
-          typename SamplerType = tools::PointSampler>
+template<typename GridT = Film::RGBA,
+         typename SamplerType = tools::PointSampler>
 class DiffuseShader: public BaseShader
 {
 public:
     DiffuseShader(const GridT& grid): mAcc(grid.getAccessor()), mXform(&grid.transform()) {}
-    virtual ~DiffuseShader() {}
-    virtual Film::RGBA operator()(const Vec3R& xyz, const Vec3R& normal, const Vec3R& rayDir) const
+    DiffuseShader(const DiffuseShader&) = default;
+    ~DiffuseShader() override = default;
+    Film::RGBA operator()(const Vec3R& xyz, const Vec3R& normal, const Vec3R& rayDir) const override
     {
         typename GridT::ValueType v = zeroVal<typename GridT::ValueType>();
         SamplerType::sample(mAcc, mXform->worldToIndex(xyz), v);
         // We take the abs of the dot product corresponding to having
         // light sources at +/- rayDir, i.e., two-sided shading.
-        return Film::RGBA(v[0],v[1],v[2]) * math::Abs(normal.dot(rayDir));
+        return Film::RGBA(v[0],v[1],v[2])
+            * static_cast<Film::RGBA::ValueT>(math::Abs(normal.dot(rayDir)));
     }
-    virtual BaseShader* copy() const { return new DiffuseShader<GridT, SamplerType>(*this); }
+    BaseShader* copy() const override { return new DiffuseShader<GridT, SamplerType>(*this); }
 
 private:
     typename GridT::ConstAccessor mAcc;
     const math::Transform* mXform;
 };
+
 // Template specialization using a constant color of the material.
 template <typename SamplerType>
 class DiffuseShader<Film::RGBA, SamplerType>: public BaseShader
 {
 public:
     DiffuseShader(const Film::RGBA& d = Film::RGBA(1.0f)): mRGBA(d) {}
-    virtual ~DiffuseShader() {}
-    virtual Film::RGBA operator()(const Vec3R&, const Vec3R& normal, const Vec3R& rayDir) const
+    DiffuseShader(const DiffuseShader&) = default;
+    ~DiffuseShader() override = default;
+    Film::RGBA operator()(const Vec3R&, const Vec3R& normal, const Vec3R& rayDir) const override
     {
         // We assume a single directional light source at the camera,
         // so the cosine of the angle between the surface normal and the
@@ -767,14 +787,15 @@
 
         // We take the abs of the dot product corresponding to having
         // light sources at +/- rayDir, i.e., two-sided shading.
-        return mRGBA * math::Abs(normal.dot(rayDir));
+        return mRGBA * static_cast<Film::RGBA::ValueT>(math::Abs(normal.dot(rayDir)));
     }
-    virtual BaseShader* copy() const { return new DiffuseShader<Film::RGBA, SamplerType>(*this); }
+    BaseShader* copy() const override { return new DiffuseShader<Film::RGBA, SamplerType>(*this); }
 
 private:
     const Film::RGBA mRGBA;
 };
 
+
 //////////////////////////////////////// RAYTRACER ////////////////////////////////////////
 
 template<typename GridT>
@@ -816,7 +837,7 @@
                   size_t pixelSamples,
                   unsigned int seed)
     : mIsMaster(true),
-      mRand(NULL),
+      mRand(nullptr),
       mInter(grid),
       mShader(shader.copy()),
       mCamera(&camera)
@@ -832,7 +853,7 @@
                   size_t pixelSamples,
                   unsigned int seed)
     : mIsMaster(true),
-      mRand(NULL),
+      mRand(nullptr),
       mInter(inter),
       mShader(shader.copy()),
       mCamera(&camera)
@@ -906,7 +927,7 @@
         math::Rand01<double> rand(seed);//offsets for anti-aliaing by jittered super-sampling
         for (size_t i=0; i<16; ++i) mRand[i] = rand();
     } else {
-        mRand = NULL;
+        mRand = nullptr;
     }
 }
 
diff -aur openvdb.3.2.0/tools/ValueTransformer.h openvdb.4.0.0/tools/ValueTransformer.h
--- openvdb.3.2.0/tools/ValueTransformer.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tools/ValueTransformer.h	2016-10-09 10:18:58.000000000 +0200
@@ -646,9 +646,17 @@
     OpAccumulator(const IterT& iter, OpT& op):
         mIsRoot(true),
         mIter(iter),
-        mOp(&op),
-        mOrigOp(new OpT(op))
-    {}
+////
+        //mOp(&op),
+        //mOrigOp(new OpT(op))
+mOp(NULL),
+mOrigOp(NULL)
+{
+    mOp = &op;
+    mOrigOp = new OpT(op);
+}
+    //{}
+////
 
     // When splitting this task, give the subtask a copy of the original functor,
     // not of this task's functor, which might have been modified arbitrarily.
@@ -679,7 +687,10 @@
     const bool mIsRoot;
     const IterT mIter;
     OpT* mOp; // pointer to original functor, which might get modified
-    OpT const * const mOrigOp; // const copy of original functor
+////
+    //OpT const * const mOrigOp; // const copy of original functor
+OpT const * mOrigOp; // const copy of original functor
+////
 }; // class OpAccumulator
 
 } // namespace valxform
diff -aur openvdb.3.2.0/tools/VolumeToMesh.h openvdb.4.0.0/tools/VolumeToMesh.h
--- openvdb.3.2.0/tools/VolumeToMesh.h	2016-07-24 09:29:15.000000000 +0200
+++ openvdb.4.0.0/tools/VolumeToMesh.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,14 +27,13 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file   VolumeToMesh.h
 ///
 /// @brief  Extract polygonal surfaces from scalar volumes.
 ///
 /// @author Mihai Alden
 
-
 #ifndef OPENVDB_TOOLS_VOLUME_TO_MESH_HAS_BEEN_INCLUDED
 #define OPENVDB_TOOLS_VOLUME_TO_MESH_HAS_BEEN_INCLUDED
 
@@ -44,19 +43,17 @@
 #include <openvdb/util/Util.h> // for INVALID_IDX
 
 #include <boost/scoped_array.hpp>
-#include <boost/scoped_ptr.hpp>
-#include <boost/type_traits/is_scalar.hpp>
-#include <boost/utility/enable_if.hpp>
-#include <boost/math/special_functions/fpclassify.hpp> // for isfinite
 
 #include <tbb/blocked_range.h>
 #include <tbb/parallel_for.h>
 #include <tbb/parallel_reduce.h>
 #include <tbb/task_scheduler_init.h>
 
+#include <cmath> // for std::isfinite()
 #include <map>
 #include <memory> // for auto_ptr/unique_ptr
 #include <set>
+#include <type_traits>
 #include <vector>
 
 
@@ -179,8 +176,8 @@
 
 /// @{
 /// @brief Point and primitive list types.
-typedef boost::scoped_array<openvdb::Vec3s>     PointList;
-typedef boost::scoped_array<PolygonPool>        PolygonPoolList;
+using PointList = boost::scoped_array<openvdb::Vec3s>;
+using PolygonPoolList = boost::scoped_array<PolygonPool>;
 /// @}
 
 
@@ -299,7 +296,7 @@
     const std::vector<Vec3d>& points,
     const std::vector<Vec3d>& normals)
 {
-    typedef math::Mat3d Mat3d;
+    using Mat3d = math::Mat3d;
 
     Vec3d avgPos(0.0);
 
@@ -395,18 +392,6 @@
 
 namespace volume_to_mesh_internal {
 
-
-template<typename T>
-struct UniquePtr
-{
-#ifdef OPENVDB_HAS_CXX11
-    typedef std::unique_ptr<T>  type;
-#else
-    typedef std::auto_ptr<T>    type;
-#endif
-};
-
-
 template<typename ValueType>
 struct FillArray
 {
@@ -675,14 +660,14 @@
 getCellVertexValues(const LeafT& leaf, const Index offset,
     math::Tuple<8, typename LeafT::ValueType>& values)
 {
-    values[0] = leaf.getValue(offset);                                                // i, j, k
-    values[3] = leaf.getValue(offset + 1);                                            // i, j, k+1
-    values[4] = leaf.getValue(offset + LeafT::DIM);                                   // i, j+1, k
-    values[7] = leaf.getValue(offset + LeafT::DIM + 1);                               // i, j+1, k+1
-    values[1] = leaf.getValue(offset + (LeafT::DIM * LeafT::DIM));                    // i+1, j, k
-    values[2] = leaf.getValue(offset + (LeafT::DIM * LeafT::DIM) + 1);                // i+1, j, k+1
-    values[5] = leaf.getValue(offset + (LeafT::DIM * LeafT::DIM) + LeafT::DIM);       // i+1, j+1, k
-    values[6] = leaf.getValue(offset + (LeafT::DIM * LeafT::DIM) + LeafT::DIM + 1);   // i+1, j+1, k+1
+    values[0] = leaf.getValue(offset);                                              // i, j, k
+    values[3] = leaf.getValue(offset + 1);                                          // i, j, k+1
+    values[4] = leaf.getValue(offset + LeafT::DIM);                                 // i, j+1, k
+    values[7] = leaf.getValue(offset + LeafT::DIM + 1);                             // i, j+1, k+1
+    values[1] = leaf.getValue(offset + (LeafT::DIM * LeafT::DIM));                  // i+1, j, k
+    values[2] = leaf.getValue(offset + (LeafT::DIM * LeafT::DIM) + 1);              // i+1, j, k+1
+    values[5] = leaf.getValue(offset + (LeafT::DIM * LeafT::DIM) + LeafT::DIM);     // i+1, j+1, k
+    values[6] = leaf.getValue(offset + (LeafT::DIM * LeafT::DIM) + LeafT::DIM + 1); // i+1, j+1, k+1
 }
 
 
@@ -983,7 +968,7 @@
 {
     if (adaptivity < 1e-6) return false;
 
-    typedef typename LeafType::ValueType VecT;
+    using VecT = typename LeafType::ValueType;
     Coord ijk, end = start;
     end[0] += dim;
     end[1] += dim;
@@ -1487,14 +1472,14 @@
 template <typename InputTreeType>
 struct ComputePoints
 {
-    typedef typename InputTreeType::LeafNodeType                            InputLeafNodeType;
-    typedef typename InputLeafNodeType::ValueType                           InputValueType;
+    using InputLeafNodeType = typename InputTreeType::LeafNodeType;
+    using InputValueType = typename InputLeafNodeType::ValueType;
 
-    typedef typename InputTreeType::template ValueConverter<Int16>::Type    Int16TreeType;
-    typedef typename Int16TreeType::LeafNodeType                            Int16LeafNodeType;
+    using Int16TreeType = typename InputTreeType::template ValueConverter<Int16>::Type;
+    using Int16LeafNodeType = typename Int16TreeType::LeafNodeType;
 
-    typedef typename InputTreeType::template ValueConverter<Index32>::Type  Index32TreeType;
-    typedef typename Index32TreeType::LeafNodeType                          Index32LeafNodeType;
+    using Index32TreeType = typename InputTreeType::template ValueConverter<Index32>::Type;
+    using Index32LeafNodeType = typename Index32TreeType::LeafNodeType;
 
     ComputePoints(Vec3s * pointArray,
         const InputTreeType& inputTree,
@@ -1540,16 +1525,16 @@
     double iso)
     : mPoints(pointArray)
     , mInputTree(&inputTree)
-    , mPointIndexNodes(pointIndexLeafNodes.empty() ? NULL : &pointIndexLeafNodes.front())
-    , mSignFlagsNodes(signFlagsLeafNodes.empty() ? NULL : &signFlagsLeafNodes.front())
+    , mPointIndexNodes(pointIndexLeafNodes.empty() ? nullptr : &pointIndexLeafNodes.front())
+    , mSignFlagsNodes(signFlagsLeafNodes.empty() ? nullptr : &signFlagsLeafNodes.front())
     , mNodeOffsets(leafNodeOffsets.get())
     , mTransform(xform)
     , mIsovalue(iso)
-    , mRefInputTree(NULL)
-    , mRefPointIndexTree(NULL)
-    , mRefSignFlagsTree(NULL)
-    , mQuantizedSeamLinePoints(NULL)
-    , mSeamLinePointsFlags(NULL)
+    , mRefInputTree(nullptr)
+    , mRefPointIndexTree(nullptr)
+    , mRefSignFlagsTree(nullptr)
+    , mQuantizedSeamLinePoints(nullptr)
+    , mSeamLinePointsFlags(nullptr)
 {
 }
 
@@ -1573,14 +1558,14 @@
 void
 ComputePoints<InputTreeType>::operator()(const tbb::blocked_range<size_t>& range) const
 {
-    typedef tree::ValueAccessor<const InputTreeType>    InputTreeAccessor;
-    typedef tree::ValueAccessor<const Index32TreeType>  Index32TreeAccessor;
-    typedef tree::ValueAccessor<const Int16TreeType>    Int16TreeAccessor;
+    using InputTreeAccessor = tree::ValueAccessor<const InputTreeType>;
+    using Index32TreeAccessor = tree::ValueAccessor<const Index32TreeType>;
+    using Int16TreeAccessor = tree::ValueAccessor<const Int16TreeType>;
 
-    typedef typename Index32TreeType::ValueType         IndexType;
+    using IndexType = typename Index32TreeType::ValueType;
 
-    typedef std::vector<Index>              IndexArray;
-    typedef std::map<IndexType, IndexArray> IndexArrayMap;
+    using IndexArray = std::vector<Index>;
+    using IndexArrayMap = std::map<IndexType, IndexArray>;
 
     InputTreeAccessor inputAcc(*mInputTree);
 
@@ -1593,9 +1578,9 @@
 
     // reference data accessors
 
-    boost::scoped_ptr<InputTreeAccessor> refInputAcc;
-    boost::scoped_ptr<Index32TreeAccessor> refPointIndexAcc;
-    boost::scoped_ptr<Int16TreeAccessor> refSignFlagsAcc;
+    std::unique_ptr<InputTreeAccessor> refInputAcc;
+    std::unique_ptr<Index32TreeAccessor> refPointIndexAcc;
+    std::unique_ptr<Int16TreeAccessor> refSignFlagsAcc;
 
     const bool hasReferenceData = mRefInputTree && mRefPointIndexTree && mRefSignFlagsTree;
 
@@ -1614,9 +1599,9 @@
         const InputLeafNodeType * inputNode = inputAcc.probeConstLeaf(origin);
 
         // get reference data
-        const InputLeafNodeType * refInputNode = NULL;
-        const Index32LeafNodeType * refPointIndexNode = NULL;
-        const Int16LeafNodeType * refSignFlagsNode = NULL;
+        const InputLeafNodeType * refInputNode = nullptr;
+        const Index32LeafNodeType * refPointIndexNode = nullptr;
+        const Int16LeafNodeType * refSignFlagsNode = nullptr;
 
         if (hasReferenceData) {
             refInputNode = refInputAcc->probeConstLeaf(origin);
@@ -1627,8 +1612,7 @@
         IndexType pointOffset = IndexType(mNodeOffsets[n]);
         IndexArrayMap regions;
 
-        for (typename Index32LeafNodeType::ValueOnIter it = pointIndexNode.beginValueOn(); it; ++it) {
-
+        for (auto it = pointIndexNode.beginValueOn(); it; ++it) {
             const Index offset = it.pos();
 
             const IndexType id = it.getValue();
@@ -1671,9 +1655,11 @@
                 computeCellPoints(points, values, signs, iso);
 
             } else {
-                if (inclusiveCell && refInputNode) collectCornerValues(*refInputNode, offset, refValues);
-                else collectCornerValues(*refInputAcc, ijk, refValues);
-
+                if (inclusiveCell && refInputNode) {
+                    collectCornerValues(*refInputNode, offset, refValues);
+                } else {
+                    collectCornerValues(*refInputAcc, ijk, refValues);
+                }
                 computeCellPoints(points, weightedPointMask, values, refValues, signs, refSigns,
                     iso, refPointIndexNode->getValue(offset), mQuantizedSeamLinePoints);
             }
@@ -1687,14 +1673,16 @@
                 Vec3d& point = points[i];
 
                 // Checks for both NaN and inf vertex positions, i.e. any value that is not finite.
-                if (!boost::math::isfinite(point[0]) ||
-                    !boost::math::isfinite(point[1]) ||
-                    !boost::math::isfinite(point[2])) {
-                    OPENVDB_THROW(ValueError, "VolumeToMesh encountered NaNs or infs in the input VDB!"
-                                  " Hint: Check the input and consider using the \"Diagnostics\" tool "
-                                  "to detect and resolve the NaNs.");
+                if (!std::isfinite(point[0]) ||
+                    !std::isfinite(point[1]) ||
+                    !std::isfinite(point[2]))
+                {
+                    OPENVDB_THROW(ValueError,
+                        "VolumeToMesh encountered NaNs or infs in the input VDB!"
+                        " Hint: Check the input and consider using the \"Diagnostics\" tool "
+                        "to detect and resolve the NaNs.");
                 }
-                
+
                 point += xyz;
                 point = mTransform.indexToWorld(point);
 
@@ -1773,14 +1761,14 @@
 template <typename InputTreeType>
 struct SeamLineWeights
 {
-    typedef typename InputTreeType::LeafNodeType                            InputLeafNodeType;
-    typedef typename InputLeafNodeType::ValueType                           InputValueType;
+    using InputLeafNodeType = typename InputTreeType::LeafNodeType;
+    using InputValueType = typename InputLeafNodeType::ValueType;
 
-    typedef typename InputTreeType::template ValueConverter<Int16>::Type    Int16TreeType;
-    typedef typename Int16TreeType::LeafNodeType                            Int16LeafNodeType;
+    using Int16TreeType = typename InputTreeType::template ValueConverter<Int16>::Type;
+    using Int16LeafNodeType = typename Int16TreeType::LeafNodeType;
 
-    typedef typename InputTreeType::template ValueConverter<Index32>::Type  Index32TreeType;
-    typedef typename Index32TreeType::LeafNodeType                          Index32LeafNodeType;
+    using Index32TreeType = typename InputTreeType::template ValueConverter<Index32>::Type;
+    using Index32LeafNodeType = typename Index32TreeType::LeafNodeType;
 
     SeamLineWeights(const std::vector<Int16LeafNodeType*>& signFlagsLeafNodes,
         const InputTreeType& inputTree,
@@ -1788,7 +1776,7 @@
         const Int16TreeType& refSignFlagsTree,
         uint32_t * quantizedPoints,
         InputValueType iso)
-        : mSignFlagsNodes(signFlagsLeafNodes.empty() ? NULL : &signFlagsLeafNodes.front())
+        : mSignFlagsNodes(signFlagsLeafNodes.empty() ? nullptr : &signFlagsLeafNodes.front())
         , mInputTree(&inputTree)
         , mRefPointIndexTree(&refPointIndexTree)
         , mRefSignFlagsTree(&refSignFlagsTree)
@@ -1816,13 +1804,15 @@
             const Int16LeafNodeType * refSignNode = signFlagsTreeAcc.probeConstLeaf(origin);
             if (!refSignNode) continue;
 
-            const Index32LeafNodeType * refPointIndexNode = pointIndexTreeAcc.probeConstLeaf(origin);
+            const Index32LeafNodeType* refPointIndexNode =
+                pointIndexTreeAcc.probeConstLeaf(origin);
             if (!refPointIndexNode) continue;
 
             const InputLeafNodeType * inputNode = inputTreeAcc.probeConstLeaf(origin);
 
-            for (typename Int16LeafNodeType::ValueOnCIter it = signFlagsNode.cbeginValueOn(); it; ++it) {
-
+            for (typename Int16LeafNodeType::ValueOnCIter it = signFlagsNode.cbeginValueOn();
+                it; ++it)
+            {
                 const Index offset = it.pos();
 
                 ijk = Index32LeafNodeType::offsetToLocalCoord(offset);
@@ -1853,7 +1843,8 @@
 
                         if (id != -1) {
 
-                            uint32_t& data = mQuantizedPoints[refPointIndexNode->getValue(offset) + (id - 1)];
+                            uint32_t& data = mQuantizedPoints[
+                                refPointIndexNode->getValue(offset) + (id - 1)];
 
                             if (!(data & MASK_DIRTY_BIT)) {
 
@@ -1887,11 +1878,11 @@
 template <typename TreeType>
 struct SetSeamLineFlags
 {
-    typedef typename TreeType::LeafNodeType    LeafNodeType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
 
     SetSeamLineFlags(const std::vector<LeafNodeType*>& signFlagsLeafNodes,
         const TreeType& refSignFlagsTree)
-        : mSignFlagsNodes(signFlagsLeafNodes.empty() ? NULL : &signFlagsLeafNodes.front())
+        : mSignFlagsNodes(signFlagsLeafNodes.empty() ? nullptr : &signFlagsLeafNodes.front())
         , mRefSignFlagsTree(&refSignFlagsTree)
     {
     }
@@ -1908,7 +1899,7 @@
             const LeafNodeType * refSignNode = refSignFlagsTreeAcc.probeConstLeaf(origin);
             if (!refSignNode) continue;
 
-            for (typename LeafNodeType::ValueOnCIter it = signFlagsNode.cbeginValueOn(); it; ++it) {
+            for (auto it = signFlagsNode.cbeginValueOn(); it; ++it) {
                 const Index offset = it.pos();
 
                 uint8_t rhsSigns = uint8_t(refSignNode->getValue(offset) & SIGNS);
@@ -1937,14 +1928,14 @@
 template <typename BoolTreeType, typename SignDataType>
 struct TransferSeamLineFlags
 {
-    typedef typename BoolTreeType::LeafNodeType                                BoolLeafNodeType;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
 
-    typedef typename BoolTreeType::template ValueConverter<SignDataType>::Type SignDataTreeType;
-    typedef typename SignDataTreeType::LeafNodeType                            SignDataLeafNodeType;
+    using SignDataTreeType = typename BoolTreeType::template ValueConverter<SignDataType>::Type;
+    using SignDataLeafNodeType = typename SignDataTreeType::LeafNodeType;
 
     TransferSeamLineFlags(const std::vector<SignDataLeafNodeType*>& signFlagsLeafNodes,
         const BoolTreeType& maskTree)
-        : mSignFlagsNodes(signFlagsLeafNodes.empty() ? NULL : &signFlagsLeafNodes.front())
+        : mSignFlagsNodes(signFlagsLeafNodes.empty() ? nullptr : &signFlagsLeafNodes.front())
         , mMaskTree(&maskTree)
     {
     }
@@ -1961,7 +1952,7 @@
             const BoolLeafNodeType * maskNode = maskAcc.probeConstLeaf(origin);
             if (!maskNode) continue;
 
-            typedef typename SignDataLeafNodeType::ValueOnCIter ValueOnCIter;
+            using ValueOnCIter = typename SignDataLeafNodeType::ValueOnCIter;
 
             for (ValueOnCIter it = signFlagsNode.cbeginValueOn(); it; ++it) {
                 const Index offset = it.pos();
@@ -1984,13 +1975,13 @@
 template <typename TreeType>
 struct MaskSeamLineVoxels
 {
-    typedef typename TreeType::LeafNodeType                         LeafNodeType;
-    typedef typename TreeType::template ValueConverter<bool>::Type  BoolTreeType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using BoolTreeType = typename TreeType::template ValueConverter<bool>::Type;
 
     MaskSeamLineVoxels(const std::vector<LeafNodeType*>& signFlagsLeafNodes,
         const TreeType& signFlagsTree,
         BoolTreeType& mask)
-        : mSignFlagsNodes(signFlagsLeafNodes.empty() ? NULL : &signFlagsLeafNodes.front())
+        : mSignFlagsNodes(signFlagsLeafNodes.empty() ? nullptr : &signFlagsLeafNodes.front())
         , mSignFlagsTree(&signFlagsTree)
         , mTempMask(false)
         , mMask(&mask)
@@ -2009,8 +2000,8 @@
 
     void operator()(const tbb::blocked_range<size_t>& range)
     {
-        typedef typename LeafNodeType::ValueOnCIter ValueOnCIter;
-        typedef typename LeafNodeType::ValueType    ValueType;
+        using ValueOnCIter = typename LeafNodeType::ValueOnCIter;
+        using ValueType = typename LeafNodeType::ValueType;
 
         tree::ValueAccessor<const TreeType> signFlagsAcc(*mSignFlagsTree);
         tree::ValueAccessor<BoolTreeType> maskAcc(*mMask);
@@ -2082,9 +2073,9 @@
 inline void
 markSeamLineData(SignDataTreeType& signFlagsTree, const SignDataTreeType& refSignFlagsTree)
 {
-    typedef typename SignDataTreeType::ValueType                            SignDataType;
-    typedef typename SignDataTreeType::LeafNodeType                         SignDataLeafNodeType;
-    typedef typename SignDataTreeType::template ValueConverter<bool>::Type  BoolTreeType;
+    using SignDataType = typename SignDataTreeType::ValueType;
+    using SignDataLeafNodeType = typename SignDataTreeType::LeafNodeType;
+    using BoolTreeType = typename SignDataTreeType::template ValueConverter<bool>::Type;
 
     std::vector<SignDataLeafNodeType*> signFlagsLeafNodes;
     signFlagsTree.getNodes(signFlagsLeafNodes);
@@ -2112,22 +2103,22 @@
 template <typename InputGridType>
 struct MergeVoxelRegions
 {
-    typedef typename InputGridType::TreeType                                InputTreeType;
-    typedef typename InputTreeType::LeafNodeType                            InputLeafNodeType;
-    typedef typename InputLeafNodeType::ValueType                           InputValueType;
-
-    typedef typename InputTreeType::template ValueConverter<float>::Type    FloatTreeType;
-    typedef typename FloatTreeType::LeafNodeType                            FloatLeafNodeType;
-    typedef Grid<FloatTreeType>                                             FloatGridType;
+    using InputTreeType = typename InputGridType::TreeType;
+    using InputLeafNodeType = typename InputTreeType::LeafNodeType;
+    using InputValueType = typename InputLeafNodeType::ValueType;
+
+    using FloatTreeType = typename InputTreeType::template ValueConverter<float>::Type;
+    using FloatLeafNodeType = typename FloatTreeType::LeafNodeType;
+    using FloatGridType = Grid<FloatTreeType>;
 
-    typedef typename InputTreeType::template ValueConverter<Int16>::Type    Int16TreeType;
-    typedef typename Int16TreeType::LeafNodeType                            Int16LeafNodeType;
+    using Int16TreeType = typename InputTreeType::template ValueConverter<Int16>::Type;
+    using Int16LeafNodeType = typename Int16TreeType::LeafNodeType;
 
-    typedef typename InputTreeType::template ValueConverter<Index32>::Type  Index32TreeType;
-    typedef typename Index32TreeType::LeafNodeType                          Index32LeafNodeType;
+    using Index32TreeType = typename InputTreeType::template ValueConverter<Index32>::Type;
+    using Index32LeafNodeType = typename Index32TreeType::LeafNodeType;
 
-    typedef typename InputTreeType::template ValueConverter<bool>::Type     BoolTreeType;
-    typedef typename BoolTreeType::LeafNodeType                             BoolLeafNodeType;
+    using BoolTreeType = typename InputTreeType::template ValueConverter<bool>::Type;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
 
     MergeVoxelRegions(const InputGridType& inputGrid,
         const Index32TreeType& pointIndexTree,
@@ -2187,16 +2178,16 @@
     : mInputTree(&inputGrid.tree())
     , mInputTransform(&inputGrid.transform())
     , mPointIndexTree(&pointIndexTree)
-    , mPointIndexNodes(pointIndexLeafNodes.empty() ? NULL : &pointIndexLeafNodes.front())
-    , mSignFlagsNodes(signFlagsLeafNodes.empty() ? NULL : &signFlagsLeafNodes.front())
+    , mPointIndexNodes(pointIndexLeafNodes.empty() ? nullptr : &pointIndexLeafNodes.front())
+    , mSignFlagsNodes(signFlagsLeafNodes.empty() ? nullptr : &signFlagsLeafNodes.front())
     , mIsovalue(iso)
     , mSurfaceAdaptivity(adaptivity)
     , mInternalAdaptivity(adaptivity)
     , mInvertSurfaceOrientation(invertSurfaceOrientation)
-    , mSpatialAdaptivityTree(NULL)
-    , mMaskTree(NULL)
-    , mRefSignFlagsTree(NULL)
-    , mSpatialAdaptivityTransform(NULL)
+    , mSpatialAdaptivityTree(nullptr)
+    , mMaskTree(nullptr)
+    , mRefSignFlagsTree(nullptr)
+    , mSpatialAdaptivityTransform(nullptr)
 {
 }
 
@@ -2205,26 +2196,26 @@
 void
 MergeVoxelRegions<InputGridType>::operator()(const tbb::blocked_range<size_t>& range) const
 {
-    typedef math::Vec3<float>                                                    Vec3sType;
-    typedef typename InputLeafNodeType::template ValueConverter<Vec3sType>::Type Vec3sLeafNodeType;
+    using Vec3sType = math::Vec3<float>;
+    using Vec3sLeafNodeType = typename InputLeafNodeType::template ValueConverter<Vec3sType>::Type;
 
-    typedef tree::ValueAccessor<const InputTreeType>    InputTreeAccessor;
-    typedef tree::ValueAccessor<const FloatTreeType>    FloatTreeAccessor;
-    typedef tree::ValueAccessor<const Index32TreeType>  Index32TreeAccessor;
-    typedef tree::ValueAccessor<const Int16TreeType>    Int16TreeAccessor;
-    typedef tree::ValueAccessor<const BoolTreeType>     BoolTreeAccessor;
+    using InputTreeAccessor = tree::ValueAccessor<const InputTreeType>;
+    using FloatTreeAccessor = tree::ValueAccessor<const FloatTreeType>;
+    using Index32TreeAccessor = tree::ValueAccessor<const Index32TreeType>;
+    using Int16TreeAccessor = tree::ValueAccessor<const Int16TreeType>;
+    using BoolTreeAccessor = tree::ValueAccessor<const BoolTreeType>;
 
-    boost::scoped_ptr<FloatTreeAccessor> spatialAdaptivityAcc;
+    std::unique_ptr<FloatTreeAccessor> spatialAdaptivityAcc;
     if (mSpatialAdaptivityTree && mSpatialAdaptivityTransform) {
         spatialAdaptivityAcc.reset(new FloatTreeAccessor(*mSpatialAdaptivityTree));
     }
 
-    boost::scoped_ptr<BoolTreeAccessor> maskAcc;
+    std::unique_ptr<BoolTreeAccessor> maskAcc;
     if (mMaskTree) {
         maskAcc.reset(new BoolTreeAccessor(*mMaskTree));
     }
 
-    boost::scoped_ptr<Int16TreeAccessor> refSignFlagsAcc;
+    std::unique_ptr<Int16TreeAccessor> refSignFlagsAcc;
     if (mRefSignFlagsTree) {
         refSignFlagsAcc.reset(new Int16TreeAccessor(*mRefSignFlagsTree));
     }
@@ -2235,7 +2226,7 @@
     BoolLeafNodeType mask;
 
     const bool invertGradientDir = mInvertSurfaceOrientation || isBoolValue<InputValueType>();
-    boost::scoped_ptr<Vec3sLeafNodeType> gradientNode;
+    std::unique_ptr<Vec3sLeafNodeType> gradientNode;
 
     Coord ijk, end;
     const int LeafDim = InputLeafNodeType::DIM;
@@ -2256,8 +2247,10 @@
         // Mask off seam line adjacent voxels
         if (maskAcc) {
             const BoolLeafNodeType* maskLeaf = maskAcc->probeConstLeaf(origin);
-            if (maskLeaf != NULL) {
-                for (typename BoolLeafNodeType::ValueOnCIter it = maskLeaf->cbeginValueOn(); it; ++it) {
+            if (maskLeaf != nullptr) {
+                for (typename BoolLeafNodeType::ValueOnCIter it = maskLeaf->cbeginValueOn();
+                    it; ++it)
+                {
                     mask.setActiveState(it.getCoord() & ~1u, true);
                 }
             }
@@ -2275,7 +2268,8 @@
             useGradients = false;
             for (Index offset = 0; offset < FloatLeafNodeType::NUM_VALUES; ++offset) {
                 ijk = adaptivityLeaf.offsetToGlobalCoord(offset);
-                ijk = mSpatialAdaptivityTransform->worldToIndexCellCentered(mInputTransform->indexToWorld(ijk));
+                ijk = mSpatialAdaptivityTransform->worldToIndexCellCentered(
+                    mInputTransform->indexToWorld(ijk));
                 float weight = spatialAdaptivityAcc->getValue(ijk);
                 float adaptivityValue = weight * adaptivity;
                 if (adaptivityValue < 1.0f) useGradients = true;
@@ -2284,8 +2278,7 @@
         }
 
         // Mask off ambiguous voxels
-        for (typename Int16LeafNodeType::ValueOnCIter it = signFlagsNode.cbeginValueOn(); it; ++it) {
-
+        for (auto it = signFlagsNode.cbeginValueOn(); it; ++it) {
             const Int16 flags = it.getValue();
             const unsigned char signs = static_cast<unsigned char>(SIGNS & int(flags));
 
@@ -2358,7 +2351,7 @@
                 gradientNode.reset(new Vec3sLeafNodeType());
             }
 
-            for (typename Int16LeafNodeType::ValueOnCIter it = signFlagsNode.cbeginValueOn(); it; ++it) {
+            for (auto it = signFlagsNode.cbeginValueOn(); it; ++it) {
                 ijk = it.getCoord();
                 if (!mask.isValueOn(ijk & ~1u)) {
                     Vec3sType dir(math::ISGradient<math::CD_2ND>::result(inputAcc, ijk));
@@ -2383,8 +2376,10 @@
 
                         adaptivity = adaptivityLeaf.getValue(ijk);
 
-                        if (mask.isValueOn(ijk) || isNonManifold(inputAcc, ijk, mIsovalue, dim)
-                            || (useGradients && !isMergable(*gradientNode, ijk, dim, adaptivity)) ) {
+                        if (mask.isValueOn(ijk)
+                            || isNonManifold(inputAcc, ijk, mIsovalue, dim)
+                            || (useGradients && !isMergable(*gradientNode, ijk, dim, adaptivity)))
+                        {
                             mask.setActiveState(ijk & coordMask, true);
                         } else {
                             mergeVoxels(pointIndexNode, ijk, dim, regionId++);
@@ -2403,7 +2398,7 @@
 // Constructs qudas
 struct UniformPrimBuilder
 {
-    UniformPrimBuilder(): mIdx(0), mPolygonPool(NULL) {}
+    UniformPrimBuilder(): mIdx(0), mPolygonPool(nullptr) {}
 
     void init(const size_t upperBound, PolygonPool& quadPool)
     {
@@ -2442,7 +2437,7 @@
 // Constructs qudas and triangles
 struct AdaptivePrimBuilder
 {
-    AdaptivePrimBuilder() : mQuadIdx(0), mTriangleIdx(0), mPolygonPool(NULL) {}
+    AdaptivePrimBuilder() : mQuadIdx(0), mTriangleIdx(0), mPolygonPool(nullptr) {}
 
     void init(const size_t upperBound, PolygonPool& polygonPool)
     {
@@ -2539,10 +2534,17 @@
 
 template<typename SignAccT, typename IdxAccT, typename PrimBuilder>
 inline void
-constructPolygons(bool invertSurfaceOrientation, Int16 flags, Int16 refFlags, const Vec3i& offsets, const Coord& ijk,
-    const SignAccT& signAcc, const IdxAccT& idxAcc, PrimBuilder& mesher)
+constructPolygons(
+    bool invertSurfaceOrientation,
+    Int16 flags,
+    Int16 refFlags,
+    const Vec3i& offsets,
+    const Coord& ijk,
+    const SignAccT& signAcc,
+    const IdxAccT& idxAcc,
+    PrimBuilder& mesher)
 {
-    typedef typename IdxAccT::ValueType IndexType;
+    using IndexType = typename IdxAccT::ValueType;
 
     IndexType v0 = IndexType(util::INVALID_IDX);
     const bool isActive = idxAcc.probeValue(ijk, v0);
@@ -2654,11 +2656,12 @@
 template<typename InputTreeType>
 struct MaskTileBorders
 {
-    typedef typename InputTreeType::ValueType                               InputValueType;
-    typedef typename InputTreeType::template ValueConverter<bool>::Type     BoolTreeType;
+    using InputValueType = typename InputTreeType::ValueType;
+    using BoolTreeType = typename InputTreeType::template ValueConverter<bool>::Type;
 
 
-    MaskTileBorders(const InputTreeType& inputTree, InputValueType iso, BoolTreeType& mask, const Vec4i* tileArray)
+    MaskTileBorders(const InputTreeType& inputTree, InputValueType iso,
+        BoolTreeType& mask, const Vec4i* tileArray)
         : mInputTree(&inputTree)
         , mIsovalue(iso)
         , mTempMask(false)
@@ -2737,7 +2740,8 @@
 
         processRegion = true;
         if (valueDepth >= inputTreeAcc.getValueDepth(ijk)) {
-            processRegion = !inputTreeAcc.probeValue(ijk, value) && isInside != isInsideValue(value, mIsovalue);
+            processRegion = (!inputTreeAcc.probeValue(ijk, value)
+                && isInside != isInsideValue(value, mIsovalue));
         }
 
         if (processRegion) {
@@ -2772,7 +2776,8 @@
 
         processRegion = true;
         if (valueDepth >= inputTreeAcc.getValueDepth(ijk)) {
-            processRegion = !inputTreeAcc.probeValue(ijk, value) && isInside != isInsideValue(value, mIsovalue);
+            processRegion = (!inputTreeAcc.probeValue(ijk, value)
+                && isInside != isInsideValue(value, mIsovalue));
         }
 
         if (processRegion) {
@@ -2806,7 +2811,8 @@
 
         processRegion = true;
         if (valueDepth >= inputTreeAcc.getValueDepth(ijk)) {
-            processRegion = !inputTreeAcc.probeValue(ijk, value) && isInside != isInsideValue(value, mIsovalue);
+            processRegion = (!inputTreeAcc.probeValue(ijk, value)
+                && isInside != isInsideValue(value, mIsovalue));
         }
 
         if (processRegion) {
@@ -2887,7 +2893,7 @@
 
 struct LeafNodeVoxelOffsets
 {
-    typedef std::vector<Index> IndexVector;
+    using IndexVector = std::vector<Index>;
 
     template<typename LeafNodeType>
     void constructOffsetList();
@@ -3215,8 +3221,9 @@
         for (size_t n = 0, N = offsets->size(); n < N; ++n) {
 
             const Index& pos = (*offsets)[n];
-            if (leafnode.isValueOn(pos) && (inside != isInsideValue(leafnode.getValue(pos), iso))) {
-
+            if (leafnode.isValueOn(pos)
+                && (inside != isInsideValue(leafnode.getValue(pos), iso)))
+            {
                 ijk = leafnode.offsetToGlobalCoord(pos);
                 if      (VoxelEdgeAcc::AXIS == 0) --ijk[0];
                 else if (VoxelEdgeAcc::AXIS == 1) --ijk[1];
@@ -3233,10 +3240,10 @@
 template<typename InputTreeType>
 struct IdentifyIntersectingVoxels
 {
-    typedef typename InputTreeType::LeafNodeType    InputLeafNodeType;
-    typedef typename InputLeafNodeType::ValueType   InputValueType;
+    using InputLeafNodeType = typename InputTreeType::LeafNodeType;
+    using InputValueType = typename InputLeafNodeType::ValueType;
 
-    typedef typename InputTreeType::template ValueConverter<bool>::Type BoolTreeType;
+    using BoolTreeType = typename InputTreeType::template ValueConverter<bool>::Type;
 
     IdentifyIntersectingVoxels(
         const InputTreeType& inputTree,
@@ -3271,7 +3278,7 @@
     BoolTreeType& intersectionTree,
     InputValueType iso)
     : mInputAccessor(inputTree)
-    , mInputNodes(inputLeafNodes.empty() ? NULL : &inputLeafNodes.front())
+    , mInputNodes(inputLeafNodes.empty() ? nullptr : &inputLeafNodes.front())
     , mIntersectionTree(false)
     , mIntersectionAccessor(intersectionTree)
     , mOffsetData()
@@ -3342,8 +3349,7 @@
     const InputTreeType& inputTree,
     typename InputTreeType::ValueType isovalue)
 {
-    typedef typename InputTreeType::LeafNodeType                            InputLeafNodeType;
-    typedef typename InputTreeType::template ValueConverter<bool>::Type     BoolTreeType;
+    using InputLeafNodeType = typename InputTreeType::LeafNodeType;
 
     std::vector<const InputLeafNodeType*> inputLeafNodes;
     inputTree.getNodes(inputLeafNodes);
@@ -3363,11 +3369,11 @@
 template<typename InputTreeType>
 struct MaskIntersectingVoxels
 {
-    typedef typename InputTreeType::LeafNodeType    InputLeafNodeType;
-    typedef typename InputLeafNodeType::ValueType   InputValueType;
+    using InputLeafNodeType = typename InputTreeType::LeafNodeType;
+    using InputValueType = typename InputLeafNodeType::ValueType;
 
-    typedef typename InputTreeType::template ValueConverter<bool>::Type BoolTreeType;
-    typedef typename BoolTreeType::LeafNodeType                         BoolLeafNodeType;
+    using BoolTreeType = typename InputTreeType::template ValueConverter<bool>::Type;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
 
     MaskIntersectingVoxels(
         const InputTreeType& inputTree,
@@ -3399,7 +3405,7 @@
     BoolTreeType& intersectionTree,
     InputValueType iso)
     : mInputAccessor(inputTree)
-    , mNodes(nodes.empty() ? NULL : &nodes.front())
+    , mNodes(nodes.empty() ? nullptr : &nodes.front())
     , mIntersectionTree(false)
     , mIntersectionAccessor(intersectionTree)
     , mIsovalue(iso)
@@ -3462,13 +3468,13 @@
 template<typename BoolTreeType>
 struct MaskBorderVoxels
 {
-    typedef typename BoolTreeType::LeafNodeType BoolLeafNodeType;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
 
     MaskBorderVoxels(const BoolTreeType& maskTree,
         const std::vector<BoolLeafNodeType*>& maskNodes,
         BoolTreeType& borderTree)
         : mMaskTree(&maskTree)
-        , mMaskNodes(maskNodes.empty() ? NULL : &maskNodes.front())
+        , mMaskNodes(maskNodes.empty() ? nullptr : &maskNodes.front())
         , mTmpBorderTree(false)
         , mBorderTree(&borderTree)
     {
@@ -3545,17 +3551,17 @@
 template<typename BoolTreeType>
 struct SyncMaskValues
 {
-    typedef typename BoolTreeType::LeafNodeType BoolLeafNodeType;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
 
     SyncMaskValues(const std::vector<BoolLeafNodeType*>& nodes, const BoolTreeType& mask)
-        : mNodes(nodes.empty() ? NULL : &nodes.front())
+        : mNodes(nodes.empty() ? nullptr : &nodes.front())
         , mMaskTree(&mask)
     {
     }
 
     void operator()(const tbb::blocked_range<size_t>& range) const
     {
-        typedef typename BoolLeafNodeType::ValueOnIter ValueOnIter;
+        using ValueOnIter = typename BoolLeafNodeType::ValueOnIter;
 
         tree::ValueAccessor<const BoolTreeType> maskTreeAcc(*mMaskTree);
 
@@ -3588,11 +3594,11 @@
 template<typename BoolTreeType>
 struct MaskSurface
 {
-    typedef typename BoolTreeType::LeafNodeType BoolLeafNodeType;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
 
     MaskSurface(const std::vector<BoolLeafNodeType*>& nodes, const BoolTreeType& mask,
         const math::Transform& inputTransform, const math::Transform& maskTransform, bool invert)
-        : mNodes(nodes.empty() ? NULL : &nodes.front())
+        : mNodes(nodes.empty() ? nullptr : &nodes.front())
         , mMaskTree(&mask)
         , mInputTransform(inputTransform)
         , mMaskTransform(maskTransform)
@@ -3602,7 +3608,7 @@
 
     void operator()(const tbb::blocked_range<size_t>& range) const
     {
-        typedef typename BoolLeafNodeType::ValueOnIter ValueOnIter;
+        using ValueOnIter = typename BoolLeafNodeType::ValueOnIter;
 
         tree::ValueAccessor<const BoolTreeType> maskTreeAcc(*mMaskTree);
 
@@ -3673,12 +3679,10 @@
     bool invertMask,
     typename InputGridType::ValueType isovalue)
 {
-    typedef typename InputGridType::TreeType                                InputTreeType;
-    typedef typename InputTreeType::LeafNodeType                            InputLeafNodeType;
-
-    typedef typename InputTreeType::template ValueConverter<bool>::Type     BoolTreeType;
-    typedef typename BoolTreeType::LeafNodeType                             BoolLeafNodeType;
-    typedef Grid<BoolTreeType>                                              BoolGridType;
+    using InputTreeType = typename InputGridType::TreeType;
+    using BoolTreeType = typename InputTreeType::template ValueConverter<bool>::Type;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
+    using BoolGridType = Grid<BoolTreeType>;
 
     if (maskGrid && maskGrid->type() == BoolGridType::gridType()) {
 
@@ -3703,7 +3707,8 @@
 
         // mask surface-mask border
 
-        MaskBorderVoxels<BoolTreeType> borderOp(intersectionTree, intersectionLeafNodes, borderTree);
+        MaskBorderVoxels<BoolTreeType> borderOp(
+            intersectionTree, intersectionLeafNodes, borderTree);
         tbb::parallel_reduce(tbb::blocked_range<size_t>(0, intersectionLeafNodes.size()), borderOp);
 
 
@@ -3734,13 +3739,13 @@
 template<typename InputTreeType>
 struct ComputeAuxiliaryData
 {
-    typedef typename InputTreeType::LeafNodeType    InputLeafNodeType;
-    typedef typename InputLeafNodeType::ValueType   InputValueType;
+    using InputLeafNodeType = typename InputTreeType::LeafNodeType;
+    using InputValueType = typename InputLeafNodeType::ValueType;
 
-    typedef tree::LeafNode<bool, InputLeafNodeType::LOG2DIM>    BoolLeafNodeType;
+    using BoolLeafNodeType = tree::LeafNode<bool, InputLeafNodeType::LOG2DIM>;
 
-    typedef typename InputTreeType::template ValueConverter<Int16>::Type    Int16TreeType;
-    typedef typename InputTreeType::template ValueConverter<Index32>::Type  Index32TreeType;
+    using Int16TreeType = typename InputTreeType::template ValueConverter<Int16>::Type;
+    using Index32TreeType = typename InputTreeType::template ValueConverter<Index32>::Type;
 
 
     ComputeAuxiliaryData(const InputTreeType& inputTree,
@@ -3805,11 +3810,11 @@
 void
 ComputeAuxiliaryData<InputTreeType>::operator()(const tbb::blocked_range<size_t>& range)
 {
-    typedef typename Int16TreeType::LeafNodeType    Int16LeafNodeType;
+    using Int16LeafNodeType = typename Int16TreeType::LeafNodeType;
 
     Coord ijk;
     math::Tuple<8, InputValueType> cellVertexValues;
-    typename UniquePtr<Int16LeafNodeType>::type signsNodePt(new Int16LeafNodeType(ijk, 0));
+    typename std::unique_ptr<Int16LeafNodeType> signsNodePt(new Int16LeafNodeType(ijk, 0));
 
     for (size_t n = range.begin(), N = range.end(); n != N; ++n) {
 
@@ -3853,7 +3858,8 @@
 
                 const uint8_t ambiguousCellFlags = sAmbiguousFace[signFlags];
                 if (ambiguousCellFlags != 0) {
-                    correctCellSigns(signFlags, ambiguousCellFlags, mInputAccessor, origin + ijk, mIsovalue);
+                    correctCellSigns(signFlags, ambiguousCellFlags, mInputAccessor,
+                        origin + ijk, mIsovalue);
                 }
 
                 edgeFlags |= int(signFlags);
@@ -3868,7 +3874,7 @@
             idxNode->topologyUnion(*signsNodePt);
 
             // zero fill
-            for (typename Index32TreeType::LeafNodeType::ValueOnIter it = idxNode->beginValueOn(); it; ++it) {
+            for (auto it = idxNode->beginValueOn(); it; ++it) {
                 idxNode->setValueOnly(it.pos(), 0);
             }
 
@@ -3887,8 +3893,8 @@
     const InputTreeType& inputTree,
     typename InputTreeType::ValueType isovalue)
 {
-    typedef typename InputTreeType::template ValueConverter<bool>::Type     BoolTreeType;
-    typedef typename BoolTreeType::LeafNodeType                             BoolLeafNodeType;
+    using BoolTreeType = typename InputTreeType::template ValueConverter<bool>::Type;
+    using BoolLeafNodeType = typename BoolTreeType::LeafNodeType;
 
     std::vector<const BoolLeafNodeType*> intersectionLeafNodes;
     intersectionTree.getNodes(intersectionLeafNodes);
@@ -3906,11 +3912,11 @@
 template<Index32 LeafNodeLog2Dim>
 struct LeafNodePointCount
 {
-    typedef tree::LeafNode<Int16, LeafNodeLog2Dim> Int16LeafNodeType;
+    using Int16LeafNodeType = tree::LeafNode<Int16, LeafNodeLog2Dim>;
 
     LeafNodePointCount(const std::vector<Int16LeafNodeType*>& leafNodes,
         boost::scoped_array<Index32>& leafNodeCount)
-        : mLeafNodes(leafNodes.empty() ? NULL : &leafNodes.front())
+        : mLeafNodes(leafNodes.empty() ? nullptr : &leafNodes.front())
         , mData(leafNodeCount.get())
     {
     }
@@ -3942,20 +3948,20 @@
 template<typename PointIndexLeafNode>
 struct AdaptiveLeafNodePointCount
 {
-    typedef tree::LeafNode<Int16, PointIndexLeafNode::LOG2DIM> Int16LeafNodeType;
+    using Int16LeafNodeType = tree::LeafNode<Int16, PointIndexLeafNode::LOG2DIM>;
 
     AdaptiveLeafNodePointCount(const std::vector<PointIndexLeafNode*>& pointIndexNodes,
         const std::vector<Int16LeafNodeType*>& signDataNodes,
         boost::scoped_array<Index32>& leafNodeCount)
-        : mPointIndexNodes(pointIndexNodes.empty() ? NULL : &pointIndexNodes.front())
-        , mSignDataNodes(signDataNodes.empty() ? NULL : &signDataNodes.front())
+        : mPointIndexNodes(pointIndexNodes.empty() ? nullptr : &pointIndexNodes.front())
+        , mSignDataNodes(signDataNodes.empty() ? nullptr : &signDataNodes.front())
         , mData(leafNodeCount.get())
     {
     }
 
     void operator()(const tbb::blocked_range<size_t>& range) const
     {
-        typedef typename PointIndexLeafNode::ValueType IndexType;
+        using IndexType = typename PointIndexLeafNode::ValueType;
 
         for (size_t n = range.begin(), N = range.end(); n != N; ++n) {
 
@@ -3991,13 +3997,13 @@
 template<typename PointIndexLeafNode>
 struct MapPoints
 {
-    typedef tree::LeafNode<Int16, PointIndexLeafNode::LOG2DIM> Int16LeafNodeType;
+    using Int16LeafNodeType = tree::LeafNode<Int16, PointIndexLeafNode::LOG2DIM>;
 
     MapPoints(const std::vector<PointIndexLeafNode*>& pointIndexNodes,
         const std::vector<Int16LeafNodeType*>& signDataNodes,
         boost::scoped_array<Index32>& leafNodeCount)
-        : mPointIndexNodes(pointIndexNodes.empty() ? NULL : &pointIndexNodes.front())
-        , mSignDataNodes(signDataNodes.empty() ? NULL : &signDataNodes.front())
+        : mPointIndexNodes(pointIndexNodes.empty() ? nullptr : &pointIndexNodes.front())
+        , mSignDataNodes(signDataNodes.empty() ? nullptr : &signDataNodes.front())
         , mData(leafNodeCount.get())
     {
     }
@@ -4011,7 +4017,7 @@
 
             Index32 pointOffset = mData[n];
 
-            for (typename PointIndexLeafNode::ValueOnIter it = indexNode.beginValueOn(); it; ++it) {
+            for (auto it = indexNode.beginValueOn(); it; ++it) {
                 const Index pos = it.pos();
                 indexNode.setValueOnly(pos, pointOffset);
                 const int signs = SIGNS & int(signNode.getValue(pos));
@@ -4032,11 +4038,11 @@
 template<typename TreeType, typename PrimBuilder>
 struct ComputePolygons
 {
-    typedef typename TreeType::template ValueConverter<Int16>::Type   Int16TreeType;
-    typedef typename Int16TreeType::LeafNodeType                      Int16LeafNodeType;
+    using Int16TreeType = typename TreeType::template ValueConverter<Int16>::Type;
+    using Int16LeafNodeType = typename Int16TreeType::LeafNodeType;
 
-    typedef typename TreeType::template ValueConverter<Index32>::Type Index32TreeType;
-    typedef typename Index32TreeType::LeafNodeType                    Index32LeafNodeType;
+    using Index32TreeType = typename TreeType::template ValueConverter<Index32>::Type;
+    using Index32LeafNodeType = typename Index32TreeType::LeafNodeType;
 
 
     ComputePolygons(
@@ -4067,9 +4073,9 @@
     const Index32TreeType& idxTree,
     PolygonPoolList& polygons,
     bool invertSurfaceOrientation)
-    : mSignFlagsLeafNodes(signFlagsLeafNodes.empty() ? NULL : &signFlagsLeafNodes.front())
+    : mSignFlagsLeafNodes(signFlagsLeafNodes.empty() ? nullptr : &signFlagsLeafNodes.front())
     , mSignFlagsTree(&signFlagsTree)
-    , mRefSignFlagsTree(NULL)
+    , mRefSignFlagsTree(nullptr)
     , mIndexTree(&idxTree)
     , mPolygonPoolList(&polygons)
     , mInvertSurfaceOrientation(invertSurfaceOrientation)
@@ -4080,7 +4086,7 @@
 void
 ComputePolygons<InputTreeType, PrimBuilder>::operator()(const tbb::blocked_range<size_t>& range) const
 {
-    typedef tree::ValueAccessor<const Int16TreeType> Int16ValueAccessor;
+    using Int16ValueAccessor = tree::ValueAccessor<const Int16TreeType>;
     Int16ValueAccessor signAcc(*mSignFlagsTree);
 
     tree::ValueAccessor<const Index32TreeType> idxAcc(*mIndexTree);
@@ -4092,7 +4098,7 @@
     Coord ijk, origin;
 
     // reference data
-    boost::scoped_ptr<Int16ValueAccessor> refSignAcc;
+    std::unique_ptr<Int16ValueAccessor> refSignAcc;
     if (mRefSignFlagsTree) refSignAcc.reset(new Int16ValueAccessor(*mRefSignFlagsTree));
 
     for (size_t n = range.begin(); n != range.end(); ++n) {
@@ -4119,7 +4125,7 @@
         if (!signleafPt || !idxLeafPt) continue;
 
 
-        const Int16LeafNodeType *refSignLeafPt = NULL;
+        const Int16LeafNodeType *refSignLeafPt = nullptr;
         if (refSignAcc) refSignLeafPt = refSignAcc->probeConstLeaf(origin);
 
         Vec3i offsets;
@@ -4196,7 +4202,7 @@
         boost::scoped_array<openvdb::Vec3s>& points,
         boost::scoped_array<unsigned>& numQuadsToDivide)
         : mPolygonPoolList(&polygons)
-        , mPointFlags(pointFlags.empty() ? NULL : &pointFlags.front())
+        , mPointFlags(pointFlags.empty() ? nullptr : &pointFlags.front())
         , mPoints(points.get())
         , mNumQuadsToDivide(numQuadsToDivide.get())
     {
@@ -4440,7 +4446,7 @@
     ReviseSeamLineFlags(PolygonPoolList& polygons,
         const std::vector<uint8_t>& pointFlags)
         : mPolygonPoolList(&polygons)
-        , mPointFlags(pointFlags.empty() ? NULL : &pointFlags.front())
+        , mPointFlags(pointFlags.empty() ? nullptr : &pointFlags.front())
     {
     }
 
@@ -4524,7 +4530,7 @@
 
     void operator()(const tbb::blocked_range<size_t>& range) const
     {
-        typedef typename InputTreeType::LeafNodeType::ValueType ValueType;
+        using ValueType = typename InputTreeType::LeafNodeType::ValueType;
 
         tree::ValueAccessor<const InputTreeType> inputAcc(*mInputTree);
         Vec3s centroid, normal;
@@ -4667,10 +4673,10 @@
 PolygonPool::PolygonPool()
     : mNumQuads(0)
     , mNumTriangles(0)
-    , mQuads(NULL)
-    , mTriangles(NULL)
-    , mQuadFlags(NULL)
-    , mTriangleFlags(NULL)
+    , mQuads(nullptr)
+    , mTriangles(nullptr)
+    , mQuadFlags(nullptr)
+    , mTriangleFlags(nullptr)
 {
 }
 
@@ -4718,8 +4724,8 @@
 PolygonPool::clearQuads()
 {
     mNumQuads = 0;
-    mQuads.reset(NULL);
-    mQuadFlags.reset(NULL);
+    mQuads.reset(nullptr);
+    mQuadFlags.reset(nullptr);
 }
 
 
@@ -4736,8 +4742,8 @@
 PolygonPool::clearTriangles()
 {
     mNumTriangles = 0;
-    mTriangles.reset(NULL);
-    mTriangleFlags.reset(NULL);
+    mTriangles.reset(nullptr);
+    mTriangleFlags.reset(nullptr);
 }
 
 
@@ -4749,7 +4755,7 @@
     if (reallocate) {
 
         if (n == 0) {
-            mQuads.reset(NULL);
+            mQuads.reset(nullptr);
         } else {
 
             boost::scoped_array<openvdb::Vec4I> quads(new openvdb::Vec4I[n]);
@@ -4778,7 +4784,7 @@
     if (reallocate) {
 
         if (n == 0) {
-            mTriangles.reset(NULL);
+            mTriangles.reset(nullptr);
         } else {
 
             boost::scoped_array<openvdb::Vec3I> triangles(new openvdb::Vec3I[n]);
@@ -4802,8 +4808,9 @@
 ////////////////////////////////////////
 
 
-inline VolumeToMesh::VolumeToMesh(double isovalue, double adaptivity, bool relaxDisorientedTriangles)
-    : mPoints(NULL)
+inline
+VolumeToMesh::VolumeToMesh(double isovalue, double adaptivity, bool relaxDisorientedTriangles)
+    : mPoints(nullptr)
     , mPolygons()
     , mPointListSize(0)
     , mSeamPointListSize(0)
@@ -4819,7 +4826,7 @@
     , mRefIdxTree(TreeBase::Ptr())
     , mInvertSurfaceMask(false)
     , mRelaxDisorientedTriangles(relaxDisorientedTriangles)
-    , mQuantizedSeamPoints(NULL)
+    , mQuantizedSeamPoints(nullptr)
     , mPointFlags(0)
 {
 }
@@ -4870,7 +4877,7 @@
     mRefSignTree = TreeBase::Ptr();
     mRefIdxTree = TreeBase::Ptr();
     mSeamPointListSize = 0;
-    mQuantizedSeamPoints.reset(NULL);
+    mQuantizedSeamPoints.reset(nullptr);
 }
 
 
@@ -4916,36 +4923,27 @@
 {
     // input data types
 
-    typedef typename InputGridType::TreeType        InputTreeType;
-    typedef typename InputTreeType::LeafNodeType    InputLeafNodeType;
-    typedef typename InputLeafNodeType::ValueType   InputValueType;
-
+    using InputTreeType = typename InputGridType::TreeType;
+    using InputLeafNodeType = typename InputTreeType::LeafNodeType;
+    using InputValueType = typename InputLeafNodeType::ValueType;
 
     // auxiliary data types
 
-    typedef typename InputTreeType::template ValueConverter<float>::Type    FloatTreeType;
-    typedef Grid<FloatTreeType>                                             FloatGridType;
-
-    typedef typename InputTreeType::template ValueConverter<bool>::Type     BoolTreeType;
-    typedef typename BoolTreeType::LeafNodeType                             BoolLeafNodeType;
-    typedef Grid<BoolTreeType>                                              BoolGridType;
-
-    typedef typename InputTreeType::template ValueConverter<Int16>::Type    Int16TreeType;
-    typedef typename Int16TreeType::LeafNodeType                            Int16LeafNodeType;
-
-    typedef typename InputTreeType::template ValueConverter<Index32>::Type  Index32TreeType;
-    typedef typename Index32TreeType::LeafNodeType                          Index32LeafNodeType;
-
+    using FloatTreeType = typename InputTreeType::template ValueConverter<float>::Type;
+    using FloatGridType = Grid<FloatTreeType>;
+    using BoolTreeType = typename InputTreeType::template ValueConverter<bool>::Type;
+    using Int16TreeType = typename InputTreeType::template ValueConverter<Int16>::Type;
+    using Int16LeafNodeType = typename Int16TreeType::LeafNodeType;
+    using Index32TreeType = typename InputTreeType::template ValueConverter<Index32>::Type;
+    using Index32LeafNodeType = typename Index32TreeType::LeafNodeType;
 
     // clear old data
-
     mPointListSize = 0;
     mPoints.reset();
     mPolygonPoolListSize = 0;
     mPolygons.reset();
     mPointFlags.clear();
 
-
     // settings
 
     const math::Transform& transform = inputGrid.transform();
@@ -4957,9 +4955,8 @@
     // Boolean grids are handled correctly by their value type.  Signed distance fields,
     // unsigned distance fields and fog volumes have the same value type but use different
     // inside value classifications.
-    const bool invertSurfaceOrientation = !volume_to_mesh_internal::isBoolValue<InputValueType>() &&
-        inputGrid.getGridClass() != openvdb::GRID_LEVEL_SET;
-
+    const bool invertSurfaceOrientation = (!volume_to_mesh_internal::isBoolValue<InputValueType>()
+        && (inputGrid.getGridClass() != openvdb::GRID_LEVEL_SET));
 
     // references, masks and auxiliary data
 
@@ -4982,8 +4979,8 @@
     volume_to_mesh_internal::identifySurfaceIntersectingVoxels(
         intersectionTree, inputTree, isovalue);
 
-    volume_to_mesh_internal::applySurfaceMask(
-        intersectionTree, adaptivityMask, inputGrid, mSurfaceMaskGrid, mInvertSurfaceMask, isovalue);
+    volume_to_mesh_internal::applySurfaceMask(intersectionTree, adaptivityMask,
+        inputGrid, mSurfaceMaskGrid, mInvertSurfaceMask, isovalue);
 
     if (intersectionTree.empty()) return;
 
@@ -5003,9 +5000,9 @@
 
     // optionally collect auxiliary data from a reference volume.
 
-    Int16TreeType * refSignFlagsTree = NULL;
-    Index32TreeType * refPointIndexTree = NULL;
-    InputTreeType const * refInputTree = NULL;
+    Int16TreeType* refSignFlagsTree = nullptr;
+    Index32TreeType* refPointIndexTree = nullptr;
+    InputTreeType const* refInputTree = nullptr;
 
     if (mRefGrid && mRefGrid->type() == InputGridType::gridType()) {
 
@@ -5054,7 +5051,8 @@
                 std::vector<Int16LeafNodeType*> refSignFlagsLeafNodes;
                 refSignFlagsTree->getNodes(refSignFlagsLeafNodes);
 
-                boost::scoped_array<Index32> leafNodeOffsets(new Index32[refSignFlagsLeafNodes.size()]);
+                boost::scoped_array<Index32> leafNodeOffsets(
+                    new Index32[refSignFlagsLeafNodes.size()]);
 
                 tbb::parallel_for(tbb::blocked_range<size_t>(0, refSignFlagsLeafNodes.size()),
                     volume_to_mesh_internal::LeafNodePointCount<Int16LeafNodeType::LOG2DIM>(
@@ -5103,12 +5101,13 @@
     boost::scoped_array<Index32> leafNodeOffsets(new Index32[signFlagsLeafNodes.size()]);
 
     if (adaptive) {
-
-        volume_to_mesh_internal::MergeVoxelRegions<InputGridType> mergeOp(inputGrid, pointIndexTree,
-            pointIndexLeafNodes, signFlagsLeafNodes, isovalue, adaptivityThreshold, invertSurfaceOrientation);
+        volume_to_mesh_internal::MergeVoxelRegions<InputGridType> mergeOp(
+            inputGrid, pointIndexTree, pointIndexLeafNodes, signFlagsLeafNodes,
+            isovalue, adaptivityThreshold, invertSurfaceOrientation);
 
         if (mAdaptivityGrid && mAdaptivityGrid->type() == FloatGridType::gridType()) {
-            const FloatGridType * adaptivityGrid = static_cast<const FloatGridType*>(mAdaptivityGrid.get());
+            const FloatGridType* adaptivityGrid =
+                static_cast<const FloatGridType*>(mAdaptivityGrid.get());
             mergeOp.setSpatialAdaptivity(*adaptivityGrid);
         }
 
@@ -5174,10 +5173,11 @@
 
     if (adaptive) {
 
-        typedef volume_to_mesh_internal::AdaptivePrimBuilder PrimBuilder;
+        using PrimBuilder = volume_to_mesh_internal::AdaptivePrimBuilder;
 
         volume_to_mesh_internal::ComputePolygons<Int16TreeType, PrimBuilder>
-            op(signFlagsLeafNodes, signFlagsTree, pointIndexTree, mPolygons, invertSurfaceOrientation);
+            op(signFlagsLeafNodes, signFlagsTree, pointIndexTree,
+                mPolygons, invertSurfaceOrientation);
 
         if (referenceMeshing) {
             op.setRefSignTree(refSignFlagsTree);
@@ -5187,10 +5187,11 @@
 
     } else {
 
-        typedef volume_to_mesh_internal::UniformPrimBuilder PrimBuilder;
+        using PrimBuilder = volume_to_mesh_internal::UniformPrimBuilder;
 
         volume_to_mesh_internal::ComputePolygons<Int16TreeType, PrimBuilder>
-            op(signFlagsLeafNodes, signFlagsTree, pointIndexTree, mPolygons, invertSurfaceOrientation);
+            op(signFlagsLeafNodes, signFlagsTree, pointIndexTree,
+                mPolygons, invertSurfaceOrientation);
 
         if (referenceMeshing) {
             op.setRefSignTree(refSignFlagsTree);
@@ -5225,7 +5226,7 @@
 
 /// @internal This overload is enabled only for grids with a scalar ValueType.
 template<typename GridType>
-inline typename boost::enable_if<boost::is_scalar<typename GridType::ValueType>, void>::type
+inline typename std::enable_if<std::is_scalar<typename GridType::ValueType>::value, void>::type
 doVolumeToMesh(
     const GridType& grid,
     std::vector<Vec3s>& points,
@@ -5245,7 +5246,7 @@
     { // Copy points
         volume_to_mesh_internal::PointListCopy ptnCpy(mesher.pointList(), points);
         tbb::parallel_for(tbb::blocked_range<size_t>(0, points.size()), ptnCpy);
-        mesher.pointList().reset(NULL);
+        mesher.pointList().reset(nullptr);
     }
 
     PolygonPoolList& polygonPoolList = mesher.polygonPoolList();
@@ -5281,7 +5282,7 @@
 
 /// @internal This overload is enabled only for grids that do not have a scalar ValueType.
 template<typename GridType>
-inline typename boost::disable_if<boost::is_scalar<typename GridType::ValueType>, void>::type
+inline typename std::enable_if<!std::is_scalar<typename GridType::ValueType>::value, void>::type
 doVolumeToMesh(
     const GridType&,
     std::vector<Vec3s>&,
@@ -5322,10 +5323,6 @@
     doVolumeToMesh(grid, points, triangles, quads, isovalue, 0.0, true);
 }
 
-
-////////////////////////////////////////
-
-
 } // namespace tools
 } // namespace OPENVDB_VERSION_NAME
 } // namespace openvdb
diff -aur openvdb.3.2.0/tools/VolumeToSpheres.h openvdb.4.0.0/tools/VolumeToSpheres.h
--- openvdb.3.2.0/tools/VolumeToSpheres.h	2016-05-22 09:09:48.000000000 +0200
+++ openvdb.4.0.0/tools/VolumeToSpheres.h	2016-10-09 10:18:58.000000000 +0200
@@ -97,7 +97,7 @@
     float maxRadius = std::numeric_limits<float>::max(),
     float isovalue = 0.0,
     int instanceCount = 10000,
-    InterrupterT* interrupter = NULL);
+    InterrupterT* interrupter = nullptr);
 
 
 /// @brief  @c fillWithSpheres method variant that automatically infers
@@ -150,7 +150,7 @@
     /// @param interrupter      a pointer adhering to the util::NullInterrupter interface.
     ///
     template<typename InterrupterT>
-    void initialize(const GridT& grid, float isovalue = 0.0, InterrupterT* interrupter = NULL);
+    void initialize(const GridT& grid, float isovalue = 0.0, InterrupterT* interrupter = nullptr);
 
 
     /// @brief  @c initialize method variant that automatically infers
@@ -722,7 +722,6 @@
     typedef typename GridT::ValueType ValueT;
 
     typedef typename TreeT::template ValueConverter<bool>::Type     BoolTreeT;
-    typedef typename TreeT::template ValueConverter<Index32>::Type  Index32TreeT;
     typedef typename TreeT::template ValueConverter<Int16>::Type    Int16TreeT;
 
     typedef boost::mt11213b RandGen;
@@ -752,7 +751,7 @@
         internal::PointAccessor ptnAcc(instancePoints);
 
         UniformPointScatter<internal::PointAccessor, RandGen, InterrupterT> scatter(
-            ptnAcc, Index64(addNBPoints ? (instances / 2) : instances), mtRand, interrupter);
+            ptnAcc, Index64(addNBPoints ? (instances / 2) : instances), mtRand, 1.0, interrupter);
 
         scatter(*interiorMaskPtr);
     }
@@ -774,7 +773,9 @@
             for (it = leafIt->cbeginValueOn(); it; ++it) {
 
                 const int flags = int(it.getValue());
-                if (!(volume_to_mesh_internal::EDGES & flags) && (volume_to_mesh_internal::INSIDE & flags)) {
+                if (!(volume_to_mesh_internal::EDGES & flags)
+                    && (volume_to_mesh_internal::INSIDE & flags))
+                {
                     instancePoints.push_back(transform.indexToWorld(it.getCoord()));
                 }
 
@@ -852,7 +853,7 @@
 void
 ClosestSurfacePoint<GridT>::initialize(const GridT& grid, float isovalue)
 {
-    initialize<GridT, util::NullInterrupter>(grid, isovalue, NULL);
+    initialize<GridT, util::NullInterrupter>(grid, isovalue, nullptr);
 }
 
 
@@ -863,10 +864,8 @@
     const GridT& grid, float isovalue, InterrupterT* interrupter)
 {
     mIsInitialized = false;
-    typedef tree::LeafManager<const TreeT>      LeafManagerT;
-    typedef tree::LeafManager<Index32TreeT>     Index32LeafManagerT;
-    typedef tree::LeafManager<Int16TreeT>       Int16LeafManagerT;
-    typedef typename GridT::ValueType ValueT;
+    typedef tree::LeafManager<Index32TreeT> Index32LeafManagerT;
+    typedef typename GridT::ValueType       ValueT;
 
     const TreeT& tree = grid.tree();
     const math::Transform& transform = grid.transform();
@@ -878,7 +877,8 @@
 
         BoolTreeT mask(false);
         volume_to_mesh_internal::identifySurfaceIntersectingVoxels(mask, tree, ValueT(isovalue));
-        volume_to_mesh_internal::computeAuxiliaryData(*mSignTreePt, *mIdxTreePt, mask, tree, ValueT(isovalue));
+        volume_to_mesh_internal::computeAuxiliaryData(
+            *mSignTreePt, *mIdxTreePt, mask, tree, ValueT(isovalue));
 
         if (interrupter && interrupter->wasInterrupted()) return;
 
@@ -914,9 +914,9 @@
         std::vector<Index32LeafNodeType*> pointIndexLeafNodes;
         mIdxTreePt->getNodes(pointIndexLeafNodes);
 
-        tbb::parallel_for(auxiliaryLeafNodeRange,
-            volume_to_mesh_internal::ComputePoints<TreeT>(mSurfacePointList.get(), tree, pointIndexLeafNodes,
-                signFlagsLeafNodes, leafNodeOffsets, transform, ValueT(isovalue)));
+        tbb::parallel_for(auxiliaryLeafNodeRange, volume_to_mesh_internal::ComputePoints<TreeT>(
+            mSurfacePointList.get(), tree, pointIndexLeafNodes,
+            signFlagsLeafNodes, leafNodeOffsets, transform, ValueT(isovalue)));
     }
 
     if (interrupter && interrupter->wasInterrupted()) return;
@@ -941,7 +941,8 @@
     typedef typename Index32TreeT::RootNodeType Index32RootNodeT;
     typedef typename Index32RootNodeT::NodeChainType Index32NodeChainT;
     BOOST_STATIC_ASSERT(boost::mpl::size<Index32NodeChainT>::value > 1);
-    typedef typename boost::mpl::at<Index32NodeChainT, boost::mpl::int_<1> >::type Index32InternalNodeT;
+    typedef typename boost::mpl::at<Index32NodeChainT, boost::mpl::int_<1> >::type
+        Index32InternalNodeT;
 
     typename Index32TreeT::NodeCIter nIt = mIdxTreePt->cbeginNode();
     nIt.setMinDepth(Index32TreeT::NodeCIter::LEAF_DEPTH - 1);
@@ -949,7 +950,7 @@
 
     std::vector<const Index32InternalNodeT*> internalNodes;
 
-    const Index32InternalNodeT* node = NULL;
+    const Index32InternalNodeT* node = nullptr;
     for (; nIt; ++nIt) {
         nIt.getNode(node);
         if (node) internalNodes.push_back(node);
diff -aur openvdb.3.2.0/tree/Iterator.h openvdb.4.0.0/tree/Iterator.h
--- openvdb.3.2.0/tree/Iterator.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tree/Iterator.h	2016-10-09 10:18:58.000000000 +0200
@@ -58,15 +58,10 @@
 class IteratorBase
 {
 public:
-    IteratorBase(): mParentNode(NULL) {}
-    IteratorBase(const MaskIterT& iter, NodeT* parent):
-        mParentNode(parent), mMaskIter(iter) {}
-
-    void operator=(const IteratorBase& other)
-    {
-        mParentNode = other.mParentNode;
-        mMaskIter = other.mMaskIter;
-    }
+    IteratorBase(): mParentNode(nullptr) {}
+    IteratorBase(const MaskIterT& iter, NodeT* parent): mParentNode(parent), mMaskIter(iter) {}
+    IteratorBase(const IteratorBase&) = default;
+    IteratorBase& operator=(const IteratorBase&) = default;
 
     bool operator==(const IteratorBase& other) const
     {
@@ -238,10 +233,10 @@
     bool isChildNode() const { return this->parent().isChildMaskOn(this->pos()); }
 
     /// @brief If this iterator is pointing to a child node, return a pointer to the node.
-    /// Otherwise, return NULL and, in @a value, the value to which this iterator is pointing.
+    /// Otherwise, return nullptr and, in @a value, the value to which this iterator is pointing.
     SetItemT* probeChild(NonConstValueType& value) const
     {
-        SetItemT* child = NULL;
+        SetItemT* child = nullptr;
         static_cast<const IterT*>(this)->getItem(this->pos(), child, value); // static polymorphism
         return child;
     }
@@ -251,14 +246,14 @@
     bool probeChild(SetItemT*& child, NonConstValueType& value) const
     {
         child = probeChild(value);
-        return (child != NULL);
+        return (child != nullptr);
     }
 
     /// @brief Return @c true if this iterator is pointing to a value and return
     /// the value in @a value.  Otherwise, return @c false.
     bool probeValue(NonConstValueType& value) const
     {
-        SetItemT* child = NULL;
+        SetItemT* child = nullptr;
         const bool isChild = static_cast<const IterT*>(this)-> // static polymorphism
             getItem(this->pos(), child, value);
         return !isChild;
diff -aur openvdb.3.2.0/tree/LeafManager.h openvdb.4.0.0/tree/LeafManager.h
--- openvdb.3.2.0/tree/LeafManager.h	2016-04-24 10:39:49.000000000 +0200
+++ openvdb.4.0.0/tree/LeafManager.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file LeafManager.h
 ///
 /// @brief A LeafManager manages a linear array of pointers to a given tree's
@@ -139,10 +139,8 @@
             {
                 assert(this->isValid());
             }
-            Iterator& operator=(const Iterator& other)
-            {
-                mRange = other.mRange; mPos = other.mPos; return *this;
-            }
+            Iterator(const Iterator&) = default;
+            Iterator& operator=(const Iterator&) = default;
             /// Advance to the next leaf node.
             Iterator& operator++() { ++mPos; return *this; }
             /// Return a reference to the leaf node to which this iterator is pointing.
@@ -227,8 +225,8 @@
         , mLeafCount(0)
         , mAuxBufferCount(0)
         , mAuxBuffersPerLeaf(auxBuffersPerLeaf)
-        , mLeafs(NULL)
-        , mAuxBuffers(NULL)
+        , mLeafs(nullptr)
+        , mAuxBuffers(nullptr)
         , mTask(0)
         , mIsMaster(true)
     {
@@ -245,7 +243,7 @@
         , mAuxBufferCount(0)
         , mAuxBuffersPerLeaf(auxBuffersPerLeaf)
         , mLeafs(new LeafType*[mLeafCount])
-        , mAuxBuffers(NULL)
+        , mAuxBuffers(nullptr)
         , mTask(0)
         , mIsMaster(true)
     {
@@ -611,29 +609,27 @@
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
     }
 
-    /// @brief Generate a linear array of pre-fix sums of offsets into the
+    /// @brief Generate a linear array of prefix sums of offsets into the
     /// active voxels in the leafs. So @a offsets[n]+m is the offset to the
     /// mth active voxel in the nth leaf node (useful for
     /// user-managed value buffers, e.g. in tools/LevelSetAdvect.h).
     /// @return The total number of active values in the leaf nodes
-    /// @param offsets Array of pre-fix sums of offsets to active voxels
-    /// @param size      On input the size of @a offsets, and on ouput
-    ///                  the new size of @a offsets.
-    /// @param grainSize Optional parameter to specify the grainsize
-    ///                  for threading, one by default.
-    /// @details If @a offsets is NULL or @a size is smaller than the
+    /// @param offsets    array of prefix sums of offsets to active voxels
+    /// @param size       on input, the size of @a offsets; on output, its new size
+    /// @param grainSize  optional grain size for threading
+    /// @details If @a offsets is @c nullptr or @a size is smaller than the
     /// total number of active voxels (the return value) then @a offsets
-    /// is re-allocated and @a size equals the total number of active voxels.
-    size_t getPreFixSum(size_t*& offsets, size_t& size, size_t grainSize=1) const
+    /// is reallocated and @a size equals the total number of active voxels.
+    size_t getPrefixSum(size_t*& offsets, size_t& size, size_t grainSize=1) const
     {
-        if (offsets == NULL || size < mLeafCount) {
+        if (offsets == nullptr || size < mLeafCount) {
             delete [] offsets;
             offsets = new size_t[mLeafCount];
             size = mLeafCount;
         }
         size_t prefix = 0;
         if ( grainSize > 0 ) {
-            PreFixSum tmp(this->leafRange( grainSize ), offsets, prefix);
+            PrefixSum tmp(this->leafRange( grainSize ), offsets, prefix);
         } else {// serial
             for (size_t i=0; i<mLeafCount; ++i) {
                 offsets[i] = prefix;
@@ -670,7 +666,7 @@
         const size_t leafCount = mTree->leafCount();
         if (leafCount != mLeafCount) {
             delete [] mLeafs;
-            mLeafs = (leafCount == 0) ? NULL : new LeafType*[leafCount];
+            mLeafs = (leafCount == 0) ? nullptr : new LeafType*[leafCount];
             mLeafCount = leafCount;
         }
         MyArray a(mLeafs);
@@ -682,7 +678,7 @@
         const size_t auxBufferCount = mLeafCount * mAuxBuffersPerLeaf;
         if (auxBufferCount != mAuxBufferCount) {
             delete [] mAuxBuffers;
-            mAuxBuffers = (auxBufferCount == 0) ? NULL : new NonConstBufferType[auxBufferCount];
+            mAuxBuffers = (auxBufferCount == 0) ? nullptr : new NonConstBufferType[auxBufferCount];
             mAuxBufferCount = auxBufferCount;
         }
         this->syncAllBuffers(serial);
@@ -787,10 +783,10 @@
         const bool mOwnsOp;
     };// LeafReducer
 
-    // Helper class to compute a pre-fix sum of offsets to active voxels
-    struct PreFixSum
+    // Helper class to compute a prefix sum of offsets to active voxels
+    struct PrefixSum
     {
-        PreFixSum(const LeafRange& r, size_t* offsets, size_t& prefix)
+        PrefixSum(const LeafRange& r, size_t* offsets, size_t& prefix)
             : mOffsets(offsets)
         {
             tbb::parallel_for( r, *this);
@@ -806,7 +802,7 @@
             }
         }
         size_t* mOffsets;
-    };// PreFixSum
+    };// PrefixSum
 
     typedef typename boost::function<void (LeafManager*, const RangeType&)> FuncType;
 
diff -aur openvdb.3.2.0/tree/LeafNodeBool.h openvdb.4.0.0/tree/LeafNodeBool.h
--- openvdb.3.2.0/tree/LeafNodeBool.h	2016-04-24 10:39:49.000000000 +0200
+++ openvdb.4.0.0/tree/LeafNodeBool.h	2016-10-09 10:18:58.000000000 +0200
@@ -31,16 +31,15 @@
 #ifndef OPENVDB_TREE_LEAF_NODE_BOOL_HAS_BEEN_INCLUDED
 #define OPENVDB_TREE_LEAF_NODE_BOOL_HAS_BEEN_INCLUDED
 
-#include <iostream>
-#include <boost/shared_ptr.hpp>
-#include <boost/shared_array.hpp>
-#include <boost/static_assert.hpp>
 #include <openvdb/Types.h>
 #include <openvdb/io/Compression.h> // for io::readData(), etc.
 #include <openvdb/math/Math.h> // for math::isZero()
 #include <openvdb/util/NodeMasks.h>
 #include "LeafNode.h"
 #include "Iterator.h"
+#include <boost/shared_array.hpp>
+#include <iostream>
+#include <type_traits>
 
 
 namespace openvdb {
@@ -54,11 +53,11 @@
 class LeafNode<bool, Log2Dim>
 {
 public:
-    typedef LeafNode<bool, Log2Dim>         LeafNodeType;
-    typedef boost::shared_ptr<LeafNodeType> Ptr;
-    typedef bool                            BuildType; 
-    typedef bool                            ValueType;
-    typedef util::NodeMask<Log2Dim>         NodeMaskType;
+    using LeafNodeType = LeafNode<bool, Log2Dim>;
+    using BuildType = bool;
+    using ValueType = bool;
+    using NodeMaskType = util::NodeMask<Log2Dim>;
+    using Ptr = SharedPtr<LeafNodeType>;
 
     // These static declarations must be on separate lines to avoid VC9 compiler errors.
     static const Index LOG2DIM    = Log2Dim;    // needed by parent nodes
@@ -72,7 +71,7 @@
     /// @brief ValueConverter<T>::Type is the type of a LeafNode having the same
     /// dimensions as this node but a different value type, T.
     template<typename ValueType>
-    struct ValueConverter { typedef LeafNode<ValueType, Log2Dim> Type; };
+    struct ValueConverter { using Type = LeafNode<ValueType, Log2Dim>; };
 
     /// @brief SameConfiguration<OtherNodeType>::value is @c true if and only if
     /// OtherNodeType is the type of a LeafNode with the same dimensions as this node.
@@ -85,7 +84,7 @@
     class Buffer
     {
     public:
-        typedef typename NodeMaskType::Word WordType;
+        using WordType = typename NodeMaskType::Word;
         static const Index WORD_COUNT = NodeMaskType::WORD_COUNT;
         Buffer() {}
         Buffer(bool on) : mData(on) {}
@@ -156,6 +155,9 @@
     /// Deep copy constructor
     LeafNode(const LeafNode&);
 
+    /// Deep assignment operator
+    LeafNode& operator=(const LeafNode&) = default;
+
     /// Value conversion copy constructor
     template<typename OtherValueType>
     explicit LeafNode(const LeafNode<OtherValueType, Log2Dim>& other);
@@ -570,11 +572,11 @@
     template<typename AccessorT>
     void addLeafAndCache(LeafNode*, AccessorT&) {}
     template<typename NodeT>
-    NodeT* stealNode(const Coord&, const ValueType&, bool) { return NULL; }
+    NodeT* stealNode(const Coord&, const ValueType&, bool) { return nullptr; }
     template<typename NodeT>
-    NodeT* probeNode(const Coord&) { return NULL; }
+    NodeT* probeNode(const Coord&) { return nullptr; }
     template<typename NodeT>
-    const NodeT* probeConstNode(const Coord&) const { return NULL; }
+    const NodeT* probeConstNode(const Coord&) const { return nullptr; }
     template<typename ArrayT> void getNodes(ArrayT&) const {}
     template<typename ArrayT> void stealNodes(ArrayT&, const ValueType&, bool) {}
     //@}
@@ -596,7 +598,7 @@
     NodeT* probeNodeAndCache(const Coord&, AccessorT&)
     {
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN
-        if (!(boost::is_same<NodeT,LeafNode>::value)) return NULL;
+        if (!(std::is_same<NodeT, LeafNode>::value)) return nullptr;
         return reinterpret_cast<NodeT*>(this);
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
     }
@@ -613,7 +615,7 @@
     const NodeT* probeConstNodeAndCache(const Coord&, AccessorT&) const
     {
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN
-        if (!(boost::is_same<NodeT,LeafNode>::value)) return NULL;
+        if (!(std::is_same<NodeT, LeafNode>::value)) return nullptr;
         return reinterpret_cast<const NodeT*>(this);
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
     }
@@ -623,9 +625,9 @@
     // Iterators
     //
 protected:
-    typedef typename NodeMaskType::OnIterator    MaskOnIter;
-    typedef typename NodeMaskType::OffIterator   MaskOffIter;
-    typedef typename NodeMaskType::DenseIterator MaskDenseIter;
+    using MaskOnIter = typename NodeMaskType::OnIterator;
+    using MaskOffIter = typename NodeMaskType::OffIterator;
+    using MaskDenseIter = typename NodeMaskType::DenseIterator;
 
     template<typename MaskIterT, typename NodeT, typename ValueT>
     struct ValueIter:
@@ -633,7 +635,7 @@
         // if MaskIterT is a dense mask iterator type.
         public SparseIteratorBase<MaskIterT, ValueIter<MaskIterT, NodeT, ValueT>, NodeT, ValueT>
     {
-        typedef SparseIteratorBase<MaskIterT, ValueIter, NodeT, ValueT> BaseT;
+        using BaseT = SparseIteratorBase<MaskIterT, ValueIter, NodeT, ValueT>;
 
         ValueIter() {}
         ValueIter(const MaskIterT& iter, NodeT* parent): BaseT(iter, parent) {}
@@ -668,8 +670,8 @@
     struct DenseIter: public DenseIteratorBase<
         MaskDenseIter, DenseIter<NodeT, ValueT>, NodeT, /*ChildT=*/void, ValueT>
     {
-        typedef DenseIteratorBase<MaskDenseIter, DenseIter, NodeT, void, ValueT> BaseT;
-        typedef typename BaseT::NonConstValueType NonConstValueT;
+        using BaseT = DenseIteratorBase<MaskDenseIter, DenseIter, NodeT, void, ValueT>;
+        using NonConstValueT = typename BaseT::NonConstValueType;
 
         DenseIter() {}
         DenseIter(const MaskDenseIter& iter, NodeT* parent): BaseT(iter, parent) {}
@@ -677,7 +679,7 @@
         bool getItem(Index pos, void*& child, NonConstValueT& value) const
         {
             value = this->parent().getValue(pos);
-            child = NULL;
+            child = nullptr;
             return false; // no child
         }
 
@@ -689,18 +691,18 @@
     };
 
 public:
-    typedef ValueIter<MaskOnIter, LeafNode, const bool>           ValueOnIter;
-    typedef ValueIter<MaskOnIter, const LeafNode, const bool>     ValueOnCIter;
-    typedef ValueIter<MaskOffIter, LeafNode, const bool>          ValueOffIter;
-    typedef ValueIter<MaskOffIter, const LeafNode, const bool>    ValueOffCIter;
-    typedef ValueIter<MaskDenseIter, LeafNode, const bool>        ValueAllIter;
-    typedef ValueIter<MaskDenseIter, const LeafNode, const bool>  ValueAllCIter;
-    typedef ChildIter<MaskOnIter, LeafNode>                       ChildOnIter;
-    typedef ChildIter<MaskOnIter, const LeafNode>                 ChildOnCIter;
-    typedef ChildIter<MaskOffIter, LeafNode>                      ChildOffIter;
-    typedef ChildIter<MaskOffIter, const LeafNode>                ChildOffCIter;
-    typedef DenseIter<LeafNode, bool>                             ChildAllIter;
-    typedef DenseIter<const LeafNode, const bool>                 ChildAllCIter;
+    using ValueOnIter = ValueIter<MaskOnIter, LeafNode, const bool>;
+    using ValueOnCIter = ValueIter<MaskOnIter, const LeafNode, const bool>;
+    using ValueOffIter = ValueIter<MaskOffIter, LeafNode, const bool>;
+    using ValueOffCIter = ValueIter<MaskOffIter, const LeafNode, const bool>;
+    using ValueAllIter = ValueIter<MaskDenseIter, LeafNode, const bool>;
+    using ValueAllCIter = ValueIter<MaskDenseIter, const LeafNode, const bool>;
+    using ChildOnIter = ChildIter<MaskOnIter, LeafNode>;
+    using ChildOnCIter = ChildIter<MaskOnIter, const LeafNode>;
+    using ChildOffIter = ChildIter<MaskOffIter, LeafNode>;
+    using ChildOffCIter = ChildIter<MaskOffIter, const LeafNode>;
+    using ChildAllIter = DenseIter<LeafNode, bool>;
+    using ChildAllCIter = DenseIter<const LeafNode, const bool>;
 
     ValueOnCIter  cbeginValueOn() const { return ValueOnCIter(mValueMask.beginOn(), this); }
     ValueOnCIter   beginValueOn() const { return ValueOnCIter(mValueMask.beginOn(), this); }
@@ -1134,10 +1136,10 @@
 LeafNode<bool, Log2Dim>::isConstant(bool& constValue, bool& state, bool tolerance) const
 {
     if (!mValueMask.isConstant(state)) return false;
-    
+
     // Note: if tolerance is true (i.e., 1), then all boolean values compare equal.
     if (!tolerance && !(mBuffer.mData.isOn() || mBuffer.mData.isOff())) return false;
-    
+
     constValue = mBuffer.mData.isOn();
     return true;
 }
@@ -1458,7 +1460,7 @@
 inline void
 LeafNode<bool, Log2Dim>::copyToDense(const CoordBBox& bbox, DenseT& dense) const
 {
-    typedef typename DenseT::ValueType DenseValueType;
+    using DenseValueType = typename DenseT::ValueType;
 
     const size_t xStride = dense.xStride(), yStride = dense.yStride(), zStride = dense.zStride();
     const Coord& min = dense.bbox().min();
@@ -1484,7 +1486,7 @@
 LeafNode<bool, Log2Dim>::copyFromDense(const CoordBBox& bbox, const DenseT& dense,
                                        bool background, bool tolerance)
 {
-    typedef typename DenseT::ValueType DenseValueType;
+    using DenseValueType = typename DenseT::ValueType;
     struct Local {
         inline static bool toBool(const DenseValueType& v) { return !math::isZero(v); }
     };
@@ -1705,8 +1707,10 @@
 LeafNode<bool, Log2Dim>::doVisit2Node(NodeT& self, OtherNodeT& other, VisitorOp& op)
 {
     // Allow the two nodes to have different ValueTypes, but not different dimensions.
-    BOOST_STATIC_ASSERT(OtherNodeT::SIZE == NodeT::SIZE);
-    BOOST_STATIC_ASSERT(OtherNodeT::LEVEL == NodeT::LEVEL);
+    static_assert(OtherNodeT::SIZE == NodeT::SIZE,
+        "can't visit nodes of different sizes simultaneously");
+    static_assert(OtherNodeT::LEVEL == NodeT::LEVEL,
+        "can't visit nodes at different tree levels simultaneously");
 
     ChildAllIterT iter = self.beginChildAll();
     OtherChildAllIterT otherIter = other.beginChildAll();
diff -aur openvdb.3.2.0/tree/LeafNode.h openvdb.4.0.0/tree/LeafNode.h
--- openvdb.3.2.0/tree/LeafNode.h	2016-05-22 09:09:48.000000000 +0200
+++ openvdb.4.0.0/tree/LeafNode.h	2016-10-09 10:18:58.000000000 +0200
@@ -31,19 +31,18 @@
 #ifndef OPENVDB_TREE_LEAFNODE_HAS_BEEN_INCLUDED
 #define OPENVDB_TREE_LEAFNODE_HAS_BEEN_INCLUDED
 
-#include <iostream>
-#include <algorithm> // for std::swap
-#include <cstring> // for std::memcpy()
-#include <boost/shared_ptr.hpp>
-#include <boost/static_assert.hpp>
-#include <boost/bind.hpp>
-#include <tbb/blocked_range.h>
-#include <tbb/spin_mutex.h>
-#include <tbb/parallel_for.h>
 #include <openvdb/Types.h>
 #include <openvdb/util/NodeMasks.h>
 #include <openvdb/io/Compression.h> // for io::readData(), etc.
 #include "Iterator.h"
+#include <tbb/blocked_range.h>
+#include <tbb/spin_mutex.h>
+#include <tbb/parallel_for.h>
+#include <algorithm> // for std::swap
+#include <cstring> // for std::memcpy()
+#include <iostream>
+#include <memory>
+#include <type_traits>
 
 
 class TestLeaf;
@@ -65,11 +64,11 @@
 class LeafNode
 {
 public:
-    typedef T                            BuildType; 
-    typedef T                            ValueType;
-    typedef LeafNode<ValueType, Log2Dim> LeafNodeType;
-    typedef boost::shared_ptr<LeafNode>  Ptr;
-    typedef util::NodeMask<Log2Dim>      NodeMaskType;
+    using BuildType = T;
+    using ValueType = T;
+    using LeafNodeType = LeafNode<ValueType, Log2Dim>;
+    using NodeMaskType = util::NodeMask<Log2Dim>;
+    using Ptr = SharedPtr<LeafNode>;
 
     static const Index
         LOG2DIM     = Log2Dim,      // needed by parent nodes
@@ -83,9 +82,7 @@
     /// @brief ValueConverter<T>::Type is the type of a LeafNode having the same
     /// dimensions as this node but a different value type, T.
     template<typename OtherValueType>
-    struct ValueConverter {
-        typedef LeafNode<OtherValueType, Log2Dim> Type;
-    };
+    struct ValueConverter { using Type = LeafNode<OtherValueType, Log2Dim>; };
 
     /// @brief SameConfiguration<OtherNodeType>::value is @c true if and only if
     /// OtherNodeType is the type of a LeafNode with the same dimensions as this node.
@@ -101,7 +98,7 @@
         std::streamoff bufpos;
         std::streamoff maskpos;
         io::MappedFile::Ptr mapping;
-        boost::shared_ptr<io::StreamMetadata> meta;
+        SharedPtr<io::StreamMetadata> meta;
     };
 #endif
 
@@ -123,9 +120,9 @@
         /// Return @c true if this buffer's values have not yet been read from disk.
         bool isOutOfCore() const { return false; }
         /// Return @c true if memory for this buffer has not yet been allocated.
-        bool empty() const { return (mData == NULL); }
+        bool empty() const { return (mData == nullptr); }
 #else
-        typedef ValueType WordType;
+        using WordType = ValueType;
         static const Index WORD_COUNT = SIZE;
         /// Default constructor
         Buffer(): mData(new ValueType[SIZE]), mOutOfCore(0) {}
@@ -135,7 +132,7 @@
             this->fill(val);
         }
         /// Copy constructor
-        Buffer(const Buffer& other): mData(NULL), mOutOfCore(other.mOutOfCore)
+        Buffer(const Buffer& other): mData(nullptr), mOutOfCore(other.mOutOfCore)
         {
             if (other.isOutOfCore()) {
                 mFileInfo = new FileInfo(*other.mFileInfo);
@@ -148,7 +145,7 @@
             }
         }
         /// Construct a buffer but don't allocate memory for the full array of values.
-        Buffer(PartialCreate, const ValueType&): mData(NULL), mOutOfCore(0) {}
+        Buffer(PartialCreate, const ValueType&): mData(nullptr), mOutOfCore(0) {}
         /// Destructor
         ~Buffer()
         {
@@ -165,13 +162,13 @@
         bool empty() const { return !mData || this->isOutOfCore(); }
 #endif
         /// Allocate memory for this buffer if it has not already been allocated.
-        bool allocate() { if (mData == NULL) mData = new ValueType[SIZE]; return true; }
+        bool allocate() { if (mData == nullptr) mData = new ValueType[SIZE]; return true; }
 
         /// Populate this buffer with a constant value.
         void fill(const ValueType& val)
         {
             this->detachFromFile();
-            if (mData != NULL) {
+            if (mData != nullptr) {
                 ValueType* target = mData;
                 Index n = SIZE;
                 while (n--) *target++ = val;
@@ -269,11 +266,11 @@
         {
 #ifndef OPENVDB_2_ABI_COMPATIBLE
             this->loadValues();
-            if (mData == NULL) {
+            if (mData == nullptr) {
                 Buffer* self = const_cast<Buffer*>(this);
                 // This lock will be contended at most once.
                 tbb::spin_mutex::scoped_lock lock(self->mMutex);
-                if (mData == NULL) self->mData = new ValueType[SIZE];
+                if (mData == nullptr) self->mData = new ValueType[SIZE];
             }
 #endif
             return mData;
@@ -286,10 +283,10 @@
         {
 #ifndef OPENVDB_2_ABI_COMPATIBLE
             this->loadValues();
-            if (mData == NULL) {
+            if (mData == nullptr) {
                 // This lock will be contended at most once.
                 tbb::spin_mutex::scoped_lock lock(mMutex);
-                if (mData == NULL) mData = new ValueType[SIZE];
+                if (mData == nullptr) mData = new ValueType[SIZE];
             }
 #endif
             return mData;
@@ -319,9 +316,9 @@
 
         bool deallocate()
         {
-            if (mData != NULL && !this->isOutOfCore()) {
+            if (mData != nullptr && !this->isOutOfCore()) {
                 delete[] mData;
-                mData = NULL;
+                mData = nullptr;
                 return true;
             }
             return false;
@@ -342,7 +339,7 @@
         {
             if (this->isOutOfCore()) {
                 delete mFileInfo;
-                mFileInfo = NULL;
+                mFileInfo = nullptr;
                 this->setOutOfCore(false);
                 return true;
             }
@@ -397,6 +394,9 @@
     /// Deep copy constructor
     LeafNode(const LeafNode&);
 
+    /// Deep assignment operator
+    LeafNode& operator=(const LeafNode&) = default;
+
     /// Value conversion copy constructor
     template<typename OtherValueType>
     explicit LeafNode(const LeafNode<OtherValueType, Log2Dim>& other);
@@ -498,9 +498,9 @@
     bool operator!=(const LeafNode& other) const { return !(other == *this); }
 
 protected:
-    typedef typename NodeMaskType::OnIterator    MaskOnIterator;
-    typedef typename NodeMaskType::OffIterator   MaskOffIterator;
-    typedef typename NodeMaskType::DenseIterator MaskDenseIterator;
+    using MaskOnIterator = typename NodeMaskType::OnIterator;
+    using MaskOffIterator = typename NodeMaskType::OffIterator;
+    using MaskDenseIterator = typename NodeMaskType::DenseIterator;
 
     // Type tags to disambiguate template instantiations
     struct ValueOn {}; struct ValueOff {}; struct ValueAll {};
@@ -513,7 +513,7 @@
         public SparseIteratorBase<
             MaskIterT, ValueIter<MaskIterT, NodeT, ValueT, TagT>, NodeT, ValueT>
     {
-        typedef SparseIteratorBase<MaskIterT, ValueIter, NodeT, ValueT> BaseT;
+        using BaseT = SparseIteratorBase<MaskIterT, ValueIter, NodeT, ValueT>;
 
         ValueIter() {}
         ValueIter(const MaskIterT& iter, NodeT* parent): BaseT(iter, parent) {}
@@ -554,8 +554,8 @@
     struct DenseIter: public DenseIteratorBase<
         MaskDenseIterator, DenseIter<NodeT, ValueT, TagT>, NodeT, /*ChildT=*/void, ValueT>
     {
-        typedef DenseIteratorBase<MaskDenseIterator, DenseIter, NodeT, void, ValueT> BaseT;
-        typedef typename BaseT::NonConstValueType NonConstValueT;
+        using BaseT = DenseIteratorBase<MaskDenseIterator, DenseIter, NodeT, void, ValueT>;
+        using NonConstValueT = typename BaseT::NonConstValueType;
 
         DenseIter() {}
         DenseIter(const MaskDenseIterator& iter, NodeT* parent): BaseT(iter, parent) {}
@@ -563,7 +563,7 @@
         bool getItem(Index pos, void*& child, NonConstValueT& value) const
         {
             value = this->parent().getValue(pos);
-            child = NULL;
+            child = nullptr;
             return false; // no child
         }
 
@@ -578,18 +578,18 @@
     };
 
 public:
-    typedef ValueIter<MaskOnIterator, LeafNode, const ValueType, ValueOn>        ValueOnIter;
-    typedef ValueIter<MaskOnIterator, const LeafNode, const ValueType, ValueOn>  ValueOnCIter;
-    typedef ValueIter<MaskOffIterator, LeafNode, const ValueType, ValueOff>      ValueOffIter;
-    typedef ValueIter<MaskOffIterator,const LeafNode,const ValueType,ValueOff>   ValueOffCIter;
-    typedef ValueIter<MaskDenseIterator, LeafNode, const ValueType, ValueAll>    ValueAllIter;
-    typedef ValueIter<MaskDenseIterator,const LeafNode,const ValueType,ValueAll> ValueAllCIter;
-    typedef ChildIter<MaskOnIterator, LeafNode, ChildOn>                         ChildOnIter;
-    typedef ChildIter<MaskOnIterator, const LeafNode, ChildOn>                   ChildOnCIter;
-    typedef ChildIter<MaskOffIterator, LeafNode, ChildOff>                       ChildOffIter;
-    typedef ChildIter<MaskOffIterator, const LeafNode, ChildOff>                 ChildOffCIter;
-    typedef DenseIter<LeafNode, ValueType, ChildAll>                             ChildAllIter;
-    typedef DenseIter<const LeafNode, const ValueType, ChildAll>                 ChildAllCIter;
+    using ValueOnIter = ValueIter<MaskOnIterator, LeafNode, const ValueType, ValueOn>;
+    using ValueOnCIter = ValueIter<MaskOnIterator, const LeafNode, const ValueType, ValueOn>;
+    using ValueOffIter = ValueIter<MaskOffIterator, LeafNode, const ValueType, ValueOff>;
+    using ValueOffCIter = ValueIter<MaskOffIterator,const LeafNode,const ValueType,ValueOff>;
+    using ValueAllIter = ValueIter<MaskDenseIterator, LeafNode, const ValueType, ValueAll>;
+    using ValueAllCIter = ValueIter<MaskDenseIterator,const LeafNode,const ValueType,ValueAll>;
+    using ChildOnIter = ChildIter<MaskOnIterator, LeafNode, ChildOn>;
+    using ChildOnCIter = ChildIter<MaskOnIterator, const LeafNode, ChildOn>;
+    using ChildOffIter = ChildIter<MaskOffIterator, LeafNode, ChildOff>;
+    using ChildOffCIter = ChildIter<MaskOffIterator, const LeafNode, ChildOff>;
+    using ChildAllIter = DenseIter<LeafNode, ValueType, ChildAll>;
+    using ChildAllCIter = DenseIter<const LeafNode, const ValueType, ChildAll>;
 
     ValueOnCIter  cbeginValueOn() const { return ValueOnCIter(mValueMask.beginOn(), this); }
     ValueOnCIter   beginValueOn() const { return ValueOnCIter(mValueMask.beginOn(), this); }
@@ -1001,11 +1001,11 @@
     template<typename AccessorT>
     void addLeafAndCache(LeafNode*, AccessorT&) {}
     template<typename NodeT>
-    NodeT* stealNode(const Coord&, const ValueType&, bool) { return NULL; }
+    NodeT* stealNode(const Coord&, const ValueType&, bool) { return nullptr; }
     template<typename NodeT>
-    NodeT* probeNode(const Coord&) { return NULL; }
+    NodeT* probeNode(const Coord&) { return nullptr; }
     template<typename NodeT>
-    const NodeT* probeConstNode(const Coord&) const { return NULL; }
+    const NodeT* probeConstNode(const Coord&) const { return nullptr; }
     template<typename ArrayT> void getNodes(ArrayT&) const {}
     template<typename ArrayT> void stealNodes(ArrayT&, const ValueType&, bool) {}
     //@}
@@ -1024,7 +1024,7 @@
     NodeT* probeNodeAndCache(const Coord&, AccessorT&)
     {
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN
-        if (!(boost::is_same<NodeT,LeafNode>::value)) return NULL;
+        if (!(std::is_same<NodeT, LeafNode>::value)) return nullptr;
         return reinterpret_cast<NodeT*>(this);
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
     }
@@ -1044,7 +1044,7 @@
     const NodeT* probeConstNodeAndCache(const Coord&, AccessorT&) const
     {
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN
-        if (!(boost::is_same<NodeT,LeafNode>::value)) return NULL;
+        if (!(std::is_same<NodeT, LeafNode>::value)) return nullptr;
         return reinterpret_cast<const NodeT*>(this);
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
     }
@@ -1075,7 +1075,7 @@
     ///                  approximatly constant.
     bool isConstant(ValueType& minValue, ValueType& maxValue,
                     bool& state, const ValueType& tolerance = zeroVal<ValueType>()) const;
-    
+
     /// Return @c true if all of this node's values are inactive.
     bool isInactive() const { return mValueMask.isOff(); }
 
@@ -1198,7 +1198,7 @@
 
 template<typename T, Index Log2Dim>
 inline
-LeafNode<T, Log2Dim>::LeafNode(const LeafNode &other):
+LeafNode<T, Log2Dim>::LeafNode(const LeafNode& other):
     mBuffer(other.mBuffer),
     mValueMask(other.valueMask()),
     mOrigin(other.mOrigin)
@@ -1471,7 +1471,7 @@
     if (!this->isAllocated()) return;
 #endif
 
-    typedef typename DenseT::ValueType DenseValueType;
+    using DenseValueType = typename DenseT::ValueType;
 
     const size_t xStride = dense.xStride(), yStride = dense.yStride(), zStride = dense.zStride();
     const Coord& min = dense.bbox().min();
@@ -1501,7 +1501,7 @@
     if (!this->allocate()) return;
 #endif
 
-    typedef typename DenseT::ValueType DenseValueType;
+    using DenseValueType = typename DenseT::ValueType;
 
     const size_t xStride = dense.xStride(), yStride = dense.yStride(), zStride = dense.zStride();
     const Coord& min = dense.bbox().min();
@@ -1564,16 +1564,16 @@
     tbb::spin_mutex::scoped_lock lock(self->mMutex);
     if (!this->isOutOfCore()) return;
 
-    boost::scoped_ptr<FileInfo> info(self->mFileInfo);
-    assert(info.get() != NULL);
-    assert(info->mapping.get() != NULL);
-    assert(info->meta.get() != NULL);
+    std::unique_ptr<FileInfo> info(self->mFileInfo);
+    assert(info.get() != nullptr);
+    assert(info->mapping.get() != nullptr);
+    assert(info->meta.get() != nullptr);
 
     /// @todo For now, we have to clear the mData pointer in order for allocate() to take effect.
-    self->mData = NULL;
+    self->mData = nullptr;
     self->allocate();
 
-    boost::shared_ptr<std::streambuf> buf = info->mapping->createBuffer();
+    SharedPtr<std::streambuf> buf = info->mapping->createBuffer();
     std::istream is(buf.get());
 
     io::setStreamMetadataPtr(is, info->meta, /*transfer=*/true);
@@ -1636,7 +1636,7 @@
         // is actually accessed.  (If this node requires clipping, its buffer
         // must be accessed and therefore must be loaded.)
         io::MappedFile::Ptr mappedFile = io::getMappedFilePtr(is);
-        const bool delayLoad = ((mappedFile.get() != NULL) && clipBBox.isInside(nodeBBox));
+        const bool delayLoad = ((mappedFile.get() != nullptr) && clipBBox.isInside(nodeBBox));
 
         if (delayLoad) {
             mBuffer.setOutOfCore(true);
@@ -2125,8 +2125,10 @@
 LeafNode<T, Log2Dim>::doVisit2Node(NodeT& self, OtherNodeT& other, VisitorOp& op)
 {
     // Allow the two nodes to have different ValueTypes, but not different dimensions.
-    BOOST_STATIC_ASSERT(OtherNodeT::SIZE == NodeT::SIZE);
-    BOOST_STATIC_ASSERT(OtherNodeT::LEVEL == NodeT::LEVEL);
+    static_assert(OtherNodeT::SIZE == NodeT::SIZE,
+        "can't visit nodes of different sizes simultaneously");
+    static_assert(OtherNodeT::LEVEL == NodeT::LEVEL,
+        "can't visit nodes at different tree levels simultaneously");
 
     ChildAllIterT iter = self.beginChildAll();
     OtherChildAllIterT otherIter = other.beginChildAll();
diff -aur openvdb.3.2.0/tree/LeafNodeMask.h openvdb.4.0.0/tree/LeafNodeMask.h
--- openvdb.3.2.0/tree/LeafNodeMask.h	2016-04-24 10:39:49.000000000 +0200
+++ openvdb.4.0.0/tree/LeafNodeMask.h	2016-10-09 10:18:58.000000000 +0200
@@ -31,22 +31,20 @@
 #ifndef OPENVDB_TREE_LEAF_NODE_MASK_HAS_BEEN_INCLUDED
 #define OPENVDB_TREE_LEAF_NODE_MASK_HAS_BEEN_INCLUDED
 
-#include <iostream>
-#include <boost/shared_ptr.hpp>
-#include <boost/shared_array.hpp>
-#include <boost/static_assert.hpp>
 #include <openvdb/Types.h>
 #include <openvdb/io/Compression.h> // for io::readData(), etc.
 #include <openvdb/math/Math.h> // for math::isZero()
 #include <openvdb/util/NodeMasks.h>
 #include "LeafNode.h"
 #include "Iterator.h"
+#include <iostream>
+#include <type_traits>
 
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
 namespace OPENVDB_VERSION_NAME {
-namespace tree {        
+namespace tree {
 
 /// @brief LeafNode specialization for values of type ValueMask that encodes both
 /// the active states and the boolean values of (2^Log2Dim)^3 voxels
@@ -55,11 +53,11 @@
 class LeafNode<ValueMask, Log2Dim>
 {
 public:
-    typedef LeafNode<ValueMask, Log2Dim>    LeafNodeType;
-    typedef boost::shared_ptr<LeafNodeType> Ptr;
-    typedef ValueMask                       BuildType;// this is a rare case where 
-    typedef bool                            ValueType;// value type != build type
-    typedef util::NodeMask<Log2Dim>         NodeMaskType;
+    using LeafNodeType = LeafNode<ValueMask, Log2Dim>;
+    using BuildType = ValueMask;// this is a rare case where
+    using ValueType = bool;// value type != build type
+    using NodeMaskType = util::NodeMask<Log2Dim>;
+    using Ptr = SharedPtr<LeafNodeType>;
 
     // These static declarations must be on separate lines to avoid VC9 compiler errors.
     static const Index LOG2DIM    = Log2Dim;    // needed by parent nodes
@@ -73,9 +71,7 @@
     /// @brief ValueConverter<T>::Type is the type of a LeafNode having the same
     /// dimensions as this node but a different value type, T.
     template<typename OtherValueType>
-    struct ValueConverter {
-        typedef LeafNode<OtherValueType, Log2Dim> Type;
-    };
+    struct ValueConverter { using Type = LeafNode<OtherValueType, Log2Dim>; };
 
     /// @brief SameConfiguration<OtherNodeType>::value is @c true if and only if
     /// OtherNodeType is the type of a LeafNode with the same dimensions as this node.
@@ -87,8 +83,9 @@
     class Buffer
     {
     public:
-        typedef typename NodeMaskType::Word WordType;
+        using WordType = typename NodeMaskType::Word;
         static const Index WORD_COUNT = NodeMaskType::WORD_COUNT;
+
         Buffer() {}
         explicit Buffer(bool on) : mData(on) {}
         Buffer(const NodeMaskType& other): mData(other) {}
@@ -148,7 +145,7 @@
 
     /// Default constructor
     LeafNode();
-    
+
     /// Constructor
     /// @param xyz     the coordinates of a voxel that lies within the node
     /// @param value   the initial value = state for all of this node's voxels
@@ -373,7 +370,7 @@
 
     /// Set all voxels within an axis-aligned box to the specified value and active state.
     void fill(const CoordBBox& bbox, bool value, bool dummy = false);
-    
+
     /// Set the state of all voxels to the specified active state.
     void fill(const bool& value, bool dummy = false);
 
@@ -584,11 +581,11 @@
     template<typename AccessorT>
     void addLeafAndCache(LeafNode*, AccessorT&) {}
     template<typename NodeT>
-    NodeT* stealNode(const Coord&, const ValueType&, bool) { return NULL; }
+    NodeT* stealNode(const Coord&, const ValueType&, bool) { return nullptr; }
     template<typename NodeT>
-    NodeT* probeNode(const Coord&) { return NULL; }
+    NodeT* probeNode(const Coord&) { return nullptr; }
     template<typename NodeT>
-    const NodeT* probeConstNode(const Coord&) const { return NULL; }
+    const NodeT* probeConstNode(const Coord&) const { return nullptr; }
     template<typename ArrayT> void getNodes(ArrayT&) const {}
     template<typename ArrayT> void stealNodes(ArrayT&, const ValueType&, bool) {}
     //@}
@@ -610,7 +607,7 @@
     NodeT* probeNodeAndCache(const Coord&, AccessorT&)
     {
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN
-        if (!(boost::is_same<NodeT,LeafNode>::value)) return NULL;
+        if (!(std::is_same<NodeT, LeafNode>::value)) return nullptr;
         return reinterpret_cast<NodeT*>(this);
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
     }
@@ -627,7 +624,7 @@
     const NodeT* probeConstNodeAndCache(const Coord&, AccessorT&) const
     {
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN
-        if (!(boost::is_same<NodeT,LeafNode>::value)) return NULL;
+        if (!(std::is_same<NodeT, LeafNode>::value)) return nullptr;
         return reinterpret_cast<const NodeT*>(this);
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
     }
@@ -637,9 +634,9 @@
     // Iterators
     //
 protected:
-    typedef typename NodeMaskType::OnIterator    MaskOnIter;
-    typedef typename NodeMaskType::OffIterator   MaskOffIter;
-    typedef typename NodeMaskType::DenseIterator MaskDenseIter;
+    using MaskOnIter = typename NodeMaskType::OnIterator;
+    using MaskOffIter = typename NodeMaskType::OffIterator;
+    using MaskDenseIter = typename NodeMaskType::DenseIterator;
 
     template<typename MaskIterT, typename NodeT, typename ValueT>
     struct ValueIter:
@@ -647,7 +644,7 @@
         // if MaskIterT is a dense mask iterator type.
         public SparseIteratorBase<MaskIterT, ValueIter<MaskIterT, NodeT, ValueT>, NodeT, ValueT>
     {
-        typedef SparseIteratorBase<MaskIterT, ValueIter, NodeT, ValueT> BaseT;
+        using BaseT = SparseIteratorBase<MaskIterT, ValueIter, NodeT, ValueT>;
 
         ValueIter() {}
         ValueIter(const MaskIterT& iter, NodeT* parent): BaseT(iter, parent) {}
@@ -682,8 +679,8 @@
     struct DenseIter: public DenseIteratorBase<
         MaskDenseIter, DenseIter<NodeT, ValueT>, NodeT, /*ChildT=*/void, ValueT>
     {
-        typedef DenseIteratorBase<MaskDenseIter, DenseIter, NodeT, void, ValueT> BaseT;
-        typedef typename BaseT::NonConstValueType NonConstValueT;
+        using BaseT = DenseIteratorBase<MaskDenseIter, DenseIter, NodeT, void, ValueT>;
+        using NonConstValueT = typename BaseT::NonConstValueType;
 
         DenseIter() {}
         DenseIter(const MaskDenseIter& iter, NodeT* parent): BaseT(iter, parent) {}
@@ -691,7 +688,7 @@
         bool getItem(Index pos, void*& child, NonConstValueT& value) const
         {
             value = this->parent().getValue(pos);
-            child = NULL;
+            child = nullptr;
             return false; // no child
         }
 
@@ -703,18 +700,18 @@
     };
 
 public:
-    typedef ValueIter<MaskOnIter, LeafNode, const bool>           ValueOnIter;
-    typedef ValueIter<MaskOnIter, const LeafNode, const bool>     ValueOnCIter;
-    typedef ValueIter<MaskOffIter, LeafNode, const bool>          ValueOffIter;
-    typedef ValueIter<MaskOffIter, const LeafNode, const bool>    ValueOffCIter;
-    typedef ValueIter<MaskDenseIter, LeafNode, const bool>        ValueAllIter;
-    typedef ValueIter<MaskDenseIter, const LeafNode, const bool>  ValueAllCIter;
-    typedef ChildIter<MaskOnIter, LeafNode>                       ChildOnIter;
-    typedef ChildIter<MaskOnIter, const LeafNode>                 ChildOnCIter;
-    typedef ChildIter<MaskOffIter, LeafNode>                      ChildOffIter;
-    typedef ChildIter<MaskOffIter, const LeafNode>                ChildOffCIter;
-    typedef DenseIter<LeafNode, bool>                             ChildAllIter;
-    typedef DenseIter<const LeafNode, const bool>                 ChildAllCIter;
+    using ValueOnIter = ValueIter<MaskOnIter, LeafNode, const bool>;
+    using ValueOnCIter = ValueIter<MaskOnIter, const LeafNode, const bool>;
+    using ValueOffIter = ValueIter<MaskOffIter, LeafNode, const bool>;
+    using ValueOffCIter = ValueIter<MaskOffIter, const LeafNode, const bool>;
+    using ValueAllIter = ValueIter<MaskDenseIter, LeafNode, const bool>;
+    using ValueAllCIter = ValueIter<MaskDenseIter, const LeafNode, const bool>;
+    using ChildOnIter = ChildIter<MaskOnIter, LeafNode>;
+    using ChildOnCIter = ChildIter<MaskOnIter, const LeafNode>;
+    using ChildOffIter = ChildIter<MaskOffIter, LeafNode>;
+    using ChildOffCIter = ChildIter<MaskOffIter, const LeafNode>;
+    using ChildAllIter = DenseIter<LeafNode, bool>;
+    using ChildAllCIter = DenseIter<const LeafNode, const bool>;
 
     ValueOnCIter  cbeginValueOn() const { return ValueOnCIter(mBuffer.mData.beginOn(), this); }
     ValueOnCIter   beginValueOn() const { return ValueOnCIter(mBuffer.mData.beginOn(), this); }
@@ -790,7 +787,7 @@
     template<typename NodeT, typename VisitorOp,
         typename ChildAllIterT, typename OtherChildAllIterT>
     static inline void doVisit2(NodeT& self, OtherChildAllIterT&, VisitorOp&, bool otherIsLHS);
-    
+
     /// Bitmask representing the values AND state of voxels
     Buffer mBuffer;
 
@@ -844,8 +841,8 @@
 
 template<Index Log2Dim>
 inline
-LeafNode<ValueMask, Log2Dim>::LeafNode(const Coord& xyz, bool value, bool)
-    : mBuffer(value)
+LeafNode<ValueMask, Log2Dim>::LeafNode(const Coord& xyz, bool value, bool active)
+    : mBuffer(value || active)
     , mOrigin(xyz & (~(DIM - 1)))
 {
 }
@@ -854,8 +851,8 @@
 #ifndef OPENVDB_2_ABI_COMPATIBLE
 template<Index Log2Dim>
 inline
-LeafNode<ValueMask, Log2Dim>::LeafNode(PartialCreate, const Coord& xyz, bool value, bool)
-    : mBuffer(value)
+LeafNode<ValueMask, Log2Dim>::LeafNode(PartialCreate, const Coord& xyz, bool value, bool active)
+    : mBuffer(value || active)
     , mOrigin(xyz & (~(DIM - 1)))
 {
 }
@@ -1100,7 +1097,7 @@
 LeafNode<ValueMask, Log2Dim>::isConstant(bool& constValue, bool& state, bool) const
 {
     if (!mBuffer.mData.isConstant(state)) return false;
-    
+
     constValue = state;
     return true;
 }
@@ -1382,7 +1379,7 @@
 inline void
 LeafNode<ValueMask, Log2Dim>::copyToDense(const CoordBBox& bbox, DenseT& dense) const
 {
-    typedef typename DenseT::ValueType DenseValueType;
+    using DenseValueType = typename DenseT::ValueType;
 
     const size_t xStride = dense.xStride(), yStride = dense.yStride(), zStride = dense.zStride();
     const Coord& min = dense.bbox().min();
@@ -1408,7 +1405,7 @@
 LeafNode<ValueMask, Log2Dim>::copyFromDense(const CoordBBox& bbox, const DenseT& dense,
                                        bool background, bool tolerance)
 {
-    typedef typename DenseT::ValueType DenseValueType;
+    using DenseValueType = typename DenseT::ValueType;
     struct Local {
         inline static bool toBool(const DenseValueType& v) { return !math::isZero(v); }
     };
@@ -1619,8 +1616,10 @@
 LeafNode<ValueMask, Log2Dim>::doVisit2Node(NodeT& self, OtherNodeT& other, VisitorOp& op)
 {
     // Allow the two nodes to have different ValueTypes, but not different dimensions.
-    BOOST_STATIC_ASSERT(OtherNodeT::SIZE == NodeT::SIZE);
-    BOOST_STATIC_ASSERT(OtherNodeT::LEVEL == NodeT::LEVEL);
+    static_assert(OtherNodeT::SIZE == NodeT::SIZE,
+        "can't visit nodes of different sizes simultaneously");
+    static_assert(OtherNodeT::LEVEL == NodeT::LEVEL,
+        "can't visit nodes at different tree levels simultaneously");
 
     ChildAllIterT iter = self.beginChildAll();
     OtherChildAllIterT otherIter = other.beginChildAll();
diff -aur openvdb.3.2.0/tree/NodeManager.h openvdb.4.0.0/tree/NodeManager.h
--- openvdb.3.2.0/tree/NodeManager.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tree/NodeManager.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file NodeManager.h
 ///
 /// @author Ken Museth
@@ -112,10 +112,8 @@
             {
                 assert(this->isValid());
             }
-            Iterator& operator=(const Iterator& other)
-            {
-                mRange = other.mRange; mPos = other.mPos; return *this;
-            }
+            Iterator(const Iterator&) = default;
+            Iterator& operator=(const Iterator&) = default;
             /// Advance to the next node.
             Iterator& operator++() { ++mPos; return *this; }
             /// Return a reference to the node to which this iterator is pointing.
@@ -199,7 +197,7 @@
         }
         const NodeOp mNodeOp;
     };// NodeList::NodeTransformer
-    
+
     // Private struct of NodeList that performs parallel_reduce
     template<typename NodeOp>
     struct NodeReducer
@@ -207,7 +205,7 @@
         NodeReducer(NodeOp& nodeOp) : mNodeOp(&nodeOp), mOwnsOp(false)
         {
         }
-        NodeReducer(const NodeReducer& other, tbb::split) : 
+        NodeReducer(const NodeReducer& other, tbb::split) :
             mNodeOp(new NodeOp(*(other.mNodeOp), tbb::split())), mOwnsOp(true)
         {
         }
@@ -228,7 +226,7 @@
         NodeOp *mNodeOp;
         const bool mOwnsOp;
     };// NodeList::NodeReducer
-    
+
 
 protected:
     ListT mList;
@@ -299,7 +297,7 @@
     {
         this->foreachTopDown<NodeOp>(op, threaded, grainSize);
     }
-    
+
     template<typename NodeOp>
     void reduceBottomUp(NodeOp& op, bool threaded, size_t grainSize)
     {
@@ -530,7 +528,7 @@
     ///  template<typename TreeType>
     ///  struct NodeCountOp
     ///  {
-    ///      NodeCountOp() : nodeCount(TreeType::DEPTH, 0), totalCount(0) 
+    ///      NodeCountOp() : nodeCount(TreeType::DEPTH, 0), totalCount(0)
     ///      {
     ///      }
     ///      NodeCountOp(const NodeCountOp& other, tbb::split) :
@@ -547,10 +545,10 @@
     ///      // do nothing for the root node
     ///      void operator()(const typename TreeT::RootNodeType& node)
     ///      {
-    ///      }  
+    ///      }
     ///      // count the internal and leaf nodes
     ///      template<typename NodeT>
-    ///      void operator()(const NodeT& node) 
+    ///      void operator()(const NodeT& node)
     ///      {
     ///          ++(nodeCount[NodeT::LEVEL]);
     ///          ++totalCount;
diff -aur openvdb.3.2.0/tree/NodeUnion.h openvdb.4.0.0/tree/NodeUnion.h
--- openvdb.3.2.0/tree/NodeUnion.h	2016-05-29 16:45:07.000000000 +0200
+++ openvdb.4.0.0/tree/NodeUnion.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,30 +27,117 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file NodeUnion.h
 ///
-/// @author Peter Cucka
-///
-/// NodeUnion is a templated helper class that controls access to either
+/// @details NodeUnion is a templated helper class that controls access to either
 /// the child node pointer or the value for a particular element of a root
-/// or internal node.  For space efficiency, the child pointer and the value
-/// are unioned, since the two are never in use simultaneously.
-/// Template specializations of NodeUnion allow for values of either POD
-/// (int, float, pointer, etc.) or class (std::string, math::Vec, etc.) types.
-/// (The latter cannot be stored directly in a union.)
+/// or internal node. For space efficiency, the child pointer and the value
+/// are unioned when possible, since the two are never in use simultaneously.
 
 #ifndef OPENVDB_TREE_NODEUNION_HAS_BEEN_INCLUDED
 #define OPENVDB_TREE_NODEUNION_HAS_BEEN_INCLUDED
 
-#include <boost/type_traits/is_class.hpp>
 #include <openvdb/version.h>
+#include <cstring> // for std::memcpy()
+#include <type_traits>
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
 namespace OPENVDB_VERSION_NAME {
 namespace tree {
 
+#ifndef OPENVDB_3_ABI_COMPATIBLE
+
+// Forward declaration of traits class
+template<typename T> struct CopyTraits;
+
+// Default implementation that stores the child pointer and the value separately
+// (i.e., not in a union)
+// This implementation is not used for POD, math::Vec or math::Coord value types.
+template<typename ValueT, typename ChildT, typename Enable = void>
+class NodeUnion
+{
+private:
+    ChildT* mChild;
+    ValueT  mValue;
+
+public:
+    NodeUnion(): mChild(nullptr), mValue() {}
+
+    ChildT* getChild() const { return mChild; }
+    void setChild(ChildT* child) { mChild = child; }
+
+    const ValueT& getValue() const { return mValue; }
+    ValueT& getValue() { return mValue; }
+    void setValue(const ValueT& val) { mValue = val; }
+};
+
+
+// Template specialization for values of POD types (int, float, pointer, etc.)
+template<typename ValueT, typename ChildT>
+class NodeUnion<ValueT, ChildT, typename std::enable_if<std::is_pod<ValueT>::value>::type>
+{
+private:
+    union { ChildT* mChild; ValueT mValue; };
+
+public:
+    NodeUnion(): mChild(nullptr) {}
+
+    ChildT* getChild() const { return mChild; }
+    void setChild(ChildT* child) { mChild = child; }
+
+    const ValueT& getValue() const { return mValue; }
+    ValueT& getValue() { return mValue; }
+    void setValue(const ValueT& val) { mValue = val; }
+};
+
+
+// Template specialization for values of types such as math::Vec3f and math::Coord
+// for which CopyTraits<T>::IsCopyable is true
+template<typename ValueT, typename ChildT>
+class NodeUnion<ValueT, ChildT, typename std::enable_if<CopyTraits<ValueT>::IsCopyable>::type>
+{
+private:
+    union { ChildT* mChild; ValueT mValue; };
+
+public:
+    NodeUnion(): mChild(nullptr) {}
+    NodeUnion(const NodeUnion& other): mChild(nullptr)
+        { std::memcpy(this, &other, sizeof(*this)); }
+    NodeUnion& operator=(const NodeUnion& rhs)
+        { std::memcpy(this, &rhs, sizeof(*this)); return *this; }
+
+    ChildT* getChild() const { return mChild; }
+    void setChild(ChildT* child) { mChild = child; }
+
+    const ValueT& getValue() const { return mValue; }
+    ValueT& getValue() { return mValue; }
+    void setValue(const ValueT& val) { mValue = val; }
+};
+
+
+/// @details A type T is copyable if
+/// # T stores member values by value (vs. by pointer or reference)
+///   and T's true byte size is given by sizeof(T).
+/// # T has a trivial destructor
+/// # T has a default constructor
+/// # T has an assignment operator
+template<typename T> struct CopyTraits { static const bool IsCopyable = false; };
+template<typename T> struct CopyTraits<math::Vec2<T>> { static const bool IsCopyable = true; };
+template<typename T> struct CopyTraits<math::Vec3<T>> { static const bool IsCopyable = true; };
+template<typename T> struct CopyTraits<math::Vec4<T>> { static const bool IsCopyable = true; };
+template<> struct CopyTraits<math::Coord> { static const bool IsCopyable = true; };
+
+
+////////////////////////////////////////
+
+
+#else // OPENVDB_3_ABI_COMPATIBLE
+
+// Prior to OpenVDB 4 and the introduction of C++11, values of non-POD types
+// were heap-allocated and stored by pointer due to C++98 restrictions on unions.
+
 // Internal implementation of a union of a child node pointer and a value
 template<bool ValueIsClass, class ValueT, class ChildT> class NodeUnionImpl;
 
@@ -64,12 +151,13 @@
     union { ChildT* child; ValueT value; } mUnion;
 
 public:
-    NodeUnionImpl() { mUnion.child = NULL; }
+    NodeUnionImpl() { mUnion.child = nullptr; }
 
     ChildT* getChild() const { return mUnion.child; }
+    void setChild(ChildT* child) { mUnion.child = child; }
+
     const ValueT& getValue() const { return mUnion.value; }
     ValueT& getValue() { return mUnion.value; }
-    void setChild(ChildT* child) { mUnion.child = child; }
     void setValue(const ValueT& val) { mUnion.value = val; }
 };
 
@@ -84,7 +172,7 @@
     bool mHasChild;
 
 public:
-    NodeUnionImpl() : mHasChild(true) { this->setChild(NULL); }
+    NodeUnionImpl() : mHasChild(true) { this->setChild(nullptr); }
     NodeUnionImpl(const NodeUnionImpl& other) : mHasChild(true)
     {
         if (other.mHasChild) {
@@ -102,9 +190,9 @@
         }
         return *this;
     }
-    ~NodeUnionImpl() { this->setChild(NULL); }
+    ~NodeUnionImpl() { this->setChild(nullptr); }
 
-    ChildT* getChild() const { return mHasChild ? mUnion.child : NULL; }
+    ChildT* getChild() const { return mHasChild ? mUnion.child : nullptr; }
     void setChild(ChildT* child)
     {
         if (!mHasChild) delete mUnion.value;
@@ -116,8 +204,6 @@
     ValueT& getValue() { return *mUnion.value; }
     void setValue(const ValueT& val)
     {
-        /// @todo To minimize storage across nodes, intern and
-        /// reuse common values, using, e.g., boost::flyweight.
         if (!mHasChild) delete mUnion.value;
         mUnion.value = new ValueT(val);
         mHasChild = false;
@@ -126,12 +212,13 @@
 
 
 template<typename ValueT, typename ChildT>
-struct NodeUnion: public NodeUnionImpl<
-    boost::is_class<ValueT>::value, ValueT, ChildT>
+struct NodeUnion: public NodeUnionImpl<std::is_class<ValueT>::value, ValueT, ChildT>
 {
     NodeUnion() {}
 };
 
+#endif // OPENVDB_3_ABI_COMPATIBLE
+
 } // namespace tree
 } // namespace OPENVDB_VERSION_NAME
 } // namespace openvdb
diff -aur openvdb.3.2.0/tree/RootNode.h openvdb.4.0.0/tree/RootNode.h
--- openvdb.3.2.0/tree/RootNode.h	2016-04-24 10:39:49.000000000 +0200
+++ openvdb.4.0.0/tree/RootNode.h	2016-10-09 10:18:58.000000000 +0200
@@ -171,19 +171,21 @@
         ChildType* child;
         Tile       tile;
 
-        NodeStruct(): child(NULL) {}
+        NodeStruct(): child(nullptr) {}
         NodeStruct(ChildType& c): child(&c) {}
-        NodeStruct(const Tile& t): child(NULL), tile(t) {}
+        NodeStruct(const Tile& t): child(nullptr), tile(t) {}
+        NodeStruct(const NodeStruct&) = default;
+        NodeStruct& operator=(const NodeStruct&) = default;
         ~NodeStruct() {} ///< @note doesn't delete child
 
-        bool isChild() const { return child != NULL; }
-        bool isTile() const { return child == NULL; }
+        bool isChild() const { return child != nullptr; }
+        bool isTile() const { return child == nullptr; }
         bool isTileOff() const { return isTile() && !tile.active; }
         bool isTileOn() const { return isTile() && tile.active; }
 
         void set(ChildType& c) { delete child; child = &c; }
-        void set(const Tile& t) { delete child; child = NULL; tile = t; }
-        ChildType& steal(const Tile& t) { ChildType* c = child; child = NULL; tile = t; return *c; }
+        void set(const Tile& t) { delete child; child = nullptr; tile = t; }
+        ChildType& steal(const Tile& t) { ChildType* c=child; child=nullptr; tile=t; return *c; }
     };
 
     typedef std::map<Coord, NodeStruct>      MapType;
@@ -283,7 +285,7 @@
         void getCoord(Coord& xyz) const { xyz = this->getCoord(); }
 
     protected:
-        BaseIter(): mParentNode(NULL) {}
+        BaseIter(): mParentNode(nullptr) {}
         BaseIter(RootNodeT& parent, const MapIterT& iter): mParentNode(&parent), mIter(iter) {}
 
         void skip() { while (this->test() && !FilterPredT::test(mIter)) ++mIter; }
@@ -369,17 +371,17 @@
         {
             if (isChild(mIter)) return &getChild(mIter);
             value = getTile(mIter).value;
-            return NULL;
+            return nullptr;
         }
         bool probeChild(ChildNodeT*& child, NonConstValueType& value) const
         {
             child = this->probeChild(value);
-            return child != NULL;
+            return child != nullptr;
         }
         bool probeValue(NonConstValueType& value) const { return !this->probeChild(value); }
 
         void setChild(ChildNodeT& c) const { RootNodeT::setChild(mIter, c); }
-        void setChild(ChildNodeT* c) const { assert(c != NULL); RootNodeT::setChild(mIter, *c); }
+        void setChild(ChildNodeT* c) const { assert(c != nullptr); RootNodeT::setChild(mIter, *c); }
         void setValue(const ValueT& v) const
         {
             if (isTile(mIter)) getTile(mIter).value = v;
@@ -573,10 +575,10 @@
     ///                otherwise mark them as inactive.
     ///
     /// @note This operation generates a dense representation of the
-    ///       filled box. This implies that active tiles are voxelized, i.e. only active 
+    ///       filled box. This implies that active tiles are voxelized, i.e. only active
     ///       voxels are generated from this fill operation.
     void denseFill(const CoordBBox& bbox, const ValueType& value, bool active = true);
-    
+
     /// @brief Copy into a dense grid the values of all voxels, both active and inactive,
     /// that intersect a given bounding box.
     /// @param bbox   inclusive bounding box of the voxels to be copied into the dense grid
@@ -693,7 +695,7 @@
 
     /// @brief Return a pointer to the node of type @c NodeT that contains voxel (x, y, z)
     /// and replace it with a tile of the specified value and state.
-    /// If no such node exists, leave the tree unchanged and return @c NULL.
+    /// If no such node exists, leave the tree unchanged and return @c nullptr.
     ///
     /// @note The caller takes ownership of the node and is responsible for deleting it.
     ///
@@ -730,7 +732,7 @@
 
     //@{
     /// @brief Return a pointer to the node that contains voxel (x, y, z).
-    /// If no such node exists, return NULL.
+    /// If no such node exists, return @c nullptr.
     template <typename NodeT>
     NodeT* probeNode(const Coord& xyz);
     template <typename NodeT>
@@ -748,7 +750,7 @@
 
     //@{
     /// @brief Return a pointer to the leaf node that contains voxel (x, y, z).
-    /// If no such node exists, return NULL.
+    /// If no such node exists, return @c nullptr.
     LeafNodeType* probeLeaf(const Coord& xyz);
     const LeafNodeType* probeConstLeaf(const Coord& xyz) const;
     const LeafNodeType* probeLeaf(const Coord& xyz) const;
@@ -826,12 +828,12 @@
     template<typename ArrayT>
     void stealNodes(ArrayT& array) { this->stealNodes(array, mBackground, false); }
     //@}
-    
+
     /// @brief Densify active tiles, i.e., replace them with leaf-level active voxels.
     ///
     /// @param threaded if true, this operation is multi-threaded (over the internal nodes).
     ///
-    /// @warning This method can explode the tree's memory footprint, especially if it 
+    /// @warning This method can explode the tree's memory footprint, especially if it
     /// contains active tiles at the upper levels, e.g. root level!
     void voxelizeActiveTiles(bool threaded = true);
 
@@ -1740,7 +1742,7 @@
 inline void
 RootNode<ChildT>::setActiveState(const Coord& xyz, bool on)
 {
-    ChildT* child = NULL;
+    ChildT* child = nullptr;
     MapIter iter = this->findCoord(xyz);
     if (iter == mTable.end()) {
         if (on) {
@@ -1763,7 +1765,7 @@
 inline void
 RootNode<ChildT>::setActiveStateAndCache(const Coord& xyz, bool on, AccessorT& acc)
 {
-    ChildT* child = NULL;
+    ChildT* child = nullptr;
     MapIter iter = this->findCoord(xyz);
     if (iter == mTable.end()) {
         if (on) {
@@ -1789,7 +1791,7 @@
 inline void
 RootNode<ChildT>::setValueOff(const Coord& xyz, const ValueType& value)
 {
-    ChildT* child = NULL;
+    ChildT* child = nullptr;
     MapIter iter = this->findCoord(xyz);
     if (iter == mTable.end()) {
         if (!math::isExactlyEqual(mBackground, value)) {
@@ -1810,7 +1812,7 @@
 inline void
 RootNode<ChildT>::setValueOffAndCache(const Coord& xyz, const ValueType& value, AccessorT& acc)
 {
-    ChildT* child = NULL;
+    ChildT* child = nullptr;
     MapIter iter = this->findCoord(xyz);
     if (iter == mTable.end()) {
         if (!math::isExactlyEqual(mBackground, value)) {
@@ -1834,7 +1836,7 @@
 inline void
 RootNode<ChildT>::setValueOn(const Coord& xyz, const ValueType& value)
 {
-    ChildT* child = NULL;
+    ChildT* child = nullptr;
     MapIter iter = this->findCoord(xyz);
     if (iter == mTable.end()) {
         child = new ChildT(xyz, mBackground);
@@ -1853,7 +1855,7 @@
 inline void
 RootNode<ChildT>::setValueAndCache(const Coord& xyz, const ValueType& value, AccessorT& acc)
 {
-    ChildT* child = NULL;
+    ChildT* child = nullptr;
     MapIter iter = this->findCoord(xyz);
     if (iter == mTable.end()) {
         child = new ChildT(xyz, mBackground);
@@ -1875,7 +1877,7 @@
 inline void
 RootNode<ChildT>::setValueOnly(const Coord& xyz, const ValueType& value)
 {
-    ChildT* child = NULL;
+    ChildT* child = nullptr;
     MapIter iter = this->findCoord(xyz);
     if (iter == mTable.end()) {
         child = new ChildT(xyz, mBackground);
@@ -1894,7 +1896,7 @@
 inline void
 RootNode<ChildT>::setValueOnlyAndCache(const Coord& xyz, const ValueType& value, AccessorT& acc)
 {
-    ChildT* child = NULL;
+    ChildT* child = nullptr;
     MapIter iter = this->findCoord(xyz);
     if (iter == mTable.end()) {
         child = new ChildT(xyz, mBackground);
@@ -1917,7 +1919,7 @@
 inline void
 RootNode<ChildT>::modifyValue(const Coord& xyz, const ModifyOp& op)
 {
-    ChildT* child = NULL;
+    ChildT* child = nullptr;
     MapIter iter = this->findCoord(xyz);
     if (iter == mTable.end()) {
         child = new ChildT(xyz, mBackground);
@@ -1949,7 +1951,7 @@
 inline void
 RootNode<ChildT>::modifyValueAndCache(const Coord& xyz, const ModifyOp& op, AccessorT& acc)
 {
-    ChildT* child = NULL;
+    ChildT* child = nullptr;
     MapIter iter = this->findCoord(xyz);
     if (iter == mTable.end()) {
         child = new ChildT(xyz, mBackground);
@@ -1985,7 +1987,7 @@
 inline void
 RootNode<ChildT>::modifyValueAndActiveState(const Coord& xyz, const ModifyOp& op)
 {
-    ChildT* child = NULL;
+    ChildT* child = nullptr;
     MapIter iter = this->findCoord(xyz);
     if (iter == mTable.end()) {
         child = new ChildT(xyz, mBackground);
@@ -2013,7 +2015,7 @@
 RootNode<ChildT>::modifyValueAndActiveStateAndCache(
     const Coord& xyz, const ModifyOp& op, AccessorT& acc)
 {
-    ChildT* child = NULL;
+    ChildT* child = nullptr;
     MapIter iter = this->findCoord(xyz);
     if (iter == mTable.end()) {
         child = new ChildT(xyz, mBackground);
@@ -2079,7 +2081,7 @@
 RootNode<ChildT>::fill(const CoordBBox& bbox, const ValueType& value, bool active)
 {
     if (bbox.empty()) return;
-    
+
     Coord xyz, tileMax;
     for (int x = bbox.min().x(); x <= bbox.max().x(); x = tileMax.x() + 1) {
         xyz.setX(x);
@@ -2096,7 +2098,7 @@
                     // If the box defined by (xyz, bbox.max()) doesn't completely enclose
                     // the tile to which xyz belongs, create a child node (or retrieve
                     // the existing one).
-                    ChildT* child = NULL;
+                    ChildT* child = nullptr;
                     MapIter iter = this->findKey(tileMin);
                     if (iter == mTable.end()) {
                         // No child or tile exists.  Create a child and initialize it
@@ -2442,10 +2444,10 @@
 RootNode<ChildT>::stealNode(const Coord& xyz, const ValueType& value, bool state)
 {
     if ((NodeT::LEVEL == ChildT::LEVEL && !(boost::is_same<NodeT, ChildT>::value)) ||
-         NodeT::LEVEL >  ChildT::LEVEL) return NULL;
+         NodeT::LEVEL >  ChildT::LEVEL) return nullptr;
     OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN
     MapIter iter = this->findCoord(xyz);
-    if (iter == mTable.end() || isTile(iter)) return NULL;
+    if (iter == mTable.end() || isTile(iter)) return nullptr;
     return (boost::is_same<NodeT, ChildT>::value)
         ? reinterpret_cast<NodeT*>(&stealChild(iter, Tile(value, state)))
         : getChild(iter).template stealNode<NodeT>(xyz, value, state);
@@ -2460,8 +2462,8 @@
 inline void
 RootNode<ChildT>::addLeaf(LeafNodeType* leaf)
 {
-    if (leaf == NULL) return;
-    ChildT* child = NULL;
+    if (leaf == nullptr) return;
+    ChildT* child = nullptr;
     const Coord& xyz = leaf->origin();
     MapIter iter = this->findCoord(xyz);
     if (iter == mTable.end()) {
@@ -2495,8 +2497,8 @@
 inline void
 RootNode<ChildT>::addLeafAndCache(LeafNodeType* leaf, AccessorT& acc)
 {
-    if (leaf == NULL) return;
-    ChildT* child = NULL;
+    if (leaf == nullptr) return;
+    ChildT* child = nullptr;
     const Coord& xyz = leaf->origin();
     MapIter iter = this->findCoord(xyz);
     if (iter == mTable.end()) {
@@ -2617,7 +2619,7 @@
 inline typename ChildT::LeafNodeType*
 RootNode<ChildT>::touchLeaf(const Coord& xyz)
 {
-    ChildT* child = NULL;
+    ChildT* child = nullptr;
     MapIter iter = this->findCoord(xyz);
     if (iter == mTable.end()) {
         child = new ChildT(xyz, mBackground, false);
@@ -2637,7 +2639,7 @@
 inline typename ChildT::LeafNodeType*
 RootNode<ChildT>::touchLeafAndCache(const Coord& xyz, AccessorT& acc)
 {
-    ChildT* child = NULL;
+    ChildT* child = nullptr;
     MapIter iter = this->findCoord(xyz);
     if (iter == mTable.end()) {
         child = new ChildT(xyz, mBackground, false);
@@ -2662,10 +2664,10 @@
 RootNode<ChildT>::probeNode(const Coord& xyz)
 {
     if ((NodeT::LEVEL == ChildT::LEVEL && !(boost::is_same<NodeT, ChildT>::value)) ||
-         NodeT::LEVEL >  ChildT::LEVEL) return NULL;
+         NodeT::LEVEL >  ChildT::LEVEL) return nullptr;
     OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN
     MapIter iter = this->findCoord(xyz);
-    if (iter == mTable.end() || isTile(iter)) return NULL;
+    if (iter == mTable.end() || isTile(iter)) return nullptr;
     ChildT* child = &getChild(iter);
     return (boost::is_same<NodeT, ChildT>::value)
         ? reinterpret_cast<NodeT*>(child)
@@ -2680,10 +2682,10 @@
 RootNode<ChildT>::probeConstNode(const Coord& xyz) const
 {
     if ((NodeT::LEVEL == ChildT::LEVEL && !(boost::is_same<NodeT, ChildT>::value)) ||
-         NodeT::LEVEL >  ChildT::LEVEL) return NULL;
+         NodeT::LEVEL >  ChildT::LEVEL) return nullptr;
     OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN
     MapCIter iter = this->findCoord(xyz);
-    if (iter == mTable.end() || isTile(iter)) return NULL;
+    if (iter == mTable.end() || isTile(iter)) return nullptr;
     const ChildT* child = &getChild(iter);
     return (boost::is_same<NodeT, ChildT>::value)
         ? reinterpret_cast<const NodeT*>(child)
@@ -2741,10 +2743,10 @@
 RootNode<ChildT>::probeNodeAndCache(const Coord& xyz, AccessorT& acc)
 {
     if ((NodeT::LEVEL == ChildT::LEVEL && !(boost::is_same<NodeT, ChildT>::value)) ||
-         NodeT::LEVEL >  ChildT::LEVEL) return NULL;
+         NodeT::LEVEL >  ChildT::LEVEL) return nullptr;
     OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN
     MapIter iter = this->findCoord(xyz);
-    if (iter == mTable.end() || isTile(iter)) return NULL;
+    if (iter == mTable.end() || isTile(iter)) return nullptr;
     ChildT* child = &getChild(iter);
     acc.insert(xyz, child);
     return (boost::is_same<NodeT, ChildT>::value)
@@ -2760,10 +2762,10 @@
 RootNode<ChildT>::probeConstNodeAndCache(const Coord& xyz, AccessorT& acc) const
 {
     if ((NodeT::LEVEL == ChildT::LEVEL && !(boost::is_same<NodeT, ChildT>::value)) ||
-         NodeT::LEVEL >  ChildT::LEVEL) return NULL;
+         NodeT::LEVEL >  ChildT::LEVEL) return nullptr;
     OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN
     MapCIter iter = this->findCoord(xyz);
-    if (iter == mTable.end() || isTile(iter)) return NULL;
+    if (iter == mTable.end() || isTile(iter)) return nullptr;
     const ChildT* child = &getChild(iter);
     acc.insert(xyz, child);
     return (boost::is_same<NodeT, ChildT>::value)
@@ -2873,7 +2875,7 @@
     for (MapIter i = mTable.begin(), e = mTable.end(); i != e; ++i) {
         if (this->isTileOff(i)) continue;
         ChildT* child = i->second.child;
-        if (child==NULL) {
+        if (child == nullptr) {
             child = new ChildT(i->first, this->getTile(i).value, true);
             i->second.child = child;
         }
@@ -3400,15 +3402,15 @@
         const size_t skipBranch = static_cast<size_t>(op(iter, otherIter));
 
         typename ChildAllIterT::ChildNodeType* child =
-            (skipBranch & 1U) ? NULL : iter.probeChild(val);
+            (skipBranch & 1U) ? nullptr : iter.probeChild(val);
         typename OtherChildAllIterT::ChildNodeType* otherChild =
-            (skipBranch & 2U) ? NULL : otherIter.probeChild(otherVal);
+            (skipBranch & 2U) ? nullptr : otherIter.probeChild(otherVal);
 
-        if (child != NULL && otherChild != NULL) {
+        if (child != nullptr && otherChild != nullptr) {
             child->visit2Node(*otherChild, op);
-        } else if (child != NULL) {
+        } else if (child != nullptr) {
             child->visit2(otherIter, op);
-        } else if (otherChild != NULL) {
+        } else if (otherChild != nullptr) {
             otherChild->visit2(iter, op, /*otherIsLHS=*/true);
         }
     }
diff -aur openvdb.3.2.0/tree/Tree.h openvdb.4.0.0/tree/Tree.h
--- openvdb.3.2.0/tree/Tree.h	2016-07-24 09:29:15.000000000 +0200
+++ openvdb.4.0.0/tree/Tree.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file tree/Tree.h
 ///
 /// @todo Optimize Tree::evalMinMax
@@ -35,15 +35,8 @@
 #ifndef OPENVDB_TREE_TREE_HAS_BEEN_INCLUDED
 #define OPENVDB_TREE_TREE_HAS_BEEN_INCLUDED
 
-#include <iostream>
-#include <sstream>
-#include <vector>
-#include <boost/shared_ptr.hpp>
-#include <boost/cstdint.hpp>
-#include <tbb/atomic.h>
-#include <tbb/concurrent_hash_map.h>
 #include <openvdb/Types.h>
-#include <openvdb/metadata/Metadata.h>
+#include <openvdb/Metadata.h>
 #include <openvdb/math/Math.h>
 #include <openvdb/math/BBox.h>
 #include <openvdb/util/Formats.h>
@@ -54,6 +47,12 @@
 #include "LeafNode.h"
 #include "TreeIterator.h"
 #include "ValueAccessor.h"
+#include <tbb/atomic.h>
+#include <tbb/concurrent_hash_map.h>
+#include <cstdint>
+#include <iostream>
+#include <sstream>
+#include <vector>
 
 
 namespace openvdb {
@@ -65,11 +64,13 @@
 class OPENVDB_API TreeBase
 {
 public:
-    typedef boost::shared_ptr<TreeBase> Ptr;
-    typedef boost::shared_ptr<const TreeBase> ConstPtr;
+    using Ptr = SharedPtr<TreeBase>;
+    using ConstPtr = SharedPtr<const TreeBase>;
 
-    TreeBase() {}
-    virtual ~TreeBase() {}
+    TreeBase() = default;
+    TreeBase(const TreeBase&) = default;
+    TreeBase& operator=(const TreeBase&) = delete; // disallow assignment
+    virtual ~TreeBase() = default;
 
     /// Return the name of this tree's type.
     virtual const Name& type() const = 0;
@@ -190,11 +191,6 @@
     ///                      4: include minimum and maximum voxel values
     /// @warning @a verboseLevel 4 forces loading of any unallocated nodes.
     virtual void print(std::ostream& os = std::cout, int verboseLevel = 1) const;
-
-private:
-    // Disallow copying of instances of this class.
-    //TreeBase(const TreeBase& other);
-    TreeBase& operator=(const TreeBase& other);
 };
 
 
@@ -205,13 +201,13 @@
 class Tree: public TreeBase
 {
 public:
-    typedef boost::shared_ptr<Tree> Ptr;
-    typedef boost::shared_ptr<const Tree> ConstPtr;
+    using Ptr = SharedPtr<Tree>;
+    using ConstPtr = SharedPtr<const Tree>;
 
-    typedef _RootNodeType                        RootNodeType;
-    typedef typename RootNodeType::ValueType     ValueType;
-    typedef typename RootNodeType::BuildType     BuildType;
-    typedef typename RootNodeType::LeafNodeType  LeafNodeType;
+    using RootNodeType = _RootNodeType;
+    using ValueType = typename RootNodeType::ValueType;
+    using BuildType = typename RootNodeType::BuildType;
+    using LeafNodeType = typename RootNodeType::LeafNodeType;
 
     static const Index DEPTH = RootNodeType::LEVEL + 1;
 
@@ -223,12 +219,14 @@
     /// to write "typename SourceTree::template ValueConverter<T>::Type".
     template<typename OtherValueType>
     struct ValueConverter {
-        typedef Tree<typename RootNodeType::template ValueConverter<OtherValueType>::Type> Type;
+        using Type = Tree<typename RootNodeType::template ValueConverter<OtherValueType>::Type>;
     };
 
 
     Tree() {}
 
+    Tree& operator=(const Tree&) = delete; // disallow assignment
+
     /// Deep copy constructor
     Tree(const Tree& other): TreeBase(other), mRoot(other.mRoot)
     {
@@ -286,18 +284,18 @@
     /// Empty tree constructor
     Tree(const ValueType& background): mRoot(background) {}
 
-    virtual ~Tree() { this->clear(); releaseAllAccessors(); }
+    ~Tree() override { this->clear(); releaseAllAccessors(); }
 
     /// Return a pointer to a deep copy of this tree
-    virtual TreeBase::Ptr copy() const { return TreeBase::Ptr(new Tree(*this)); }
+    TreeBase::Ptr copy() const override { return TreeBase::Ptr(new Tree(*this)); }
 
     /// Return the name of the type of a voxel's value (e.g., "float" or "vec3d")
-    virtual Name valueType() const { return typeNameAsString<ValueType>(); }
+    Name valueType() const override { return typeNameAsString<ValueType>(); }
 
     /// Return the name of this type of tree.
     static const Name& treeType();
     /// Return the name of this type of tree.
-    virtual const Name& type() const { return this->treeType(); }
+    const Name& type() const override { return this->treeType(); }
 
     bool operator==(const Tree&) const { OPENVDB_THROW(NotImplementedError, ""); }
     bool operator!=(const Tree&) const { OPENVDB_THROW(NotImplementedError, ""); }
@@ -317,10 +315,10 @@
     template<typename OtherRootNodeType>
     bool hasSameTopology(const Tree<OtherRootNodeType>& other) const;
 
-    virtual bool evalLeafBoundingBox(CoordBBox& bbox) const;
-    virtual bool evalActiveVoxelBoundingBox(CoordBBox& bbox) const;
-    virtual bool evalActiveVoxelDim(Coord& dim) const;
-    virtual bool evalLeafDim(Coord& dim) const;
+    bool evalLeafBoundingBox(CoordBBox& bbox) const override;
+    bool evalActiveVoxelBoundingBox(CoordBBox& bbox) const override;
+    bool evalActiveVoxelDim(Coord& dim) const override;
+    bool evalLeafDim(Coord& dim) const override;
 
     /// @brief Traverse the type hierarchy of nodes, and return, in @a dims, a list
     /// of the Log2Dims of nodes in order from RootNode to LeafNode.
@@ -334,27 +332,27 @@
     /// @brief Read the tree topology from a stream.
     ///
     /// This will read the tree structure and tile values, but not voxel data.
-    virtual void readTopology(std::istream&, bool saveFloatAsHalf = false);
+    void readTopology(std::istream&, bool saveFloatAsHalf = false) override;
     /// @brief Write the tree topology to a stream.
     ///
     /// This will write the tree structure and tile values, but not voxel data.
-    virtual void writeTopology(std::ostream&, bool saveFloatAsHalf = false) const;
+    void writeTopology(std::ostream&, bool saveFloatAsHalf = false) const override;
     /// Read all data buffers for this tree.
-    virtual void readBuffers(std::istream&, bool saveFloatAsHalf = false);
+    void readBuffers(std::istream&, bool saveFloatAsHalf = false) override;
 #ifndef OPENVDB_2_ABI_COMPATIBLE
     /// Read all of this tree's data buffers that intersect the given bounding box.
-    virtual void readBuffers(std::istream&, const CoordBBox&, bool saveFloatAsHalf = false);
+    void readBuffers(std::istream&, const CoordBBox&, bool saveFloatAsHalf = false) override;
     /// @brief Read all of this tree's data buffers that are not yet resident in memory
     /// (because delayed loading is in effect).
     /// @details If this tree was read from a memory-mapped file, this operation
     /// disconnects the tree from the file.
     /// @sa clipUnallocatedNodes, io::File::open, io::MappedFile
-    virtual void readNonresidentBuffers() const;
+    void readNonresidentBuffers() const override;
 #endif
     /// Write out all data buffers for this tree.
-    virtual void writeBuffers(std::ostream&, bool saveFloatAsHalf = false) const;
+    void writeBuffers(std::ostream&, bool saveFloatAsHalf = false) const override;
 
-    virtual void print(std::ostream& os = std::cout, int verboseLevel = 1) const;
+    void print(std::ostream& os = std::cout, int verboseLevel = 1) const override;
 
 
     //
@@ -363,26 +361,26 @@
     /// @brief Return the depth of this tree.
     ///
     /// A tree with only a root node and leaf nodes has depth 2, for example.
-    virtual Index treeDepth() const { return DEPTH; }
+    Index treeDepth() const override { return DEPTH; }
     /// Return the number of leaf nodes.
-    virtual Index32 leafCount() const { return mRoot.leafCount(); }
+    Index32 leafCount() const override { return mRoot.leafCount(); }
     /// Return the number of non-leaf nodes.
-    virtual Index32 nonLeafCount() const { return mRoot.nonLeafCount(); }
+    Index32 nonLeafCount() const override { return mRoot.nonLeafCount(); }
     /// Return the number of active voxels stored in leaf nodes.
-    virtual Index64 activeLeafVoxelCount() const { return mRoot.onLeafVoxelCount(); }
+    Index64 activeLeafVoxelCount() const override { return mRoot.onLeafVoxelCount(); }
     /// Return the number of inactive voxels stored in leaf nodes.
-    virtual Index64 inactiveLeafVoxelCount() const { return mRoot.offLeafVoxelCount(); }
+    Index64 inactiveLeafVoxelCount() const override { return mRoot.offLeafVoxelCount(); }
     /// Return the total number of active voxels.
-    virtual Index64 activeVoxelCount() const { return mRoot.onVoxelCount(); }
+    Index64 activeVoxelCount() const override { return mRoot.onVoxelCount(); }
     /// Return the number of inactive voxels within the bounding box of all active voxels.
-    virtual Index64 inactiveVoxelCount() const;
+    Index64 inactiveVoxelCount() const override;
     /// Return the total number of active tiles.
-    Index64 activeTileCount() const { return mRoot.onTileCount(); }
+    Index64 activeTileCount() const override { return mRoot.onTileCount(); }
 
     /// Return the minimum and maximum active values in this tree.
     void evalMinMax(ValueType &min, ValueType &max) const;
 
-    virtual Index64 memUsage() const { return sizeof(*this) + mRoot.memUsage(); }
+    Index64 memUsage() const override { return sizeof(*this) + mRoot.memUsage(); }
 
 
     //
@@ -480,7 +478,7 @@
     /// @details Typically, unallocated nodes are leaf nodes whose voxel buffers
     /// are not yet resident in memory because delayed loading is in effect.
     /// @sa readNonresidentBuffers, io::File::open
-    virtual void clipUnallocatedNodes();
+    void clipUnallocatedNodes() override;
 #endif
 
     //@{
@@ -538,7 +536,7 @@
 
     /// @brief Return a pointer to the node of type @c NodeT that contains voxel (x, y, z)
     /// and replace it with a tile of the specified value and state.
-    /// If no such node exists, leave the tree unchanged and return @c NULL.
+    /// If no such node exists, leave the tree unchanged and return @c nullptr.
     /// @note The caller takes ownership of the node and is responsible for deleting it.
     template<typename NodeT>
     NodeT* stealNode(const Coord& xyz, const ValueType& value, bool active);
@@ -552,7 +550,7 @@
 
     //@{
     /// @brief Return a pointer to the node of type @c NodeType that contains
-    /// voxel (x, y, z).  If no such node exists, return NULL.
+    /// voxel (x, y, z).  If no such node exists, return @c nullptr.
     template<typename NodeType> NodeType* probeNode(const Coord& xyz);
     template<typename NodeType> const NodeType* probeConstNode(const Coord& xyz) const;
     template<typename NodeType> const NodeType* probeNode(const Coord& xyz) const;
@@ -560,7 +558,7 @@
 
     //@{
     /// @brief Return a pointer to the leaf node that contains voxel (x, y, z).
-    /// If no such node exists, return NULL.
+    /// If no such node exists, return @c nullptr.
     LeafNodeType* probeLeaf(const Coord& xyz);
     const LeafNodeType* probeConstLeaf(const Coord& xyz) const;
     const LeafNodeType* probeLeaf(const Coord& xyz) const { return this->probeConstLeaf(xyz); }
@@ -570,14 +568,14 @@
     /// @brief Adds all nodes of a certain type to a container with the following API:
     /// @code
     /// struct ArrayT {
-    ///    typedef value_type;// defines the type of nodes to be added to the array
-    ///    void push_back(value_type nodePtr);// method that add nodes to the array
+    ///    using value_type = ...;             // the type of node to be added to the array
+    ///    void push_back(value_type nodePtr); // add a node to the array
     /// };
     /// @endcode
     /// @details An example of a wrapper around a c-style array is:
     /// @code
     /// struct MyArray {
-    ///    typedef LeafType* value_type;
+    ///    using value_type = LeafType*;
     ///    value_type* ptr;
     ///    MyArray(value_type* array) : ptr(array) {}
     ///    void push_back(value_type leaf) { *ptr++ = leaf; }
@@ -597,14 +595,14 @@
     /// adds them to a container with the following API:
     /// @code
     /// struct ArrayT {
-    ///    typedef value_type;// defines the type of nodes to be added to the array
-    ///    void push_back(value_type nodePtr);// method that add nodes to the array
+    ///    using value_type = ...;             // the type of node to be added to the array
+    ///    void push_back(value_type nodePtr); // add a node to the array
     /// };
     /// @endcode
     /// @details An example of a wrapper around a c-style array is:
     /// @code
     /// struct MyArray {
-    ///    typedef LeafType* value_type;
+    ///    using value_type = LeafType*;
     ///    value_type* ptr;
     ///    MyArray(value_type* array) : ptr(array) {}
     ///    void push_back(value_type leaf) { *ptr++ = leaf; }
@@ -665,7 +663,7 @@
 
     /// @brief Return this tree's background value wrapped as metadata.
     /// @note Query the metadata object for the value's type.
-    virtual Metadata::Ptr getBackgroundValue() const;
+    Metadata::Ptr getBackgroundValue() const override;
 
     /// @brief Return this tree's background value.
     ///
@@ -675,7 +673,7 @@
     const ValueType& background() const { return mRoot.background(); }
 
     /// Min and max are both inclusive.
-    virtual void getIndexRange(CoordBBox& bbox) const { mRoot.getIndexRange(bbox); }
+    void getIndexRange(CoordBBox& bbox) const override { mRoot.getIndexRange(bbox); }
 
     /// @brief Densify active tiles, i.e., replace them with leaf-level active voxels.
     ///
@@ -1013,7 +1011,7 @@
     ///     template<typename TreeT>
     ///     struct PrintTreeVisitor
     ///     {
-    ///         typedef typename TreeT::RootNodeType RootT;
+    ///         using RootT = typename TreeT::RootNodeType;
     ///         bool visitedRoot;
     ///
     ///         PrintTreeVisitor(): visitedRoot(false) {}
@@ -1027,7 +1025,7 @@
     ///             }
     ///             typename IterT::NonConstValueType value;
     ///             typename IterT::ChildNodeType* child = iter.probeChild(value);
-    ///             if (child == NULL) {
+    ///             if (child == nullptr) {
     ///                 std::cout << "Tile with value " << value << std::endl;
     ///                 return true; // no child to visit, so stop descending
     ///             }
@@ -1152,14 +1150,14 @@
 
     //@{
     /// Iterator over all nodes in this tree
-    typedef NodeIteratorBase<Tree, typename RootNodeType::ChildOnIter>        NodeIter;
-    typedef NodeIteratorBase<const Tree, typename RootNodeType::ChildOnCIter> NodeCIter;
+    using NodeIter = NodeIteratorBase<Tree, typename RootNodeType::ChildOnIter>;
+    using NodeCIter = NodeIteratorBase<const Tree, typename RootNodeType::ChildOnCIter>;
     //@}
 
     //@{
     /// Iterator over all leaf nodes in this tree
-    typedef LeafIteratorBase<Tree, typename RootNodeType::ChildOnIter>        LeafIter;
-    typedef LeafIteratorBase<const Tree, typename RootNodeType::ChildOnCIter> LeafCIter;
+    using LeafIter = LeafIteratorBase<Tree, typename RootNodeType::ChildOnIter>;
+    using LeafCIter = LeafIteratorBase<const Tree, typename RootNodeType::ChildOnCIter>;
     //@}
 
     //@{
@@ -1176,12 +1174,12 @@
     LeafCIter cbeginLeaf() const { return LeafCIter(*this); }
     //@}
 
-    typedef TreeValueIteratorBase<Tree, typename RootNodeType::ValueAllIter> ValueAllIter;
-    typedef TreeValueIteratorBase<const Tree, typename RootNodeType::ValueAllCIter> ValueAllCIter;
-    typedef TreeValueIteratorBase<Tree, typename RootNodeType::ValueOnIter> ValueOnIter;
-    typedef TreeValueIteratorBase<const Tree, typename RootNodeType::ValueOnCIter> ValueOnCIter;
-    typedef TreeValueIteratorBase<Tree, typename RootNodeType::ValueOffIter> ValueOffIter;
-    typedef TreeValueIteratorBase<const Tree, typename RootNodeType::ValueOffCIter> ValueOffCIter;
+    using ValueAllIter = TreeValueIteratorBase<Tree, typename RootNodeType::ValueAllIter>;
+    using ValueAllCIter = TreeValueIteratorBase<const Tree, typename RootNodeType::ValueAllCIter>;
+    using ValueOnIter = TreeValueIteratorBase<Tree, typename RootNodeType::ValueOnIter>;
+    using ValueOnCIter = TreeValueIteratorBase<const Tree, typename RootNodeType::ValueOnCIter>;
+    using ValueOffIter = TreeValueIteratorBase<Tree, typename RootNodeType::ValueOffIter>;
+    using ValueOffCIter = TreeValueIteratorBase<const Tree, typename RootNodeType::ValueOffCIter>;
 
     //@{
     /// Return an iterator over all values (tile and voxel) across all nodes.
@@ -1211,11 +1209,8 @@
 
 
 protected:
-    typedef tbb::concurrent_hash_map<ValueAccessorBase<Tree, true>*, bool> AccessorRegistry;
-    typedef tbb::concurrent_hash_map<ValueAccessorBase<const Tree, true>*, bool> ConstAccessorRegistry;
-
-    // Disallow assignment of instances of this class.
-    Tree& operator=(const Tree&);
+    using AccessorRegistry = tbb::concurrent_hash_map<ValueAccessorBase<Tree, true>*, bool>;
+    using ConstAccessorRegistry = tbb::concurrent_hash_map<ValueAccessorBase<const Tree, true>*, bool>;
 
     /// @brief Notify all registered accessors, by calling ValueAccessor::release(),
     /// that this tree is about to be deleted.
@@ -1225,10 +1220,10 @@
     template<typename NodeType>
     struct DeallocateNodes {
         DeallocateNodes(std::vector<NodeType*>& nodes)
-            : mNodes(nodes.empty() ? NULL : &nodes.front()) { }
+            : mNodes(nodes.empty() ? nullptr : &nodes.front()) { }
         void operator()(const tbb::blocked_range<size_t>& range) const {
             for (size_t n = range.begin(), N = range.end(); n < N; ++n) {
-                delete mNodes[n]; mNodes[n] = NULL;
+                delete mNodes[n]; mNodes[n] = nullptr;
             }
         }
         NodeType ** const mNodes;
@@ -1254,7 +1249,7 @@
 /// @note This is NOT the standard tree configuration (Tree4 is).
 template<typename T, Index N1=4, Index N2=3>
 struct Tree3 {
-    typedef Tree<RootNode<InternalNode<LeafNode<T, N2>, N1> > > Type;
+    using Type = Tree<RootNode<InternalNode<LeafNode<T, N2>, N1>>>;
 };
 
 
@@ -1264,7 +1259,7 @@
 /// @note This is the standard tree configuration.
 template<typename T, Index N1=5, Index N2=4, Index N3=3>
 struct Tree4 {
-    typedef Tree<RootNode<InternalNode<InternalNode<LeafNode<T, N3>, N2>, N1> > > Type;
+    using Type = Tree<RootNode<InternalNode<InternalNode<LeafNode<T, N3>, N2>, N1>>>;
 };
 
 /// @brief Tree5<T, N1, N2, N3, N4>::Type is the type of a five-level tree
@@ -1273,8 +1268,8 @@
 /// @note This is NOT the standard tree configuration (Tree4 is).
 template<typename T, Index N1=6, Index N2=5, Index N3=4, Index N4=3>
 struct Tree5 {
-    typedef Tree<RootNode<InternalNode<InternalNode<InternalNode<LeafNode<T, N4>, N3>, N2>, N1> > >
-        Type;
+    using Type =
+        Tree<RootNode<InternalNode<InternalNode<InternalNode<LeafNode<T, N4>, N3>, N2>, N1>>>;
 };
 
 
@@ -1562,7 +1557,7 @@
 inline void
 Tree<RootNodeType>::releaseAllAccessors()
 {
-    mAccessorRegistry.erase(NULL);
+    mAccessorRegistry.erase(nullptr);
     for (typename AccessorRegistry::iterator it = mAccessorRegistry.begin();
         it != mAccessorRegistry.end(); ++it)
     {
@@ -1570,7 +1565,7 @@
     }
     mAccessorRegistry.clear();
 
-    mAccessorRegistry.erase(NULL);
+    mAccessorRegistry.erase(nullptr);
     for (typename ConstAccessorRegistry::iterator it = mConstAccessorRegistry.begin();
         it != mConstAccessorRegistry.end(); ++it)
     {
@@ -1822,7 +1817,7 @@
 {
     Metadata::Ptr result;
     if (Metadata::isRegisteredType(valueType())) {
-        typedef TypedMetadata<ValueType> MetadataT;
+        using MetadataT = TypedMetadata<ValueType>;
         result = Metadata::createMetadata(valueType());
         if (result->typeName() == MetadataT::staticTypeName()) {
             MetadataT* m = static_cast<MetadataT*>(result.get());
@@ -2060,7 +2055,7 @@
 Tree<RootNodeType>::visit2(OtherTreeType& other, VisitorOp& op)
 {
     this->clearAllAccessors();
-    typedef typename OtherTreeType::RootNodeType OtherRootNodeType;
+    using OtherRootNodeType = typename OtherTreeType::RootNodeType;
     mRoot.template visit2<OtherRootNodeType, VisitorOp>(other.root(), op);
 }
 
@@ -2070,7 +2065,7 @@
 inline void
 Tree<RootNodeType>::visit2(OtherTreeType& other, VisitorOp& op) const
 {
-    typedef typename OtherTreeType::RootNodeType OtherRootNodeType;
+    using OtherRootNodeType = typename OtherTreeType::RootNodeType;
     mRoot.template visit2<OtherRootNodeType, VisitorOp>(other.root(), op);
 }
 
@@ -2083,7 +2078,7 @@
 Tree<RootNodeType>::visit2(OtherTreeType& other, const VisitorOp& op)
 {
     this->clearAllAccessors();
-    typedef typename OtherTreeType::RootNodeType OtherRootNodeType;
+    using OtherRootNodeType = typename OtherTreeType::RootNodeType;
     mRoot.template visit2<OtherRootNodeType, const VisitorOp>(other.root(), op);
 }
 
@@ -2095,7 +2090,7 @@
 inline void
 Tree<RootNodeType>::visit2(OtherTreeType& other, const VisitorOp& op) const
 {
-    typedef typename OtherTreeType::RootNodeType OtherRootNodeType;
+    using OtherRootNodeType = typename OtherTreeType::RootNodeType;
     mRoot.template visit2<OtherRootNodeType, const VisitorOp>(other.root(), op);
 }
 
@@ -2107,7 +2102,7 @@
 inline const Name&
 Tree<RootNodeType>::treeType()
 {
-    if (sTreeTypeName == NULL) {
+    if (sTreeTypeName == nullptr) {
         std::vector<Index> dims;
         Tree::getNodeLog2Dims(dims);
         std::ostringstream ostr;
@@ -2116,7 +2111,7 @@
             ostr << "_" << dims[i];
         }
         Name* s = new Name(ostr.str());
-        if (sTreeTypeName.compare_and_swap(s, NULL) != NULL) delete s;
+        if (sTreeTypeName.compare_and_swap(s, nullptr) != nullptr) delete s;
     }
     return *sTreeTypeName;
 }
@@ -2272,7 +2267,7 @@
 
 #ifndef OPENVDB_2_ABI_COMPATIBLE
         if (it.getLevel() == 0) {
-            const LeafNodeType* leaf = NULL;
+            const LeafNodeType* leaf = nullptr;
             it.getNode(leaf);
             if (leaf && !leaf->isAllocated()) ++unallocatedLeafCount;
         }
diff -aur openvdb.3.2.0/tree/ValueAccessor.h openvdb.4.0.0/tree/ValueAccessor.h
--- openvdb.3.2.0/tree/ValueAccessor.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/tree/ValueAccessor.h	2016-10-09 10:18:58.000000000 +0200
@@ -27,7 +27,7 @@
 // LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 //
 ///////////////////////////////////////////////////////////////////////////
-//
+
 /// @file ValueAccessor.h
 ///
 /// When traversing a grid in a spatially coherent pattern (e.g., iterating
@@ -105,18 +105,18 @@
 /// only on the Tree type, so for any given Tree, only two distinct instantiations
 /// are possible, ValueAccessorBase<Tree> and ValueAccessorBase<const Tree>.
 ///
-/// @warning If IsSafe = false then the ValueAccessor will not register itself 
-/// with the tree from which it is constructed. While in some rare cases this can       
+/// @warning If IsSafe = false then the ValueAccessor will not register itself
+/// with the tree from which it is constructed. While in some rare cases this can
 /// lead to better performance (since it avoids the small overhead of insertion
-/// on creation and deletion on destruction) it is also unsafe if the tree is 
-/// modified. So unless you're an expert it is highly recommended to set 
+/// on creation and deletion on destruction) it is also unsafe if the tree is
+/// modified. So unless you're an expert it is highly recommended to set
 /// IsSafe = true, which is the default in all derived ValueAccessors defined
-/// below. However if you know that the tree is no being modifed for the lifespan 
-/// of the ValueAccessor AND the work performed per ValueAccessor is small relative 
-/// to overhead of registering it you should consider setting IsSafe = false. If 
+/// below. However if you know that the tree is no being modifed for the lifespan
+/// of the ValueAccessor AND the work performed per ValueAccessor is small relative
+/// to overhead of registering it you should consider setting IsSafe = false. If
 /// this turns out to improve performance you should really rewrite your code so as
-/// to better amortize the construction of the ValueAccessor, i.e. reuse it as much 
-/// as possible!  
+/// to better amortize the construction of the ValueAccessor, i.e. reuse it as much
+/// as possible!
 template<typename TreeType, bool IsSafe>
 class ValueAccessorBase
 {
@@ -167,7 +167,7 @@
     // Allow trees to deregister themselves.
     template<typename> friend class Tree;
 
-    virtual void release() { mTree = NULL; }
+    virtual void release() { mTree = nullptr; }
 
     TreeType* mTree;
 }; // class ValueAccessorBase
@@ -191,22 +191,22 @@
 /// @param _TreeType    the type of the tree to be accessed [required]
 /// @param IsSafe       if IsSafe = false then the ValueAccessor will
 ///                     not register itself with the tree from which
-///                     it is consturcted (see warning).                     
+///                     it is consturcted (see warning).
 /// @param CacheLevels  the number of nodes to be cached, starting from the leaf level
 ///                     and not including the root (i.e., CacheLevels < DEPTH),
 ///                     and defaulting to all non-root nodes
 /// @param MutexType    the type of mutex to use (see note)
-///    
-/// @warning If IsSafe = false then the ValueAccessor will not register itself 
-/// with the tree from which it is constructed. While in some rare cases this can       
+///
+/// @warning If IsSafe = false then the ValueAccessor will not register itself
+/// with the tree from which it is constructed. While in some rare cases this can
 /// lead to better performance (since it avoids the small overhead of insertion
-/// on creation and deletion on destruction) it is also unsafe if the tree is 
-/// modified. So unless you're an expert it is highly recommended to set 
-/// IsSafe = true, which is the default. However if you know that the tree is no 
-/// being modifed for the lifespan of the ValueAccessor AND the work performed 
-/// per ValueAccessor is small relative to overhead of registering it you should 
-/// consider setting IsSafe = false. If this improves performance you should 
-/// really rewrite your code so as to better amortize the construction of the 
+/// on creation and deletion on destruction) it is also unsafe if the tree is
+/// modified. So unless you're an expert it is highly recommended to set
+/// IsSafe = true, which is the default. However if you know that the tree is no
+/// being modifed for the lifespan of the ValueAccessor AND the work performed
+/// per ValueAccessor is small relative to overhead of registering it you should
+/// consider setting IsSafe = false. If this improves performance you should
+/// really rewrite your code so as to better amortize the construction of the
 /// ValueAccessor, i.e. reuse it as much as possible!
 ///
 /// @note If @c MutexType is a TBB-compatible mutex, then multiple threads may
@@ -349,7 +349,7 @@
     NodeType* getNode()
     {
         LockT lock(mMutex);
-        NodeType* node = NULL;
+        NodeType* node = nullptr;
         mCache.getNode(node);
         return node;
     }
@@ -367,7 +367,7 @@
     /// isCached(xyz) returns @c false for any voxel (x, y, z) contained in
     /// that node.  [Mainly for internal use]
     template<typename NodeType>
-    void eraseNode() { LockT lock(mMutex); NodeType* node = NULL; mCache.erase(node); }
+    void eraseNode() { LockT lock(mMutex); NodeType* node = nullptr; mCache.erase(node); }
 
     /// @brief Add the specified leaf to this tree, possibly creating a child branch
     /// in the process.  If the leaf node already exists, replace it.
@@ -398,7 +398,7 @@
 
     //@{
     /// @brief Return a pointer to the node of the specified type that contains
-    /// voxel (x, y, z), or NULL if no such node exists.
+    /// voxel (x, y, z), or @c nullptr if no such node exists.
     template<typename NodeT>
     NodeT* probeNode(const Coord& xyz)
     {
@@ -420,7 +420,7 @@
 
     //@{
     /// @brief Return a pointer to the leaf node that contains voxel (x, y, z),
-    /// or NULL if no such node exists.
+    /// or @c nullptr if no such node exists.
     LeafNodeT* probeLeaf(const Coord& xyz)
     {
         LockT lock(mMutex);
@@ -522,13 +522,13 @@
 
 /// Template specialization of the ValueAccessor with no mutex and three cache levels
 template<typename TreeType, bool IsSafe>
-class ValueAccessor<TreeType, IsSafe, 3, tbb::null_mutex>
-    : public ValueAccessor3<TreeType, IsSafe>
+class ValueAccessor<TreeType, IsSafe, 3, tbb::null_mutex>: public ValueAccessor3<TreeType, IsSafe>
 {
 public:
     ValueAccessor(TreeType& tree): ValueAccessor3<TreeType, IsSafe>(tree) {}
-    ValueAccessor(const ValueAccessor& other): ValueAccessor3<TreeType, IsSafe>(other) {}
-    virtual ~ValueAccessor() {}
+    ValueAccessor(const ValueAccessor&) = default;
+    ValueAccessor& operator=(const ValueAccessor&) = default;
+    virtual ~ValueAccessor() = default;
 };
 
 
@@ -574,7 +574,7 @@
     CacheItem(TreeCacheT& parent):
         mParent(&parent),
         mHash(CoordLimits::max()),
-        mNode(NULL),
+        mNode(nullptr),
         mNext(parent)
     {
     }
@@ -607,7 +607,7 @@
     /// Cache the given node at this level.
     void insert(const Coord& xyz, const NodeType* node)
     {
-        mHash = (node != NULL) ? xyz & ~(NodeType::DIM-1) : Coord::max();
+        mHash = (node != nullptr) ? xyz & ~(NodeType::DIM-1) : Coord::max();
         mNode = node;
     }
     /// Forward the given node to another level of the cache.
@@ -615,13 +615,13 @@
     void insert(const Coord& xyz, const OtherNodeType* node) { mNext.insert(xyz, node); }
 
     /// Erase the node at this level.
-    void erase(const NodeType*) { mHash = Coord::max(); mNode = NULL; }
+    void erase(const NodeType*) { mHash = Coord::max(); mNode = nullptr; }
     /// Erase the node at another level of the cache.
     template<typename OtherNodeType>
     void erase(const OtherNodeType* node) { mNext.erase(node); }
 
     /// Erase the nodes at this and lower levels of the cache.
-    void clear() { mHash = Coord::max(); mNode = NULL; mNext.clear(); }
+    void clear() { mHash = Coord::max(); mNode = nullptr; mNext.clear(); }
 
     /// Return the cached node (if any) at this level.
     void getNode(const NodeType*& node) const { node = mNode; }
@@ -875,7 +875,7 @@
     typedef typename RootNodeType::ValueType           ValueType;
     typedef typename RootNodeType::LeafNodeType        LeafNodeType;
 
-    CacheItem(TreeCacheT& parent): mParent(&parent), mRoot(NULL) {}
+    CacheItem(TreeCacheT& parent): mParent(&parent), mRoot(nullptr) {}
     CacheItem(TreeCacheT& parent, const CacheItem& other): mParent(&parent), mRoot(other.mRoot) {}
 
     CacheItem& copy(TreeCacheT& parent, const CacheItem& other)
@@ -893,9 +893,9 @@
     template <typename OtherNodeType>
     void insert(const Coord&, const OtherNodeType*) {}
 
-    void erase(const RootNodeType*) { mRoot = NULL; }
+    void erase(const RootNodeType*) { mRoot = nullptr; }
 
-    void clear() { mRoot = NULL; }
+    void clear() { mRoot = nullptr; }
 
     void getNode(RootNodeType*& node)
     {
@@ -1169,7 +1169,7 @@
     void setValueOff(const Coord& xyz) { this->setActiveState(xyz, false); }
 
     /// Return the cached node of type @a NodeType.  [Mainly for internal use]
-    template<typename NodeT> NodeT* getNode() { return NULL; }
+    template<typename NodeT> NodeT* getNode() { return nullptr; }
 
     /// Cache the given node, which should lie along the path from the root node to
     /// the node containing voxel (x, y, z).  [Mainly for internal use]
@@ -1270,7 +1270,7 @@
     typedef typename boost::mpl::at<InvTreeT, boost::mpl::int_<L0> >::type NodeT0;
 
     /// Constructor from a tree
-    ValueAccessor1(TreeType& tree) : BaseT(tree), mKey0(Coord::max()), mNode0(NULL)
+    ValueAccessor1(TreeType& tree) : BaseT(tree), mKey0(Coord::max()), mNode0(nullptr)
     {
     }
 
@@ -1454,7 +1454,7 @@
     template<typename NodeT>
     NodeT* getNode()
     {
-        const NodeT* node = NULL;
+        const NodeT* node = nullptr;
         this->getNode(node);
         return const_cast<NodeT*>(node);
     }
@@ -1470,7 +1470,7 @@
     template<typename NodeT>
     void eraseNode()
     {
-        const NodeT* node = NULL;
+        const NodeT* node = nullptr;
         this->eraseNode(node);
     }
 
@@ -1510,7 +1510,7 @@
     }
 
     /// @brief @return a pointer to the node of the specified type that contains
-    /// voxel (x, y, z) and if it doesn't exist, return NULL.
+    /// voxel (x, y, z) and if it doesn't exist, return @c nullptr.
     template <typename NodeT>
     NodeT* probeNode(const Coord& xyz)
     {
@@ -1524,7 +1524,7 @@
             }
             return BaseT::mTree->root().template probeNodeAndCache<NodeT>(xyz, *this);
         }
-        return NULL;
+        return nullptr;
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
     }
     LeafNodeT* probeLeaf(const Coord& xyz)
@@ -1533,7 +1533,7 @@
     }
 
     /// @brief @return a const pointer to the nodeof the specified type that contains
-    /// voxel (x, y, z) and if it doesn't exist, return NULL.
+    /// voxel (x, y, z) and if it doesn't exist, return @c nullptr.
     template <typename NodeT>
     const NodeT* probeConstNode(const Coord& xyz) const
     {
@@ -1546,7 +1546,7 @@
             }
             return BaseT::mTree->root().template probeConstNodeAndCache<NodeT>(xyz, this->self());
         }
-        return NULL;
+        return nullptr;
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
     }
     const LeafNodeT* probeConstLeaf(const Coord& xyz) const
@@ -1559,7 +1559,7 @@
     virtual void clear()
     {
         mKey0  = Coord::max();
-        mNode0 = NULL;
+        mNode0 = nullptr;
     }
 
 private:
@@ -1576,10 +1576,10 @@
     void getNode(const NodeT0*& node) { node = mNode0; }
     void getNode(const RootNodeT*& node)
     {
-        node = (BaseT::mTree ? &BaseT::mTree->root() : NULL);
+        node = (BaseT::mTree ? &BaseT::mTree->root() : nullptr);
     }
-    template <typename OtherNodeType> void getNode(const OtherNodeType*& node) { node = NULL; }
-    void eraseNode(const NodeT0*) { mKey0 = Coord::max(); mNode0 = NULL; }
+    template <typename OtherNodeType> void getNode(const OtherNodeType*& node) { node = nullptr; }
+    void eraseNode(const NodeT0*) { mKey0 = Coord::max(); mNode0 = nullptr; }
     template <typename OtherNodeType> void eraseNode(const OtherNodeType*) {}
 
     /// Private copy method
@@ -1646,8 +1646,8 @@
 
     /// Constructor from a tree
     ValueAccessor2(TreeType& tree) : BaseT(tree),
-                                     mKey0(Coord::max()), mNode0(NULL),
-                                     mKey1(Coord::max()), mNode1(NULL) {}
+                                     mKey0(Coord::max()), mNode0(nullptr),
+                                     mKey1(Coord::max()), mNode1(nullptr) {}
 
     /// Copy constructor
     ValueAccessor2(const ValueAccessor2& other) : BaseT(other) { this->copy(other); }
@@ -1862,7 +1862,7 @@
     template<typename NodeT>
     NodeT* getNode()
     {
-        const NodeT* node = NULL;
+        const NodeT* node = nullptr;
         this->getNode(node);
         return const_cast<NodeT*>(node);
     }
@@ -1878,7 +1878,7 @@
     template<typename NodeT>
     void eraseNode()
     {
-        const NodeT* node = NULL;
+        const NodeT* node = nullptr;
         this->eraseNode(node);
     }
 
@@ -1928,7 +1928,7 @@
         return BaseT::mTree->root().touchLeafAndCache(xyz, *this);
     }
     /// @brief @return a pointer to the node of the specified type that contains
-    /// voxel (x, y, z) and if it doesn't exist, return NULL.
+    /// voxel (x, y, z) and if it doesn't exist, return @c nullptr.
     template <typename NodeT>
     NodeT* probeNode(const Coord& xyz)
     {
@@ -1951,15 +1951,15 @@
             }
             return BaseT::mTree->root().template probeNodeAndCache<NodeT>(xyz, *this);
         }
-        return NULL;
+        return nullptr;
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
     }
     /// @brief @return a pointer to the leaf node that contains
-    /// voxel (x, y, z) and if it doesn't exist, return NULL.
+    /// voxel (x, y, z) and if it doesn't exist, return @c nullptr.
     LeafNodeT* probeLeaf(const Coord& xyz) { return this->template probeNode<LeafNodeT>(xyz); }
 
     /// @brief @return a const pointer to the node of the specified type that contains
-    /// voxel (x, y, z) and if it doesn't exist, return NULL.
+    /// voxel (x, y, z) and if it doesn't exist, return @c nullptr.
     template <typename NodeT>
     const NodeT* probeConstLeaf(const Coord& xyz) const
     {
@@ -1980,11 +1980,11 @@
             }
             return BaseT::mTree->root().template probeConstNodeAndCache<NodeT>(xyz, this->self());
         }
-        return NULL;
+        return nullptr;
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
     }
     /// @brief @return a const pointer to the leaf node that contains
-    /// voxel (x, y, z) and if it doesn't exist, return NULL.
+    /// voxel (x, y, z) and if it doesn't exist, return @c nullptr.
     const LeafNodeT* probeConstLeaf(const Coord& xyz) const
     {
         return this->template probeConstNode<LeafNodeT>(xyz);
@@ -1992,7 +1992,7 @@
     const LeafNodeT* probeLeaf(const Coord& xyz) const { return this->probeConstLeaf(xyz); }
 
     /// @brief @return a const pointer to the node of the specified type that contains
-    /// voxel (x, y, z) and if it doesn't exist, return NULL.
+    /// voxel (x, y, z) and if it doesn't exist, return @c nullptr.
     template <typename NodeT>
     const NodeT* probeConstNode(const Coord& xyz) const
     {
@@ -2014,7 +2014,7 @@
             }
             return BaseT::mTree->root().template probeConstNodeAndCache<NodeT>(xyz, this->self());
         }
-        return NULL;
+        return nullptr;
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
     }
 
@@ -2022,9 +2022,9 @@
     virtual void clear()
     {
         mKey0  = Coord::max();
-        mNode0 = NULL;
+        mNode0 = nullptr;
         mKey1  = Coord::max();
-        mNode1 = NULL;
+        mNode1 = nullptr;
     }
 
 private:
@@ -2042,12 +2042,12 @@
     void getNode(const NodeT1*& node) { node = mNode1; }
     void getNode(const RootNodeT*& node)
     {
-        node = (BaseT::mTree ? &BaseT::mTree->root() : NULL);
+        node = (BaseT::mTree ? &BaseT::mTree->root() : nullptr);
     }
-    template <typename OtherNodeType> void getNode(const OtherNodeType*& node) { node = NULL; }
+    template <typename OtherNodeType> void getNode(const OtherNodeType*& node) { node = nullptr; }
 
-    void eraseNode(const NodeT0*) { mKey0 = Coord::max(); mNode0 = NULL; }
-    void eraseNode(const NodeT1*) { mKey1 = Coord::max(); mNode1 = NULL; }
+    void eraseNode(const NodeT0*) { mKey0 = Coord::max(); mNode0 = nullptr; }
+    void eraseNode(const NodeT1*) { mKey1 = Coord::max(); mNode1 = nullptr; }
     template <typename OtherNodeType> void eraseNode(const OtherNodeType*) {}
 
     /// Private copy method
@@ -2134,9 +2134,9 @@
 
     /// Constructor from a tree
     ValueAccessor3(TreeType& tree) : BaseT(tree),
-                                     mKey0(Coord::max()), mNode0(NULL),
-                                     mKey1(Coord::max()), mNode1(NULL),
-                                     mKey2(Coord::max()), mNode2(NULL) {}
+                                     mKey0(Coord::max()), mNode0(nullptr),
+                                     mKey1(Coord::max()), mNode1(nullptr),
+                                     mKey2(Coord::max()), mNode2(nullptr) {}
 
     /// Copy constructor
     ValueAccessor3(const ValueAccessor3& other) : BaseT(other) { this->copy(other); }
@@ -2384,7 +2384,7 @@
     template<typename NodeT>
     NodeT* getNode()
     {
-        const NodeT* node = NULL;
+        const NodeT* node = nullptr;
         this->getNode(node);
         return const_cast<NodeT*>(node);
     }
@@ -2400,7 +2400,7 @@
     template<typename NodeT>
     void eraseNode()
     {
-        const NodeT* node = NULL;
+        const NodeT* node = nullptr;
         this->eraseNode(node);
     }
 
@@ -2459,7 +2459,7 @@
         return BaseT::mTree->root().touchLeafAndCache(xyz, *this);
     }
     /// @brief @return a pointer to the node of the specified type that contains
-    /// voxel (x, y, z) and if it doesn't exist, return NULL.
+    /// voxel (x, y, z) and if it doesn't exist, return @c nullptr.
     template <typename NodeT>
     NodeT* probeNode(const Coord& xyz)
     {
@@ -2494,15 +2494,15 @@
             }
             return BaseT::mTree->root().template probeNodeAndCache<NodeT>(xyz, *this);
         }
-        return NULL;
+        return nullptr;
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
     }
     /// @brief @return a pointer to the leaf node that contains
-    /// voxel (x, y, z) and if it doesn't exist, return NULL.
+    /// voxel (x, y, z) and if it doesn't exist, return @c nullptr.
     LeafNodeT* probeLeaf(const Coord& xyz) { return this->template probeNode<LeafNodeT>(xyz); }
 
     /// @brief @return a const pointer to the node of the specified type that contains
-    /// voxel (x, y, z) and if it doesn't exist, return NULL.
+    /// voxel (x, y, z) and if it doesn't exist, return @c nullptr.
     template <typename NodeT>
     const NodeT* probeConstNode(const Coord& xyz) const
     {
@@ -2536,11 +2536,11 @@
             }
             return BaseT::mTree->root().template probeConstNodeAndCache<NodeT>(xyz, this->self());
         }
-        return NULL;
+        return nullptr;
         OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
     }
     /// @brief @return a const pointer to the leaf node that contains
-    /// voxel (x, y, z) and if it doesn't exist, return NULL.
+    /// voxel (x, y, z) and if it doesn't exist, return @c nullptr.
     const LeafNodeT* probeConstLeaf(const Coord& xyz) const
     {
         return this->template probeConstNode<LeafNodeT>(xyz);
@@ -2551,11 +2551,11 @@
     virtual void clear()
     {
         mKey0  = Coord::max();
-        mNode0 = NULL;
+        mNode0 = nullptr;
         mKey1  = Coord::max();
-        mNode1 = NULL;
+        mNode1 = nullptr;
         mKey2  = Coord::max();
-        mNode2 = NULL;
+        mNode2 = nullptr;
     }
 
 private:
@@ -2592,13 +2592,13 @@
     void getNode(const NodeT2*& node) { node = mNode2; }
     void getNode(const RootNodeT*& node)
     {
-        node = (BaseT::mTree ? &BaseT::mTree->root() : NULL);
+        node = (BaseT::mTree ? &BaseT::mTree->root() : nullptr);
     }
-    template <typename OtherNodeType> void getNode(const OtherNodeType*& node) { node = NULL; }
+    template <typename OtherNodeType> void getNode(const OtherNodeType*& node) { node = nullptr; }
 
-    void eraseNode(const NodeT0*) { mKey0 = Coord::max(); mNode0 = NULL; }
-    void eraseNode(const NodeT1*) { mKey1 = Coord::max(); mNode1 = NULL; }
-    void eraseNode(const NodeT2*) { mKey2 = Coord::max(); mNode2 = NULL; }
+    void eraseNode(const NodeT0*) { mKey0 = Coord::max(); mNode0 = nullptr; }
+    void eraseNode(const NodeT1*) { mKey1 = Coord::max(); mNode1 = nullptr; }
+    void eraseNode(const NodeT2*) { mKey2 = Coord::max(); mNode2 = nullptr; }
     template <typename OtherNodeType> void eraseNode(const OtherNodeType*) {}
 
     /// Cache the given node, which should lie along the path from the root node to
diff -aur openvdb.3.2.0/Types.h openvdb.4.0.0/Types.h
--- openvdb.3.2.0/Types.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/Types.h	2016-10-09 10:18:58.000000000 +0200
@@ -43,9 +43,8 @@
 #include <openvdb/math/Mat3.h>
 #include <openvdb/math/Mat4.h>
 #include <openvdb/math/Coord.h>
-#include <boost/type_traits/is_convertible.hpp>
-#include <boost/type_traits/is_integral.hpp>
-#include <boost/static_assert.hpp>
+#include <memory>
+#include <type_traits>
 
 
 namespace openvdb {
@@ -53,62 +52,115 @@
 namespace OPENVDB_VERSION_NAME {
 
 // One-dimensional scalar types
-typedef uint32_t            Index32;
-typedef uint64_t            Index64;
-typedef Index32             Index;
-typedef int16_t             Int16;
-typedef int32_t             Int32;
-typedef int64_t             Int64;
-typedef Int32               Int;
-typedef unsigned char       Byte;
-typedef double              Real;
+using Index32 = uint32_t;
+using Index64 = uint64_t;
+using Index   = Index32;
+using Int16   = int16_t;
+using Int32   = int32_t;
+using Int64   = int64_t;
+using Int     = Int32;
+using Byte    = unsigned char;
+using Real    = double;
 
 // Two-dimensional vector types
-typedef math::Vec2<Real>    Vec2R;
-typedef math::Vec2<Index32> Vec2I;
-typedef math::Vec2<float>   Vec2f;
-typedef math::Vec2<half>    Vec2H;
+using Vec2R = math::Vec2<Real>;
+using Vec2I = math::Vec2<Index32>;
+using Vec2f = math::Vec2<float>;
+using Vec2H = math::Vec2<half>;
 using math::Vec2i;
 using math::Vec2s;
 using math::Vec2d;
 
 // Three-dimensional vector types
-typedef math::Vec3<Real>    Vec3R;
-typedef math::Vec3<Index32> Vec3I;
-typedef math::Vec3<float>   Vec3f;
-typedef math::Vec3<half>    Vec3H;
+using Vec3R = math::Vec3<Real>;
+using Vec3I = math::Vec3<Index32>;
+using Vec3f = math::Vec3<float>;
+using Vec3H = math::Vec3<half>;
 using math::Vec3i;
 using math::Vec3s;
 using math::Vec3d;
 
 using math::Coord;
 using math::CoordBBox;
-typedef math::BBox<Vec3d>   BBoxd;
+using BBoxd = math::BBox<Vec3d>;
 
 // Four-dimensional vector types
-typedef math::Vec4<Real>    Vec4R;
-typedef math::Vec4<Index32> Vec4I;
-typedef math::Vec4<float>   Vec4f;
-typedef math::Vec4<half>    Vec4H;
+using Vec4R = math::Vec4<Real>;
+using Vec4I = math::Vec4<Index32>;
+using Vec4f = math::Vec4<float>;
+using Vec4H = math::Vec4<half>;
 using math::Vec4i;
 using math::Vec4s;
 using math::Vec4d;
 
 // Three-dimensional matrix types
-typedef math::Mat3<Real>    Mat3R;
+using Mat3R = math::Mat3<Real>;
 
 // Four-dimensional matrix types
-typedef math::Mat4<Real>    Mat4R;
-typedef math::Mat4<double>  Mat4d;
-typedef math::Mat4<float>   Mat4s;
+using Mat4R = math::Mat4<Real>;
+using Mat4d = math::Mat4<double>;
+using Mat4s = math::Mat4<float>;
 
 // Quaternions
-typedef math::Quat<Real>    QuatR;
+using QuatR = math::Quat<Real>;
 
 // Dummy type for a voxel with a binary mask value, e.g. the active state
 class ValueMask {};
 
 
+#ifdef OPENVDB_3_ABI_COMPATIBLE
+
+// Use Boost shared pointers in OpenVDB 3 ABI compatibility mode.
+template<typename T> using SharedPtr = boost::shared_ptr<T>;
+
+template<typename T, typename U> inline SharedPtr<T>
+ConstPtrCast(const SharedPtr<U>& ptr) { return boost::const_pointer_cast<T, U>(ptr); }
+
+template<typename T, typename U> inline SharedPtr<T>
+DynamicPtrCast(const SharedPtr<U>& ptr) { return boost::dynamic_pointer_cast<T, U>(ptr); }
+
+template<typename T, typename U> inline SharedPtr<T>
+StaticPtrCast(const SharedPtr<U>& ptr) { return boost::static_pointer_cast<T, U>(ptr); }
+
+#else // if !defined(OPENVDB_3_ABI_COMPATIBLE)
+
+// Use STL shared pointers from OpenVDB 4 on.
+template<typename T> using SharedPtr = std::shared_ptr<T>;
+
+/// @brief Return a new shared pointer that points to the same object
+/// as the given pointer but with possibly different <TT>const</TT>-ness.
+/// @par Example:
+/// @code
+/// FloatGrid::ConstPtr grid = ...;
+/// FloatGrid::Ptr nonConstGrid = ConstPtrCast<FloatGrid>(grid);
+/// FloatGrid::ConstPtr constGrid = ConstPtrCast<const FloatGrid>(nonConstGrid);
+/// @endcode
+template<typename T, typename U> inline SharedPtr<T>
+ConstPtrCast(const SharedPtr<U>& ptr) { return std::const_pointer_cast<T, U>(ptr); }
+
+/// @brief Return a new shared pointer that is either null or points to
+/// the same object as the given pointer after a @c dynamic_cast.
+/// @par Example:
+/// @code
+/// GridBase::ConstPtr grid = ...;
+/// FloatGrid::ConstPtr floatGrid = DynamicPtrCast<const FloatGrid>(grid);
+/// @endcode
+template<typename T, typename U> inline SharedPtr<T>
+DynamicPtrCast(const SharedPtr<U>& ptr) { return std::dynamic_pointer_cast<T, U>(ptr); }
+
+/// @brief Return a new shared pointer that points to the same object
+/// as the given pointer after a @c static_cast.
+/// @par Example:
+/// @code
+/// FloatGrid::Ptr floatGrid = ...;
+/// GridBase::Ptr grid = StaticPtrCast<GridBase>(floatGrid);
+/// @endcode
+template<typename T, typename U> inline SharedPtr<T>
+StaticPtrCast(const SharedPtr<U>& ptr) { return std::static_pointer_cast<T, U>(ptr); }
+
+#endif // OPENVDB_3_ABI_COMPATIBLE
+
+
 ////////////////////////////////////////
 
 
@@ -118,9 +170,9 @@
 template<typename IntType_, Index Kind>
 struct PointIndex
 {
-    BOOST_STATIC_ASSERT(boost::is_integral<IntType_>::value);
+    static_assert(std::is_integral<IntType_>::value, "PointIndex requires an integer value type");
 
-    typedef IntType_ IntType;
+    using IntType = IntType_;
 
     PointIndex(IntType i = IntType(0)): mIndex(i) {}
 
@@ -135,11 +187,11 @@
 };
 
 
-typedef PointIndex<Index32, 0> PointIndex32;
-typedef PointIndex<Index64, 0> PointIndex64;
+using PointIndex32 = PointIndex<Index32, 0>;
+using PointIndex64 = PointIndex<Index64, 0>;
 
-typedef PointIndex<Index32, 1> PointDataIndex32;
-typedef PointIndex<Index64, 1> PointDataIndex64;
+using PointDataIndex32 = PointIndex<Index32, 1>;
+using PointDataIndex64 = PointIndex<Index64, 1>;
 
 
 ////////////////////////////////////////
@@ -148,22 +200,25 @@
 template<typename T> struct VecTraits {
     static const bool IsVec = false;
     static const int Size = 1;
-    typedef T ElementType;
+    using ElementType = T;
 };
+
 template<typename T> struct VecTraits<math::Vec2<T> > {
     static const bool IsVec = true;
     static const int Size = 2;
-    typedef T ElementType;
+    using ElementType = T;
 };
+
 template<typename T> struct VecTraits<math::Vec3<T> > {
     static const bool IsVec = true;
     static const int Size = 3;
-    typedef T ElementType;
+    using ElementType = T;
 };
+
 template<typename T> struct VecTraits<math::Vec4<T> > {
     static const bool IsVec = true;
     static const int Size = 4;
-    typedef T ElementType;
+    using ElementType = T;
 };
 
 
@@ -172,15 +227,8 @@
 
 /// @brief CanConvertType<FromType, ToType>::value is @c true if a value
 /// of type @a ToType can be constructed from a value of type @a FromType.
-///
-/// @note @c boost::is_convertible tests for implicit convertibility only.
-/// What we want is the equivalent of C++11's @c std::is_constructible,
-/// which allows for explicit conversions as well.  Unfortunately, not all
-/// compilers support @c std::is_constructible yet, so for now, types that
-/// can only be converted explicitly have to be indicated with specializations
-/// of this template.
 template<typename FromType, typename ToType>
-struct CanConvertType { enum { value = boost::is_convertible<FromType, ToType>::value }; };
+struct CanConvertType { enum { value = std::is_constructible<ToType, FromType>::value }; };
 
 // Specializations for vector types, which can be constructed from values
 // of their own ValueTypes (or values that can be converted to their ValueTypes),
@@ -198,12 +246,13 @@
 template<typename T0, typename T1>
 struct CanConvertType<T0, math::Vec4<T1> > { enum { value = CanConvertType<T0, T1>::value }; };
 template<> struct CanConvertType<PointIndex32, PointDataIndex32> { enum {value = true}; };
-template<> struct CanConvertType<PointDataIndex32, PointIndex32> { enum {value = true}; };    
+template<> struct CanConvertType<PointDataIndex32, PointIndex32> { enum {value = true}; };
 template<typename T>
 struct CanConvertType<T, ValueMask> { enum {value = CanConvertType<T, bool>::value}; };
 template<typename T>
 struct CanConvertType<ValueMask, T> { enum {value = CanConvertType<bool, T>::value}; };
-    
+
+
 ////////////////////////////////////////
 
 
@@ -312,8 +361,8 @@
 class CombineArgs
 {
 public:
-    typedef AValueType AValueT;
-    typedef BValueType BValueT;
+    using AValueT = AValueType;
+    using BValueT = BValueType;
 
     CombineArgs()
         : mAValPtr(NULL)
@@ -418,6 +467,7 @@
 ////////////////////////////////////////
 
 
+#ifdef OPENVDB_3_ABI_COMPATIBLE
 /// In copy constructors, members stored as shared pointers can be handled
 /// in several ways:
 /// <dl>
@@ -432,15 +482,16 @@
 /// <dd>Create a deep copy of the member.
 /// </dl>
 enum CopyPolicy { CP_NEW, CP_SHARE, CP_COPY };
+#endif
 
 
-// Dummy class that distinguishes shallow copy constructors from
-// deep copy constructors
+/// @brief Tag dispatch class that distinguishes shallow copy constructors
+/// from deep copy constructors
 class ShallowCopy {};
-// Dummy class that distinguishes topology copy constructors from
-// deep copy constructors
+/// @brief Tag dispatch class that distinguishes topology copy constructors
+/// from deep copy constructors
 class TopologyCopy {};
-// Dummy class that distinguishes constructors during file input
+/// @brief Tag dispatch class that distinguishes constructors during file input
 class PartialCreate {};
 
 } // namespace OPENVDB_VERSION_NAME
diff -aur openvdb.3.2.0/unittest/TestConjGradient.cc openvdb.4.0.0/unittest/TestConjGradient.cc
--- openvdb.3.2.0/unittest/TestConjGradient.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestConjGradient.cc	2016-10-09 10:18:58.000000000 +0200
@@ -218,23 +218,23 @@
     // Test small vector - runs in series
     {
         const size_t length = 1000;
-        VectorType aVec(length, 2.f);
-        VectorType bVec(length, 3.f);
+        VectorType aVec(length, 2.0);
+        VectorType bVec(length, 3.0);
 
         VectorType::ValueType result = aVec.dot(bVec);
-        
-        CPPUNIT_ASSERT_DOUBLES_EQUAL( result, 6.f * length, 1.e-7);
-    } 
+
+        CPPUNIT_ASSERT_DOUBLES_EQUAL(result, 6.0 * length, 1.0e-7);
+    }
     // Test long vector  - runs in parallel
     {
         const size_t length = 10034502;
-        VectorType aVec(length, 2.f);
-        VectorType bVec(length, 3.f);
+        VectorType aVec(length, 2.0);
+        VectorType bVec(length, 3.0);
 
         VectorType::ValueType result = aVec.dot(bVec);
-        
-        CPPUNIT_ASSERT_DOUBLES_EQUAL( result, 6.f * length, 1.e-7);
-    } 
+
+        CPPUNIT_ASSERT_DOUBLES_EQUAL(result, 6.0 * length, 1.0e-7);
+    }
 }
 
 // Copyright (c) 2012-2016 DreamWorks Animation LLC
diff -aur openvdb.3.2.0/unittest/TestCoord.cc openvdb.4.0.0/unittest/TestCoord.cc
--- openvdb.3.2.0/unittest/TestCoord.cc	2016-07-24 09:29:15.000000000 +0200
+++ openvdb.4.0.0/unittest/TestCoord.cc	2016-10-09 10:18:58.000000000 +0200
@@ -58,6 +58,11 @@
 {
     using openvdb::Coord;
 
+    for (int i=0; i<3; ++i) {
+        CPPUNIT_ASSERT_EQUAL(Coord::min()[i], std::numeric_limits<Coord::Int32>::min());
+        CPPUNIT_ASSERT_EQUAL(Coord::max()[i], std::numeric_limits<Coord::Int32>::max());
+    }
+
     Coord xyz(-1, 2, 4);
     Coord xyz2 = -xyz;
     CPPUNIT_ASSERT_EQUAL(Coord(1, -2, -4), xyz2);
diff -aur openvdb.3.2.0/unittest/TestFile.cc openvdb.4.0.0/unittest/TestFile.cc
--- openvdb.3.2.0/unittest/TestFile.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestFile.cc	2016-10-09 10:18:58.000000000 +0200
@@ -28,10 +28,6 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 
-#include <boost/bind.hpp>
-#include <boost/uuid/uuid_generators.hpp>
-#include <cppunit/extensions/HelperMacros.h>
-#include <tbb/tbb_thread.h> // for tbb::this_tbb_thread::sleep()
 #include <openvdb/Exceptions.h>
 #include <openvdb/io/File.h>
 #include <openvdb/io/Queue.h>
@@ -42,11 +38,17 @@
 #include <openvdb/version.h>
 #include <openvdb/openvdb.h>
 #include "util.h" // for unittest_util::makeSphere()
+#include <boost/scoped_array.hpp>
+#include <cppunit/extensions/HelperMacros.h>
+#include <tbb/tbb_thread.h> // for tbb::this_tbb_thread::sleep()
+#include <algorithm> // for std::sort()
 #include <cstdio> // for remove() and rename()
 #include <fstream>
+#include <functional> // for std::bind()
 #include <iostream>
 #include <map>
 #include <set>
+#include <sstream>
 #include <vector>
 #include <sys/types.h> // for stat()
 #include <sys/stat.h>
@@ -62,8 +64,8 @@
 class TestFile: public CppUnit::TestCase
 {
 public:
-    virtual void setUp() {}
-    virtual void tearDown() { openvdb::uninitialize(); }
+    void setUp() override {}
+    void tearDown() override { openvdb::uninitialize(); }
 
     CPPUNIT_TEST_SUITE(TestFile);
     CPPUNIT_TEST(testHeader);
@@ -173,8 +175,8 @@
     using namespace openvdb;
     using namespace openvdb::io;
 
-    typedef Int32Tree TreeType;
-    typedef Grid<TreeType> GridType;
+    using TreeType = Int32Tree;
+    using GridType = Grid<TreeType>;
 
     File file("something.vdb2");
 
@@ -275,8 +277,8 @@
     // Read in the data blocks.
     gd2.seekToBlocks(istr);
     gd2_grid->readBuffers(istr);
-    TreeType::Ptr tree2 = boost::dynamic_pointer_cast<TreeType>(gd2_grid->baseTreePtr());
-    CPPUNIT_ASSERT(tree2.get() != NULL);
+    TreeType::Ptr tree2 = DynamicPtrCast<TreeType>(gd2_grid->baseTreePtr());
+    CPPUNIT_ASSERT(tree2.get() != nullptr);
     CPPUNIT_ASSERT_EQUAL(10, tree2->getValue(Coord(10, 1, 2)));
     CPPUNIT_ASSERT_EQUAL(5, tree2->getValue(Coord(0, 0, 0)));
 
@@ -296,8 +298,8 @@
     using namespace openvdb;
     using namespace openvdb::io;
 
-    typedef Int32Tree TreeType;
-    typedef Grid<TreeType> GridType;
+    using TreeType = Int32Tree;
+    using GridType = Grid<TreeType>;
 
     File file("something.vdb2");
 
@@ -385,8 +387,8 @@
     // Read in the data blocks.
     gd_in.seekToBlocks(istr);
     gd_in_grid->readBuffers(istr);
-    TreeType::Ptr grid_in = boost::dynamic_pointer_cast<TreeType>(gd_in_grid->baseTreePtr());
-    CPPUNIT_ASSERT(grid_in.get() != NULL);
+    TreeType::Ptr grid_in = DynamicPtrCast<TreeType>(gd_in_grid->baseTreePtr());
+    CPPUNIT_ASSERT(grid_in.get() != nullptr);
     CPPUNIT_ASSERT_EQUAL(10, grid_in->getValue(Coord(10, 1, 2)));
     CPPUNIT_ASSERT_EQUAL(5, grid_in->getValue(Coord(0, 0, 0)));
     CPPUNIT_ASSERT_EQUAL(1, grid_in->getValue(Coord(1000, 1000, 16000)));
@@ -429,9 +431,8 @@
     // Read in the data blocks.
     gd2_in.seekToBlocks(istr);
     gd2_in_grid->readBuffers(istr);
-    TreeType::Ptr grid2_in =
-        boost::dynamic_pointer_cast<TreeType>(gd2_in_grid->baseTreePtr());
-    CPPUNIT_ASSERT(grid2_in.get() != NULL);
+    TreeType::Ptr grid2_in = DynamicPtrCast<TreeType>(gd2_in_grid->baseTreePtr());
+    CPPUNIT_ASSERT(grid2_in.get() != nullptr);
     CPPUNIT_ASSERT_EQUAL(50, grid2_in->getValue(Coord(1000, 1000, 1000)));
     CPPUNIT_ASSERT_EQUAL(10, grid2_in->getValue(Coord(0, 0, 0)));
     CPPUNIT_ASSERT_EQUAL(2, grid2_in->getValue(Coord(100000, 100000, 16000)));
@@ -450,24 +451,24 @@
     using namespace openvdb;
     using namespace openvdb::io;
 
-    typedef Vec3STree TreeType;
-    typedef Grid<TreeType> GridType;
+    using TreeType = Vec3STree;
+    using GridType = Grid<TreeType>;
 
     // Register all grid types.
     initialize();
     // Ensure that the registry is cleared on exit.
     struct Local { static void uninitialize(char*) { openvdb::uninitialize(); } };
-    boost::shared_ptr<char> onExit((char*)(0), Local::uninitialize);
+    SharedPtr<char> onExit(nullptr, Local::uninitialize);
 
     // Create two test grids.
     GridType::Ptr grid1 = createGrid<GridType>(/*bg=*/Vec3s(1, 1, 1));
     TreeType& tree1 = grid1->tree();
-    CPPUNIT_ASSERT(grid1.get() != NULL);
+    CPPUNIT_ASSERT(grid1.get() != nullptr);
     grid1->setTransform(math::Transform::createLinearTransform(0.1));
     grid1->setName("grid1");
 
     GridType::Ptr grid2 = createGrid<GridType>(/*bg=*/Vec3s(2, 2, 2));
-    CPPUNIT_ASSERT(grid2.get() != NULL);
+    CPPUNIT_ASSERT(grid2.get() != nullptr);
     TreeType& tree2 = grid2->tree();
     grid2->setTransform(math::Transform::createLinearTransform(0.2));
     // Flag this grid for 16-bit float output.
@@ -502,14 +503,14 @@
             bgrid2 = vdbFile.readGrid("grid2");
         vdbFile.close();
 
-        CPPUNIT_ASSERT(bgrid1.get() != NULL);
+        CPPUNIT_ASSERT(bgrid1.get() != nullptr);
         CPPUNIT_ASSERT(bgrid1->isType<GridType>());
-        CPPUNIT_ASSERT(bgrid2.get() != NULL);
+        CPPUNIT_ASSERT(bgrid2.get() != nullptr);
         CPPUNIT_ASSERT(bgrid2->isType<GridType>());
 
-        const TreeType& btree1 = boost::static_pointer_cast<GridType>(bgrid1)->tree();
+        const TreeType& btree1 = StaticPtrCast<GridType>(bgrid1)->tree();
         CPPUNIT_ASSERT_EQUAL(Vec3s(10, 10, 10), btree1.getValue(Coord(10, 10, 10)));
-        const TreeType& btree2 = boost::static_pointer_cast<GridType>(bgrid2)->tree();
+        const TreeType& btree2 = StaticPtrCast<GridType>(bgrid2)->tree();
         CPPUNIT_ASSERT_EQUAL(Vec3s(10, 10, 10), btree2.getValue(Coord(10, 10, 10)));
     }
 }
@@ -528,7 +529,7 @@
     // We will not be able to remove something.vdb2 on Windows if the pointers
     // are still referencing data opened by the "file" variable.
     const char* filename = "something.vdb2";
-    boost::shared_ptr<const char> scopedFile(filename, ::remove);
+    SharedPtr<const char> scopedFile(filename, ::remove);
 
     // Create grids.
     Int32Tree::Ptr tree1(new Int32Tree(1));
@@ -580,40 +581,40 @@
     meta = file.getMetadata();
 
     // Verify the metadata.
-    CPPUNIT_ASSERT(meta.get() != NULL);
+    CPPUNIT_ASSERT(meta.get() != nullptr);
     CPPUNIT_ASSERT_EQUAL(2, int(meta->metaCount()));
     CPPUNIT_ASSERT_EQUAL(std::string("Einstein"), meta->metaValue<std::string>("author"));
     CPPUNIT_ASSERT_EQUAL(2009, meta->metaValue<int32_t>("year"));
 
     // Verify the grids.
-    CPPUNIT_ASSERT(grids.get() != NULL);
+    CPPUNIT_ASSERT(grids.get() != nullptr);
     CPPUNIT_ASSERT_EQUAL(4, int(grids->size()));
 
     GridBase::Ptr grid = findGridByName(*grids, "density");
-    CPPUNIT_ASSERT(grid.get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
     Int32Tree::Ptr density = gridPtrCast<Int32Grid>(grid)->treePtr();
-    CPPUNIT_ASSERT(density.get() != NULL);
+    CPPUNIT_ASSERT(density.get() != nullptr);
 
     grid.reset();
     grid = findGridByName(*grids, "density_copy");
-    CPPUNIT_ASSERT(grid.get() != NULL);
-    CPPUNIT_ASSERT(gridPtrCast<Int32Grid>(grid)->treePtr().get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
+    CPPUNIT_ASSERT(gridPtrCast<Int32Grid>(grid)->treePtr().get() != nullptr);
     // Verify that "density_copy" is an instance of (i.e., shares a tree with) "density".
     CPPUNIT_ASSERT_EQUAL(density, gridPtrCast<Int32Grid>(grid)->treePtr());
 
     grid.reset();
     grid = findGridByName(*grids, "");
-    CPPUNIT_ASSERT(grid.get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
     FloatTree::Ptr temperature = gridPtrCast<FloatGrid>(grid)->treePtr();
-    CPPUNIT_ASSERT(temperature.get() != NULL);
+    CPPUNIT_ASSERT(temperature.get() != nullptr);
 
     grid.reset();
     for (GridPtrVec::reverse_iterator it = grids->rbegin(); !grid && it != grids->rend(); ++it) {
         // Search for the second unnamed grid starting from the end of the list.
         if ((*it)->getName() == "") grid = *it;
     }
-    CPPUNIT_ASSERT(grid.get() != NULL);
-    CPPUNIT_ASSERT(gridPtrCast<FloatGrid>(grid)->treePtr().get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
+    CPPUNIT_ASSERT(gridPtrCast<FloatGrid>(grid)->treePtr().get() != nullptr);
     // Verify that the second unnamed grid is an instance of the first.
     CPPUNIT_ASSERT_EQUAL(temperature, gridPtrCast<FloatGrid>(grid)->treePtr());
 
@@ -630,27 +631,27 @@
     CPPUNIT_ASSERT_EQUAL(4, int(grids->size()));
 
     grid = findGridByName(*grids, "density");
-    CPPUNIT_ASSERT(grid.get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
     density = gridPtrCast<Int32Grid>(grid)->treePtr();
-    CPPUNIT_ASSERT(density.get() != NULL);
+    CPPUNIT_ASSERT(density.get() != nullptr);
     grid = findGridByName(*grids, "density_copy");
-    CPPUNIT_ASSERT(grid.get() != NULL);
-    CPPUNIT_ASSERT(gridPtrCast<Int32Grid>(grid)->treePtr().get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
+    CPPUNIT_ASSERT(gridPtrCast<Int32Grid>(grid)->treePtr().get() != nullptr);
     // Verify that "density_copy" is *not* an instance of "density".
     CPPUNIT_ASSERT(gridPtrCast<Int32Grid>(grid)->treePtr() != density);
 
     // Verify that the two unnamed grids are not instances of each other.
     grid = findGridByName(*grids, "");
-    CPPUNIT_ASSERT(grid.get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
     temperature = gridPtrCast<FloatGrid>(grid)->treePtr();
-    CPPUNIT_ASSERT(temperature.get() != NULL);
+    CPPUNIT_ASSERT(temperature.get() != nullptr);
     grid.reset();
     for (GridPtrVec::reverse_iterator it = grids->rbegin(); !grid && it != grids->rend(); ++it) {
         // Search for the second unnamed grid starting from the end of the list.
         if ((*it)->getName() == "") grid = *it;
     }
-    CPPUNIT_ASSERT(grid.get() != NULL);
-    CPPUNIT_ASSERT(gridPtrCast<FloatGrid>(grid)->treePtr().get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
+    CPPUNIT_ASSERT(gridPtrCast<FloatGrid>(grid)->treePtr().get() != nullptr);
     CPPUNIT_ASSERT(gridPtrCast<FloatGrid>(grid)->treePtr() != temperature);
 
     // Rewrite with instancing disabled, then reread with instancing enabled.
@@ -660,7 +661,7 @@
         /// no longer a need for delayed load from the old file, replace it
         /// with the new file.
         const char* tempFilename = "somethingelse.vdb";
-        boost::shared_ptr<const char> scopedTempFile(tempFilename, ::remove);
+        SharedPtr<const char> scopedTempFile(tempFilename, ::remove);
         io::File vdbFile(tempFilename);
         vdbFile.setInstancingEnabled(false);
         vdbFile.write(*grids, *meta);
@@ -676,26 +677,26 @@
 
     // Verify that "density_copy" is not an instance of "density".
     grid = findGridByName(*grids, "density");
-    CPPUNIT_ASSERT(grid.get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
     density = gridPtrCast<Int32Grid>(grid)->treePtr();
-    CPPUNIT_ASSERT(density.get() != NULL);
+    CPPUNIT_ASSERT(density.get() != nullptr);
     grid = findGridByName(*grids, "density_copy");
-    CPPUNIT_ASSERT(grid.get() != NULL);
-    CPPUNIT_ASSERT(gridPtrCast<Int32Grid>(grid)->treePtr().get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
+    CPPUNIT_ASSERT(gridPtrCast<Int32Grid>(grid)->treePtr().get() != nullptr);
     CPPUNIT_ASSERT(gridPtrCast<Int32Grid>(grid)->treePtr() != density);
 
     // Verify that the two unnamed grids are not instances of each other.
     grid = findGridByName(*grids, "");
-    CPPUNIT_ASSERT(grid.get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
     temperature = gridPtrCast<FloatGrid>(grid)->treePtr();
-    CPPUNIT_ASSERT(temperature.get() != NULL);
+    CPPUNIT_ASSERT(temperature.get() != nullptr);
     grid.reset();
     for (GridPtrVec::reverse_iterator it = grids->rbegin(); !grid && it != grids->rend(); ++it) {
         // Search for the second unnamed grid starting from the end of the list.
         if ((*it)->getName() == "") grid = *it;
     }
-    CPPUNIT_ASSERT(grid.get() != NULL);
-    CPPUNIT_ASSERT(gridPtrCast<FloatGrid>(grid)->treePtr().get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
+    CPPUNIT_ASSERT(gridPtrCast<FloatGrid>(grid)->treePtr().get() != nullptr);
     CPPUNIT_ASSERT(gridPtrCast<FloatGrid>(grid)->treePtr() != temperature);
 }
 
@@ -706,8 +707,8 @@
     using namespace openvdb;
     using namespace openvdb::io;
 
-    typedef Int32Grid GridType;
-    typedef GridType::TreeType TreeType;
+    using GridType = Int32Grid;
+    using TreeType = GridType::TreeType;
 
     File file("something.vdb2");
 
@@ -735,7 +736,7 @@
 
     // Write out the number of grids.
     int32_t gridCount = 2;
-    ostr.write((char*)&gridCount, sizeof(int32_t));
+    ostr.write(reinterpret_cast<char*>(&gridCount), sizeof(int32_t));
     // Write out the grids.
     file.writeGrid(gd, grid, ostr, /*seekable=*/true);
     file.writeGrid(gd2, grid2, ostr, /*seekable=*/true);
@@ -790,7 +791,7 @@
     using namespace openvdb;
     using namespace openvdb::io;
 
-    typedef Int32Tree TreeType;
+    using TreeType = Int32Tree;
 
     // Register data types.
     openvdb::initialize();
@@ -816,7 +817,7 @@
     }
 
     const char* filename = "testGridNaming.vdb2";
-    boost::shared_ptr<const char> scopedFile(filename, ::remove);
+    SharedPtr<const char> scopedFile(filename, ::remove);
 
     // Test first with grid instancing disabled, then with instancing enabled.
     for (int instancing = 0; instancing <= 1; ++instancing) {
@@ -853,7 +854,7 @@
 
             // Partially read the current grid.
             GridBase::ConstPtr grid = file.readGridPartial(name);
-            CPPUNIT_ASSERT(grid.get() != NULL);
+            CPPUNIT_ASSERT(grid.get() != nullptr);
 
             // Verify that the grid is named "grid".
             CPPUNIT_ASSERT_EQUAL(openvdb::Name("grid"), grid->getName());
@@ -862,21 +863,21 @@
 
             // Fully read the current grid.
             grid = file.readGrid(name);
-            CPPUNIT_ASSERT(grid.get() != NULL);
+            CPPUNIT_ASSERT(grid.get() != nullptr);
             CPPUNIT_ASSERT_EQUAL(openvdb::Name("grid"), grid->getName());
             CPPUNIT_ASSERT_EQUAL((n < 0 ? 0 : n), grid->metaValue<openvdb::Int32>("index"));
         }
 
         // Read all three grids at once.
         GridPtrVecPtr allGrids = file.getGrids();
-        CPPUNIT_ASSERT(allGrids.get() != NULL);
+        CPPUNIT_ASSERT(allGrids.get() != nullptr);
         CPPUNIT_ASSERT_EQUAL(3, int(allGrids->size()));
 
         GridBase::ConstPtr firstGrid;
         std::vector<int> indices;
         for (GridPtrVecCIter i = allGrids->begin(), e = allGrids->end(); i != e; ++i) {
             GridBase::ConstPtr grid = *i;
-            CPPUNIT_ASSERT(grid.get() != NULL);
+            CPPUNIT_ASSERT(grid.get() != nullptr);
 
             indices.push_back(grid->metaValue<openvdb::Int32>("index"));
 
@@ -909,20 +910,20 @@
 
         // Verify that the grid can be read and that its index is 0.
         GridBase::ConstPtr grid = file.readGrid(weirdName);
-        CPPUNIT_ASSERT(grid.get() != NULL);
+        CPPUNIT_ASSERT(grid.get() != nullptr);
         CPPUNIT_ASSERT_EQUAL(weirdName, grid->getName());
         CPPUNIT_ASSERT_EQUAL(0, grid->metaValue<openvdb::Int32>("index"));
 
         // Verify that the other grids can still be read successfully.
         grid = file.readGrid("grid[0]");
-        CPPUNIT_ASSERT(grid.get() != NULL);
+        CPPUNIT_ASSERT(grid.get() != nullptr);
         CPPUNIT_ASSERT_EQUAL(openvdb::Name("grid"), grid->getName());
         // Because there are now only two grids named "grid", the one with
         // index 1 is now "grid[0]".
         CPPUNIT_ASSERT_EQUAL(1, grid->metaValue<openvdb::Int32>("index"));
 
         grid = file.readGrid("grid[1]");
-        CPPUNIT_ASSERT(grid.get() != NULL);
+        CPPUNIT_ASSERT(grid.get() != nullptr);
         CPPUNIT_ASSERT_EQUAL(openvdb::Name("grid"), grid->getName());
         // Because there are now only two grids named "grid", the one with
         // index 2 is now "grid[1]".
@@ -941,7 +942,7 @@
     using namespace openvdb::io;
 
     const char* filename = "testEmptyFile.vdb2";
-    boost::shared_ptr<const char> scopedFile(filename, ::remove);
+    SharedPtr<const char> scopedFile(filename, ::remove);
 
     {
         File file(filename);
@@ -953,10 +954,10 @@
     GridPtrVecPtr grids = file.getGrids();
     MetaMap::Ptr meta = file.getMetadata();
 
-    CPPUNIT_ASSERT(grids.get() != NULL);
+    CPPUNIT_ASSERT(grids.get() != nullptr);
     CPPUNIT_ASSERT(grids->empty());
 
-    CPPUNIT_ASSERT(meta.get() != NULL);
+    CPPUNIT_ASSERT(meta.get() != nullptr);
     CPPUNIT_ASSERT_EQUAL(0, int(meta->metaCount()));
 }
 
@@ -967,10 +968,10 @@
     using namespace openvdb;
     using namespace openvdb::io;
 
-    typedef Int32Grid GridType;
+    using GridType = Int32Grid;
 
     const char* filename = "something.vdb2";
-    boost::shared_ptr<const char> scopedFile(filename, ::remove);
+    SharedPtr<const char> scopedFile(filename, ::remove);
 
     File file(filename);
 
@@ -992,7 +993,7 @@
 
     // Write out the number of grids.
     int32_t gridCount = 2;
-    ostr.write((char*)&gridCount, sizeof(int32_t));
+    ostr.write(reinterpret_cast<char*>(&gridCount), sizeof(int32_t));
     // Write out the grids.
     file.writeGrid(gd, grid, ostr, /*seekable=*/true);
     file.writeGrid(gd2, grid2, ostr, /*seekable=*/true);
@@ -1033,7 +1034,7 @@
     gd_grid->readTransform(istr);
     gd_grid->readTopology(istr);
     CPPUNIT_ASSERT_EQUAL(gd.gridName(), file2gd.gridName());
-    CPPUNIT_ASSERT(gd_grid.get() != NULL);
+    CPPUNIT_ASSERT(gd_grid.get() != nullptr);
     CPPUNIT_ASSERT_EQUAL(0, int(gd_grid->baseTree().leafCount()));
     //CPPUNIT_ASSERT_EQUAL(8, int(gd_grid->baseTree().nonLeafCount()));
     CPPUNIT_ASSERT_EQUAL(4, int(gd_grid->baseTree().treeDepth()));
@@ -1051,7 +1052,7 @@
     gd_grid->readTransform(istr);
     gd_grid->readTopology(istr);
     CPPUNIT_ASSERT_EQUAL(gd2.gridName(), file2gd.gridName());
-    CPPUNIT_ASSERT(gd_grid.get() != NULL);
+    CPPUNIT_ASSERT(gd_grid.get() != nullptr);
     CPPUNIT_ASSERT_EQUAL(0, int(gd_grid->baseTree().leafCount()));
     //CPPUNIT_ASSERT_EQUAL(8, int(gd_grid->nonLeafCount()));
     CPPUNIT_ASSERT_EQUAL(4, int(gd_grid->baseTree().treeDepth()));
@@ -1070,10 +1071,10 @@
 {
     using namespace openvdb;
 
-    typedef openvdb::FloatGrid FloatGrid;
-    typedef openvdb::Int32Grid IntGrid;
-    typedef FloatGrid::TreeType FloatTree;
-    typedef Int32Grid::TreeType IntTree;
+    using FloatGrid = openvdb::FloatGrid;
+    using IntGrid = openvdb::Int32Grid;
+    using FloatTree = FloatGrid::TreeType;
+    using IntTree = Int32Grid::TreeType;
 
     // Create a VDB to write.
 
@@ -1181,7 +1182,7 @@
     // Test closing the file.
     vdbfile.close();
     CPPUNIT_ASSERT(vdbfile.isOpen() == false);
-    CPPUNIT_ASSERT(vdbfile.fileMetadata().get() == NULL);
+    CPPUNIT_ASSERT(vdbfile.fileMetadata().get() == nullptr);
     CPPUNIT_ASSERT_EQUAL(0, int(vdbfile.gridDescriptors().size()));
     CPPUNIT_ASSERT_THROW(vdbfile.inputStream(), openvdb::IoError);
 
@@ -1195,7 +1196,7 @@
     std::ofstream file("dummy.vdb2", std::ios_base::binary);
 
     int64_t something = 1;
-    file.write((char*)&something, sizeof(int64_t));
+    file.write(reinterpret_cast<char*>(&something), sizeof(int64_t));
 
     file.close();
 
@@ -1251,10 +1252,10 @@
 {
     using namespace openvdb;
 
-    typedef openvdb::FloatGrid FloatGrid;
-    typedef openvdb::Int32Grid IntGrid;
-    typedef FloatGrid::TreeType FloatTree;
-    typedef Int32Grid::TreeType IntTree;
+    using FloatGrid = openvdb::FloatGrid;
+    using IntGrid = openvdb::Int32Grid;
+    using FloatTree = FloatGrid::TreeType;
+    using IntTree = Int32Grid::TreeType;
 
     // Create a vdb to write.
 
@@ -1314,15 +1315,15 @@
     GridBase::Ptr grid;
     grid.reset();
     grid = findGridByName(*grids2, "density");
-    CPPUNIT_ASSERT(grid.get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
     IntTree::Ptr density = gridPtrCast<IntGrid>(grid)->treePtr();
-    CPPUNIT_ASSERT(density.get() != NULL);
+    CPPUNIT_ASSERT(density.get() != nullptr);
 
     grid.reset();
     grid = findGridByName(*grids2, "temperature");
-    CPPUNIT_ASSERT(grid.get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
     FloatTree::Ptr temperature = gridPtrCast<FloatGrid>(grid)->treePtr();
-    CPPUNIT_ASSERT(temperature.get() != NULL);
+    CPPUNIT_ASSERT(temperature.get() != nullptr);
 
     CPPUNIT_ASSERT_DOUBLES_EQUAL(5, density->getValue(Coord(0, 0, 0)), /*tolerance=*/0);
     CPPUNIT_ASSERT_DOUBLES_EQUAL(6, density->getValue(Coord(100, 0, 0)), /*tolerance=*/0);
@@ -1368,13 +1369,13 @@
     meta = vdbfile2.getMetadata();
 
     // Ensure we have the metadata.
-    CPPUNIT_ASSERT(meta.get() != NULL);
+    CPPUNIT_ASSERT(meta.get() != nullptr);
     CPPUNIT_ASSERT_EQUAL(2, int(meta->metaCount()));
     CPPUNIT_ASSERT(meta->metaValue<std::string>("author") == "Einstein");
     CPPUNIT_ASSERT_EQUAL(2009, meta->metaValue<int32_t>("year"));
 
     // Ensure we got the grids.
-    CPPUNIT_ASSERT(grids.get() != NULL);
+    CPPUNIT_ASSERT(grids.get() != nullptr);
     CPPUNIT_ASSERT_EQUAL(0, int(grids->size()));
 
     // Cannot write an open file.
@@ -1399,7 +1400,7 @@
     openvdb::initialize();
 
     const char* filename = "testReadGridMetadata.vdb2";
-    boost::shared_ptr<const char> scopedFile(filename, ::remove);
+    SharedPtr<const char> scopedFile(filename, ::remove);
 
     // Create grids
     Int32Grid::Ptr igrid = createGrid<Int32Grid>(/*bg=*/1);
@@ -1462,17 +1463,17 @@
 
         // Read all grids and store them in a list.
         GridPtrVecPtr gridMetadata = vdbfile.readAllGridMetadata();
-        CPPUNIT_ASSERT(gridMetadata.get() != NULL);
+        CPPUNIT_ASSERT(gridMetadata.get() != nullptr);
         CPPUNIT_ASSERT_EQUAL(2, int(gridMetadata->size()));
 
         // Read individual grids and append them to the list.
         GridBase::Ptr grid = vdbfile.readGridMetadata("igrid");
-        CPPUNIT_ASSERT(grid.get() != NULL);
+        CPPUNIT_ASSERT(grid.get() != nullptr);
         CPPUNIT_ASSERT_EQUAL(std::string("igrid"), grid->getName());
         gridMetadata->push_back(grid);
 
         grid = vdbfile.readGridMetadata("fgrid");
-        CPPUNIT_ASSERT(grid.get() != NULL);
+        CPPUNIT_ASSERT(grid.get() != nullptr);
         CPPUNIT_ASSERT_EQUAL(std::string("fgrid"), grid->getName());
         gridMetadata->push_back(grid);
 
@@ -1480,9 +1481,9 @@
         for (size_t i = 0, N = gridMetadata->size(); i < N; ++i) {
             grid = (*gridMetadata)[i];
 
-            CPPUNIT_ASSERT(grid.get() != NULL);
+            CPPUNIT_ASSERT(grid.get() != nullptr);
             CPPUNIT_ASSERT(grid->getName() == "igrid" || grid->getName() == "fgrid");
-            CPPUNIT_ASSERT(grid->baseTreePtr().get() != NULL);
+            CPPUNIT_ASSERT(grid->baseTreePtr().get() != nullptr);
 
             // Since we didn't read the grid's topology, the tree should be empty.
             CPPUNIT_ASSERT_EQUAL(0, int(grid->constBaseTreePtr()->leafCount()));
@@ -1530,10 +1531,10 @@
 {
     using namespace openvdb;
 
-    typedef openvdb::FloatGrid FloatGrid;
-    typedef openvdb::Int32Grid IntGrid;
-    typedef FloatGrid::TreeType FloatTree;
-    typedef Int32Grid::TreeType IntTree;
+    using FloatGrid = openvdb::FloatGrid;
+    using IntGrid = openvdb::Int32Grid;
+    using FloatTree = FloatGrid::TreeType;
+    using IntTree = Int32Grid::TreeType;
 
     // Create grids
     IntGrid::Ptr grid = createGrid<IntGrid>(/*bg=*/1);
@@ -1583,11 +1584,11 @@
 
     GridBase::ConstPtr density = vdbfile2.readGridPartial("density");
 
-    CPPUNIT_ASSERT(density.get() != NULL);
+    CPPUNIT_ASSERT(density.get() != nullptr);
 
     IntTree::ConstPtr typedDensity = gridConstPtrCast<IntGrid>(density)->treePtr();
 
-    CPPUNIT_ASSERT(typedDensity.get() != NULL);
+    CPPUNIT_ASSERT(typedDensity.get() != nullptr);
 
     // the following should cause a compiler error.
     // typedDensity->setValue(0, 0, 0, 0);
@@ -1608,10 +1609,10 @@
 {
     using namespace openvdb;
 
-    typedef openvdb::FloatGrid FloatGrid;
-    typedef openvdb::Int32Grid IntGrid;
-    typedef FloatGrid::TreeType FloatTree;
-    typedef Int32Grid::TreeType IntTree;
+    using FloatGrid = openvdb::FloatGrid;
+    using IntGrid = openvdb::Int32Grid;
+    using FloatTree = FloatGrid::TreeType;
+    using IntTree = Int32Grid::TreeType;
 
     // Create a vdb to write.
 
@@ -1664,11 +1665,11 @@
     // Get Temperature
     GridBase::Ptr temperature = vdbfile2.readGrid("temperature");
 
-    CPPUNIT_ASSERT(temperature.get() != NULL);
+    CPPUNIT_ASSERT(temperature.get() != nullptr);
 
     FloatTree::Ptr typedTemperature = gridPtrCast<FloatGrid>(temperature)->treePtr();
 
-    CPPUNIT_ASSERT(typedTemperature.get() != NULL);
+    CPPUNIT_ASSERT(typedTemperature.get() != nullptr);
 
     CPPUNIT_ASSERT_DOUBLES_EQUAL(10, typedTemperature->getValue(Coord(0, 0, 0)), 0);
     CPPUNIT_ASSERT_DOUBLES_EQUAL(11, typedTemperature->getValue(Coord(0, 100, 0)), 0);
@@ -1676,11 +1677,11 @@
     // Get Density
     GridBase::Ptr density = vdbfile2.readGrid("density");
 
-    CPPUNIT_ASSERT(density.get() != NULL);
+    CPPUNIT_ASSERT(density.get() != nullptr);
 
     IntTree::Ptr typedDensity = gridPtrCast<IntGrid>(density)->treePtr();
 
-    CPPUNIT_ASSERT(typedDensity.get() != NULL);
+    CPPUNIT_ASSERT(typedDensity.get() != nullptr);
 
     CPPUNIT_ASSERT_DOUBLES_EQUAL(5,typedDensity->getValue(Coord(0, 0, 0)), /*tolerance=*/0);
     CPPUNIT_ASSERT_DOUBLES_EQUAL(6,typedDensity->getValue(Coord(100, 0, 0)), /*tolerance=*/0);
@@ -1707,7 +1708,7 @@
 {
     using namespace openvdb;
 
-    typedef typename GridT::ValueType ValueT;
+    using ValueT = typename GridT::ValueType;
 
     const CoordBBox bbox = clipped.evalActiveVoxelBoundingBox();
     CPPUNIT_ASSERT_EQUAL(4, bbox.min().x());
@@ -1772,7 +1773,7 @@
     srcGrids.push_back(vgrid);
 
     const char* filename = "testReadClippedGrid.vdb";
-    boost::shared_ptr<const char> scopedFile(filename, ::remove);
+    SharedPtr<const char> scopedFile(filename, ::remove);
 
     enum { OUTPUT_TO_FILE = 0, OUTPUT_TO_STREAM = 1 };
     for (int outputMethod = OUTPUT_TO_FILE; outputMethod <= OUTPUT_TO_STREAM; ++outputMethod)
@@ -1796,17 +1797,17 @@
         // Read and clip each grid.
 
         CPPUNIT_ASSERT_NO_THROW(grid = vdbfile.readGrid("bgrid", clipBox));
-        CPPUNIT_ASSERT(grid.get() != NULL);
+        CPPUNIT_ASSERT(grid.get() != nullptr);
         CPPUNIT_ASSERT_NO_THROW(bgrid = gridPtrCast<BoolGrid>(grid));
         validateClippedGrid(*bgrid, bfg);
 
         CPPUNIT_ASSERT_NO_THROW(grid = vdbfile.readGrid("fgrid", clipBox));
-        CPPUNIT_ASSERT(grid.get() != NULL);
+        CPPUNIT_ASSERT(grid.get() != nullptr);
         CPPUNIT_ASSERT_NO_THROW(fgrid = gridPtrCast<FloatGrid>(grid));
         validateClippedGrid(*fgrid, ffg);
 
         CPPUNIT_ASSERT_NO_THROW(grid = vdbfile.readGrid("vgrid", clipBox));
-        CPPUNIT_ASSERT(grid.get() != NULL);
+        CPPUNIT_ASSERT(grid.get() != nullptr);
         CPPUNIT_ASSERT_NO_THROW(vgrid = gridPtrCast<Vec3SGrid>(grid));
         validateClippedGrid(*vgrid, vfg);
     }
@@ -1824,8 +1825,8 @@
     using namespace openvdb;
     using namespace openvdb::io;
 
-    typedef Int32Grid GridType;
-    typedef GridType::TreeType TreeType;
+    using GridType = Int32Grid;
+    using TreeType = GridType::TreeType;
 
     File file("something.vdb2");
 
@@ -1855,7 +1856,7 @@
 
     GridBase::Ptr temperature = file2.readGrid("temperature");
 
-    CPPUNIT_ASSERT(temperature.get() != NULL);
+    CPPUNIT_ASSERT(temperature.get() != nullptr);
 
     // Clear registries.
     GridBase::clearRegistry();
@@ -1871,10 +1872,10 @@
     using namespace openvdb;
     using namespace openvdb::io;
 
-    typedef openvdb::FloatGrid FloatGrid;
-    typedef openvdb::Int32Grid IntGrid;
-    typedef FloatGrid::TreeType FloatTree;
-    typedef Int32Grid::TreeType IntTree;
+    using FloatGrid = openvdb::FloatGrid;
+    using IntGrid = openvdb::Int32Grid;
+    using FloatTree = FloatGrid::TreeType;
+    using IntTree = Int32Grid::TreeType;
 
     // Create a vdb to write.
 
@@ -1956,9 +1957,9 @@
     using namespace openvdb;
     using namespace openvdb::io;
 
-    typedef openvdb::FloatGrid FloatGrid;
-    typedef FloatGrid::TreeType FloatTree;
-    typedef Int32Grid::TreeType IntTree;
+    using FloatGrid = openvdb::FloatGrid;
+    using FloatTree = FloatGrid::TreeType;
+    using IntTree = Int32Grid::TreeType;
 
     // Create trees.
     IntTree::Ptr itree(new IntTree(1));
@@ -1994,7 +1995,7 @@
     openvdb::initialize();
 
     const char* filename = "testNameIterator.vdb2";
-    boost::shared_ptr<const char> scopedFile(filename, ::remove);
+    SharedPtr<const char> scopedFile(filename, ::remove);
 
     // Write the grids out to a file.
     {
@@ -2040,7 +2041,7 @@
     using namespace openvdb;
     using namespace openvdb::io;
 
-    typedef openvdb::Int32Grid IntGrid;
+    using IntGrid = openvdb::Int32Grid;
 
     // Register types.
     openvdb::initialize();
@@ -2069,7 +2070,7 @@
     grids.push_back(fogGrid);
 
     const char* filename = "testCompression.vdb2";
-    boost::shared_ptr<const char> scopedFile(filename, ::remove);
+    SharedPtr<const char> scopedFile(filename, ::remove);
 
     size_t uncompressedSize = 0;
     {
@@ -2120,7 +2121,7 @@
             // Verify that the original and input grids are equal.
             {
                 const IntGrid::Ptr grid = gridPtrCast<IntGrid>((*inGrids)[0]);
-                CPPUNIT_ASSERT(grid.get() != NULL);
+                CPPUNIT_ASSERT(grid.get() != nullptr);
                 CPPUNIT_ASSERT_EQUAL(int(intGrid->getGridClass()), int(grid->getGridClass()));
 
                 CPPUNIT_ASSERT(grid->tree().hasSameTopology(intGrid->tree()));
@@ -2150,7 +2151,7 @@
                 const FloatGrid::Ptr
                     grid = gridPtrCast<FloatGrid>((*inGrids)[idx]),
                     refGrid = gridPtrCast<FloatGrid>(grids[idx]);
-                CPPUNIT_ASSERT(grid.get() != NULL);
+                CPPUNIT_ASSERT(grid.get() != nullptr);
                 CPPUNIT_ASSERT_EQUAL(int(refGrid->getGridClass()), int(grid->getGridClass()));
 
                 CPPUNIT_ASSERT(grid->tree().hasSameTopology(refGrid->tree()));
@@ -2195,7 +2196,8 @@
 
     io::Queue::Notifier notifier()
     {
-        return boost::bind(&TestAsyncHelper::validate, this, _1, _2);
+        return std::bind(&TestAsyncHelper::validate, this,
+            std::placeholders::_1, std::placeholders::_2);
     }
 
     void insert(io::Queue::Id id, const std::string& filename)
@@ -2263,7 +2265,7 @@
     {
         // Write a reference file without using asynchronous I/O.
         const char* filename = "testAsyncref.vdb";
-        boost::shared_ptr<const char> scopedFile(filename, ::remove);
+        SharedPtr<const char> scopedFile(filename, ::remove);
         io::File f(filename);
         f.write(grids, fileMetadata);
 
@@ -2333,7 +2335,7 @@
         io::Queue queue(/*capacity=*/1);
         queue.setTimeout(0/*sec*/);
 
-        boost::shared_ptr<const char>
+        SharedPtr<const char>
             scopedFile1("testAsyncIOa.vdb", ::remove),
             scopedFile2("testAsyncIOb.vdb", ::remove);
         std::ofstream
@@ -2418,7 +2420,7 @@
         outdata(new char[decompbufbytes]);
 
     for (int compcode = 0; compcode <= BLOSC_ZLIB; ++compcode) {
-        char* compname = NULL;
+        char* compname = nullptr;
         if (0 > blosc_compcode_to_compname(compcode, &compname)) continue;
         /// @todo This changes the compressor setting globally.
         if (blosc_set_compressor(compname) < 0) continue;
diff -aur openvdb.3.2.0/unittest/TestGradient.cc openvdb.4.0.0/unittest/TestGradient.cc
--- openvdb.3.2.0/unittest/TestGradient.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestGradient.cc	2016-10-09 10:18:58.000000000 +0200
@@ -28,34 +28,32 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 
-#include <sstream>
-#include <cppunit/extensions/HelperMacros.h>
 #include <openvdb/Types.h>
 #include <openvdb/openvdb.h>
 #include <openvdb/tools/GridOperators.h>
 #include "util.h" // for unittest_util::makeSphere()
+#include <cppunit/extensions/HelperMacros.h>
+#include <sstream>
 
-#define ASSERT_DOUBLES_EXACTLY_EQUAL(expected, actual) \
-    CPPUNIT_ASSERT_DOUBLES_EQUAL((expected), (actual), /*tolerance=*/0.0);
 
 class TestGradient: public CppUnit::TestFixture
 {
 public:
-    virtual void setUp() { openvdb::initialize(); }
-    virtual void tearDown() { openvdb::uninitialize(); }
+    void setUp() override { openvdb::initialize(); }
+    void tearDown() override { openvdb::uninitialize(); }
 
     CPPUNIT_TEST_SUITE(TestGradient);
-    CPPUNIT_TEST(testISGradient);                    // Gradient in Index Space
+    CPPUNIT_TEST(testISGradient);               // gradient in index space
     CPPUNIT_TEST(testISGradientStencil);
-    CPPUNIT_TEST(testWSGradient);                    // Gradient in World Space
+    CPPUNIT_TEST(testWSGradient);               // gradient in world space
     CPPUNIT_TEST(testWSGradientStencil);
     CPPUNIT_TEST(testWSGradientStencilFrustum);
-    CPPUNIT_TEST(testWSGradientNormSqr);             // Gradient Norm Sqr (world space only)
-    CPPUNIT_TEST(testWSGradientNormSqrStencil);      // Gradient Norm Sqr (world space only)
-    CPPUNIT_TEST(testGradientTool);                  // Gradient tool
-    CPPUNIT_TEST(testGradientMaskedTool);            // Gradient tool
-    CPPUNIT_TEST(testIntersectsIsoValue);          // zero-crossing
-    CPPUNIT_TEST(testOldStyleStencils);              // old stencil impl - deprecate
+    CPPUNIT_TEST(testWSGradientNormSqr);        // gradient norm sqr (world space only)
+    CPPUNIT_TEST(testWSGradientNormSqrStencil); // gradient norm sqr (world space only)
+    CPPUNIT_TEST(testGradientTool);             // gradient tool
+    CPPUNIT_TEST(testGradientMaskedTool);       // gradient tool
+    CPPUNIT_TEST(testIntersectsIsoValue);       // zero-crossing
+    CPPUNIT_TEST(testOldStyleStencils);         // old stencil impl - deprecate
 
     CPPUNIT_TEST_SUITE_END();
 
@@ -80,7 +78,7 @@
 {
     using namespace openvdb;
 
-    typedef FloatGrid::ConstAccessor  AccessorType;
+    using AccessorType = FloatGrid::ConstAccessor;
     FloatGrid::Ptr grid = createGrid<FloatGrid>(/*background=*/5.0);
     FloatTree& tree = grid->tree();
 
@@ -197,7 +195,7 @@
 {
     using namespace openvdb;
 
-    typedef FloatGrid::ConstAccessor  AccessorType;
+    using AccessorType = FloatGrid::ConstAccessor;
 
     double voxel_size = 0.5;
     FloatGrid::Ptr grid = FloatGrid::create(/*background=*/5.0);
@@ -228,7 +226,7 @@
         // verify the new map is an affine map
         CPPUNIT_ASSERT(rotated_map->type() == math::AffineMap::mapType());
         math::AffineMap::Ptr affine_map =
-            boost::static_pointer_cast<math::AffineMap, math::MapBase>(rotated_map);
+            StaticPtrCast<math::AffineMap, math::MapBase>(rotated_map);
         // the gradient should have the same length even after rotation
         result = math::Gradient<math::AffineMap, math::CD_2ND>::result(
             *affine_map, inAccessor, xyz);
@@ -290,7 +288,7 @@
             dim, center, radius, *grid, unittest_util::SPHERE_DENSE);
 
         math::AffineMap::Ptr affine_map =
-            boost::static_pointer_cast<math::AffineMap, math::MapBase>(rotated_map);
+            StaticPtrCast<math::AffineMap, math::MapBase>(rotated_map);
 
         // math::ScaleMap map(voxel_sizes);
         result = math::Gradient<math::AffineMap, math::CD_2ND>::result(
@@ -305,8 +303,7 @@
         // remake the sphere
         unittest_util::makeSphere<FloatGrid>(
             dim, center, radius, *grid, unittest_util::SPHERE_DENSE);
-        math::ScaleMap::Ptr scale_map =
-            boost::static_pointer_cast<math::ScaleMap, math::MapBase>(base_map);
+        math::ScaleMap::Ptr scale_map = StaticPtrCast<math::ScaleMap, math::MapBase>(base_map);
 
         // math::ScaleMap map(voxel_sizes);
         result = math::Gradient<math::ScaleMap, math::CD_2ND>::result(*scale_map, inAccessor, xyz);
@@ -328,7 +325,7 @@
 
     Vec3d trans(2,2,2);
     math::NonlinearFrustumMap::Ptr map =
-        boost::static_pointer_cast<math::NonlinearFrustumMap, math::MapBase>(
+        StaticPtrCast<math::NonlinearFrustumMap, math::MapBase>(
             frustum.preScale(Vec3d(10,10,10))->postTranslate(trans));
 
 
@@ -443,7 +440,7 @@
         // verify the new map is an affine map
         CPPUNIT_ASSERT(rotated_map->type() == math::AffineMap::mapType());
         math::AffineMap::Ptr affine_map =
-            boost::static_pointer_cast<math::AffineMap, math::MapBase>(rotated_map);
+            StaticPtrCast<math::AffineMap, math::MapBase>(rotated_map);
         // the gradient should have the same length even after rotation
 
         result = math::Gradient<math::AffineMap, math::CD_2ND>::result(
@@ -503,7 +500,7 @@
         unittest_util::makeSphere<FloatGrid>(
             dim, center, radius, *grid, unittest_util::SPHERE_DENSE);
         math::AffineMap::Ptr affine_map =
-            boost::static_pointer_cast<math::AffineMap, math::MapBase>(rotated_map);
+            StaticPtrCast<math::AffineMap, math::MapBase>(rotated_map);
 
         stencil.moveTo(xyz);
         result = math::Gradient<math::AffineMap, math::CD_2ND>::result(*affine_map, stencil);
@@ -532,7 +529,7 @@
 {
     using namespace openvdb;
 
-    typedef FloatGrid::ConstAccessor  AccessorType;
+    using AccessorType = FloatGrid::ConstAccessor;
     double voxel_size = 0.5;
     FloatGrid::Ptr grid = FloatGrid::create(/*background=*/5.0);
     grid->setTransform(math::Transform::createLinearTransform(voxel_size));
diff -aur openvdb.3.2.0/unittest/TestGrid.cc openvdb.4.0.0/unittest/TestGrid.cc
--- openvdb.3.2.0/unittest/TestGrid.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestGrid.cc	2016-10-09 10:18:58.000000000 +0200
@@ -28,7 +28,6 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 
-#include <cppunit/extensions/HelperMacros.h>
 #include <openvdb/Exceptions.h>
 #include <openvdb/openvdb.h>
 #include <openvdb/Types.h>
@@ -37,6 +36,7 @@
 #include <openvdb/Grid.h>
 #include <openvdb/tree/Tree.h>
 #include <openvdb/util/CpuTimer.h>
+#include <cppunit/extensions/HelperMacros.h>
 
 #define ASSERT_DOUBLES_EXACTLY_EQUAL(expected, actual) \
     CPPUNIT_ASSERT_DOUBLES_EQUAL((expected), (actual), /*tolerance=*/0.0);
@@ -74,42 +74,43 @@
 class ProxyTree: public openvdb::TreeBase
 {
 public:
-    typedef int ValueType;
-    typedef int BuildType;
-    typedef void ValueAllCIter;
-    typedef void ValueAllIter;
-    typedef void ValueOffCIter;
-    typedef void ValueOffIter;
-    typedef void ValueOnCIter;
-    typedef void ValueOnIter;
-    typedef openvdb::TreeBase::Ptr TreeBasePtr;
-    typedef boost::shared_ptr<ProxyTree> Ptr;
-    typedef boost::shared_ptr<const ProxyTree> ConstPtr;
+    using ValueType = int;
+    using BuildType = int;
+    using ValueAllCIter = void;
+    using ValueAllIter = void;
+    using ValueOffCIter = void;
+    using ValueOffIter = void;
+    using ValueOnCIter = void;
+    using ValueOnIter = void;
+    using TreeBasePtr = openvdb::TreeBase::Ptr;
+    using Ptr = openvdb::SharedPtr<ProxyTree>;
+    using ConstPtr = openvdb::SharedPtr<const ProxyTree>;
 
     static const openvdb::Index DEPTH;
     static const ValueType backg;
 
     ProxyTree() {}
     ProxyTree(const ValueType&) {}
-    virtual ~ProxyTree() {}
+    ProxyTree(const ProxyTree&) = default;
+    ~ProxyTree() override = default;
 
     static const openvdb::Name& treeType() { static const openvdb::Name s("proxy"); return s; }
-    virtual const openvdb::Name& type() const { return treeType(); }
-    virtual openvdb::Name valueType() const { return "proxy"; }
+    const openvdb::Name& type() const override { return treeType(); }
+    openvdb::Name valueType() const override { return "proxy"; }
     const ValueType& background() const { return backg; }
 
-    virtual TreeBasePtr copy() const { return TreeBasePtr(new ProxyTree(*this)); }
+    TreeBasePtr copy() const override { return TreeBasePtr(new ProxyTree(*this)); }
 
-    virtual void readTopology(std::istream& is, bool = false) { is.seekg(0, std::ios::beg); }
-    virtual void writeTopology(std::ostream& os, bool = false) const { os.seekp(0); }
+    void readTopology(std::istream& is, bool = false) override { is.seekg(0, std::ios::beg); }
+    void writeTopology(std::ostream& os, bool = false) const override { os.seekp(0); }
 
 #ifndef OPENVDB_2_ABI_COMPATIBLE
-    virtual void readBuffers(std::istream& is,
-        const openvdb::CoordBBox&, bool /*saveFloatAsHalf*/=false) { is.seekg(0); }
-    virtual void readNonresidentBuffers() const {}
+    void readBuffers(std::istream& is,
+        const openvdb::CoordBBox&, bool /*saveFloatAsHalf*/=false) override { is.seekg(0); }
+    void readNonresidentBuffers() const override {}
 #endif
-    virtual void readBuffers(std::istream& is, bool /*saveFloatAsHalf*/=false) { is.seekg(0); }
-    virtual void writeBuffers(std::ostream& os, bool /*saveFloatAsHalf*/=false) const
+    void readBuffers(std::istream& is, bool /*saveFloatAsHalf*/=false) override { is.seekg(0); }
+    void writeBuffers(std::ostream& os, bool /*saveFloatAsHalf*/=false) const override
         { os.seekp(0, std::ios::beg); }
 
     bool empty() const { return true; }
@@ -117,35 +118,35 @@
     void prune(const ValueType& = 0) {}
     void clip(const openvdb::CoordBBox&) {}
 #ifndef OPENVDB_2_ABI_COMPATIBLE
-    virtual void clipUnallocatedNodes() {}
+    void clipUnallocatedNodes() override {}
 #endif
 
-    virtual void getIndexRange(openvdb::CoordBBox&) const {}
-    virtual bool evalLeafBoundingBox(openvdb::CoordBBox& bbox) const
+    void getIndexRange(openvdb::CoordBBox&) const override {}
+    bool evalLeafBoundingBox(openvdb::CoordBBox& bbox) const override
         { bbox.min() = bbox.max() = openvdb::Coord(0, 0, 0); return false; }
-    virtual bool evalActiveVoxelBoundingBox(openvdb::CoordBBox& bbox) const
+    bool evalActiveVoxelBoundingBox(openvdb::CoordBBox& bbox) const override
         { bbox.min() = bbox.max() = openvdb::Coord(0, 0, 0); return false; }
-    virtual bool evalActiveVoxelDim(openvdb::Coord& dim) const
+    bool evalActiveVoxelDim(openvdb::Coord& dim) const override
         { dim = openvdb::Coord(0, 0, 0); return false; }
-    virtual bool evalLeafDim(openvdb::Coord& dim) const
+    bool evalLeafDim(openvdb::Coord& dim) const override
         { dim = openvdb::Coord(0, 0, 0); return false; }
 
-    virtual openvdb::Index treeDepth() const { return 0; }
-    virtual openvdb::Index leafCount() const { return 0; }
-    virtual openvdb::Index nonLeafCount() const { return 0; }
-    virtual openvdb::Index64 activeVoxelCount() const { return 0UL; }
-    virtual openvdb::Index64 inactiveVoxelCount() const { return 0UL; }
-    virtual openvdb::Index64 activeLeafVoxelCount() const { return 0UL; }
-    virtual openvdb::Index64 inactiveLeafVoxelCount() const { return 0UL; }
+    openvdb::Index treeDepth() const override { return 0; }
+    openvdb::Index leafCount() const override { return 0; }
+    openvdb::Index nonLeafCount() const override { return 0; }
+    openvdb::Index64 activeVoxelCount() const override { return 0UL; }
+    openvdb::Index64 inactiveVoxelCount() const override { return 0UL; }
+    openvdb::Index64 activeLeafVoxelCount() const override { return 0UL; }
+    openvdb::Index64 inactiveLeafVoxelCount() const override { return 0UL; }
 #ifndef OPENVDB_2_ABI_COMPATIBLE
-    virtual openvdb::Index64 activeTileCount() const { return 0UL; }
+    openvdb::Index64 activeTileCount() const override { return 0UL; }
 #endif
 };
 
 const openvdb::Index ProxyTree::DEPTH = 0;
 const ProxyTree::ValueType ProxyTree::backg = 0;
 
-typedef openvdb::Grid<ProxyTree> ProxyGrid;
+using ProxyGrid = openvdb::Grid<ProxyTree>;
 
 
 ////////////////////////////////////////
@@ -155,8 +156,8 @@
 {
     using namespace openvdb::tree;
 
-    typedef Tree<RootNode<InternalNode<LeafNode<float, 3>, 2> > > TreeType;
-    typedef openvdb::Grid<TreeType> GridType;
+    using TreeType = Tree<RootNode<InternalNode<LeafNode<float, 3>, 2> > >;
+    using GridType = openvdb::Grid<TreeType>;
 
     openvdb::GridBase::clearRegistry();
 
@@ -341,8 +342,8 @@
 
     // Verify that a grid can't be converted to another type with a different
     // tree configuration.
-    typedef tree::Tree3<double, 2, 3>::Type DTree23;
-    typedef Grid<DTree23> DGrid23;
+    using DTree23 = tree::Tree3<double, 2, 3>::Type;
+    using DGrid23 = Grid<DTree23>;
     CPPUNIT_ASSERT_THROW(DGrid23 d23grid(fgrid), openvdb::TypeError);
 }
 
@@ -356,7 +357,7 @@
 {
     using namespace openvdb;
 
-    typedef typename GridT::ValueType ValueT;
+    using ValueT = typename GridT::ValueType;
 
     const CoordBBox bbox = clipped.evalActiveVoxelBoundingBox();
     CPPUNIT_ASSERT_EQUAL(4, bbox.min().x());
diff -aur openvdb.3.2.0/unittest/TestInternalOrigin.cc openvdb.4.0.0/unittest/TestInternalOrigin.cc
--- openvdb.3.2.0/unittest/TestInternalOrigin.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestInternalOrigin.cc	2016-10-09 10:18:58.000000000 +0200
@@ -65,7 +65,7 @@
     FloatTree4 tree(0.0f);
     std::set<openvdb::Coord>::iterator iter=indices.begin();
     for (int n = 0; iter != indices.end(); ++n, ++iter) {
-        tree.setValue(*iter, float(1.0 + float(n) * 0.5f));
+        tree.setValue(*iter, float(1.0 + double(n) * 0.5));
     }
 
     openvdb::Coord C3, G;
diff -aur openvdb.3.2.0/unittest/TestLaplacian.cc openvdb.4.0.0/unittest/TestLaplacian.cc
--- openvdb.3.2.0/unittest/TestLaplacian.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestLaplacian.cc	2016-10-09 10:18:58.000000000 +0200
@@ -28,21 +28,19 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 
-#include <sstream>
-#include <cppunit/extensions/HelperMacros.h>
 #include <openvdb/Types.h>
 #include <openvdb/openvdb.h>
 #include <openvdb/tools/GridOperators.h>
 #include "util.h" // for unittest_util::makeSphere()
+#include <cppunit/extensions/HelperMacros.h>
+#include <sstream>
 
-#define ASSERT_DOUBLES_EXACTLY_EQUAL(expected, actual) \
-    CPPUNIT_ASSERT_DOUBLES_EQUAL((expected), (actual), /*tolerance=*/0.0);
 
 class TestLaplacian: public CppUnit::TestFixture
 {
 public:
-    virtual void setUp() { openvdb::initialize(); }
-    virtual void tearDown() { openvdb::uninitialize(); }
+    void setUp() override { openvdb::initialize(); }
+    void tearDown() override { openvdb::uninitialize(); }
 
     CPPUNIT_TEST_SUITE(TestLaplacian);
     CPPUNIT_TEST(testISLaplacian);                    // Laplacian in Index Space
@@ -171,8 +169,7 @@
     math::MapBase::Ptr rotated_map = map.preRotate(1.5, math::X_AXIS);
     // verify the new map is an affine map
     CPPUNIT_ASSERT(rotated_map->type() == math::AffineMap::mapType());
-    math::AffineMap::Ptr affine_map =
-        boost::static_pointer_cast<math::AffineMap, math::MapBase>(rotated_map);
+    math::AffineMap::Ptr affine_map = StaticPtrCast<math::AffineMap, math::MapBase>(rotated_map);
 
     // the laplacian is invariant to rotation
     result = math::Laplacian<math::AffineMap, math::CD_SECOND>::result(
@@ -242,7 +239,7 @@
 
     math::Vec3d trans(2,2,2);
     math::NonlinearFrustumMap::Ptr map =
-        boost::static_pointer_cast<math::NonlinearFrustumMap, math::MapBase>(
+        StaticPtrCast<math::NonlinearFrustumMap, math::MapBase>(
             frustum.preScale(Vec3d(10,10,10))->postTranslate(trans));
 
     CPPUNIT_ASSERT(!map->hasUniformScale());
@@ -312,8 +309,7 @@
     math::MapBase::Ptr rotated_map = map.preRotate(1.5, math::X_AXIS);
     // verify the new map is an affine map
     CPPUNIT_ASSERT(rotated_map->type() == math::AffineMap::mapType());
-    math::AffineMap::Ptr affine_map =
-        boost::static_pointer_cast<math::AffineMap, math::MapBase>(rotated_map);
+    math::AffineMap::Ptr affine_map = StaticPtrCast<math::AffineMap, math::MapBase>(rotated_map);
 
     // the laplacian is invariant to rotation
     math::SevenPointStencil<FloatGrid> sevenpt(*grid);
diff -aur openvdb.3.2.0/unittest/TestLeafManager.cc openvdb.4.0.0/unittest/TestLeafManager.cc
--- openvdb.3.2.0/unittest/TestLeafManager.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestLeafManager.cc	2016-10-09 10:18:58.000000000 +0200
@@ -28,30 +28,24 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 
-#include <cstdio> // for remove()
-#include <fstream>
-#include <sstream>
-#include <cppunit/extensions/HelperMacros.h>
-#include <openvdb/Exceptions.h>
 #include <openvdb/Types.h>
 #include <openvdb/tree/LeafManager.h>
 #include "util.h" // for unittest_util::makeSphere()
+#include <cppunit/extensions/HelperMacros.h>
 
-#define ASSERT_DOUBLES_EXACTLY_EQUAL(expected, actual) \
-    CPPUNIT_ASSERT_DOUBLES_EQUAL((expected), (actual), /*tolerance=*/0.0);
 
 class TestLeafManager: public CppUnit::TestFixture
 {
 public:
-    virtual void setUp() { openvdb::initialize(); }
-    virtual void tearDown() { openvdb::uninitialize(); }
+    void setUp() override { openvdb::initialize(); }
+    void tearDown() override { openvdb::uninitialize(); }
 
     CPPUNIT_TEST_SUITE(TestLeafManager);
     CPPUNIT_TEST(test);
     CPPUNIT_TEST(testForeach);
     CPPUNIT_TEST(testReduce);
     CPPUNIT_TEST_SUITE_END();
-   
+
     void test();
     void testForeach();
     void testReduce();
@@ -59,7 +53,7 @@
 
 
 CPPUNIT_TEST_SUITE_REGISTRATION(TestLeafManager);
-  
+
 void
 TestLeafManager::test()
 {
@@ -238,7 +232,7 @@
     tree.fill( bbox1, -1.0f);
     tree.fill( bbox2,  1.0f);
     tree.voxelizeActiveTiles();
-    
+
     for (CoordBBox::Iterator<true> iter(bbox1); iter; ++iter) {
         CPPUNIT_ASSERT_EQUAL( -1.0f, tree.getValue(*iter));
     }
@@ -279,7 +273,7 @@
     tree.fill( bbox1, -1.0f);
     tree.fill( bbox2,  1.0f);
     tree.voxelizeActiveTiles();
-    
+
     for (CoordBBox::Iterator<true> iter(bbox1); iter; ++iter) {
         CPPUNIT_ASSERT_EQUAL( -1.0f, tree.getValue(*iter));
     }
@@ -300,7 +294,7 @@
     CPPUNIT_ASSERT_EQUAL(size_t(0), r.auxBufferCount());
     CPPUNIT_ASSERT_EQUAL(size_t(0), r.auxBuffersPerLeaf());
 
-    Index n = 0; 
+    Index n = 0;
     for (CoordBBox::Iterator<true> iter(bbox1); iter; ++iter) {
         ++n;
         CPPUNIT_ASSERT_EQUAL( -1.0f, tree.getValue(*iter));
diff -aur openvdb.3.2.0/unittest/TestLevelSetRayIntersector.cc openvdb.4.0.0/unittest/TestLevelSetRayIntersector.cc
--- openvdb.3.2.0/unittest/TestLevelSetRayIntersector.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestLevelSetRayIntersector.cc	2016-10-09 10:18:58.000000000 +0200
@@ -28,6 +28,7 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 
+/// @file unittest/TestLevelSetRayIntersector.cc
 /// @author Ken Museth
 
 // Uncomment to enable statistics of ray-intersections
@@ -50,9 +51,6 @@
 #endif
 
 
-#define ASSERT_DOUBLES_EXACTLY_EQUAL(expected, actual) \
-    CPPUNIT_ASSERT_DOUBLES_EQUAL((expected), (actual), /*tolerance=*/0.0);
-
 #define ASSERT_DOUBLES_APPROX_EQUAL(expected, actual) \
     CPPUNIT_ASSERT_DOUBLES_EQUAL((expected), (actual), /*tolerance=*/1.e-6);
 
diff -aur openvdb.3.2.0/unittest/TestMaps.cc openvdb.4.0.0/unittest/TestMaps.cc
--- openvdb.3.2.0/unittest/TestMaps.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestMaps.cc	2016-10-09 10:18:58.000000000 +0200
@@ -28,10 +28,10 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 
-#include <cppunit/extensions/HelperMacros.h>
 #include <openvdb/Exceptions.h>
 #include <openvdb/math/Maps.h>
 #include <openvdb/util/MapsUtil.h>
+#include <cppunit/extensions/HelperMacros.h>
 
 
 class TestMaps: public CppUnit::TestCase
@@ -480,7 +480,7 @@
 
     Vec3d trans(2,2,2);
     NonlinearFrustumMap::Ptr map =
-        boost::static_pointer_cast<NonlinearFrustumMap, MapBase>(
+        openvdb::StaticPtrCast<NonlinearFrustumMap, MapBase>(
             frustum.preScale(Vec3d(10,10,10))->postTranslate(trans));
 
     CPPUNIT_ASSERT(!map->hasUniformScale());
@@ -668,7 +668,7 @@
          openvdb::BBoxd bbox(Vec3d(0), Vec3d(100));
          NonlinearFrustumMap frustum(bbox, 2, 5);
          NonlinearFrustumMap::Ptr map =
-             boost::static_pointer_cast<NonlinearFrustumMap, MapBase>(
+             openvdb::StaticPtrCast<NonlinearFrustumMap, MapBase>(
                  frustum.preScale(Vec3d(2,2,2)));
          Vec3d center(20,20,10);
          double radius(1);
@@ -788,7 +788,6 @@
         CPPUNIT_ASSERT_DOUBLES_EQUAL(tmp(2), test(2), TOL);
     }
     {
-
         openvdb::BBoxd bbox(Vec3d(0), Vec3d(100));
         NonlinearFrustumMap frustum(bbox, 1./6., 5);
         /// frustum will have depth, far plane - near plane = 5
@@ -796,9 +795,8 @@
 
         Vec3d trans(2,2,2);
         NonlinearFrustumMap::Ptr map =
-            boost::static_pointer_cast<NonlinearFrustumMap, MapBase>(
-            frustum.preScale(Vec3d(10,10,10))->postTranslate(trans));
-
+            openvdb::StaticPtrCast<NonlinearFrustumMap, MapBase>(
+                frustum.preScale(Vec3d(10,10,10))->postTranslate(trans));
 
         const Vec3d test(1,2,3);
         const Vec3d origin(0, 0, 0);
@@ -827,8 +825,6 @@
 
 }
 
-
-
 // Copyright (c) 2012-2016 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb.3.2.0/unittest/TestMeanCurvature.cc openvdb.4.0.0/unittest/TestMeanCurvature.cc
--- openvdb.3.2.0/unittest/TestMeanCurvature.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestMeanCurvature.cc	2016-10-09 10:18:58.000000000 +0200
@@ -28,23 +28,20 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 
-#include <sstream>
-#include <cppunit/extensions/HelperMacros.h>
 #include <openvdb/Types.h>
 #include <openvdb/openvdb.h>
 #include <openvdb/math/Stencils.h>
 #include <openvdb/math/Operators.h>
 #include <openvdb/tools/GridOperators.h>
 #include "util.h" // for unittest_util::makeSphere()
+#include <cppunit/extensions/HelperMacros.h>
 
-#define ASSERT_DOUBLES_EXACTLY_EQUAL(expected, actual) \
-    CPPUNIT_ASSERT_DOUBLES_EQUAL((expected), (actual), /*tolerance=*/0.0);
 
 class TestMeanCurvature: public CppUnit::TestFixture
 {
 public:
-    virtual void setUp() { openvdb::initialize(); }
-    virtual void tearDown() { openvdb::uninitialize(); }
+    void setUp() override { openvdb::initialize(); }
+    void tearDown() override { openvdb::uninitialize(); }
 
     CPPUNIT_TEST_SUITE(TestMeanCurvature);
     CPPUNIT_TEST(testISMeanCurvature);                    // MeanCurvature in Index Space
diff -aur openvdb.3.2.0/unittest/TestMetaMap.cc openvdb.4.0.0/unittest/TestMetaMap.cc
--- openvdb.3.2.0/unittest/TestMetaMap.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestMetaMap.cc	2016-10-09 10:18:58.000000000 +0200
@@ -31,7 +31,7 @@
 #include <cppunit/extensions/HelperMacros.h>
 #include <openvdb/Exceptions.h>
 #include <openvdb/Metadata.h>
-#include <openvdb/metadata/MetaMap.h>
+#include <openvdb/MetaMap.h>
 
 class TestMetaMap: public CppUnit::TestCase
 {
diff -aur openvdb.3.2.0/unittest/TestMultiResGrid.cc openvdb.4.0.0/unittest/TestMultiResGrid.cc
--- openvdb.3.2.0/unittest/TestMultiResGrid.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestMultiResGrid.cc	2016-10-09 10:18:58.000000000 +0200
@@ -137,13 +137,12 @@
     using namespace openvdb;
 
     typedef tools::MultiResGrid<DoubleTree> MultiResGridT;
-    typedef MultiResGridT::ValueType ValueT;
     const double background = -1.0;
     const size_t levels = 4;
 
     MultiResGridT::Ptr mrg(new MultiResGridT( levels, background));
 
-    CPPUNIT_ASSERT(mrg != NULL);
+    CPPUNIT_ASSERT(mrg != nullptr);
     CPPUNIT_ASSERT_EQUAL(levels  , mrg->numLevels());
     CPPUNIT_ASSERT_EQUAL(0UL,      mrg->finestLevel());
     CPPUNIT_ASSERT_EQUAL(levels-1, mrg->coarsestLevel());
@@ -154,8 +153,9 @@
 
     // First check all trees against the background value
     for (size_t level = 0; level < mrg->numLevels(); ++level) {
-        for (CoordBBox::Iterator<true> ijk(bbox>>level); ijk; ++ijk) {
-            CPPUNIT_ASSERT_DOUBLES_EQUAL( background, mrg->tree(level).getValue(*ijk), /*tot=*/0.0);
+        for (CoordBBox::Iterator<true> iter(bbox>>level); iter; ++iter) {
+            CPPUNIT_ASSERT_DOUBLES_EQUAL(background,
+                mrg->tree(level).getValue(*iter), /*tolerance=*/0.0);
         }
     }
 
@@ -164,8 +164,9 @@
         mrg->tree(level).fill( bbox>>level, double(level));
         mrg->tree(level).voxelizeActiveTiles();// avoid active tiles
         // Check values
-        for (CoordBBox::Iterator<true> ijk(bbox>>level); ijk; ++ijk) {
-            CPPUNIT_ASSERT_DOUBLES_EQUAL(double(level), mrg->tree(level).getValue(*ijk), /*tot=*/0.0);
+        for (CoordBBox::Iterator<true> iter(bbox>>level); iter; ++iter) {
+            CPPUNIT_ASSERT_DOUBLES_EQUAL(double(level),
+                mrg->tree(level).getValue(*iter), /*tolerance=*/0.0);
         }
         //mrg->tree( level ).print(std::cerr, 2);
         // Check bounding box of active voxels
@@ -189,58 +190,59 @@
     CPPUNIT_ASSERT_DOUBLES_EQUAL(2.25, mrg->sampleValue<1>(ijk, 2.25f), /*tolerance=*/ 0.001);
 
     // Value at a floating-point position close to ijk and a floating point level
-    CPPUNIT_ASSERT_DOUBLES_EQUAL(2.25, mrg->sampleValue<1>(Vec3R(0.124), 2.25f), /*tolerance=*/ 0.001);
+    CPPUNIT_ASSERT_DOUBLES_EQUAL(2.25,
+        mrg->sampleValue<1>(Vec3R(0.124), 2.25f), /*tolerance=*/ 0.001);
 
     // prolongate at a given point at top level
     CPPUNIT_ASSERT_DOUBLES_EQUAL(1.0, mrg->prolongateVoxel(ijk, 0), /*tolerance=*/ 0.0);
 
     // First check the coarsest level (3)
-    for (CoordBBox::Iterator<true> ijk(bbox>>3UL); ijk; ++ijk) {
-        CPPUNIT_ASSERT_DOUBLES_EQUAL(3.0, mrg->tree(3).getValue(*ijk), /*tot=*/0.0);
+    for (CoordBBox::Iterator<true> iter(bbox>>3UL); iter; ++iter) {
+        CPPUNIT_ASSERT_DOUBLES_EQUAL(3.0, mrg->tree(3).getValue(*iter), /*tolerance=*/0.0);
     }
 
     // Prolongate from level 3 -> level 2 and check values
     mrg->prolongateActiveVoxels(2);
-    for (CoordBBox::Iterator<true> ijk(bbox>>2UL); ijk; ++ijk) {
-        CPPUNIT_ASSERT_DOUBLES_EQUAL(3.0, mrg->tree(2).getValue(*ijk), /*tot=*/0.0);
+    for (CoordBBox::Iterator<true> iter(bbox>>2UL); iter; ++iter) {
+        CPPUNIT_ASSERT_DOUBLES_EQUAL(3.0, mrg->tree(2).getValue(*iter), /*tolerance=*/0.0);
     }
 
     // Prolongate from level 2 -> level 1 and check values
     mrg->prolongateActiveVoxels(1);
-    for (CoordBBox::Iterator<true> ijk(bbox>>1UL); ijk; ++ijk) {
-        CPPUNIT_ASSERT_DOUBLES_EQUAL(3.0, mrg->tree(1).getValue(*ijk), /*tot=*/0.0);
+    for (CoordBBox::Iterator<true> iter(bbox>>1UL); iter; ++iter) {
+        CPPUNIT_ASSERT_DOUBLES_EQUAL(3.0, mrg->tree(1).getValue(*iter), /*tolerance=*/0.0);
     }
 
     // Prolongate from level 1 -> level 0 and check values
     mrg->prolongateActiveVoxels(0);
-    for (CoordBBox::Iterator<true> ijk(bbox); ijk; ++ijk) {
-        CPPUNIT_ASSERT_DOUBLES_EQUAL(3.0, mrg->tree(0).getValue(*ijk), /*tot=*/0.0);
+    for (CoordBBox::Iterator<true> iter(bbox); iter; ++iter) {
+        CPPUNIT_ASSERT_DOUBLES_EQUAL(3.0, mrg->tree(0).getValue(*iter), /*tolerance=*/0.0);
     }
 
     // Redefine values at the finest level and check values
     mrg->finestTree().fill( bbox, 5.0 );
     mrg->finestTree().voxelizeActiveTiles();// avoid active tiles
-    for (CoordBBox::Iterator<true> ijk(bbox); ijk; ++ijk) {
-        CPPUNIT_ASSERT_DOUBLES_EQUAL(5.0, mrg->tree(0).getValue(*ijk), /*tot=*/0.0);
+    for (CoordBBox::Iterator<true> iter(bbox); iter; ++iter) {
+        CPPUNIT_ASSERT_DOUBLES_EQUAL(5.0, mrg->tree(0).getValue(*iter), /*tolerance=*/0.0);
     }
 
     // USE RESTRICTION BY INJECTION since it doesn't have boundary issues
     // // Restrict from level 0 -> level 1 and check values
     // mrg->restrictActiveVoxels(1);
-    // for (CoordBBox::Iterator<true> ijk((bbox>>1UL).expandBy(-1)); ijk; ++ijk) {
-    //     CPPUNIT_ASSERT_DOUBLES_EQUAL(5.0, mrg->tree(1).getValue(*ijk), /*tot=*/0.0);
+    // for (CoordBBox::Iterator<true> iter((bbox>>1UL).expandBy(-1)); iter; ++iter) {
+    //     CPPUNIT_ASSERT_DOUBLES_EQUAL(5.0, mrg->tree(1).getValue(*iter), /*tolerance=*/0.0);
     // }
 
     // // Restrict from level 1 -> level 2 and check values
     // mrg->restrictActiveVoxels(2);
-    // for (CoordBBox::Iterator<true> ijk(bbox>>2UL); ijk; ++ijk) {
-    //     CPPUNIT_ASSERT_DOUBLES_EQUAL(5.0, mrg->tree(2).getValue(*ijk), /*tot=*/0.0);
+    // for (CoordBBox::Iterator<true> iter(bbox>>2UL); iter; ++iter) {
+    //     CPPUNIT_ASSERT_DOUBLES_EQUAL(5.0, mrg->tree(2).getValue(*iter), /*tolerance=*/0.0);
     // }
 
     // // Restrict from level 2 -> level 3 and check values
     // mrg->restrictActiveVoxels(3);
-    // for (CoordBBox::Iterator<true> ijk(bbox>>3UL); ijk; ++ijk) {
-    //     CPPUNIT_ASSERT_DOUBLES_EQUAL(5.0, mrg->tree(3).getValue(*ijk), /*tot=*/0.0);
+    // for (CoordBBox::Iterator<true> iter(bbox>>3UL); iter; ++iter) {
+    //     CPPUNIT_ASSERT_DOUBLES_EQUAL(5.0, mrg->tree(3).getValue(*iter), /*tolerance=*/0.0);
     // }
 }
 
@@ -258,7 +260,6 @@
     ls->setName("LevelSetSphere");
 
     typedef tools::MultiResGrid<FloatTree> MultiResGridT;
-    typedef MultiResGridT::ValueType ValueT;
     const size_t levels = 4;
 
     // Generate LOD sequence
@@ -319,7 +320,8 @@
     filenames.push_back("utahteapot.vdb");
     util::CpuTimer timer;
     for ( size_t i=0; i<filenames.size(); ++i) {
-        std::cerr << "\n=====================>\"" << filenames[i] << "\" =====================" << std::endl;
+        std::cerr << "\n=====================>\"" << filenames[i]
+            << "\" =====================" << std::endl;
         std::cerr << "Reading \"" << filenames[i] << "\" ...";
         io::File file( path + filenames[i] );
         file.open(false);//disable delayed loading
diff -aur openvdb.3.2.0/unittest/TestNodeManager.cc openvdb.4.0.0/unittest/TestNodeManager.cc
--- openvdb.3.2.0/unittest/TestNodeManager.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestNodeManager.cc	2016-10-09 10:18:58.000000000 +0200
@@ -28,24 +28,19 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 
-#include <cstdio> // for remove()
-#include <fstream>
-#include <sstream>
-#include <cppunit/extensions/HelperMacros.h>
 #include <openvdb/Exceptions.h>
 #include <openvdb/Types.h>
 #include <openvdb/tree/NodeManager.h>
 #include <openvdb/tree/LeafManager.h>
 #include "util.h" // for unittest_util::makeSphere()
+#include <cppunit/extensions/HelperMacros.h>
 
-#define ASSERT_DOUBLES_EXACTLY_EQUAL(expected, actual) \
-    CPPUNIT_ASSERT_DOUBLES_EQUAL((expected), (actual), /*tolerance=*/0.0);
 
 class TestNodeManager: public CppUnit::TestFixture
 {
 public:
-    virtual void setUp() { openvdb::initialize(); }
-    virtual void tearDown() { openvdb::uninitialize(); }
+    void setUp() override { openvdb::initialize(); }
+    void tearDown() override { openvdb::uninitialize(); }
 
     CPPUNIT_TEST_SUITE(TestNodeManager);
     CPPUNIT_TEST(testAll);
diff -aur openvdb.3.2.0/unittest/TestPointsToMask.cc openvdb.4.0.0/unittest/TestPointsToMask.cc
--- openvdb.3.2.0/unittest/TestPointsToMask.cc	2016-04-24 10:39:49.000000000 +0200
+++ openvdb.4.0.0/unittest/TestPointsToMask.cc	2016-10-09 10:18:58.000000000 +0200
@@ -28,11 +28,11 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 
-#include <cppunit/extensions/HelperMacros.h>
+#include <openvdb/openvdb.h>
 #include <openvdb/math/Math.h> // for math::Random01
 #include <openvdb/tools/PointsToMask.h>
 #include <openvdb/util/CpuTimer.h>
-
+#include <cppunit/extensions/HelperMacros.h>
 #include <vector>
 #include <algorithm>
 #include <cmath>
@@ -198,9 +198,6 @@
     }
 }
 
-
-
-
 // Copyright (c) 2012-2016 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb.3.2.0/unittest/TestPrePostAPI.cc openvdb.4.0.0/unittest/TestPrePostAPI.cc
--- openvdb.3.2.0/unittest/TestPrePostAPI.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestPrePostAPI.cc	2016-10-09 10:18:58.000000000 +0200
@@ -388,7 +388,8 @@
             CPPUNIT_ASSERT( correct.eq(result, TOL));
         }
         {
-            const Mat4d result = ustm.postShear(13., X_AXIS, Z_AXIS)->getAffineMap()->getConstMat4();
+            const Mat4d result =
+                ustm.postShear(13., X_AXIS, Z_AXIS)->getAffineMap()->getConstMat4();
             CPPUNIT_ASSERT( correct.eq(result, TOL));
         }
         {
@@ -587,14 +588,16 @@
 {
     using namespace openvdb::math;
 
-    typedef BBox<Vec3d> BBoxd;
+    using BBoxd = BBox<Vec3d>;
 
     double TOL = 1e-7;
     {
 
         BBoxd bbox(Vec3d(-5,-5,0), Vec3d(5,5,10));
-        Transform::Ptr t = Transform::createFrustumTransform(bbox, /* taper*/ 1, /*depth*/10, /* voxel size */1.f);
-        Transform::Ptr tinv = Transform::createFrustumTransform(bbox, /* taper*/ 1, /*depth*/10, /* voxel size */1.f);
+        Transform::Ptr t = Transform::createFrustumTransform(
+            bbox, /* taper*/ 1, /*depth*/10, /* voxel size */1.f);
+        Transform::Ptr tinv = Transform::createFrustumTransform(
+            bbox, /* taper*/ 1, /*depth*/10, /* voxel size */1.f);
 
 
         // create matrix with pre-API
@@ -615,8 +618,10 @@
 
         // test this by verifying that equvilent interal matrix
         // represenations are inverses
-        NonlinearFrustumMap::Ptr frustum = boost::static_pointer_cast<NonlinearFrustumMap, MapBase>( t->baseMap() );
-        NonlinearFrustumMap::Ptr frustuminv = boost::static_pointer_cast<NonlinearFrustumMap, MapBase>( tinv->baseMap() );
+        NonlinearFrustumMap::Ptr frustum =
+            openvdb::StaticPtrCast<NonlinearFrustumMap, MapBase>(t->baseMap());
+        NonlinearFrustumMap::Ptr frustuminv =
+            openvdb::StaticPtrCast<NonlinearFrustumMap, MapBase>(tinv->baseMap());
 
         Mat4d m = frustum->secondMap().getMat4();
         Mat4d minv = frustuminv->secondMap().getMat4();
@@ -648,7 +653,8 @@
     {
 
         BBoxd bbox(Vec3d(-5,-5,0), Vec3d(5,5,10));
-        Transform::Ptr t = Transform::createFrustumTransform(bbox, /* taper*/ 1, /*depth*/10, /* voxel size */1.f);
+        Transform::Ptr t = Transform::createFrustumTransform(
+            bbox, /* taper*/ 1, /*depth*/10, /* voxel size */1.f);
 
 
         Mat4d m = Mat4d::identity();
@@ -677,7 +683,8 @@
         t->preMult(minv);
         t->postMult(minv);
 
-        NonlinearFrustumMap::Ptr frustum = boost::static_pointer_cast<NonlinearFrustumMap, MapBase>( t->baseMap() );
+        NonlinearFrustumMap::Ptr frustum =
+            openvdb::StaticPtrCast<NonlinearFrustumMap, MapBase>(t->baseMap());
         Mat4d mtest = frustum->secondMap().getMat4();
 
         // verify that the results is the scale
@@ -705,7 +712,6 @@
 
 }
 
-
 // Copyright (c) 2012-2016 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb.3.2.0/unittest/TestStream.cc openvdb.4.0.0/unittest/TestStream.cc
--- openvdb.3.2.0/unittest/TestStream.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestStream.cc	2016-10-09 10:18:58.000000000 +0200
@@ -28,7 +28,6 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 
-#include <cppunit/extensions/HelperMacros.h>
 #include <openvdb/Exceptions.h>
 #include <openvdb/io/Stream.h>
 #include <openvdb/Metadata.h>
@@ -36,6 +35,7 @@
 #include <openvdb/math/Transform.h>
 #include <openvdb/version.h>
 #include <openvdb/openvdb.h>
+#include <cppunit/extensions/HelperMacros.h>
 #include <cstdio> // for remove()
 #include <fstream>
 
@@ -46,8 +46,8 @@
 class TestStream: public CppUnit::TestCase
 {
 public:
-    virtual void setUp();
-    virtual void tearDown();
+    void setUp() override;
+    void tearDown() override;
 
     CPPUNIT_TEST_SUITE(TestStream);
     CPPUNIT_TEST(testWrite);
@@ -154,8 +154,8 @@
 {
     using namespace openvdb;
 
-    CPPUNIT_ASSERT(grids.get() != NULL);
-    CPPUNIT_ASSERT(meta.get() != NULL);
+    CPPUNIT_ASSERT(grids.get() != nullptr);
+    CPPUNIT_ASSERT(meta.get() != nullptr);
 
     // Verify the metadata.
     CPPUNIT_ASSERT_EQUAL(2, int(meta->metaCount()));
@@ -166,22 +166,22 @@
     CPPUNIT_ASSERT_EQUAL(3, int(grids->size()));
 
     GridBase::Ptr grid = findGridByName(*grids, "density");
-    CPPUNIT_ASSERT(grid.get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
     Int32Tree::Ptr density = gridPtrCast<Int32Grid>(grid)->treePtr();
-    CPPUNIT_ASSERT(density.get() != NULL);
+    CPPUNIT_ASSERT(density.get() != nullptr);
 
     grid.reset();
     grid = findGridByName(*grids, "density_copy");
-    CPPUNIT_ASSERT(grid.get() != NULL);
-    CPPUNIT_ASSERT(gridPtrCast<Int32Grid>(grid)->treePtr().get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
+    CPPUNIT_ASSERT(gridPtrCast<Int32Grid>(grid)->treePtr().get() != nullptr);
     // Verify that "density_copy" is an instance of (i.e., shares a tree with) "density".
     CPPUNIT_ASSERT_EQUAL(density, gridPtrCast<Int32Grid>(grid)->treePtr());
 
     grid.reset();
     grid = findGridByName(*grids, "temperature");
-    CPPUNIT_ASSERT(grid.get() != NULL);
+    CPPUNIT_ASSERT(grid.get() != nullptr);
     FloatTree::Ptr temperature = gridPtrCast<FloatGrid>(grid)->treePtr();
-    CPPUNIT_ASSERT(temperature.get() != NULL);
+    CPPUNIT_ASSERT(temperature.get() != nullptr);
 
     ASSERT_DOUBLES_EXACTLY_EQUAL(5, density->getValue(Coord(0, 0, 0)));
     ASSERT_DOUBLES_EXACTLY_EQUAL(6, density->getValue(Coord(100, 0, 0)));
@@ -226,7 +226,7 @@
     GridPtrVecPtr grids = createTestGrids(meta);
     const char* filename = "something.vdb2";
     io::File(filename).write(*grids, *meta);
-    boost::shared_ptr<const char> scopedFile(filename, ::remove);
+    SharedPtr<const char> scopedFile(filename, ::remove);
 
     // Stream the grids back in.
     std::ifstream is(filename, std::ios_base::binary);
@@ -249,7 +249,7 @@
 
     // Create test grids and stream them to a file (and then close the file).
     const char* filename = "something.vdb2";
-    boost::shared_ptr<const char> scopedFile(filename, ::remove);
+    SharedPtr<const char> scopedFile(filename, ::remove);
     {
         std::ofstream os(filename, std::ios_base::binary);
         grids = createTestGrids(meta);
@@ -266,8 +266,8 @@
     grids = file.getGrids();
 
     CPPUNIT_ASSERT(!file.inputHasGridOffsets());
-    CPPUNIT_ASSERT(meta.get() != NULL);
-    CPPUNIT_ASSERT(grids.get() != NULL);
+    CPPUNIT_ASSERT(meta.get() != nullptr);
+    CPPUNIT_ASSERT(grids.get() != nullptr);
     CPPUNIT_ASSERT(!grids->empty());
 
     verifyTestGrids(grids, meta);
diff -aur openvdb.3.2.0/unittest/TestTools.cc openvdb.4.0.0/unittest/TestTools.cc
--- openvdb.3.2.0/unittest/TestTools.cc	2016-04-24 10:39:49.000000000 +0200
+++ openvdb.4.0.0/unittest/TestTools.cc	2016-10-09 10:18:58.000000000 +0200
@@ -31,13 +31,11 @@
 #include <sstream>
 #include <algorithm>// for std::sort
 #include <cppunit/extensions/HelperMacros.h>
-#include <boost/random/mersenne_twister.hpp>
 #include <tbb/atomic.h>
 #include <openvdb/Types.h>
 #include <openvdb/openvdb.h>
 #include <openvdb/tools/ChangeBackground.h>
 #include <openvdb/tools/Diagnostics.h>
-#include <openvdb/tools/Clip.h>
 #include <openvdb/tools/GridOperators.h>
 #include <openvdb/tools/Filter.h>
 #include <openvdb/tools/LevelSetUtil.h>
@@ -96,7 +94,6 @@
     CPPUNIT_TEST(testAccumulate);
     CPPUNIT_TEST(testUtil);
     CPPUNIT_TEST(testVectorTransformer);
-    CPPUNIT_TEST(testClipping);
 
     CPPUNIT_TEST_SUITE_END();
 
@@ -124,7 +121,6 @@
     void testAccumulate();
     void testUtil();
     void testVectorTransformer();
-    void testClipping();
 };
 
 CPPUNIT_TEST_SUITE_REGISTRATION(TestTools);
@@ -195,19 +191,19 @@
         tree->fill(CoordBBox(Coord(0), Coord(leafDim - 1)), 1.0);
         CPPUNIT_ASSERT_EQUAL(Index32(0), tree->leafCount());
         CPPUNIT_ASSERT_EQUAL(Index64(leafDim * leafDim * leafDim), tree->activeVoxelCount());
-        CPPUNIT_ASSERT_EQUAL(1UL, tree->activeTileCount());
-        
+        CPPUNIT_ASSERT_EQUAL(Index64(1), tree->activeTileCount());
+
         tree->setValue(Coord(leafDim, leafDim - 1, leafDim - 1), 1.0);
-        
+
         CPPUNIT_ASSERT_EQUAL(Index64(leafDim * leafDim * leafDim + 1),
                              tree->activeVoxelCount());
-        CPPUNIT_ASSERT_EQUAL(1UL, tree->activeTileCount());
+        CPPUNIT_ASSERT_EQUAL(Index64(1), tree->activeTileCount());
 
         openvdb::tools::dilateVoxels(*tree);
 
         CPPUNIT_ASSERT_EQUAL(Index64(leafDim * leafDim * leafDim + 1 + 5),
                              tree->activeVoxelCount());
-        CPPUNIT_ASSERT_EQUAL(1UL, tree->activeTileCount());
+        CPPUNIT_ASSERT_EQUAL(Index64(1), tree->activeTileCount());
     }
     {
         // Set and dilate a single voxel at each of the eight corners of a leaf node.
@@ -519,14 +515,14 @@
         tree->fill(CoordBBox(Coord(0), Coord(leafDim - 1)), 1.0);
         CPPUNIT_ASSERT_EQUAL(Index32(0), tree->leafCount());
         CPPUNIT_ASSERT_EQUAL(Index64(leafDim * leafDim * leafDim), tree->activeVoxelCount());
-        CPPUNIT_ASSERT_EQUAL(1UL, tree->activeTileCount());
-        
+        CPPUNIT_ASSERT_EQUAL(Index64(1), tree->activeTileCount());
+
         // This has no effect
         openvdb::tools::dilateActiveValues(*tree, 1, openvdb::tools::NN_FACE, openvdb::tools::IGNORE_TILES);
 
         CPPUNIT_ASSERT_EQUAL(Index32(0), tree->leafCount());
         CPPUNIT_ASSERT_EQUAL(Index64(leafDim * leafDim * leafDim), tree->activeVoxelCount());
-        CPPUNIT_ASSERT_EQUAL(1UL, tree->activeTileCount());
+        CPPUNIT_ASSERT_EQUAL(Index64(1), tree->activeTileCount());
     }
     {
         // Create an active, leaf node-sized tile.
@@ -534,15 +530,15 @@
         tree->fill(CoordBBox(Coord(0), Coord(leafDim - 1)), 1.0);
         CPPUNIT_ASSERT_EQUAL(Index32(0), tree->leafCount());
         CPPUNIT_ASSERT_EQUAL(Index64(leafDim * leafDim * leafDim), tree->activeVoxelCount());
-        CPPUNIT_ASSERT_EQUAL(1UL, tree->activeTileCount());
+        CPPUNIT_ASSERT_EQUAL(Index64(1), tree->activeTileCount());
 
         // Adds 6 faces of voxels, each of size leafDim^2
         openvdb::tools::dilateActiveValues(*tree, 1, openvdb::tools::NN_FACE, openvdb::tools::EXPAND_TILES);
 
         CPPUNIT_ASSERT_EQUAL(Index32(1+6), tree->leafCount());
         CPPUNIT_ASSERT_EQUAL(Index64((leafDim + 6) * leafDim * leafDim), tree->activeVoxelCount());
-        CPPUNIT_ASSERT_EQUAL(0UL, tree->activeTileCount());
-        
+        CPPUNIT_ASSERT_EQUAL(Index64(0), tree->activeTileCount());
+
     }
     {
         // Create an active, leaf node-sized tile.
@@ -550,15 +546,15 @@
         tree->fill(CoordBBox(Coord(0), Coord(leafDim - 1)), 1.0);
         CPPUNIT_ASSERT_EQUAL(Index32(0), tree->leafCount());
         CPPUNIT_ASSERT_EQUAL(Index64(leafDim * leafDim * leafDim), tree->activeVoxelCount());
-        CPPUNIT_ASSERT_EQUAL(1UL, tree->activeTileCount());
+        CPPUNIT_ASSERT_EQUAL(Index64(1), tree->activeTileCount());
 
         // Adds 6 faces of voxels, each of size leafDim^2
         openvdb::tools::dilateActiveValues(*tree, 1, openvdb::tools::NN_FACE, openvdb::tools::PRESERVE_TILES);
 
         CPPUNIT_ASSERT_EQUAL(Index32(6), tree->leafCount());
         CPPUNIT_ASSERT_EQUAL(Index64((leafDim + 6) * leafDim * leafDim), tree->activeVoxelCount());
-        CPPUNIT_ASSERT_EQUAL(1UL, tree->activeTileCount());
-        
+        CPPUNIT_ASSERT_EQUAL(Index64(1), tree->activeTileCount());
+
     }
     {
         // Set and dilate a single voxel at each of the eight corners of a leaf node.
@@ -842,7 +838,7 @@
         }
     }
 #endif
-    
+
 }
 
 void
@@ -1280,7 +1276,7 @@
 TestTools::testLevelSetPlatonic()
 {
     using namespace openvdb;
-    
+
     const float scale = 0.5f;
     const Vec3f center(1.0f, 2.0f, 3.0f);
     const float voxelSize = 0.025f, width = 2.0f, background = width*voxelSize;
@@ -1291,7 +1287,7 @@
     // The tests below are not particularly good (a visual inspection
     // in Houdini is much better) but at least it exercises the code
     // and performs an elementary suite of tests.
-    
+
     {// test tetrahedron
         FloatGrid::Ptr ls = tools::createLevelSetTetrahedron<FloatGrid>(scale, center,
                                                                         voxelSize, width);
@@ -1337,7 +1333,7 @@
         CPPUNIT_ASSERT_DOUBLES_EQUAL(background, ls->background(), 1e-6);
         CPPUNIT_ASSERT_DOUBLES_EQUAL(ls->background(),ls->tree().getValue(Coord(0)), 1e-6);
     }
-    
+
 }// testLevelSetPlatonic
 
 void
@@ -2183,7 +2179,7 @@
         CPPUNIT_ASSERT_EQUAL(1, a.spatialOrder());
         CPPUNIT_ASSERT_EQUAL(3, a.temporalOrder());
         CPPUNIT_ASSERT(!a.isLimiterOn());
-            
+
         a.setIntegrator(tools::Scheme::RK4);
         CPPUNIT_ASSERT_EQUAL(1, a.spatialOrder());
         CPPUNIT_ASSERT_EQUAL(4, a.temporalOrder());
@@ -2198,13 +2194,13 @@
         CPPUNIT_ASSERT_EQUAL(2, a.spatialOrder());
         CPPUNIT_ASSERT_EQUAL(2, a.temporalOrder());
         CPPUNIT_ASSERT( a.isLimiterOn());
-        
+
         a.setLimiter(tools::Scheme::NO_LIMITER);
         CPPUNIT_ASSERT_EQUAL(2, a.spatialOrder());
         CPPUNIT_ASSERT_EQUAL(2, a.temporalOrder());
         CPPUNIT_ASSERT(!a.isLimiterOn());
     }
-    
+
     {//test RK4 advect without a mask
         GridT::Ptr density0 = GridT::create(0.0f), density1;
         density0->fill(CoordBBox(Coord(0),Coord(6)), 1.0f);
@@ -2212,7 +2208,7 @@
         CPPUNIT_ASSERT_EQUAL(density0->tree().getValue(Coord(24,3,3)), 0.0f);
         CPPUNIT_ASSERT( density0->tree().isValueOn(Coord( 3,3,3)));
         CPPUNIT_ASSERT(!density0->tree().isValueOn(Coord(24,3,3)));
-        
+
         AdvT a(velocity);
         a.setIntegrator(tools::Scheme::RK4);
         for (int i=1; i<=240; ++i) {
@@ -2226,7 +2222,7 @@
             //file.write(grids);
             density0 = density1;
         }
-        CPPUNIT_ASSERT_EQUAL(density0->tree().getValue(Coord(3,3,3)), 0.0f); 
+        CPPUNIT_ASSERT_EQUAL(density0->tree().getValue(Coord(3,3,3)), 0.0f);
         CPPUNIT_ASSERT(density0->tree().getValue(Coord(24,3,3)) > 0.0f);
         CPPUNIT_ASSERT(!density0->tree().isValueOn(Coord( 3,3,3)));
         CPPUNIT_ASSERT( density0->tree().isValueOn(Coord(24,3,3)));
@@ -2238,7 +2234,7 @@
         CPPUNIT_ASSERT_EQUAL(density0->tree().getValue(Coord(24,3,3)), 0.0f);
         CPPUNIT_ASSERT( density0->tree().isValueOn(Coord( 3,3,3)));
         CPPUNIT_ASSERT(!density0->tree().isValueOn(Coord(24,3,3)));
-        
+
         AdvT a(velocity);
         a.setIntegrator(tools::Scheme::BFECC);
         for (int i=1; i<=240; ++i) {
@@ -2252,7 +2248,7 @@
             //file.write(grids);
             density0 = density1;
         }
-        CPPUNIT_ASSERT_EQUAL(density0->tree().getValue(Coord(3,3,3)), 0.0f); 
+        CPPUNIT_ASSERT_EQUAL(density0->tree().getValue(Coord(3,3,3)), 0.0f);
         CPPUNIT_ASSERT(density0->tree().getValue(Coord(24,3,3)) > 0.0f);
         CPPUNIT_ASSERT(!density0->tree().isValueOn(Coord( 3,3,3)));
         CPPUNIT_ASSERT( density0->tree().isValueOn(Coord(24,3,3)));
@@ -2267,7 +2263,7 @@
 
         BoolGrid::Ptr mask = BoolGrid::create(false);
         mask->fill(CoordBBox(Coord(4,0,0),Coord(30,8,8)), true);
-        
+
         AdvT a(velocity);
         a.setGrainSize(0);
         a.setIntegrator(tools::Scheme::MAC);
@@ -2292,7 +2288,7 @@
 
     /*
     {//benchmark on a sphere
-        util::CpuTimer timer; 
+        util::CpuTimer timer;
         GridT::Ptr density0 = GridT::create(0.0f), density1;
         density0->fill(CoordBBox(Coord(0), Coord(600)), 1.0f);
         timer.start("densify");
@@ -2304,7 +2300,7 @@
         //a.setIntegrator(tools::Scheme::MAC);
         //a.setIntegrator(tools::Scheme::BFECC);
         a.setIntegrator(tools::Scheme::RK4);
-        
+
         for (int i=1; i<=10; ++i) {
             timer.start("Volume Advection");
             density1 = a.advect<GridT, SamplerT>(*density0, 0.1f);
@@ -2710,100 +2706,31 @@
 ////////////////////////////////////////
 
 
-// See also TestGrid::testClipping()
-void
-TestTools::testClipping()
-{
-    using namespace openvdb;
-
-    FloatGrid cube(0.f);
-    cube.fill(CoordBBox(Coord(-10), Coord(10)), /*value=*/5.f, /*active=*/true);
-
-    struct Local {
-        static void validate(const FloatGrid& clipped)
-        {
-            const CoordBBox bbox = clipped.evalActiveVoxelBoundingBox();
-            CPPUNIT_ASSERT_EQUAL(4, bbox.min().x());
-            CPPUNIT_ASSERT_EQUAL(4, bbox.min().y());
-            CPPUNIT_ASSERT_EQUAL(-6, bbox.min().z());
-            CPPUNIT_ASSERT_EQUAL(4, bbox.max().x());
-            CPPUNIT_ASSERT_EQUAL(4, bbox.max().y());
-            CPPUNIT_ASSERT_EQUAL(6, bbox.max().z());
-            CPPUNIT_ASSERT_EQUAL(6 + 6 + 1, int(clipped.activeVoxelCount()));
-            CPPUNIT_ASSERT_EQUAL(2, int(clipped.constTree().leafCount()));
-
-            FloatGrid::ConstAccessor acc = clipped.getConstAccessor();
-            const float bg = clipped.background();
-            Coord xyz;
-            int &x = xyz[0], &y = xyz[1], &z = xyz[2];
-            for (x = -10; x <= 10; ++x) {
-                for (y = -10; y <= 10; ++y) {
-                    for (z = -10; z <= 10; ++z) {
-                        if (x == 4 && y == 4 && z >= -6 && z <= 6) {
-                            CPPUNIT_ASSERT_EQUAL(5.f, acc.getValue(Coord(4, 4, z)));
-                        } else {
-                            CPPUNIT_ASSERT_EQUAL(bg, acc.getValue(Coord(x, y, z)));
-                        }
-                    }
-                }
-            }
-        }
-    };
-
-    {
-        // Test clipping against a bounding box.
-        BBoxd clipBox(Vec3d(4.0, 4.0, -6.0), Vec3d(4.9, 4.9, 6.0));
-        FloatGrid::Ptr clipped = tools::clip(cube, clipBox);
-        Local::validate(*clipped);
-    }
-    {
-        // Test clipping against a mask grid.
-        MaskGrid mask(false);
-        mask.fill(CoordBBox(Coord(4, 4, -6), Coord(4, 4, 6)), true, true);
-        FloatGrid::Ptr clipped = tools::clip(cube, mask);
-        Local::validate(*clipped);
-    }
-    {
-        // Test clipping against a boolean mask grid.
-        BoolGrid mask(false);
-        mask.fill(CoordBBox(Coord(4, 4, -6), Coord(4, 4, 6)), true, true);
-        FloatGrid::Ptr clipped = tools::clip(cube, mask);
-        Local::validate(*clipped);
-    }
-    {
-        // Test clipping against a non-boolean mask grid.
-        Int32Grid mask(0);
-        mask.fill(CoordBBox(Coord(4, 4, -6), Coord(4, 4, 6)), -5, true);
-        FloatGrid::Ptr clipped = tools::clip(cube, mask);
-        Local::validate(*clipped);
-    }
-}
-
 void
 TestTools::testPrune()
 {
     /// @todo Add more unit-tests!
-    
+
     using namespace openvdb;
 
     {// try prunning a tree with const values
         const float value = 5.345f;
-    
+
         FloatTree tree(value);
         CPPUNIT_ASSERT_EQUAL(Index32(0), tree.leafCount());
         CPPUNIT_ASSERT_EQUAL(Index32(1), tree.nonLeafCount()); // root node
         CPPUNIT_ASSERT(tree.empty());
-        
+
         tree.fill(CoordBBox(Coord(-10), Coord(10)), value, /*active=*/false);
         CPPUNIT_ASSERT(!tree.empty());
-        
+
         tools::prune(tree);
-        
+
         CPPUNIT_ASSERT_EQUAL(Index32(0), tree.leafCount());
         CPPUNIT_ASSERT_EQUAL(Index32(1), tree.nonLeafCount()); // root node
         CPPUNIT_ASSERT(tree.empty());
     }
-    
+
     {// Prune a tree with a single leaf node with random values in the range [0,1]
         typedef tree::LeafNode<float,3> LeafNodeT;
         const float val = 1.0, tol = 1.1f;
@@ -2840,7 +2767,7 @@
 
         ASSERT_DOUBLES_EXACTLY_EQUAL(median, tree.getValue(Coord(0)));
     }
-    
+
     /*
     {// Bechmark serial prune
         util::CpuTimer timer;
@@ -2849,7 +2776,7 @@
         sourceFile.open(false);//disable delayed loading
         FloatGrid::Ptr grid = gridPtrCast<FloatGrid>(sourceFile.getGrids()->at(0));
         const Index32 leafCount = grid->tree().leafCount();
-        
+
         timer.start("\nSerial tolerance prune");
         grid->tree().prune();
         timer.stop();
diff -aur openvdb.3.2.0/unittest/TestTransform.cc openvdb.4.0.0/unittest/TestTransform.cc
--- openvdb.3.2.0/unittest/TestTransform.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestTransform.cc	2016-10-09 10:18:58.000000000 +0200
@@ -398,8 +398,8 @@
 
     ss.clear();
     writeString(ss, Name("LinearTransform"));
-    ss.write((char*)&tmpMin, sizeof(Coord::ValueType) * 3);
-    ss.write((char*)&tmpMax, sizeof(Coord::ValueType) * 3);
+    ss.write(reinterpret_cast<char*>(&tmpMin), sizeof(Coord::ValueType) * 3);
+    ss.write(reinterpret_cast<char*>(&tmpMax), sizeof(Coord::ValueType) * 3);
     tmpLocalToWorld = math::Mat4d::identity(),
     tmpWorldToLocal = math::Mat4d::identity(),
     tmpVoxelToLocal = math::Mat4d::identity(),
@@ -440,8 +440,8 @@
 
     ss.clear();
     writeString(ss, Name("LinearTransform"));
-    ss.write((char*)&tmpMin, sizeof(Coord::ValueType) * 3);
-    ss.write((char*)&tmpMax, sizeof(Coord::ValueType) * 3);
+    ss.write(reinterpret_cast<char*>(&tmpMin), sizeof(Coord::ValueType) * 3);
+    ss.write(reinterpret_cast<char*>(&tmpMax), sizeof(Coord::ValueType) * 3);
     tmpLocalToWorld = math::Mat4d::identity(),
     tmpWorldToLocal = math::Mat4d::identity(),
     tmpVoxelToLocal = math::Mat4d::identity(),
diff -aur openvdb.3.2.0/unittest/TestTree.cc openvdb.4.0.0/unittest/TestTree.cc
--- openvdb.3.2.0/unittest/TestTree.cc	2016-07-24 09:29:15.000000000 +0200
+++ openvdb.4.0.0/unittest/TestTree.cc	2016-10-09 10:18:58.000000000 +0200
@@ -51,18 +51,18 @@
     CPPUNIT_ASSERT_DOUBLES_EQUAL((expected), (actual), /*tolerance=*/0.0);
 
 
-typedef float                                            ValueType;
-typedef openvdb::tree::LeafNode<ValueType,3>             LeafNodeType;
-typedef openvdb::tree::InternalNode<LeafNodeType,4>      InternalNodeType1;
-typedef openvdb::tree::InternalNode<InternalNodeType1,5> InternalNodeType2;
-typedef openvdb::tree::RootNode<InternalNodeType2>       RootNodeType;
+using ValueType = float;
+using LeafNodeType = openvdb::tree::LeafNode<ValueType,3>;
+using InternalNodeType1 = openvdb::tree::InternalNode<LeafNodeType,4>;
+using InternalNodeType2 = openvdb::tree::InternalNode<InternalNodeType1,5>;
+using RootNodeType = openvdb::tree::RootNode<InternalNodeType2>;
 
 
 class TestTree: public CppUnit::TestFixture
 {
 public:
-    virtual void setUp() { openvdb::initialize(); }
-    virtual void tearDown() { openvdb::uninitialize(); }
+    void setUp() override { openvdb::initialize(); }
+    void tearDown() override { openvdb::uninitialize(); }
 
     CPPUNIT_TEST_SUITE(TestTree);
     CPPUNIT_TEST(testChangeBackground);
@@ -129,8 +129,9 @@
     void testStealNode();
 
 private:
-    template<class TreeType> void testWriteHalf();
-    template<class TreeType> void doTestMerge(openvdb::MergePolicy);
+    template<typename TreeType> void testWriteHalf();
+    template<typename TreeType> void doTestMerge(openvdb::MergePolicy);
+    template<typename TreeTypeA, typename TreeTypeB> void doTestTopologyDifference();
 };
 
 
@@ -146,7 +147,7 @@
         voxelSize = 1.0f / (dim-1),
         halfWidth = 4,
         gamma = halfWidth * voxelSize;
-    typedef openvdb::FloatGrid GridT;
+    using GridT = openvdb::FloatGrid;
     const openvdb::Coord inside(int(center[0]*dim), int(center[1]*dim), int(center[2]*dim));
     const openvdb::Coord outside(dim);
 
@@ -215,8 +216,8 @@
 void
 TestTree::testWriteHalf()
 {
-    typedef openvdb::Grid<TreeType> GridType;
-    typedef typename TreeType::ValueType ValueT;
+    using GridType = openvdb::Grid<TreeType>;
+    using ValueT = typename TreeType::ValueType;
     ValueT background(5);
     GridType grid(background);
 
@@ -477,7 +478,7 @@
 void
 evalMinMaxTest()
 {
-    typedef typename TreeT::ValueType ValueT;
+    using ValueT = typename TreeT::ValueType;
 
     struct Local {
         static bool isEqual(const ValueT& a, const ValueT& b) {
@@ -601,7 +602,7 @@
 void
 evalMinMaxTest<openvdb::Coord>()
 {
-    typedef openvdb::tree::Tree4<openvdb::Coord,5,4,3>::Type  CoordTree;
+    using CoordTree = openvdb::tree::Tree4<openvdb::Coord,5,4,3>::Type;
     const openvdb::Coord backg(5,4,-6), a(5,4,-7), b(5,5,-6);
 
     CoordTree tree(backg);
@@ -627,7 +628,7 @@
     tree.evalMinMax(minVal, maxVal);
     CPPUNIT_ASSERT_EQUAL(a, minVal);
     CPPUNIT_ASSERT_EQUAL(b, maxVal);
-}    
+}
 
 } // unnamed namespace
 
@@ -917,7 +918,7 @@
 TestTree::testIO()
 {
     const char* filename = "testIO.dbg";
-    boost::shared_ptr<const char> scopedFile(filename, ::remove);
+    openvdb::SharedPtr<const char> scopedFile(filename, ::remove);
     {
         ValueType background=5.0f;
         RootNodeType root_node(background);
@@ -1152,8 +1153,8 @@
 
     TreeType treeA, treeB;
 
-    typedef typename TreeType::RootNodeType RootT;
-    typedef typename TreeType::LeafNodeType LeafT;
+    using RootT = typename TreeType::RootNodeType;
+    using LeafT = typename TreeType::LeafNodeType;
 
     const typename TreeType::ValueType val(1);
     const int
@@ -1229,7 +1230,7 @@
     using openvdb::Coord;
     // Use a small custom tree so we don't run out of memory when
     // tiles are converted to dense leafs :)
-    typedef openvdb::tree::Tree4<float,2, 2, 2>::Type MyTree;
+    using MyTree = openvdb::tree::Tree4<float,2, 2, 2>::Type;
     float background=5.0f;
     const Coord xyz[] = {Coord(-1,-2,-3),Coord( 1, 2, 3)};
     //check two leaf nodes and two tiles at each level 1, 2 and 3
@@ -2012,16 +2013,20 @@
             ASSERT_DOUBLES_EXACTLY_EQUAL(*iter, tree0_copy.getValue(p));
         }
     }
-}// testTopologyDifference
+} // testTopologyDifference
+
+
+////////////////////////////////////////
+
 
 void
 TestTree::testFill()
 {
     // Use a custom tree configuration to ensure we flood-fill at all levels!
-    typedef openvdb::tree::LeafNode<float,2>     LeafT;//4^3
-    typedef openvdb::tree::InternalNode<LeafT,2> InternalT;//4^3
-    typedef openvdb::tree::RootNode<InternalT>   RootT;// child nodes are 16^3
-    typedef openvdb::tree::Tree<RootT>           TreeT;
+    using LeafT = openvdb::tree::LeafNode<float,2>;//4^3
+    using InternalT = openvdb::tree::InternalNode<LeafT,2>;//4^3
+    using RootT = openvdb::tree::RootNode<InternalT>;// child nodes are 16^3
+    using TreeT = openvdb::tree::Tree<RootT>;
 
     const float outside = 2.0f, inside = -outside;
     const openvdb::CoordBBox bbox(openvdb::Coord(-3,-50,30), openvdb::Coord(13,11,323));
@@ -2030,13 +2035,13 @@
          openvdb::Grid<TreeT>::Ptr grid = openvdb::Grid<TreeT>::create(outside);
          TreeT& tree = grid->tree();
          CPPUNIT_ASSERT(!tree.hasActiveTiles());
-         CPPUNIT_ASSERT_EQUAL(size_t(0), tree.activeVoxelCount());
+         CPPUNIT_ASSERT_EQUAL(openvdb::Index64(0), tree.activeVoxelCount());
          for (openvdb::CoordBBox::Iterator<true> ijk(bbox); ijk; ++ijk) {
              ASSERT_DOUBLES_EXACTLY_EQUAL(outside, tree.getValue(*ijk));
          }
          tree.sparseFill(bbox, inside, /*state*/true);
          CPPUNIT_ASSERT(tree.hasActiveTiles());
-         CPPUNIT_ASSERT_EQUAL(size_t(bbox.volume()), tree.activeVoxelCount());
+         CPPUNIT_ASSERT_EQUAL(openvdb::Index64(bbox.volume()), tree.activeVoxelCount());
           for (openvdb::CoordBBox::Iterator<true> ijk(bbox); ijk; ++ijk) {
              ASSERT_DOUBLES_EXACTLY_EQUAL(inside, tree.getValue(*ijk));
          }
@@ -2045,13 +2050,13 @@
          openvdb::Grid<TreeT>::Ptr grid = openvdb::Grid<TreeT>::create(outside);
          TreeT& tree = grid->tree();
          CPPUNIT_ASSERT(!tree.hasActiveTiles());
-         CPPUNIT_ASSERT_EQUAL(size_t(0), tree.activeVoxelCount());
+         CPPUNIT_ASSERT_EQUAL(openvdb::Index64(0), tree.activeVoxelCount());
          for (openvdb::CoordBBox::Iterator<true> ijk(bbox); ijk; ++ijk) {
              ASSERT_DOUBLES_EXACTLY_EQUAL(outside, tree.getValue(*ijk));
          }
          tree.denseFill(bbox, inside, /*state*/true);
          CPPUNIT_ASSERT(!tree.hasActiveTiles());
-         CPPUNIT_ASSERT_EQUAL(size_t(bbox.volume()), tree.activeVoxelCount());
+         CPPUNIT_ASSERT_EQUAL(openvdb::Index64(bbox.volume()), tree.activeVoxelCount());
          for (openvdb::CoordBBox::Iterator<true> ijk(bbox); ijk; ++ijk) {
              ASSERT_DOUBLES_EXACTLY_EQUAL(inside, tree.getValue(*ijk));
          }
@@ -2063,10 +2068,10 @@
 TestTree::testSignedFloodFill()
 {
     // Use a custom tree configuration to ensure we flood-fill at all levels!
-    typedef openvdb::tree::LeafNode<float,2>     LeafT;//4^3
-    typedef openvdb::tree::InternalNode<LeafT,2> InternalT;//4^3
-    typedef openvdb::tree::RootNode<InternalT>   RootT;// child nodes are 16^3
-    typedef openvdb::tree::Tree<RootT>           TreeT;
+    using LeafT = openvdb::tree::LeafNode<float,2>;//4^3
+    using InternalT = openvdb::tree::InternalNode<LeafT,2>;//4^3
+    using RootT = openvdb::tree::RootNode<InternalT>;// child nodes are 16^3
+    using TreeT = openvdb::tree::Tree<RootT>;
 
     const float outside = 2.0f, inside = -outside, radius = 20.0f;
 
@@ -2278,7 +2283,7 @@
 
     // This version is fast since it only visits voxel and avoids
     // random access to set the voxels off.
-    typedef openvdb::FloatTree::LeafNodeType::ValueOnIter VoxelOnIter;
+    using VoxelOnIter = openvdb::FloatTree::LeafNodeType::ValueOnIter;
     for (openvdb::FloatTree::LeafIter lIter = tree.beginLeaf(); lIter; ++lIter) {
         for (VoxelOnIter vIter = lIter->beginValueOn(); vIter; ++vIter) {
             if (fabs(*vIter)<new_width) continue;
@@ -2340,7 +2345,7 @@
         openvdb::FloatTree::Ptr tree(new openvdb::FloatTree(background));
         CPPUNIT_ASSERT_EQUAL(-1, tree->getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 0, int(tree->leafCount()));
-        CPPUNIT_ASSERT(tree->touchLeaf(xyz)!=NULL);
+        CPPUNIT_ASSERT(tree->touchLeaf(xyz) != nullptr);
         CPPUNIT_ASSERT_EQUAL( 3, tree->getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 1, int(tree->leafCount()));
         CPPUNIT_ASSERT(!tree->isValueOn(xyz));
@@ -2351,7 +2356,7 @@
         openvdb::tree::ValueAccessor<openvdb::FloatTree> acc(*tree);
         CPPUNIT_ASSERT_EQUAL(-1, acc.getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 0, int(tree->leafCount()));
-        CPPUNIT_ASSERT(acc.touchLeaf(xyz)!=NULL);
+        CPPUNIT_ASSERT(acc.touchLeaf(xyz) != nullptr);
         CPPUNIT_ASSERT_EQUAL( 3, tree->getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 1, int(tree->leafCount()));
         CPPUNIT_ASSERT(!acc.isValueOn(xyz));
@@ -2369,13 +2374,13 @@
         openvdb::FloatTree::Ptr tree(new openvdb::FloatTree(background));
         CPPUNIT_ASSERT_EQUAL(-1, tree->getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 0, int(tree->leafCount()));
-        CPPUNIT_ASSERT(tree->probeLeaf(xyz)==NULL);
+        CPPUNIT_ASSERT(tree->probeLeaf(xyz) == nullptr);
         CPPUNIT_ASSERT_EQUAL(-1, tree->getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 0, int(tree->leafCount()));
         tree->setValue(xyz, value);
         CPPUNIT_ASSERT_EQUAL( 3, tree->getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 1, int(tree->leafCount()));
-        CPPUNIT_ASSERT(tree->probeLeaf(xyz)!=NULL);
+        CPPUNIT_ASSERT(tree->probeLeaf(xyz) != nullptr);
         CPPUNIT_ASSERT_EQUAL( 3, tree->getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 1, int(tree->leafCount()));
         CPPUNIT_ASSERT(tree->isValueOn(xyz));
@@ -2385,7 +2390,7 @@
         const openvdb::FloatTree tree1(background);
         CPPUNIT_ASSERT_EQUAL(-1, tree1.getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 0, int(tree1.leafCount()));
-        CPPUNIT_ASSERT(tree1.probeConstLeaf(xyz)==NULL);
+        CPPUNIT_ASSERT(tree1.probeConstLeaf(xyz) == nullptr);
         CPPUNIT_ASSERT_EQUAL(-1, tree1.getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 0, int(tree1.leafCount()));
         openvdb::FloatTree tmp(tree1);
@@ -2393,7 +2398,7 @@
         const openvdb::FloatTree tree2(tmp);
         CPPUNIT_ASSERT_EQUAL( 3, tree2.getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 1, int(tree2.leafCount()));
-        CPPUNIT_ASSERT(tree2.probeConstLeaf(xyz)!=NULL);
+        CPPUNIT_ASSERT(tree2.probeConstLeaf(xyz) != nullptr);
         CPPUNIT_ASSERT_EQUAL( 3, tree2.getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 1, int(tree2.leafCount()));
         CPPUNIT_ASSERT(tree2.isValueOn(xyz));
@@ -2404,13 +2409,13 @@
         openvdb::tree::ValueAccessor<openvdb::FloatTree> acc(*tree);
         CPPUNIT_ASSERT_EQUAL(-1, acc.getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 0, int(tree->leafCount()));
-        CPPUNIT_ASSERT(acc.probeLeaf(xyz)==NULL);
+        CPPUNIT_ASSERT(acc.probeLeaf(xyz) == nullptr);
         CPPUNIT_ASSERT_EQUAL(-1, acc.getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 0, int(tree->leafCount()));
         acc.setValue(xyz, value);
         CPPUNIT_ASSERT_EQUAL( 3, acc.getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 1, int(tree->leafCount()));
-        CPPUNIT_ASSERT(acc.probeLeaf(xyz)!=NULL);
+        CPPUNIT_ASSERT(acc.probeLeaf(xyz) != nullptr);
         CPPUNIT_ASSERT_EQUAL( 3, acc.getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 1, int(tree->leafCount()));
         CPPUNIT_ASSERT(acc.isValueOn(xyz));
@@ -2421,7 +2426,7 @@
         openvdb::tree::ValueAccessor<const openvdb::FloatTree> acc1(tree1);
         CPPUNIT_ASSERT_EQUAL(-1, acc1.getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 0, int(tree1.leafCount()));
-        CPPUNIT_ASSERT(acc1.probeConstLeaf(xyz)==NULL);
+        CPPUNIT_ASSERT(acc1.probeConstLeaf(xyz) == nullptr);
         CPPUNIT_ASSERT_EQUAL(-1, acc1.getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 0, int(tree1.leafCount()));
         openvdb::FloatTree tmp(tree1);
@@ -2430,7 +2435,7 @@
         openvdb::tree::ValueAccessor<const openvdb::FloatTree> acc2(tree2);
         CPPUNIT_ASSERT_EQUAL( 3, acc2.getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 1, int(tree2.leafCount()));
-        CPPUNIT_ASSERT(acc2.probeConstLeaf(xyz)!=NULL);
+        CPPUNIT_ASSERT(acc2.probeConstLeaf(xyz) != nullptr);
         CPPUNIT_ASSERT_EQUAL( 3, acc2.getValueDepth(xyz));
         CPPUNIT_ASSERT_EQUAL( 1, int(tree2.leafCount()));
         CPPUNIT_ASSERT(acc2.isValueOn(xyz));
@@ -2444,7 +2449,7 @@
 {
     using namespace openvdb;
 
-    typedef FloatTree::LeafNodeType LeafT;
+    using LeafT = FloatTree::LeafNodeType;
 
     const Coord ijk(100);
     FloatGrid grid;
@@ -2452,7 +2457,7 @@
 
     tree.setValue(ijk, 5.0);
     const LeafT* oldLeaf = tree.probeLeaf(ijk);
-    CPPUNIT_ASSERT(oldLeaf != NULL);
+    CPPUNIT_ASSERT(oldLeaf != nullptr);
     ASSERT_DOUBLES_EXACTLY_EQUAL(5.0, oldLeaf->getValue(ijk));
 
     LeafT* newLeaf = new LeafT;
@@ -2475,7 +2480,7 @@
     FloatTree& tree = grid.tree();
 
     tree.setValue(ijk, 5.0);
-    CPPUNIT_ASSERT(tree.probeLeaf(ijk) != NULL);
+    CPPUNIT_ASSERT(tree.probeLeaf(ijk) != nullptr);
 
     const Index lvl = FloatTree::DEPTH >> 1;
     OPENVDB_NO_UNREACHABLE_CODE_WARNING_BEGIN
@@ -2483,7 +2488,7 @@
     else tree.addTile(1,ijk, 3.0, /*active=*/true);
     OPENVDB_NO_UNREACHABLE_CODE_WARNING_END
 
-    CPPUNIT_ASSERT(tree.probeLeaf(ijk) == NULL);
+    CPPUNIT_ASSERT(tree.probeLeaf(ijk) == nullptr);
     ASSERT_DOUBLES_EXACTLY_EQUAL(3.0, tree.getValue(ijk));
 }
 
@@ -2646,12 +2651,12 @@
     }
     /*
     {//testing Tree::getNodes() with std::deque<T*> where T is not part of the tree configuration
-        typedef openvdb::tree::LeafNode<float, 5> NodeT;
+        using NodeT = openvdb::tree::LeafNode<float, 5>;
         std::deque<const NodeT*> array;
         tree.getNodes(array);//should NOT compile since NodeT is not part of the FloatTree configuration
     }
     {//testing Tree::getNodes() const with std::deque<T*> where T is not part of the tree configuration
-        typedef openvdb::tree::LeafNode<float, 5> NodeT;
+        using NodeT = openvdb::tree::LeafNode<float, 5>;
         std::deque<const NodeT*> array;
         const FloatTree& tmp = tree;
         tmp.getNodes(array);//should NOT compile since NodeT is not part of the FloatTree configuration
@@ -2772,7 +2777,7 @@
     /*
     {//testing Tree::stealNodes() with std::deque<T*> where T is not part of the tree configuration
         FloatTree tree2 = tree;
-        typedef openvdb::tree::LeafNode<float, 5> NodeT;
+        using NodeT = openvdb::tree::LeafNode<float, 5>;
         std::deque<const NodeT*> array;
         //should NOT compile since NodeT is not part of the FloatTree configuration
         tree2.stealNodes(array, 0.0f, true);
@@ -2790,14 +2795,14 @@
     const openvdb::Coord xyz(-23,42,70);
 
     {// stal a LeafNode
-        typedef FloatTree::LeafNodeType NodeT;
+        using NodeT = FloatTree::LeafNodeType;
         CPPUNIT_ASSERT_EQUAL(Index(0), NodeT::getLevel());
 
         FloatTree tree(background);
         CPPUNIT_ASSERT_EQUAL(Index(0), tree.leafCount());
         CPPUNIT_ASSERT(!tree.isValueOn(xyz));
         CPPUNIT_ASSERT_DOUBLES_EQUAL(background, tree.getValue(xyz), epsilon);
-        CPPUNIT_ASSERT(tree.root().stealNode<NodeT>(xyz, value, false)==NULL);
+        CPPUNIT_ASSERT(tree.root().stealNode<NodeT>(xyz, value, false) == nullptr);
 
         tree.setValue(xyz, value);
         CPPUNIT_ASSERT_EQUAL(Index(1), tree.leafCount());
@@ -2805,24 +2810,24 @@
         CPPUNIT_ASSERT_DOUBLES_EQUAL(value, tree.getValue(xyz), epsilon);
 
         NodeT* node = tree.root().stealNode<NodeT>(xyz, background, false);
-        CPPUNIT_ASSERT(node != NULL);
+        CPPUNIT_ASSERT(node != nullptr);
         CPPUNIT_ASSERT_EQUAL(Index(0), tree.leafCount());
         CPPUNIT_ASSERT(!tree.isValueOn(xyz));
         CPPUNIT_ASSERT_DOUBLES_EQUAL(background, tree.getValue(xyz), epsilon);
-        CPPUNIT_ASSERT(tree.root().stealNode<NodeT>(xyz, value, false)==NULL);
+        CPPUNIT_ASSERT(tree.root().stealNode<NodeT>(xyz, value, false) == nullptr);
         CPPUNIT_ASSERT_DOUBLES_EQUAL(value, node->getValue(xyz), epsilon);
         CPPUNIT_ASSERT(node->isValueOn(xyz));
         delete node;
     }
     {// steal a bottom InternalNode
-        typedef FloatTree::RootNodeType::ChildNodeType::ChildNodeType NodeT;
+        using NodeT = FloatTree::RootNodeType::ChildNodeType::ChildNodeType;
         CPPUNIT_ASSERT_EQUAL(Index(1), NodeT::getLevel());
 
         FloatTree tree(background);
         CPPUNIT_ASSERT_EQUAL(Index(0), tree.leafCount());
         CPPUNIT_ASSERT(!tree.isValueOn(xyz));
         CPPUNIT_ASSERT_DOUBLES_EQUAL(background, tree.getValue(xyz), epsilon);
-        CPPUNIT_ASSERT(tree.root().stealNode<NodeT>(xyz, value, false)==NULL);
+        CPPUNIT_ASSERT(tree.root().stealNode<NodeT>(xyz, value, false) == nullptr);
 
         tree.setValue(xyz, value);
         CPPUNIT_ASSERT_EQUAL(Index(1), tree.leafCount());
@@ -2830,24 +2835,24 @@
         CPPUNIT_ASSERT_DOUBLES_EQUAL(value, tree.getValue(xyz), epsilon);
 
         NodeT* node = tree.root().stealNode<NodeT>(xyz, background, false);
-        CPPUNIT_ASSERT(node != NULL);
+        CPPUNIT_ASSERT(node != nullptr);
         CPPUNIT_ASSERT_EQUAL(Index(0), tree.leafCount());
         CPPUNIT_ASSERT(!tree.isValueOn(xyz));
         CPPUNIT_ASSERT_DOUBLES_EQUAL(background, tree.getValue(xyz), epsilon);
-        CPPUNIT_ASSERT(tree.root().stealNode<NodeT>(xyz, value, false)==NULL);
+        CPPUNIT_ASSERT(tree.root().stealNode<NodeT>(xyz, value, false) == nullptr);
         CPPUNIT_ASSERT_DOUBLES_EQUAL(value, node->getValue(xyz), epsilon);
         CPPUNIT_ASSERT(node->isValueOn(xyz));
         delete node;
     }
     {// steal a top InternalNode
-        typedef FloatTree::RootNodeType::ChildNodeType NodeT;
+        using NodeT = FloatTree::RootNodeType::ChildNodeType;
         CPPUNIT_ASSERT_EQUAL(Index(2), NodeT::getLevel());
 
         FloatTree tree(background);
         CPPUNIT_ASSERT_EQUAL(Index(0), tree.leafCount());
         CPPUNIT_ASSERT(!tree.isValueOn(xyz));
         CPPUNIT_ASSERT_DOUBLES_EQUAL(background, tree.getValue(xyz), epsilon);
-        CPPUNIT_ASSERT(tree.root().stealNode<NodeT>(xyz, value, false)==NULL);
+        CPPUNIT_ASSERT(tree.root().stealNode<NodeT>(xyz, value, false) == nullptr);
 
         tree.setValue(xyz, value);
         CPPUNIT_ASSERT_EQUAL(Index(1), tree.leafCount());
@@ -2855,11 +2860,11 @@
         CPPUNIT_ASSERT_DOUBLES_EQUAL(value, tree.getValue(xyz), epsilon);
 
         NodeT* node = tree.root().stealNode<NodeT>(xyz, background, false);
-        CPPUNIT_ASSERT(node != NULL);
+        CPPUNIT_ASSERT(node != nullptr);
         CPPUNIT_ASSERT_EQUAL(Index(0), tree.leafCount());
         CPPUNIT_ASSERT(!tree.isValueOn(xyz));
         CPPUNIT_ASSERT_DOUBLES_EQUAL(background, tree.getValue(xyz), epsilon);
-        CPPUNIT_ASSERT(tree.root().stealNode<NodeT>(xyz, value, false)==NULL);
+        CPPUNIT_ASSERT(tree.root().stealNode<NodeT>(xyz, value, false) == nullptr);
         CPPUNIT_ASSERT_DOUBLES_EQUAL(value, node->getValue(xyz), epsilon);
         CPPUNIT_ASSERT(node->isValueOn(xyz));
         delete node;
diff -aur openvdb.3.2.0/unittest/TestVolumeRayIntersector.cc openvdb.4.0.0/unittest/TestVolumeRayIntersector.cc
--- openvdb.3.2.0/unittest/TestVolumeRayIntersector.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/unittest/TestVolumeRayIntersector.cc	2016-10-09 10:18:58.000000000 +0200
@@ -28,10 +28,9 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 
+/// @file unittest/TestVolumeRayIntersector.cc
 /// @author Ken Museth
 
-#include <cppunit/extensions/HelperMacros.h>
-#include <openvdb/Exceptions.h>
 #include <openvdb/openvdb.h>
 #include <openvdb/math/Ray.h>
 #include <openvdb/Types.h>
@@ -39,16 +38,13 @@
 #include <openvdb/tools/LevelSetSphere.h>
 #include <openvdb/tools/RayIntersector.h>
 
+#include <cppunit/extensions/HelperMacros.h>
+
+#include <cassert>
+#include <deque>
 #include <iostream>
-#include <fstream>
-#include <string>
-#include <sstream>
-#include <assert.h>
 #include <vector>
-#include <deque>
 
-#define ASSERT_DOUBLES_EXACTLY_EQUAL(expected, actual) \
-    CPPUNIT_ASSERT_DOUBLES_EQUAL((expected), (actual), /*tolerance=*/0.0);
 
 #define ASSERT_DOUBLES_APPROX_EQUAL(expected, actual) \
     CPPUNIT_ASSERT_DOUBLES_EQUAL((expected), (actual), /*tolerance=*/1.e-6);
diff -aur openvdb.3.2.0/util/NodeMasks.h openvdb.4.0.0/util/NodeMasks.h
--- openvdb.3.2.0/util/NodeMasks.h	2016-04-24 10:39:49.000000000 +0200
+++ openvdb.4.0.0/util/NodeMasks.h	2016-10-09 10:18:58.000000000 +0200
@@ -170,17 +170,19 @@
 
 
 /// Base class for the bit mask iterators
-template <typename NodeMask>
+template<typename NodeMask>
 class BaseMaskIterator
 {
 protected:
-    Index32          mPos;//bit position
-    const NodeMask*  mParent;//this iterator can't change the parent_mask!
+    Index32 mPos; // bit position
+    const NodeMask* mParent; // this iterator can't change the parent_mask!
+
 public:
-    BaseMaskIterator() : mPos(NodeMask::SIZE), mParent(NULL) {}
-    BaseMaskIterator(Index32 pos,const NodeMask *parent) : mPos(pos), mParent(parent)
+    BaseMaskIterator(): mPos(NodeMask::SIZE), mParent(nullptr) {}
+    BaseMaskIterator(const BaseMaskIterator&) = default;
+    BaseMaskIterator(Index32 pos, const NodeMask* parent): mPos(pos), mParent(parent)
     {
-        assert( (parent==NULL && pos==0 ) ||  (parent!=NULL && pos<=NodeMask::SIZE) );
+        assert((parent == nullptr && pos == 0) || (parent != nullptr && pos <= NodeMask::SIZE));
     }
     bool operator==(const BaseMaskIterator &iter) const {return mPos == iter.mPos;}
     bool operator!=(const BaseMaskIterator &iter) const {return mPos != iter.mPos;}
@@ -189,14 +191,10 @@
     {
         mPos = iter.mPos; mParent = iter.mParent; return *this;
     }
-    Index32 offset() const {return mPos;}
-    Index32 pos() const {return mPos;}
-    bool test() const
-    {
-        assert(mPos  <= NodeMask::SIZE);
-        return (mPos != NodeMask::SIZE);
-    }
-    operator bool() const {return this->test();}
+    Index32 offset() const { return mPos; }
+    Index32 pos() const { return mPos; }
+    bool test() const { assert(mPos <= NodeMask::SIZE); return (mPos != NodeMask::SIZE); }
+    operator bool() const { return this->test(); }
 }; // class BaseMaskIterator
 
 
@@ -213,7 +211,7 @@
     OnMaskIterator(Index32 pos,const NodeMask *parent) : BaseType(pos,parent) {}
     void increment()
     {
-        assert(mParent != NULL);
+        assert(mParent != nullptr);
         mPos = mParent->findNextOn(mPos+1);
         assert(mPos <= NodeMask::SIZE);
     }
@@ -244,7 +242,7 @@
     OffMaskIterator(Index32 pos,const NodeMask *parent) : BaseType(pos,parent) {}
     void increment()
     {
-        assert(mParent != NULL);
+        assert(mParent != nullptr);
         mPos=mParent->findNextOff(mPos+1);
         assert(mPos <= NodeMask::SIZE);
     }
@@ -276,7 +274,7 @@
     DenseMaskIterator(Index32 pos,const NodeMask *parent) : BaseType(pos,parent) {}
     void increment()
     {
-        assert(mParent != NULL);
+        assert(mParent != nullptr);
         mPos += 1;//careful - the increment might go beyond the end
         assert(mPos<= NodeMask::SIZE);
     }
@@ -365,7 +363,7 @@
     //
     // Bitwise logical operations
     //
-    
+
     /// @brief Apply a functor to the words of the this and the other mask.
     ///
     /// @details An example that implements the "operator&=" method:
@@ -405,7 +403,7 @@
         for (Index32 n = WORD_COUNT; n--;  ++w1, ++w2) *w1 &= *w2;
         return *this;
     }
-    /// @brief Bitwise union 
+    /// @brief Bitwise union
     const NodeMask& operator|=(const NodeMask& other)
     {
         Word *w1 = mWords;
@@ -433,7 +431,7 @@
     NodeMask operator&(const NodeMask& other) const { NodeMask m(*this); m &= other; return m; }
     NodeMask operator|(const NodeMask& other) const { NodeMask m(*this); m |= other; return m; }
     NodeMask operator^(const NodeMask& other) const { NodeMask m(*this); m ^= other; return m; }
-   
+
     /// Return the byte size of this NodeMask
     static Index32 memUsage() { return static_cast<Index32>(WORD_COUNT*sizeof(Word)); }
     /// Return the total number of on bits
@@ -526,7 +524,7 @@
         if ( !isOn && mWords[0] != Word(0)) return false;//early out
         const Word *w = mWords + 1, *n = mWords + WORD_COUNT;
         while( w<n && *w == mWords[0] ) ++w;
-        return w == n; 
+        return w == n;
     }
     Index32 findFirstOn() const
     {
@@ -662,7 +660,7 @@
     //
     // Bitwise logical operations
     //
-    
+
     /// @brief Apply a functor to the words of the this and the other mask.
     ///
     /// @details An example that implements the "operator&=" method:
@@ -694,13 +692,13 @@
         mByte &= other.mByte;
         return *this;
     }
-    /// @brief Bitwise union 
+    /// @brief Bitwise union
     const NodeMask& operator|=(const NodeMask& other)
     {
         mByte |= other.mByte;
         return *this;
     }
-    /// @brief Bitwise difference 
+    /// @brief Bitwise difference
     const NodeMask& operator-=(const NodeMask& other)
     {
         mByte &= static_cast<Byte>(~other.mByte);
@@ -924,7 +922,7 @@
         mWord |= other.mWord;
         return *this;
     }
-    /// @brief Bitwise difference 
+    /// @brief Bitwise difference
     const NodeMask& operator-=(const NodeMask& other)
     {
         mWord &= ~other.mWord;
@@ -986,7 +984,7 @@
         return 0 != (mWord & (UINT64_C(0x01) << (n & 63)));
     }
     /// Return true if the <i>n</i>th bit is off
-    bool isOff(Index32 n) const {return !this->isOn(n); } 
+    bool isOff(Index32 n) const {return !this->isOn(n); }
     /// Return true if all the bits are on
     bool isOn() const { return mWord == UINT64_C(0xFFFFFFFFFFFFFFFF); }
     /// Return true if all the bits are off
@@ -996,7 +994,7 @@
     /// returns true - else it is undefined.
     bool isConstant(bool &isOn) const
     {   isOn = this->isOn();
-        return isOn || this->isOff(); 
+        return isOn || this->isOff();
     }
     Index32 findFirstOn() const { return mWord ? FindLowestOn(mWord) : 64; }
     Index32 findFirstOff() const
@@ -1072,7 +1070,7 @@
     Index32  *mBits;
 
 public:
-    RootNodeMask(): mBitSize(0), mIntSize(0), mBits(NULL) {}
+    RootNodeMask(): mBitSize(0), mIntSize(0), mBits(nullptr) {}
     RootNodeMask(Index32 bit_size):
         mBitSize(bit_size), mIntSize(((bit_size-1)>>5)+1), mBits(new Index32[mIntSize])
     {
@@ -1115,11 +1113,10 @@
         Index32             mBitSize;
         const RootNodeMask* mParent;//this iterator can't change the parent_mask!
     public:
-        BaseIterator() : mPos(0), mBitSize(0), mParent(NULL) {}
-        BaseIterator(Index32 pos,const RootNodeMask *parent)
-            : mPos(pos), mBitSize(parent->getBitSize()), mParent(parent) {
-            assert( pos<=mBitSize );
-        }
+        BaseIterator() : mPos(0), mBitSize(0), mParent(nullptr) {}
+        BaseIterator(const BaseIterator&) = default;
+        BaseIterator(Index32 pos, const RootNodeMask* parent):
+            mPos(pos), mBitSize(parent->getBitSize()), mParent(parent) { assert(pos <= mBitSize); }
         bool operator==(const BaseIterator &iter) const {return mPos == iter.mPos;}
         bool operator!=(const BaseIterator &iter) const {return mPos != iter.mPos;}
         bool operator< (const BaseIterator &iter) const {return mPos <  iter.mPos;}
@@ -1153,7 +1150,7 @@
         OnIterator() : BaseIterator() {}
         OnIterator(Index32 pos,const RootNodeMask *parent) : BaseIterator(pos,parent) {}
         void increment() {
-            assert(mParent!=NULL);
+            assert(mParent != nullptr);
             mPos=mParent->findNextOn(mPos+1);
             assert(mPos <= mBitSize);
         }
@@ -1181,7 +1178,7 @@
         OffIterator() : BaseIterator()  {}
         OffIterator(Index32 pos,const RootNodeMask *parent) : BaseIterator(pos,parent) {}
         void increment() {
-            assert(mParent!=NULL);
+            assert(mParent != nullptr);
             mPos=mParent->findNextOff(mPos+1);
             assert(mPos <= mBitSize);
         }
@@ -1209,7 +1206,7 @@
         DenseIterator() : BaseIterator() {}
         DenseIterator(Index32 pos,const RootNodeMask *parent) : BaseIterator(pos,parent) {}
         void increment() {
-            assert(mParent!=NULL);
+            assert(mParent != nullptr);
             mPos += 1;//carefull - the increament might go beyond the end
             assert(mPos<= mBitSize);
         }
@@ -1370,11 +1367,11 @@
 
     void save(std::ostream& os) const {
         assert(mBits);
-        os.write((const char *)mBits,mIntSize*sizeof(Index32));
+        os.write(reinterpret_cast<const char*>(mBits), mIntSize * sizeof(Index32));
     }
     void load(std::istream& is) {
         assert(mBits);
-        is.read((char *)mBits,mIntSize*sizeof(Index32));
+        is.read(reinterpret_cast<char*>(mBits), mIntSize * sizeof(Index32));
     }
     /// @brief simple print method for debugging
     void printInfo(std::ostream& os=std::cout) const {
diff -aur openvdb.3.2.0/version.h openvdb.4.0.0/version.h
--- openvdb.3.2.0/version.h	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/version.h	2016-10-09 10:18:58.000000000 +0200
@@ -40,18 +40,18 @@
 /// openvdb::vX_Y_Z::Vec3i, openvdb::vX_Y_Z::io::File, openvdb::vX_Y_Z::tree::Tree, etc.,
 /// where X, Y and Z are OPENVDB_LIBRARY_MAJOR_VERSION, OPENVDB_LIBRARY_MINOR_VERSION
 /// and OPENVDB_LIBRARY_PATCH_VERSION, respectively (defined below).
-#define OPENVDB_VERSION_NAME v3_2_0
+#define OPENVDB_VERSION_NAME v4_0_0
 
 // Library major, minor and patch version numbers
-#define OPENVDB_LIBRARY_MAJOR_VERSION_NUMBER 3
-#define OPENVDB_LIBRARY_MINOR_VERSION_NUMBER 2
+#define OPENVDB_LIBRARY_MAJOR_VERSION_NUMBER 4
+#define OPENVDB_LIBRARY_MINOR_VERSION_NUMBER 0
 #define OPENVDB_LIBRARY_PATCH_VERSION_NUMBER 0
 
 /// @brief Library version number string of the form "<major>.<minor>.<patch>"
 /// @details This is a macro rather than a static constant because we typically
 /// want the compile-time version number, not the runtime version number
 /// (although the two are usually the same).
-#define OPENVDB_LIBRARY_VERSION_STRING "3.2.0"
+#define OPENVDB_LIBRARY_VERSION_STRING "4.0.0"
 
 /// Library version number as a packed integer ("%02x%02x%04x", major, minor, patch)
 #define OPENVDB_LIBRARY_VERSION_NUMBER \
diff -aur openvdb.3.2.0/viewer/Camera.cc openvdb.4.0.0/viewer/Camera.cc
--- openvdb.3.2.0/viewer/Camera.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/viewer/Camera.cc	2016-10-09 10:18:58.000000000 +0200
@@ -77,7 +77,7 @@
     , mMouseXPos(0.0)
     , mMouseYPos(0.0)
 #if GLFW_VERSION_MAJOR >= 3
-    , mWindow(NULL)
+    , mWindow(nullptr)
 #endif
 {
 }
@@ -123,7 +123,7 @@
 Camera::aim()
 {
 #if GLFW_VERSION_MAJOR >= 3
-    if (mWindow == NULL) return;
+    if (mWindow == nullptr) return;
 #endif
 
     // Get the window size
@@ -146,7 +146,7 @@
     glLoadIdentity();
 
     // Window aspect (assumes square pixels)
-    double aspectRatio = (double)width / (double)height;
+    double aspectRatio = double(width) / double(height);
 
     // Set perspective view (fov is in degrees in the y direction.)
     gluPerspective(mFov, aspectRatio, mNearPlane, mFarPlane);
@@ -181,7 +181,7 @@
 Camera::keyCallback(int key, int)
 {
 #if GLFW_VERSION_MAJOR >= 3
-    if (mWindow == NULL) return;
+    if (mWindow == nullptr) return;
     int state = glfwGetKey(mWindow, key);
 #else
     int state = glfwGetKey(key);
diff -aur openvdb.3.2.0/viewer/Viewer.cc openvdb.4.0.0/viewer/Viewer.cc
--- openvdb.3.2.0/viewer/Viewer.cc	2016-04-10 09:22:12.000000000 +0200
+++ openvdb.4.0.0/viewer/Viewer.cc	2016-10-09 10:18:58.000000000 +0200
@@ -45,8 +45,8 @@
 #include <sstream>
 #include <vector>
 #include <limits>
+#include <boost/date_time/posix_time/posix_time.hpp>
 #include <boost/thread/thread.hpp>
-#include <time.h> // for nanosleep()
 
 #ifdef OPENVDB_USE_GLFW_3
 //#define GLFW_INCLUDE_GLU
@@ -835,8 +835,7 @@
 {
     secs = fabs(secs);
     int isecs = int(secs);
-    struct timespec sleepTime = { isecs /*sec*/, int(1.0e9 * (secs - isecs)) /*nsec*/ };
-    nanosleep(&sleepTime, /*remainingTime=*/NULL);
+    boost::this_thread::sleep(boost::posix_time::seconds(isecs));
 }
 
 
