Seulement dans openvdb-6.1.0: appveyor.yml
Seulement dans openvdb-6.0.0: BuildingWithCMake.md
Seulement dans openvdb-6.1.0: ci
Seulement dans openvdb-6.1.0: .circleci
Seulement dans openvdb-6.1.0: .cirrus.yml
Seulement dans openvdb-6.1.0/cmake: backports
diff -aur openvdb-6.0.0/cmake/FindBlosc.cmake openvdb-6.1.0/cmake/FindBlosc.cmake
--- openvdb-6.0.0/cmake/FindBlosc.cmake	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/cmake/FindBlosc.cmake	2019-05-07 22:58:35.000000000 +0200
@@ -1,4 +1,4 @@
-# Copyright (c) 2012-2016 DreamWorks Animation LLC
+# Copyright (c) 2012-2019 DreamWorks Animation LLC
 #
 # All rights reserved. This software is distributed under the
 # Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -24,57 +24,195 @@
 # IN NO EVENT SHALL THE COPYRIGHT HOLDERS' AND CONTRIBUTORS' AGGREGATE
 # LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 #
+#[=======================================================================[.rst:
 
-# -*- cmake -*-
-# - Find Blosc
-#
-# Author : Nicholas Yue yue.nicholas@gmail.com
-#
-# BLOSC_FOUND            set if Blosc is found.
-# BLOSC_INCLUDE_DIR      Blosc's include directory
-# BLOSC_LIBRARYDIR      Blosc's library directory
-# BLOSC_LIBRARIES        all Blosc libraries
+FindBlosc
+---------
+
+Find Blosc include dirs and libraries
+
+Use this module by invoking find_package with the form::
+
+  find_package(Blosc
+    [version] [EXACT]      # Minimum or EXACT version e.g. 1.5.0
+    [REQUIRED]             # Fail with error if Blosc is not found
+    )
+
+IMPORTED Targets
+^^^^^^^^^^^^^^^^
+
+``Blosc::blosc``
+  This module defines IMPORTED target Blosc::Blosc, if Blosc has been found.
 
-FIND_PACKAGE ( PackageHandleStandardArgs )
+Result Variables
+^^^^^^^^^^^^^^^^
 
-FIND_PATH( BLOSC_LOCATION include/blosc.h
-  "$ENV{BLOSC_ROOT}"
+This will define the following variables:
+
+``Blosc_FOUND``
+  True if the system has the Blosc library.
+``Blosc_VERSION``
+  The version of the Blosc library which was found.
+``Blosc_INCLUDE_DIRS``
+  Include directories needed to use Blosc.
+``Blosc_LIBRARIES``
+  Libraries needed to link to Blosc.
+``Blosc_LIBRARY_DIRS``
+  Blosc library directories.
+
+Cache Variables
+^^^^^^^^^^^^^^^
+
+The following cache variables may also be set:
+
+``Blosc_INCLUDE_DIR``
+  The directory containing ``blosc.h``.
+``Blosc_LIBRARY``
+  The path to the Blosc library.
+
+Hints
+^^^^^
+
+Instead of explicitly setting the cache variables, the following variables
+may be provided to tell this module where to look.
+
+``BLOSC_ROOT``
+  Preferred installation prefix.
+``BLOSC_INCLUDEDIR``
+  Preferred include directory e.g. <prefix>/include
+``BLOSC_LIBRARYDIR``
+  Preferred library directory e.g. <prefix>/lib
+``SYSTEM_LIBRARY_PATHS``
+  Paths appended to all include and lib searches.
+
+#]=======================================================================]
+
+mark_as_advanced(
+  Blosc_INCLUDE_DIR
+  Blosc_LIBRARY
+)
+
+# Append BLOSC_ROOT or $ENV{BLOSC_ROOT} if set (prioritize the direct cmake var)
+set(_BLOSC_ROOT_SEARCH_DIR "")
+
+if(BLOSC_ROOT)
+  list(APPEND _BLOSC_ROOT_SEARCH_DIR ${BLOSC_ROOT})
+else()
+  set(_ENV_BLOSC_ROOT $ENV{BLOSC_ROOT})
+  if(_ENV_BLOSC_ROOT)
+    list(APPEND _BLOSC_ROOT_SEARCH_DIR ${_ENV_BLOSC_ROOT})
+  endif()
+endif()
+
+# Additionally try and use pkconfig to find blosc
+
+find_package(PkgConfig)
+pkg_check_modules(PC_Blosc QUIET blosc)
+
+# ------------------------------------------------------------------------
+#  Search for blosc include DIR
+# ------------------------------------------------------------------------
+
+set(_BLOSC_INCLUDE_SEARCH_DIRS "")
+list(APPEND _BLOSC_INCLUDE_SEARCH_DIRS
+  ${BLOSC_INCLUDEDIR}
+  ${_BLOSC_ROOT_SEARCH_DIR}
+  ${PC_Blosc_INCLUDE_DIRS}
+  ${SYSTEM_LIBRARY_PATHS}
+)
+
+# Look for a standard blosc header file.
+find_path(Blosc_INCLUDE_DIR blosc.h
   NO_DEFAULT_PATH
-  NO_SYSTEM_ENVIRONMENT_PATH
+  PATHS ${_BLOSC_INCLUDE_SEARCH_DIRS}
+  PATH_SUFFIXES include
+)
+
+if(EXISTS "${Blosc_INCLUDE_DIR}/blosc.h")
+  file(STRINGS "${Blosc_INCLUDE_DIR}/blosc.h"
+    _blosc_version_major_string REGEX "#define BLOSC_VERSION_MAJOR +[0-9]+ "
+  )
+  string(REGEX REPLACE "#define BLOSC_VERSION_MAJOR +([0-9]+).*$" "\\1"
+    _blosc_version_major_string "${_blosc_version_major_string}"
   )
+  string(STRIP "${_blosc_version_major_string}" Blosc_VERSION_MAJOR)
 
-FIND_PACKAGE_HANDLE_STANDARD_ARGS ( Blosc
-  REQUIRED_VARS BLOSC_LOCATION
+  file(STRINGS "${Blosc_INCLUDE_DIR}/blosc.h"
+     _blosc_version_minor_string REGEX "#define BLOSC_VERSION_MINOR +[0-9]+ "
   )
+  string(REGEX REPLACE "#define BLOSC_VERSION_MINOR +([0-9]+).*$" "\\1"
+    _blosc_version_minor_string "${_blosc_version_minor_string}"
+  )
+  string(STRIP "${_blosc_version_minor_string}" Blosc_VERSION_MINOR)
 
-IF ( BLOSC_FOUND )
+  unset(_blosc_version_major_string)
+  unset(_blosc_version_minor_string)
 
-  SET ( BLOSC_LIBRARYDIR ${BLOSC_LOCATION}/lib
-    CACHE STRING "Blosc library directories")
+  set(Blosc_VERSION ${Blosc_VERSION_MAJOR}.${Blosc_VERSION_MINOR})
+endif()
 
-  SET ( _blosc_library_name "blosc" )
-  
-  # Static library setup
-  IF (Blosc_USE_STATIC_LIBS)
-    SET(CMAKE_FIND_LIBRARY_SUFFIXES_BACKUP ${CMAKE_FIND_LIBRARY_SUFFIXES})
-	IF (WIN32)
-	  SET ( _blosc_library_name "libblosc" )
-	ELSE ()
-	  SET(CMAKE_FIND_LIBRARY_SUFFIXES ".a")
-	ENDIF ()
-  ENDIF()
-
-  FIND_LIBRARY ( BLOSC_blosc_LIBRARY ${_blosc_library_name}
-    PATHS ${BLOSC_LIBRARYDIR}
-    NO_DEFAULT_PATH
-    NO_SYSTEM_ENVIRONMENT_PATH
-    )
-  
-  # Static library tear down
-  IF (Blosc_USE_STATIC_LIBS)
-    SET( CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_FIND_LIBRARY_SUFFIXES_BACKUP} )
-  ENDIF()
+# ------------------------------------------------------------------------
+#  Search for blosc lib DIR
+# ------------------------------------------------------------------------
+
+set(_BLOSC_LIBRARYDIR_SEARCH_DIRS "")
+list(APPEND _BLOSC_LIBRARYDIR_SEARCH_DIRS
+  ${BLOSC_LIBRARYDIR}
+  ${_BLOSC_ROOT_SEARCH_DIR}
+  ${PC_Blosc_LIBRARY_DIRS}
+  ${SYSTEM_LIBRARY_PATHS}
+)
+
+# Static library setup
+if(UNIX AND BLOSC_USE_STATIC_LIBS)
+  set(_BLOSC_ORIG_CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_FIND_LIBRARY_SUFFIXES})
+  set(CMAKE_FIND_LIBRARY_SUFFIXES ".a")
+endif()
+
+set(BLOSC_PATH_SUFFIXES
+  lib64
+  lib
+)
 
-  SET( BLOSC_INCLUDE_DIR "${BLOSC_LOCATION}/include" CACHE STRING "Blosc include directory" )
-
-ENDIF ( BLOSC_FOUND )
+find_library(Blosc_LIBRARY blosc
+  NO_DEFAULT_PATH
+  PATHS ${_BLOSC_LIBRARYDIR_SEARCH_DIRS}
+  PATH_SUFFIXES ${BLOSC_PATH_SUFFIXES}
+)
+
+if(UNIX AND BLOSC_USE_STATIC_LIBS)
+  set(CMAKE_FIND_LIBRARY_SUFFIXES ${_BLOSC_ORIG_CMAKE_FIND_LIBRARY_SUFFIXES})
+  unset(_BLOSC_ORIG_CMAKE_FIND_LIBRARY_SUFFIXES)
+endif()
+
+# ------------------------------------------------------------------------
+#  Cache and set Blosc_FOUND
+# ------------------------------------------------------------------------
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(Blosc
+  FOUND_VAR Blosc_FOUND
+  REQUIRED_VARS
+    Blosc_LIBRARY
+    Blosc_INCLUDE_DIR
+  VERSION_VAR Blosc_VERSION
+)
+
+if(Blosc_FOUND)
+  set(Blosc_LIBRARIES ${Blosc_LIBRARY})
+  set(Blosc_INCLUDE_DIRS ${Blosc_INCLUDE_DIR})
+  set(Blosc_DEFINITIONS ${PC_Blosc_CFLAGS_OTHER})
+
+  get_filename_component(Blosc_LIBRARY_DIRS ${Blosc_LIBRARY} DIRECTORY)
+
+  if(NOT TARGET Blosc::blosc)
+    add_library(Blosc::blosc UNKNOWN IMPORTED)
+    set_target_properties(Blosc::blosc PROPERTIES
+      IMPORTED_LOCATION "${Blosc_LIBRARIES}"
+      INTERFACE_COMPILE_DEFINITIONS "${Blosc_DEFINITIONS}"
+      INTERFACE_INCLUDE_DIRECTORIES "${Blosc_INCLUDE_DIRS}"
+    )
+  endif()
+elseif(Blosc_FIND_REQUIRED)
+  message(FATAL_ERROR "Unable to find Blosc")
+endif()
Seulement dans openvdb-6.1.0/cmake: FindCppUnit.cmake
Seulement dans openvdb-6.0.0/cmake: FindCPPUnit.cmake
Seulement dans openvdb-6.0.0/cmake: FindGLEW.cmake
Seulement dans openvdb-6.0.0/cmake: FindGLFW3.cmake
Seulement dans openvdb-6.0.0/cmake: FindGLFW.cmake
Seulement dans openvdb-6.0.0/cmake: FindHDK.cmake
Seulement dans openvdb-6.1.0/cmake: FindIlmBase.cmake
Seulement dans openvdb-6.0.0/cmake: FindILMBase.cmake
Seulement dans openvdb-6.1.0/cmake: FindLog4cplus.cmake
Seulement dans openvdb-6.0.0/cmake: FindMaya.cmake
diff -aur openvdb-6.0.0/cmake/FindOpenEXR.cmake openvdb-6.1.0/cmake/FindOpenEXR.cmake
--- openvdb-6.0.0/cmake/FindOpenEXR.cmake	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/cmake/FindOpenEXR.cmake	2019-05-07 22:58:35.000000000 +0200
@@ -1,4 +1,4 @@
-# Copyright (c) 2012-2016 DreamWorks Animation LLC
+# Copyright (c) 2012-2019 DreamWorks Animation LLC
 #
 # All rights reserved. This software is distributed under the
 # Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -24,102 +24,306 @@
 # IN NO EVENT SHALL THE COPYRIGHT HOLDERS' AND CONTRIBUTORS' AGGREGATE
 # LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 #
+#[=======================================================================[.rst:
 
-# -*- cmake -*-
-# - Find OpenEXR
-#
-# Author : Nicholas Yue yue.nicholas@gmail.com
-#
-# This module will define the following variables:
-#  OPENEXR_INCLUDE_DIRS - Location of the openexr includes
-#  OPENEXR_LIBRARIES - [TODO] Required libraries for all requested bindings
-#  OPENEXR_FOUND - true if OPENEXR was found on the system
-#  OPENEXR_LIBRARYDIR - the full set of library directories
+FindOpenEXR
+-----------
+
+Find OpenEXR include dirs and libraries
 
-FIND_PACKAGE ( PackageHandleStandardArgs )
+Use this module by invoking find_package with the form::
 
-FIND_PATH ( OPENEXR_LOCATION include/OpenEXR/OpenEXRConfig.h
-  ENV OPENEXR_ROOT
+  find_package(OpenEXR
+    [version] [EXACT]      # Minimum or EXACT version
+    [REQUIRED]             # Fail with error if OpenEXR is not found
+    [COMPONENTS <libs>...] # OpenEXR libraries by their canonical name
+                           # e.g. "IlmImf" for "libIlmImf"
+    )
+
+IMPORTED Targets
+^^^^^^^^^^^^^^^^
+
+``OpenEXR::IlmImf``
+  The IlmImf library target.
+``OpenEXR::IlmImfUtil``
+  The IlmImfUtil library target.
+
+Result Variables
+^^^^^^^^^^^^^^^^
+
+This will define the following variables:
+
+``OpenEXR_FOUND``
+  True if the system has the OpenEXR library.
+``OpenEXR_VERSION``
+  The version of the OpenEXR library which was found.
+``OpenEXR_INCLUDE_DIRS``
+  Include directories needed to use OpenEXR.
+``OpenEXR_LIBRARIES``
+  Libraries needed to link to OpenEXR.
+``OpenEXR_LIBRARY_DIRS``
+  OpenEXR library directories.
+``OpenEXR_DEFINITIONS``
+  Definitions to use when compiling code that uses OpenEXR.
+``OpenEXR_{COMPONENT}_FOUND``
+  True if the system has the named OpenEXR component.
+
+Cache Variables
+^^^^^^^^^^^^^^^
+
+The following cache variables may also be set:
+
+``OpenEXR_INCLUDE_DIR``
+  The directory containing ``OpenEXR/config-auto.h``.
+``OpenEXR_{COMPONENT}_LIBRARY``
+  Individual component libraries for OpenEXR
+``OpenEXR_{COMPONENT}_DLL``
+  Individual component dlls for OpenEXR on Windows.
+
+Hints
+^^^^^
+
+Instead of explicitly setting the cache variables, the following variables
+may be provided to tell this module where to look.
+
+``OPENEXR_ROOT``
+  Preferred installation prefix.
+``OPENEXR_INCLUDEDIR``
+  Preferred include directory e.g. <prefix>/include
+``OPENEXR_LIBRARYDIR``
+  Preferred library directory e.g. <prefix>/lib
+``SYSTEM_LIBRARY_PATHS``
+  Paths appended to all include and lib searches.
+
+#]=======================================================================]
+
+# Support new if() IN_LIST operator
+if(POLICY CMP0057)
+  cmake_policy(SET CMP0057 NEW)
+endif()
+
+mark_as_advanced(
+  OpenEXR_INCLUDE_DIR
+  OpenEXR_LIBRARY
+)
+
+set(_OPENEXR_COMPONENT_LIST
+  IlmImf
+  IlmImfUtil
+)
+
+if(OpenEXR_FIND_COMPONENTS)
+  set(OPENEXR_COMPONENTS_PROVIDED TRUE)
+  set(_IGNORED_COMPONENTS "")
+  foreach(COMPONENT ${OpenEXR_FIND_COMPONENTS})
+    if(NOT ${COMPONENT} IN_LIST _OPENEXR_COMPONENT_LIST)
+      list(APPEND _IGNORED_COMPONENTS ${COMPONENT})
+    endif()
+  endforeach()
+
+  if(_IGNORED_COMPONENTS)
+    message(STATUS "Ignoring unknown components of OpenEXR:")
+    foreach(COMPONENT ${_IGNORED_COMPONENTS})
+      message(STATUS "  ${COMPONENT}")
+    endforeach()
+    list(REMOVE_ITEM OpenEXR_FIND_COMPONENTS ${_IGNORED_COMPONENTS})
+  endif()
+else()
+  set(OPENEXR_COMPONENTS_PROVIDED FALSE)
+  set(OpenEXR_FIND_COMPONENTS ${_OPENEXR_COMPONENT_LIST})
+endif()
+
+# Append OPENEXR_ROOT or $ENV{OPENEXR_ROOT} if set (prioritize the direct cmake var)
+set(_OPENEXR_ROOT_SEARCH_DIR "")
+
+if(OPENEXR_ROOT)
+  list(APPEND _OPENEXR_ROOT_SEARCH_DIR ${OPENEXR_ROOT})
+else()
+  set(_ENV_OPENEXR_ROOT $ENV{OPENEXR_ROOT})
+  if(_ENV_OPENEXR_ROOT)
+    list(APPEND _OPENEXR_ROOT_SEARCH_DIR ${_ENV_OPENEXR_ROOT})
+  endif()
+endif()
+
+# Additionally try and use pkconfig to find OpenEXR
+
+find_package(PkgConfig)
+pkg_check_modules(PC_OpenEXR QUIET OpenEXR)
+
+# ------------------------------------------------------------------------
+#  Search for OpenEXR include DIR
+# ------------------------------------------------------------------------
+
+set(_OPENEXR_INCLUDE_SEARCH_DIRS "")
+list(APPEND _OPENEXR_INCLUDE_SEARCH_DIRS
+  ${OPENEXR_INCLUDEDIR}
+  ${_OPENEXR_ROOT_SEARCH_DIR}
+  ${PC_OpenEXR_INCLUDEDIR}
+  ${SYSTEM_LIBRARY_PATHS}
+)
+
+# Look for a standard OpenEXR header file.
+find_path(OpenEXR_INCLUDE_DIR OpenEXRConfig.h
   NO_DEFAULT_PATH
-  NO_SYSTEM_ENVIRONMENT_PATH
+  PATHS ${_OPENEXR_INCLUDE_SEARCH_DIRS}
+  PATH_SUFFIXES  include/OpenEXR OpenEXR
+)
+
+if(EXISTS "${OpenEXR_INCLUDE_DIR}/OpenEXRConfig.h")
+  # Get the EXR version information from the config header
+  file(STRINGS "${OpenEXR_INCLUDE_DIR}/OpenEXRConfig.h"
+    _openexr_version_major_string REGEX "#define OPENEXR_VERSION_MAJOR "
+  )
+  string(REGEX REPLACE "#define OPENEXR_VERSION_MAJOR" ""
+    _openexr_version_major_string "${_openexr_version_major_string}"
   )
+  string(STRIP "${_openexr_version_major_string}" OpenEXR_VERSION_MAJOR)
 
-FIND_PACKAGE_HANDLE_STANDARD_ARGS ( OpenEXR
-  REQUIRED_VARS OPENEXR_LOCATION
+  file(STRINGS "${OpenEXR_INCLUDE_DIR}/OpenEXRConfig.h"
+     _openexr_version_minor_string REGEX "#define OPENEXR_VERSION_MINOR "
   )
+  string(REGEX REPLACE "#define OPENEXR_VERSION_MINOR" ""
+    _openexr_version_minor_string "${_openexr_version_minor_string}"
+  )
+  string(STRIP "${_openexr_version_minor_string}" OpenEXR_VERSION_MINOR)
+
+  unset(_openexr_version_major_string)
+  unset(_openexr_version_minor_string)
+
+  set(OpenEXR_VERSION ${OpenEXR_VERSION_MAJOR}.${OpenEXR_VERSION_MINOR})
+endif()
+
+# ------------------------------------------------------------------------
+#  Search for OPENEXR lib DIR
+# ------------------------------------------------------------------------
+
+set(_OPENEXR_LIBRARYDIR_SEARCH_DIRS "")
 
-OPTION ( OPENEXR_NAMESPACE_VERSIONING "Namespace versioning of libraries" ON )
+# Append to _OPENEXR_LIBRARYDIR_SEARCH_DIRS in priority order
 
-IF ( OPENEXR_FOUND )
-
-  FILE ( STRINGS "${OPENEXR_LOCATION}/include/OpenEXR/OpenEXRConfig.h" _openexr_version_major_string REGEX "#define OPENEXR_VERSION_MAJOR ")
-  STRING ( REGEX REPLACE "#define OPENEXR_VERSION_MAJOR" "" _openexr_version_major_unstrip "${_openexr_version_major_string}")
-  STRING ( STRIP "${_openexr_version_major_unstrip}" OPENEXR_VERSION_MAJOR )
-
-  FILE ( STRINGS "${OPENEXR_LOCATION}/include/OpenEXR/OpenEXRConfig.h" _openexr_version_minor_string REGEX "#define OPENEXR_VERSION_MINOR ")
-  STRING ( REGEX REPLACE "#define OPENEXR_VERSION_MINOR" "" _openexr_version_minor_unstrip "${_openexr_version_minor_string}")
-  STRING ( STRIP "${_openexr_version_minor_unstrip}" OPENEXR_VERSION_MINOR )
-  
-  MESSAGE ( STATUS "Found OpenEXR v${OPENEXR_VERSION_MAJOR}.${OPENEXR_VERSION_MINOR} at ${OPENEXR_LOCATION}" )
-
-  IF ( OPENEXR_NAMESPACE_VERSIONING )
-	SET ( ILMIMF_LIBRARY_NAME IlmImf-${OPENEXR_VERSION_MAJOR}_${OPENEXR_VERSION_MINOR} )
-  ELSE ( OPENEXR_NAMESPACE_VERSIONING )
-	SET ( ILMIMF_LIBRARY_NAME IlmImf )
-  ENDIF ( OPENEXR_NAMESPACE_VERSIONING )
-	
-  SET ( OPENEXR_INCLUDE_DIRS
-    ${OPENEXR_LOCATION}/include
-    ${OPENEXR_LOCATION}/include/OpenEXR
-    CACHE STRING "Openexr include directories")
-  SET ( OPENEXR_LIBRARYDIR ${OPENEXR_LOCATION}/lib
-    CACHE STRING "Openexr library directories")
-  SET ( OPENEXR_FOUND TRUE )
-
-
-  IF (Openexr_USE_STATIC_LIBS)
-    IF (APPLE)
-      SET(CMAKE_FIND_LIBRARY_SUFFIXES ".a")
-      FIND_LIBRARY ( Openexr_ILMIMF_LIBRARY ${ILMIMF_LIBRARY_NAME} PATHS ${OPENEXR_LIBRARYDIR} )
-    ELSEIF (WIN32)
-      # Link library
-      SET(CMAKE_FIND_LIBRARY_SUFFIXES ".lib")
-      FIND_LIBRARY ( Openexr_ILMIMF_LIBRARY ${ILMIMF_LIBRARY_NAME} PATHS ${OPENEXR_LIBRARYDIR} )
-    ELSE (APPLE)
-      # MESSAGE ( "CMAKE_FIND_LIBRARY_SUFFIXES = " ${CMAKE_FIND_LIBRARY_SUFFIXES})
-      SET ( ORIGINAL_CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_FIND_LIBRARY_SUFFIXES})
-      SET ( CMAKE_FIND_LIBRARY_SUFFIXES ".a")
-      FIND_LIBRARY ( Openexr_ILMIMF_LIBRARY ${ILMIMF_LIBRARY_NAME} PATHS ${OPENEXR_LIBRARYDIR}
-		NO_DEFAULT_PATH
-		NO_SYSTEM_ENVIRONMENT_PATH
-		)
-      SET ( CMAKE_FIND_LIBRARY_SUFFIXES ${ORIGINAL_CMAKE_FIND_LIBRARY_SUFFIXES})
-    ENDIF (APPLE)
-  ELSE ()
-    IF (APPLE)
-      SET(CMAKE_FIND_LIBRARY_SUFFIXES ".dylib")
-      FIND_LIBRARY ( Openexr_ILMIMF_LIBRARY ${ILMIMF_LIBRARY_NAME} PATHS ${OPENEXR_LIBRARYDIR} )
-    ELSEIF (WIN32)
-      # Link library
-      SET(CMAKE_FIND_LIBRARY_SUFFIXES ".lib")
-      FIND_LIBRARY ( Openexr_ILMIMF_LIBRARY ${ILMIMF_LIBRARY_NAME} PATHS ${OPENEXR_LIBRARYDIR} )
-      # Load library
-      SET(CMAKE_FIND_LIBRARY_SUFFIXES ".dll")
-      FIND_LIBRARY ( Openexr_ILMIMF_DLL ${ILMIMF_LIBRARY_NAME} PATHS ${OPENEXR_LOCATION}/bin )
-      # MUST reset
-      SET(CMAKE_FIND_LIBRARY_SUFFIXES ".lib")
-    ELSE (APPLE)
-      FIND_LIBRARY ( Openexr_ILMIMF_LIBRARY ${ILMIMF_LIBRARY_NAME} PATHS ${OPENEXR_LIBRARYDIR}
-		NO_DEFAULT_PATH
-		NO_CMAKE_ENVIRONMENT_PATH
-		NO_CMAKE_PATH
-		NO_SYSTEM_ENVIRONMENT_PATH
-		NO_CMAKE_SYSTEM_PATH
-		)
-    ENDIF (APPLE)
-  ENDIF ()
-
-  # SET( Openexr_ILMIMF_LIBRARY ${OPENEXR_ILMIMF_LIBRARY_PATH} CACHE STRING "Openexr's IlmImf library")
-  
-ENDIF ( OPENEXR_FOUND )
+list(APPEND _OPENEXR_LIBRARYDIR_SEARCH_DIRS
+  ${OPENEXR_LIBRARYDIR}
+  ${_OPENEXR_ROOT_SEARCH_DIR}
+  ${PC_OpenEXR_LIBDIR}
+  ${SYSTEM_LIBRARY_PATHS}
+)
+
+# Build suffix directories
+
+set(OPENEXR_PATH_SUFFIXES
+  lib64
+  lib
+)
+
+if(UNIX )
+  list(INSERT OPENEXR_PATH_SUFFIXES 0 lib/x86_64-linux-gnu)
+endif()
+
+set(_OPENEXR_ORIG_CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_FIND_LIBRARY_SUFFIXES})
+
+# library suffix handling
+if(WIN32)
+  list(APPEND CMAKE_FIND_LIBRARY_SUFFIXES
+    "-${OpenEXR_VERSION_MAJOR}_${OpenEXR_VERSION_MINOR}.lib"
+  )
+else()
+  if(OPENEXR_USE_STATIC_LIBS)
+    list(APPEND CMAKE_FIND_LIBRARY_SUFFIXES
+      "-${OpenEXR_VERSION_MAJOR}_${OpenEXR_VERSION_MINOR}.a"
+    )
+  else()
+    if(APPLE)
+      list(APPEND CMAKE_FIND_LIBRARY_SUFFIXES
+        "-${OpenEXR_VERSION_MAJOR}_${OpenEXR_VERSION_MINOR}.dylib"
+      )
+    else()
+      list(APPEND CMAKE_FIND_LIBRARY_SUFFIXES
+        "-${OpenEXR_VERSION_MAJOR}_${OpenEXR_VERSION_MINOR}.so"
+      )
+    endif()
+  endif()
+endif()
+
+set(OpenEXR_LIB_COMPONENTS "")
+
+foreach(COMPONENT ${OpenEXR_FIND_COMPONENTS})
+  find_library(OpenEXR_${COMPONENT}_LIBRARY ${COMPONENT}
+    NO_DEFAULT_PATH
+    PATHS ${_OPENEXR_LIBRARYDIR_SEARCH_DIRS}
+    PATH_SUFFIXES ${OPENEXR_PATH_SUFFIXES}
+  )
+  list(APPEND OpenEXR_LIB_COMPONENTS ${OpenEXR_${COMPONENT}_LIBRARY})
+
+  if(WIN32 AND NOT OPENEXR_USE_STATIC_LIBS)
+    set(_OPENEXR_TMP ${CMAKE_FIND_LIBRARY_SUFFIXES})
+    set(CMAKE_FIND_LIBRARY_SUFFIXES ".dll")
+    find_library(OpenEXR_${COMPONENT}_DLL ${COMPONENT}
+      NO_DEFAULT_PATH
+      PATHS ${_OPENEXR_LIBRARYDIR_SEARCH_DIRS}
+      PATH_SUFFIXES bin
+    )
+    set(CMAKE_FIND_LIBRARY_SUFFIXES ${_OPENEXR_TMP})
+    unset(_OPENEXR_TMP)
+  endif()
+
+  if(OpenEXR_${COMPONENT}_LIBRARY)
+    set(OpenEXR_${COMPONENT}_FOUND TRUE)
+  else()
+    set(OpenEXR_${COMPONENT}_FOUND FALSE)
+  endif()
+endforeach()
+
+# reset lib suffix
+
+set(CMAKE_FIND_LIBRARY_SUFFIXES ${_OPENEXR_ORIG_CMAKE_FIND_LIBRARY_SUFFIXES})
+unset(_OPENEXR_ORIG_CMAKE_FIND_LIBRARY_SUFFIXES)
+
+# ------------------------------------------------------------------------
+#  Cache and set OPENEXR_FOUND
+# ------------------------------------------------------------------------
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(OpenEXR
+  FOUND_VAR OpenEXR_FOUND
+  REQUIRED_VARS
+    OpenEXR_INCLUDE_DIR
+    OpenEXR_LIB_COMPONENTS
+  VERSION_VAR OpenEXR_VERSION
+  HANDLE_COMPONENTS
+)
+
+if(OpenEXR_FOUND)
+  set(OpenEXR_LIBRARIES ${OpenEXR_LIB_COMPONENTS})
+
+  # We have to add both include and include/OpenEXR to the include
+  # path in case OpenEXR and IlmBase are installed separately
+
+  set(OpenEXR_INCLUDE_DIRS)
+  list(APPEND OpenEXR_INCLUDE_DIRS
+    ${OpenEXR_INCLUDE_DIR}/../
+    ${OpenEXR_INCLUDE_DIR}
+  )
+  set(OpenEXR_DEFINITIONS ${PC_OpenEXR_CFLAGS_OTHER})
 
+  set(OpenEXR_LIBRARY_DIRS "")
+  foreach(LIB ${OpenEXR_LIB_COMPONENTS})
+    get_filename_component(_OPENEXR_LIBDIR ${LIB} DIRECTORY)
+    list(APPEND OpenEXR_LIBRARY_DIRS ${_OPENEXR_LIBDIR})
+  endforeach()
+  list(REMOVE_DUPLICATES OpenEXR_LIBRARY_DIRS)
+
+  # Configure imported target
+
+  foreach(COMPONENT ${OpenEXR_FIND_COMPONENTS})
+    if(NOT TARGET OpenEXR::${COMPONENT})
+      add_library(OpenEXR::${COMPONENT} UNKNOWN IMPORTED)
+      set_target_properties(OpenEXR::${COMPONENT} PROPERTIES
+        IMPORTED_LOCATION "${OpenEXR_${COMPONENT}_LIBRARY}"
+        INTERFACE_COMPILE_OPTIONS "${OpenEXR_DEFINITIONS}"
+        INTERFACE_INCLUDE_DIRECTORIES "${OpenEXR_INCLUDE_DIRS}"
+      )
+    endif()
+  endforeach()
+elseif(OpenEXR_FIND_REQUIRED)
+  message(FATAL_ERROR "Unable to find OpenEXR")
+endif()
diff -aur openvdb-6.0.0/cmake/FindOpenVDB.cmake openvdb-6.1.0/cmake/FindOpenVDB.cmake
--- openvdb-6.0.0/cmake/FindOpenVDB.cmake	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/cmake/FindOpenVDB.cmake	2019-05-07 22:58:35.000000000 +0200
@@ -1,4 +1,4 @@
-# Copyright (c) 2012-2016 DreamWorks Animation LLC
+# Copyright (c) 2012-2019 DreamWorks Animation LLC
 #
 # All rights reserved. This software is distributed under the
 # Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -24,74 +24,456 @@
 # IN NO EVENT SHALL THE COPYRIGHT HOLDERS' AND CONTRIBUTORS' AGGREGATE
 # LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 #
+#[=======================================================================[.rst:
 
-# -*- cmake -*-
-# - Find OpenVDB
-#
-# Author : Fredrik Salomonsson fredriks@d2.com
-#
-# OpenVDB_FOUND                 Set if OpenVDB is found.
-# OpenVDB_INCLUDE_DIR           OpenVDB's include directory
-# OpenVDB_LIBRARY_DIR           OpenVDB's library directory
-# OpenVDB_<C>_LIBRARY           Specific openvdb library (<C> is upper-case)
-# OpenVDB_LIBRARIES             All openvdb libraries
-# OpenVDB_MAJOR_VERSION         Major version number
-# OpenVDB_MINOR_VERSION         Minor version number
-# OpenVDB_PATCH_VERSION         Patch version number
-#
-# This module read hints about search locations from variables::
+FindOpenVDB
+-----------
+
+Find OpenVDB include dirs, libraries and settings
+
+Use this module by invoking find_package with the form::
+
+  find_package(OpenVDB
+    [version] [EXACT]      # Minimum or EXACT version
+    [REQUIRED]             # Fail with error if OpenVDB is not found
+    [COMPONENTS <libs>...] # OpenVDB libraries by their canonical name
+                           # e.g. "openvdb" for "libopenvdb"
+    )
+
+IMPORTED Targets
+^^^^^^^^^^^^^^^^
+
+``OpenVDB::openvdb``
+  The core openvdb library target.
+
+Result Variables
+^^^^^^^^^^^^^^^^
+
+This will define the following variables:
+
+``OpenVDB_FOUND``
+  True if the system has the OpenVDB library.
+``OpenVDB_VERSION``
+  The version of the OpenVDB library which was found.
+``OpenVDB_INCLUDE_DIRS``
+  Include directories needed to use OpenVDB.
+``OpenVDB_LIBRARIES``
+  Libraries needed to link to OpenVDB.
+``OpenVDB_LIBRARY_DIRS``
+  OpenVDB library directories.
+``OpenVDB_DEFINITIONS``
+  Definitions to use when compiling code that uses OpenVDB.
+``OpenVDB_{COMPONENT}_FOUND``
+  True if the system has the named OpenVDB component.
+``OpenVDB_USES_BLOSC``
+  True if the OpenVDB Library has been built with blosc support
+``OpenVDB_USES_LOG4CPLUS``
+  True if the OpenVDB Library has been built with log4cplus support
+``OpenVDB_USES_EXR``
+  True if the OpenVDB Library has been built with openexr support
+``OpenVDB_ABI``
+  Set if this module was able to determine the ABI number the located
+  OpenVDB Library was built against. Unset otherwise.
+
+Cache Variables
+^^^^^^^^^^^^^^^
+
+The following cache variables may also be set:
+
+``OpenVDB_INCLUDE_DIR``
+  The directory containing ``openvdb/version.h``.
+``OpenVDB_{COMPONENT}_LIBRARY``
+  Individual component libraries for OpenVDB
+
+Hints
+^^^^^
+
+Instead of explicitly setting the cache variables, the following variables
+may be provided to tell this module where to look.
+
+``OPENVDB_ROOT``
+  Preferred installation prefix.
+``OPENVDB_INCLUDEDIR``
+  Preferred include directory e.g. <prefix>/include
+``OPENVDB_LIBRARYDIR``
+  Preferred library directory e.g. <prefix>/lib
+``SYSTEM_LIBRARY_PATHS``
+  Paths appended to all include and lib searches.
+
+#]=======================================================================]
+
+cmake_minimum_required(VERSION 3.3)
+# Monitoring <PackageName>_ROOT variables
+if(POLICY CMP0074)
+  cmake_policy(SET CMP0074 NEW)
+endif()
+
+# Include utility functions for version information
+include(${CMAKE_CURRENT_LIST_DIR}/OpenVDBUtils.cmake)
+
+mark_as_advanced(
+  OpenVDB_INCLUDE_DIR
+  OpenVDB_LIBRARY
+)
+
+set(_OPENVDB_COMPONENT_LIST
+  openvdb
+)
+
+if(OpenVDB_FIND_COMPONENTS)
+  set(OPENVDB_COMPONENTS_PROVIDED TRUE)
+  set(_IGNORED_COMPONENTS "")
+  foreach(COMPONENT ${OpenVDB_FIND_COMPONENTS})
+    if(NOT ${COMPONENT} IN_LIST _OPENVDB_COMPONENT_LIST)
+      list(APPEND _IGNORED_COMPONENTS ${COMPONENT})
+    endif()
+  endforeach()
+
+  if(_IGNORED_COMPONENTS)
+    message(STATUS "Ignoring unknown components of OpenVDB:")
+    foreach(COMPONENT ${_IGNORED_COMPONENTS})
+      message(STATUS "  ${COMPONENT}")
+    endforeach()
+    list(REMOVE_ITEM OpenVDB_FIND_COMPONENTS ${_IGNORED_COMPONENTS})
+  endif()
+else()
+  set(OPENVDB_COMPONENTS_PROVIDED FALSE)
+  set(OpenVDB_FIND_COMPONENTS ${_OPENVDB_COMPONENT_LIST})
+endif()
+
+# Append OPENVDB_ROOT or $ENV{OPENVDB_ROOT} if set (prioritize the direct cmake var)
+set(_OPENVDB_ROOT_SEARCH_DIR "")
+
+if(OPENVDB_ROOT)
+  list(APPEND _OPENVDB_ROOT_SEARCH_DIR ${OPENVDB_ROOT})
+else()
+  set(_ENV_OPENVDB_ROOT $ENV{OPENVDB_ROOT})
+  if(_ENV_OPENVDB_ROOT)
+    list(APPEND _OPENVDB_ROOT_SEARCH_DIR ${_ENV_OPENVDB_ROOT})
+  endif()
+endif()
+
+# Additionally try and use pkconfig to find OpenVDB
+
+find_package(PkgConfig)
+pkg_check_modules(PC_OpenVDB QUIET OpenVDB)
+
+# This CMake module supports being called from external packages AND from
+# within the OpenVDB repository for building openvdb components with the
+# core library build disabled. Determine where we are being called from:
 #
-# OPENVDB_ROOT                  Preferred installtion prefix
+# (repo structure = <root>/cmake/FindOpenVDB.cmake)
+# (inst structure = <root>/lib/cmake/OpenVDB/FindOpenVDB.cmake)
+
+get_filename_component(_DIR_NAME ${CMAKE_CURRENT_LIST_DIR} NAME)
+
+if(${_DIR_NAME} STREQUAL "cmake")
+  # Called from root repo for openvdb components
+elseif(${_DIR_NAME} STREQUAL "OpenVDB")
+  # Set the install variable to track directories if this is being called from
+  # an installed location and from another package. The expected installation
+  # directory structure is:
+  #  <root>/lib/cmake/OpenVDB/FindOpenVDB.cmake
+  #  <root>/include
+  #  <root>/bin
+  get_filename_component(_IMPORT_PREFIX ${CMAKE_CURRENT_LIST_DIR} DIRECTORY)
+  get_filename_component(_IMPORT_PREFIX ${_IMPORT_PREFIX} DIRECTORY)
+  get_filename_component(_IMPORT_PREFIX ${_IMPORT_PREFIX} DIRECTORY)
+  set(_OPENVDB_INSTALL ${_IMPORT_PREFIX})
+  list(APPEND _OPENVDB_ROOT_SEARCH_DIR ${_OPENVDB_INSTALL})
+endif()
+
+unset(_DIR_NAME)
+unset(_IMPORT_PREFIX)
+
+# ------------------------------------------------------------------------
+#  Search for OpenVDB include DIR
+# ------------------------------------------------------------------------
 
-FIND_PACKAGE( PackageHandleStandardArgs )
+set(_OPENVDB_INCLUDE_SEARCH_DIRS "")
+list(APPEND _OPENVDB_INCLUDE_SEARCH_DIRS
+  ${OPENVDB_INCLUDEDIR}
+  ${_OPENVDB_ROOT_SEARCH_DIR}
+  ${PC_OpenVDB_INCLUDE_DIRS}
+  ${SYSTEM_LIBRARY_PATHS}
+)
 
-FIND_PATH( OPENVDB_LOCATION include/openvdb/version.h 
-  "$ENV{OPENVDB_ROOT}"
+# Look for a standard OpenVDB header file.
+find_path(OpenVDB_INCLUDE_DIR openvdb/version.h
   NO_DEFAULT_PATH
-  NO_SYSTEM_ENVIRONMENT_PATH
+  PATHS ${_OPENVDB_INCLUDE_SEARCH_DIRS}
+  PATH_SUFFIXES include
+)
+
+OPENVDB_VERSION_FROM_HEADER("${OpenVDB_INCLUDE_DIR}/openvdb/version.h"
+  VERSION OpenVDB_VERSION
+  MAJOR   OpenVDB_MAJOR_VERSION
+  MINOR   OpenVDB_MINOR_VERSION
+  PATCH   OpenVDB_PATCH_VERSION
+)
+
+# ------------------------------------------------------------------------
+#  Search for OPENVDB lib DIR
+# ------------------------------------------------------------------------
+
+set(_OPENVDB_LIBRARYDIR_SEARCH_DIRS "")
+
+# Append to _OPENVDB_LIBRARYDIR_SEARCH_DIRS in priority order
+
+list(APPEND _OPENVDB_LIBRARYDIR_SEARCH_DIRS
+  ${OPENVDB_LIBRARYDIR}
+  ${_OPENVDB_ROOT_SEARCH_DIR}
+  ${PC_OpenVDB_LIBRARY_DIRS}
+  ${SYSTEM_LIBRARY_PATHS}
+)
+
+# Build suffix directories
+
+set(OPENVDB_PATH_SUFFIXES
+  lib64
+  lib
+)
+
+# Static library setup
+if(UNIX AND OPENVDB_USE_STATIC_LIBS)
+  set(_OPENVDB_ORIG_CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_FIND_LIBRARY_SUFFIXES})
+  set(CMAKE_FIND_LIBRARY_SUFFIXES ".a")
+endif()
+
+set(OpenVDB_LIB_COMPONENTS "")
+
+foreach(COMPONENT ${OpenVDB_FIND_COMPONENTS})
+  set(LIB_NAME ${COMPONENT})
+  find_library(OpenVDB_${COMPONENT}_LIBRARY ${LIB_NAME}
+    NO_DEFAULT_PATH
+    PATHS ${_OPENVDB_LIBRARYDIR_SEARCH_DIRS}
+    PATH_SUFFIXES ${OPENVDB_PATH_SUFFIXES}
   )
+  list(APPEND OpenVDB_LIB_COMPONENTS ${OpenVDB_${COMPONENT}_LIBRARY})
 
-FIND_PACKAGE_HANDLE_STANDARD_ARGS( OpenVDB
-  REQUIRED_VARS OPENVDB_LOCATION 
+  if(OpenVDB_${COMPONENT}_LIBRARY)
+    set(OpenVDB_${COMPONENT}_FOUND TRUE)
+  else()
+    set(OpenVDB_${COMPONENT}_FOUND FALSE)
+  endif()
+endforeach()
+
+if(UNIX AND OPENVDB_USE_STATIC_LIBS)
+  set(CMAKE_FIND_LIBRARY_SUFFIXES ${_OPENVDB_ORIG_CMAKE_FIND_LIBRARY_SUFFIXES})
+  unset(_OPENVDB_ORIG_CMAKE_FIND_LIBRARY_SUFFIXES)
+endif()
+
+# ------------------------------------------------------------------------
+#  Cache and set OPENVDB_FOUND
+# ------------------------------------------------------------------------
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(OpenVDB
+  FOUND_VAR OpenVDB_FOUND
+  REQUIRED_VARS
+    OpenVDB_INCLUDE_DIR
+    OpenVDB_LIB_COMPONENTS
+  VERSION_VAR OpenVDB_VERSION
+  HANDLE_COMPONENTS
+)
+
+# ------------------------------------------------------------------------
+#  Determine ABI number
+# ------------------------------------------------------------------------
+
+# Set the ABI number the library was built against. Uses vdb_print
+
+if(_OPENVDB_INSTALL)
+  OPENVDB_ABI_VERSION_FROM_PRINT(
+    "${_OPENVDB_INSTALL}/bin/vdb_print"
+    ABI OpenVDB_ABI
   )
+else()
+  # Try and find vdb_print from the include path
+  OPENVDB_ABI_VERSION_FROM_PRINT(
+    "${OpenVDB_INCLUDE_DIR}/../bin/vdb_print"
+    ABI OpenVDB_ABI
+  )
+endif()
 
-IF( OpenVDB_FOUND )
-  SET( OpenVDB_INCLUDE_DIR ${OPENVDB_LOCATION}/include
-    CACHE PATH "OpenVDB include directory")
-
-  SET( OpenVDB_LIBRARY_DIR ${OPENVDB_LOCATION}/lib
-    CACHE PATH "OpenVDB library directory" )
-  
-  FIND_LIBRARY( OpenVDB_OPENVDB_LIBRARY openvdb
-    PATHS ${OpenVDB_LIBRARY_DIR}
-    NO_DEFAULT_PATH
-    NO_SYSTEM_ENVIRONMENT_PATH
+if(NOT OpenVDB_FIND_QUIET)
+  if(NOT OpenVDB_ABI)
+    message(WARNING "Unable to determine OpenVDB ABI version from OpenVDB "
+      "installation. The library major version \"${OpenVDB_MAJOR_VERSION}\" "
+      "will be inferred. If this is not correct, use "
+      "add_definitions(-DOPENVDB_ABI_VERSION_NUMBER=N)"
     )
-  
-  SET( OpenVDB_LIBRARIES "")
-  LIST( APPEND OpenVDB_LIBRARIES ${OpenVDB_OPENVDB_LIBRARY} )
-  
-  SET( OPENVDB_VERSION_FILE ${OpenVDB_INCLUDE_DIR}/openvdb/version.h )
-
-  FILE( STRINGS "${OPENVDB_VERSION_FILE}" openvdb_major_version_str
-    REGEX "^#define[\t ]+OPENVDB_LIBRARY_MAJOR_VERSION_NUMBER[\t ]+.*")
-  FILE( STRINGS "${OPENVDB_VERSION_FILE}" openvdb_minor_version_str
-    REGEX "^#define[\t ]+OPENVDB_LIBRARY_MINOR_VERSION_NUMBER[\t ]+.*")
-  FILE( STRINGS "${OPENVDB_VERSION_FILE}" openvdb_patch_version_str
-    REGEX "^#define[\t ]+OPENVDB_LIBRARY_PATCH_VERSION_NUMBER[\t ]+.*")
-
-  STRING( REGEX REPLACE "^.*OPENVDB_LIBRARY_MAJOR_VERSION_NUMBER[\t ]+([0-9]*).*$" "\\1"
-    _openvdb_major_version_number "${openvdb_major_version_str}")
-  STRING( REGEX REPLACE "^.*OPENVDB_LIBRARY_MINOR_VERSION_NUMBER[\t ]+([0-9]*).*$" "\\1"
-    _openvdb_minor_version_number "${openvdb_minor_version_str}")
-  STRING( REGEX REPLACE "^.*OPENVDB_LIBRARY_PATCH_VERSION_NUMBER[\t ]+([0-9]*).*$" "\\1"
-    _openvdb_patch_version_number "${openvdb_patch_version_str}")
-
-  SET( OpenVDB_MAJOR_VERSION ${_openvdb_major_version_number}
-    CACHE STRING "OpenVDB major version number" )
-  SET( OpenVDB_MINOR_VERSION ${_openvdb_minor_version_number}
-    CACHE STRING "OpenVDB minor version number" )
-  SET( OpenVDB_PATCH_VERSION ${_openvdb_patch_version_number}
-    CACHE STRING "OpenVDB patch version number" )
+  else()
+    message(STATUS "OpenVDB ABI Version: ${OpenVDB_ABI}")
+  endif()
+endif()
+
+# ------------------------------------------------------------------------
+#  Handle OpenVDB dependencies
+# ------------------------------------------------------------------------
+
+# Add standard dependencies
+
+find_package(IlmBase REQUIRED COMPONENTS Half)
+find_package(TBB REQUIRED COMPONENTS tbb)
+find_package(ZLIB REQUIRED)
+find_package(Boost REQUIRED COMPONENTS iostreams system)
+
+# Use GetPrerequisites to see which libraries this OpenVDB lib has linked to
+# which we can query for optional deps. This basically runs ldd/otoll/objdump
+# etc to track deps. We could use a vdb_config binary tools here to improve
+# this process
+
+include(GetPrerequisites)
+
+set(_EXCLUDE_SYSTEM_PREREQUISITES 1)
+set(_RECURSE_PREREQUISITES 0)
+set(_OPENVDB_PREREQUISITE_LIST)
+
+get_prerequisites(${OpenVDB_openvdb_LIBRARY}
+  _OPENVDB_PREREQUISITE_LIST
+  ${_EXCLUDE_SYSTEM_PREREQUISITES}
+  ${_RECURSE_PREREQUISITES}
+  ""
+  "${SYSTEM_LIBRARY_PATHS}"
+)
+
+unset(_EXCLUDE_SYSTEM_PREREQUISITES)
+unset(_RECURSE_PREREQUISITES)
+
+# As the way we resolve optional libraries relies on library file names, use
+# the configuration options from the main CMakeLists.txt to allow users
+# to manually identify the requirements of OpenVDB builds if they know them.
+
+set(OpenVDB_USES_BLOSC ${USE_BLOSC})
+set(OpenVDB_USES_LOG4CPLUS ${USE_LOG4CPLUS})
+set(OpenVDB_USES_EXR ${USE_EXR})
+
+# Search for optional dependencies
+
+foreach(PREREQUISITE ${_OPENVDB_PREREQUISITE_LIST})
+  set(_HAS_DEP)
+  get_filename_component(PREREQUISITE ${PREREQUISITE} NAME)
+
+  string(FIND ${PREREQUISITE} "blosc" _HAS_DEP)
+  if(NOT ${_HAS_DEP} EQUAL -1)
+    set(OpenVDB_USES_BLOSC ON)
+  endif()
+
+  string(FIND ${PREREQUISITE} "log4cplus" _HAS_DEP)
+  if(NOT ${_HAS_DEP} EQUAL -1)
+    set(OpenVDB_USES_LOG4CPLUS ON)
+  endif()
+
+  string(FIND ${PREREQUISITE} "IlmImf" _HAS_DEP)
+  if(NOT ${_HAS_DEP} EQUAL -1)
+    set(OpenVDB_USES_EXR ON)
+  endif()
+endforeach()
+
+unset(_OPENVDB_PREREQUISITE_LIST)
+unset(_HAS_DEP)
+
+if(OpenVDB_USES_BLOSC)
+  find_package(Blosc REQUIRED)
+endif()
+
+if(OpenVDB_USES_LOG4CPLUS)
+  find_package(Log4cplus REQUIRED)
+endif()
+
+if(OpenVDB_USES_EXR)
+  find_package(IlmBase REQUIRED)
+  find_package(OpenEXR REQUIRED)
+endif()
+
+if(UNIX)
+  find_package(Threads REQUIRED)
+endif()
+
+# Set deps. Note that the order here is important. If we're building against
+# Houdini 17.5 we must include OpenEXR and IlmBase deps first to ensure the
+# users chosen namespaced headers are correctly prioritized. Otherwise other
+# include paths from shared installs (including houdini) may pull in the wrong
+# headers
+
+set(_OPENVDB_VISIBLE_DEPENDENCIES
+  Boost::iostreams
+  Boost::system
+  IlmBase::Half
+)
+
+set(_OPENVDB_DEFINITIONS)
+if(OpenVDB_ABI)
+  list(APPEND _OPENVDB_DEFINITIONS "-DOPENVDB_ABI_VERSION_NUMBER=${OpenVDB_ABI}")
+endif()
+
+if(OpenVDB_USES_EXR)
+  list(APPEND _OPENVDB_VISIBLE_DEPENDENCIES
+    IlmBase::IlmThread
+    IlmBase::Iex
+    IlmBase::Imath
+    OpenEXR::IlmImf
+  )
+  list(APPEND _OPENVDB_DEFINITIONS "-DOPENVDB_TOOLS_RAYTRACER_USE_EXR")
+endif()
+
+if(OpenVDB_USES_LOG4CPLUS)
+  list(APPEND _OPENVDB_VISIBLE_DEPENDENCIES Log4cplus::log4cplus)
+  list(APPEND _OPENVDB_DEFINITIONS "-DOPENVDB_USE_LOG4CPLUS")
+endif()
+
+list(APPEND _OPENVDB_VISIBLE_DEPENDENCIES
+  TBB::tbb
+)
+if(UNIX)
+  list(APPEND _OPENVDB_VISIBLE_DEPENDENCIES
+    Threads::Threads
+  )
+endif()
+
+set(_OPENVDB_HIDDEN_DEPENDENCIES)
+
+if(OpenVDB_USES_BLOSC)
+  list(APPEND _OPENVDB_HIDDEN_DEPENDENCIES Blosc::blosc)
+endif()
+
+list(APPEND _OPENVDB_HIDDEN_DEPENDENCIES ZLIB::ZLIB)
+
+# ------------------------------------------------------------------------
+#  Configure imported target
+# ------------------------------------------------------------------------
+
+set(OpenVDB_LIBRARIES
+  ${OpenVDB_LIB_COMPONENTS}
+)
+set(OpenVDB_INCLUDE_DIRS ${OpenVDB_INCLUDE_DIR})
+
+set(OpenVDB_DEFINITIONS)
+list(APPEND OpenVDB_DEFINITIONS "${PC_OpenVDB_CFLAGS_OTHER}")
+list(APPEND OpenVDB_DEFINITIONS "${_OPENVDB_DEFINITIONS}")
+list(REMOVE_DUPLICATES OpenVDB_DEFINITIONS)
+
+set(OpenVDB_LIBRARY_DIRS "")
+foreach(LIB ${OpenVDB_LIB_COMPONENTS})
+  get_filename_component(_OPENVDB_LIBDIR ${LIB} DIRECTORY)
+  list(APPEND OpenVDB_LIBRARY_DIRS ${_OPENVDB_LIBDIR})
+endforeach()
+list(REMOVE_DUPLICATES OpenVDB_LIBRARY_DIRS)
+
+foreach(COMPONENT ${OpenVDB_FIND_COMPONENTS})
+  if(NOT TARGET OpenVDB::${COMPONENT})
+    add_library(OpenVDB::${COMPONENT} UNKNOWN IMPORTED)
+    set_target_properties(OpenVDB::${COMPONENT} PROPERTIES
+      IMPORTED_LOCATION "${OpenVDB_${COMPONENT}_LIBRARY}"
+      INTERFACE_COMPILE_OPTIONS "${OpenVDB_DEFINITIONS}"
+      INTERFACE_INCLUDE_DIRECTORIES "${OpenVDB_INCLUDE_DIR}"
+      IMPORTED_LINK_DEPENDENT_LIBRARIES "${_OPENVDB_HIDDEN_DEPENDENCIES}" # non visible deps
+      INTERFACE_LINK_LIBRARIES "${_OPENVDB_VISIBLE_DEPENDENCIES}" # visible deps (headers)
+   )
+  endif()
+endforeach()
 
-ENDIF( OpenVDB_FOUND )
+unset(_OPENVDB_DEFINITIONS)
+unset(_OPENVDB_VISIBLE_DEPENDENCIES)
+unset(_OPENVDB_HIDDEN_DEPENDENCIES)
diff -aur openvdb-6.0.0/cmake/FindTBB.cmake openvdb-6.1.0/cmake/FindTBB.cmake
--- openvdb-6.0.0/cmake/FindTBB.cmake	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/cmake/FindTBB.cmake	2019-05-07 22:58:35.000000000 +0200
@@ -1,4 +1,4 @@
-# Copyright (c) 2012-2016 DreamWorks Animation LLC
+# Copyright (c) 2012-2019 DreamWorks Animation LLC
 #
 # All rights reserved. This software is distributed under the
 # Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -24,112 +24,307 @@
 # IN NO EVENT SHALL THE COPYRIGHT HOLDERS' AND CONTRIBUTORS' AGGREGATE
 # LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 #
+#[=======================================================================[.rst:
 
-#-*-cmake-*-
-# - Find TBB
-#
-# Author : Nicholas Yue yue.nicholas@gmail.com
-#
-# This auxiliary CMake file helps in find the TBB headers and libraries
-#
-# TBB_FOUND                  set if TBB is found.
-# TBB_INCLUDE_DIR            TBB's include directory
-# TBB_tbb_LIBRARY            TBB libraries
-# TBB_tbb_preview_LIBRARY    TBB_preview libraries (Mulitple Rendering Context)
-# TBB_tbbmalloc_LIBRARY      TBBmalloc libraries (Mulitple Rendering Context)
+FindTBB
+-------
+
+Find Tbb include dirs and libraries
 
-FIND_PACKAGE ( PackageHandleStandardArgs )
+Use this module by invoking find_package with the form::
 
-# SET ( TBB_FOUND FALSE )
+  find_package(TBB
+    [version] [EXACT]      # Minimum or EXACT version
+    [REQUIRED]             # Fail with error if Tbb is not found
+    [COMPONENTS <libs>...] # Tbb libraries by their canonical name
+                           # e.g. "tbb" for "libtbb"
+    )
+
+IMPORTED Targets
+^^^^^^^^^^^^^^^^
+
+``TBB::tbb``
+  The tbb library target.
+``TBB::tbbmalloc``
+  The tbbmalloc library target.
+
+Result Variables
+^^^^^^^^^^^^^^^^
+
+This will define the following variables:
+
+``Tbb_FOUND``
+  True if the system has the Tbb library.
+``Tbb_VERSION``
+  The version of the Tbb library which was found.
+``Tbb_INCLUDE_DIRS``
+  Include directories needed to use Tbb.
+``Tbb_LIBRARIES``
+  Libraries needed to link to Tbb.
+``Tbb_LIBRARY_DIRS``
+  Tbb library directories.
+``TBB_{COMPONENT}_FOUND``
+  True if the system has the named TBB component.
+
+Cache Variables
+^^^^^^^^^^^^^^^
+
+The following cache variables may also be set:
+
+``Tbb_INCLUDE_DIR``
+  The directory containing ``tbb/tbb_stddef.h``.
+``Tbb_{COMPONENT}_LIBRARY``
+  Individual component libraries for Tbb
+
+Hints
+^^^^^
+
+Instead of explicitly setting the cache variables, the following variables
+may be provided to tell this module where to look.
+
+``TBB_ROOT``
+  Preferred installation prefix.
+``TBB_INCLUDEDIR``
+  Preferred include directory e.g. <prefix>/include
+``TBB_LIBRARYDIR``
+  Preferred library directory e.g. <prefix>/lib
+``SYSTEM_LIBRARY_PATHS``
+  Paths appended to all include and lib searches.
+
+#]=======================================================================]
+
+# Support new if() IN_LIST operator
+if(POLICY CMP0057)
+  cmake_policy(SET CMP0057 NEW)
+endif()
+
+mark_as_advanced(
+  Tbb_INCLUDE_DIR
+  Tbb_LIBRARY
+)
+
+set(_TBB_COMPONENT_LIST
+  tbb
+  tbbmalloc
+)
+
+if(TBB_FIND_COMPONENTS)
+  set(_TBB_COMPONENTS_PROVIDED TRUE)
+  set(_IGNORED_COMPONENTS "")
+  foreach(COMPONENT ${TBB_FIND_COMPONENTS})
+    if(NOT ${COMPONENT} IN_LIST _TBB_COMPONENT_LIST)
+      list(APPEND _IGNORED_COMPONENTS ${COMPONENT})
+    endif()
+  endforeach()
+
+  if(_IGNORED_COMPONENTS)
+    message(STATUS "Ignoring unknown components of TBB:")
+    foreach(COMPONENT ${_IGNORED_COMPONENTS})
+      message(STATUS "  ${COMPONENT}")
+    endforeach()
+    list(REMOVE_ITEM TBB_FIND_COMPONENTS ${_IGNORED_COMPONENTS})
+  endif()
+else()
+  set(_TBB_COMPONENTS_PROVIDED FALSE)
+  set(TBB_FIND_COMPONENTS ${_TBB_COMPONENT_LIST})
+endif()
+
+# Append TBB_ROOT or $ENV{TBB_ROOT} if set (prioritize the direct cmake var)
+set(_TBB_ROOT_SEARCH_DIR "")
+
+if(TBB_ROOT)
+  list(APPEND _TBB_ROOT_SEARCH_DIR ${TBB_ROOT})
+else()
+  set(_ENV_TBB_ROOT $ENV{TBB_ROOT})
+  if(_ENV_TBB_ROOT)
+    list(APPEND _TBB_ROOT_SEARCH_DIR ${_ENV_TBB_ROOT})
+  endif()
+endif()
+
+# Additionally try and use pkconfig to find Tbb
+
+find_package(PkgConfig)
+pkg_check_modules(PC_Tbb QUIET tbb)
+
+# ------------------------------------------------------------------------
+#  Search for tbb include DIR
+# ------------------------------------------------------------------------
+
+set(_TBB_INCLUDE_SEARCH_DIRS "")
+list(APPEND _TBB_INCLUDE_SEARCH_DIRS
+  ${TBB_INCLUDEDIR}
+  ${_TBB_ROOT_SEARCH_DIR}
+  ${PC_Tbb_INCLUDE_DIRS}
+  ${SYSTEM_LIBRARY_PATHS}
+)
 
-FIND_PATH( TBB_LOCATION include/tbb/tbb.h
-  "$ENV{TBB_ROOT}"
+# Look for a standard tbb header file.
+find_path(Tbb_INCLUDE_DIR tbb/tbb_stddef.h
   NO_DEFAULT_PATH
-  NO_CMAKE_ENVIRONMENT_PATH
-  NO_CMAKE_PATH
-  NO_SYSTEM_ENVIRONMENT_PATH
-  NO_CMAKE_SYSTEM_PATH
-  )
-
-FIND_PACKAGE_HANDLE_STANDARD_ARGS ( TBB
-  REQUIRED_VARS TBB_LOCATION
-  )
-
-IF ( TBB_FOUND )
-
-  SET( TBB_INCLUDE_DIR "${TBB_LOCATION}/include" CACHE STRING "TBB include directory")
-
-  IF (APPLE)
-	IF (TBB_FOR_CLANG)
-      SET ( TBB_LIBRARYDIR ${TBB_LOCATION}/lib/libc++ CACHE STRING "TBB library directory")
-	ELSE ()
-      SET ( TBB_LIBRARYDIR ${TBB_LOCATION}/lib CACHE STRING "TBB library directory")
-	ENDIF ()
-	SET(CMAKE_FIND_LIBRARY_SUFFIXES ".dylib")
-	FIND_LIBRARY ( TBB_LIBRARY_PATH tbb PATHS ${TBB_LIBRARYDIR} )
-	FIND_LIBRARY ( TBB_PREVIEW_LIBRARY_PATH tbb_preview PATHS ${TBB_LIBRARYDIR} )
-	FIND_LIBRARY ( TBBMALLOC_LIBRARY_PATH tbbmalloc PATHS ${TBB_LIBRARYDIR} )
-	LIST ( APPEND TBB_LIBRARIES_LIST ${TBB_LIBRARY_PATH} ${TBBmx_LIBRARY_PATH} )
-  ELSEIF (WIN32)
-	IF (MSVC10)
-      SET ( TBB_VC_DIR vc10 )
-	ELSEIF (MSVC11)
-      SET ( TBB_VC_DIR vc11 )
-	ELSEIF (MSVC12)
-      SET ( TBB_VC_DIR vc12 )
-	ENDIF ( MSVC10)
-	#  MESSAGE ( "TBB_VC_DIR = ${TBB_VC_DIR}" )
-	SET (TBB_PATH_SUFFIXES intel64/${TBB_VC_DIR} )
-	FIND_LIBRARY ( TBB_LIBRARY_PATH tbb PATHS ${TBB_LIBRARYDIR} PATH_SUFFIXES ${TBB_PATH_SUFFIXES})
-	FIND_LIBRARY ( TBB_PREVIEW_LIBRARY_PATH tbb_preview PATHS ${TBB_LIBRARYDIR}  PATH_SUFFIXES ${TBB_PATH_SUFFIXES})
-	FIND_LIBRARY ( TBBMALLOC_LIBRARY_PATH tbbmalloc PATHS ${TBB_LIBRARYDIR}  PATH_SUFFIXES ${TBB_PATH_SUFFIXES})
-	LIST ( APPEND TBB_LIBRARIES_LIST ${TBB_LIBRARY_PATH} ${TBBmx_LIBRARY_PATH} )
-  ELSE (APPLE)
-	# MESSAGE ( "CMAKE_COMPILER_IS_GNUCXX = ${CMAKE_COMPILER_IS_GNUCXX}")
-    SET ( TBB_LIBRARYDIR ${TBB_LOCATION}/lib CACHE STRING "TBB library directory")
-	IF (${CMAKE_COMPILER_IS_GNUCXX})
-	  IF ( TBB_MATCH_COMPILER_VERSION )
-		STRING(REGEX MATCHALL "[0-9]+" GCC_VERSION_COMPONENTS ${CMAKE_CXX_COMPILER_VERSION})
-		LIST(GET GCC_VERSION_COMPONENTS 0 GCC_MAJOR)
-		LIST(GET GCC_VERSION_COMPONENTS 1 GCC_MINOR)
-		# MESSAGE(STATUS ${GCC_MAJOR})
-		# MESSAGE(STATUS ${GCC_MINOR})
-		# MESSAGE ( "TBB CMAKE_CXX_COMPILER_VERSION = ${CMAKE_CXX_COMPILER_VERSION}")
-		SET ( TBB_PATH_SUFFIXES intel64/gcc${GCC_MAJOR}.${GCC_MINOR} x86_64-linux-gnu )
-	  ELSE ()
-		SET ( TBB_PATH_SUFFIXES intel64/gcc4.4 x86_64-linux-gnu )
-	  ENDIF ()
-	ELSE ()
-      MESSAGE ( FATAL_ERROR "Can't handle non-GCC compiler")
-	ENDIF ()
-	FIND_LIBRARY ( TBB_LIBRARY_PATH tbb PATHS ${TBB_LIBRARYDIR} PATH_SUFFIXES ${TBB_PATH_SUFFIXES}
-      NO_DEFAULT_PATH
-      NO_CMAKE_ENVIRONMENT_PATH
-      NO_CMAKE_PATH
-      NO_SYSTEM_ENVIRONMENT_PATH
-      NO_CMAKE_SYSTEM_PATH
-	  )
-	FIND_LIBRARY ( TBB_PREVIEW_LIBRARY_PATH tbb_preview PATHS ${TBB_LIBRARYDIR} PATH_SUFFIXES ${TBB_PATH_SUFFIXES}
-      NO_DEFAULT_PATH
-      NO_CMAKE_ENVIRONMENT_PATH
-      NO_CMAKE_PATH
-      NO_SYSTEM_ENVIRONMENT_PATH
-      NO_CMAKE_SYSTEM_PATH
-	  )
-	FIND_LIBRARY ( TBBMALLOC_LIBRARY_PATH tbbmalloc PATHS ${TBB_LIBRARYDIR} PATH_SUFFIXES ${TBB_PATH_SUFFIXES}
-      NO_DEFAULT_PATH
-      NO_CMAKE_ENVIRONMENT_PATH
-      NO_CMAKE_PATH
-      NO_SYSTEM_ENVIRONMENT_PATH
-      NO_CMAKE_SYSTEM_PATH
-	  )
-	LIST ( APPEND TBB_LIBRARIES_LIST ${TBB_LIBRARY_PATH} ${TBBmx_LIBRARY_PATH} )
-  ENDIF (APPLE)
-
-  GET_FILENAME_COMPONENT ( TBB_LIBRARYDIR ${TBB_LIBRARY_PATH} PATH CACHE )
-
-  SET( Tbb_TBB_LIBRARY ${TBB_LIBRARY_PATH} CACHE STRING "tbb library")
-  SET( Tbb_TBB_PREVIEW_LIBRARY ${TBB_PREVIEW_LIBRARY_PATH} CACHE STRING "tbb_preview library")
-  SET( Tbb_TBBMALLOC_LIBRARY ${TBBMALLOC_LIBRARY_PATH} CACHE STRING "tbbmalloc library")
+  PATHS ${_TBB_INCLUDE_SEARCH_DIRS}
+  PATH_SUFFIXES include
+)
+
+if(EXISTS "${Tbb_INCLUDE_DIR}/tbb/tbb_stddef.h")
+  file(STRINGS "${Tbb_INCLUDE_DIR}/tbb/tbb_stddef.h"
+    _tbb_version_major_string REGEX "#define TBB_VERSION_MAJOR "
+  )
+  string(REGEX REPLACE "#define TBB_VERSION_MAJOR" ""
+    _tbb_version_major_string "${_tbb_version_major_string}"
+  )
+  string(STRIP "${_tbb_version_major_string}" Tbb_VERSION_MAJOR)
+
+  file(STRINGS "${Tbb_INCLUDE_DIR}/tbb/tbb_stddef.h"
+     _tbb_version_minor_string REGEX "#define TBB_VERSION_MINOR "
+  )
+  string(REGEX REPLACE "#define TBB_VERSION_MINOR" ""
+    _tbb_version_minor_string "${_tbb_version_minor_string}"
+  )
+  string(STRIP "${_tbb_version_minor_string}" Tbb_VERSION_MINOR)
+
+  unset(_tbb_version_major_string)
+  unset(_tbb_version_minor_string)
+
+  set(Tbb_VERSION ${Tbb_VERSION_MAJOR}.${Tbb_VERSION_MINOR})
+endif()
+
+# ------------------------------------------------------------------------
+#  Search for TBB lib DIR
+# ------------------------------------------------------------------------
+
+set(_TBB_LIBRARYDIR_SEARCH_DIRS "")
+
+# Append to _TBB_LIBRARYDIR_SEARCH_DIRS in priority order
+
+set(_TBB_LIBRARYDIR_SEARCH_DIRS "")
+list(APPEND _TBB_LIBRARYDIR_SEARCH_DIRS
+  ${TBB_LIBRARYDIR}
+  ${_TBB_ROOT_SEARCH_DIR}
+  ${PC_Tbb_LIBRARY_DIRS}
+  ${SYSTEM_LIBRARY_PATHS}
+)
+
+set(TBB_PATH_SUFFIXES
+  lib64
+  lib
+)
+
+# platform branching
+
+if(UNIX)
+  list(INSERT TBB_PATH_SUFFIXES 0 lib/x86_64-linux-gnu)
+endif()
+
+if(APPLE)
+  if(TBB_FOR_CLANG)
+    list(INSERT TBB_PATH_SUFFIXES 0 lib/libc++)
+  endif()
+elseif(WIN32)
+  if(MSVC10)
+    set(TBB_VC_DIR vc10)
+  elseif(MSVC11)
+    set(TBB_VC_DIR vc11)
+  elseif(MSVC12)
+    set(TBB_VC_DIR vc12)
+  endif()
+  list(INSERT TBB_PATH_SUFFIXES 0 lib/intel64/${TBB_VC_DIR})
+else()
+  if(${CMAKE_CXX_COMPILER_ID} STREQUAL GNU)
+    if(TBB_MATCH_COMPILER_VERSION)
+      string(REGEX MATCHALL "[0-9]+" GCC_VERSION_COMPONENTS ${CMAKE_CXX_COMPILER_VERSION})
+      list(GET GCC_VERSION_COMPONENTS 0 GCC_MAJOR)
+      list(GET GCC_VERSION_COMPONENTS 1 GCC_MINOR)
+      list(INSERT TBB_PATH_SUFFIXES 0 lib/intel64/gcc${GCC_MAJOR}.${GCC_MINOR})
+    else()
+      list(INSERT TBB_PATH_SUFFIXES 0 lib/intel64/gcc4.4)
+    endif()
+  endif()
+endif()
+
+if(UNIX AND TBB_USE_STATIC_LIBS)
+  set(_TBB_ORIG_CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_FIND_LIBRARY_SUFFIXES})
+  set(CMAKE_FIND_LIBRARY_SUFFIXES ".a")
+endif()
+
+set(Tbb_LIB_COMPONENTS "")
+
+foreach(COMPONENT ${TBB_FIND_COMPONENTS})
+  find_library(Tbb_${COMPONENT}_LIBRARY ${COMPONENT}
+    NO_DEFAULT_PATH
+    PATHS ${_TBB_LIBRARYDIR_SEARCH_DIRS}
+    PATH_SUFFIXES ${TBB_PATH_SUFFIXES}
+  )
+
+  # On Unix, TBB sometimes uses linker scripts instead of symlinks, so parse the linker script
+  # and correct the library name if so
+  if(UNIX AND EXISTS ${Tbb_${COMPONENT}_LIBRARY})
+    # Ignore files where the first four bytes equals the ELF magic number
+    file(READ ${Tbb_${COMPONENT}_LIBRARY} Tbb_${COMPONENT}_HEX OFFSET 0 LIMIT 4 HEX)
+    if(NOT ${Tbb_${COMPONENT}_HEX} STREQUAL "7f454c46")
+      # Read the first 1024 bytes of the library and match against an "INPUT (file)" regex
+      file(READ ${Tbb_${COMPONENT}_LIBRARY} Tbb_${COMPONENT}_ASCII OFFSET 0 LIMIT 1024)
+      if("${Tbb_${COMPONENT}_ASCII}" MATCHES "INPUT \\(([^(]+)\\)")
+        # Extract the directory and apply the matched text (in brackets)
+        get_filename_component(Tbb_${COMPONENT}_DIR "${Tbb_${COMPONENT}_LIBRARY}" DIRECTORY)
+        set(Tbb_${COMPONENT}_LIBRARY "${Tbb_${COMPONENT}_DIR}/${CMAKE_MATCH_1}")
+      endif()
+    endif()
+  endif()
+
+  list(APPEND Tbb_LIB_COMPONENTS ${Tbb_${COMPONENT}_LIBRARY})
+
+  if(Tbb_${COMPONENT}_LIBRARY)
+    set(TBB_${COMPONENT}_FOUND TRUE)
+  else()
+    set(TBB_${COMPONENT}_FOUND FALSE)
+  endif()
+endforeach()
+
+if(UNIX AND TBB_USE_STATIC_LIBS)
+  set(CMAKE_FIND_LIBRARY_SUFFIXES ${_TBB_ORIG_CMAKE_FIND_LIBRARY_SUFFIXES})
+  unset(_TBB_ORIG_CMAKE_FIND_LIBRARY_SUFFIXES)
+endif()
+
+# ------------------------------------------------------------------------
+#  Cache and set TBB_FOUND
+# ------------------------------------------------------------------------
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(TBB
+  FOUND_VAR TBB_FOUND
+  REQUIRED_VARS
+    Tbb_INCLUDE_DIR
+    Tbb_LIB_COMPONENTS
+  VERSION_VAR Tbb_VERSION
+  HANDLE_COMPONENTS
+)
+
+if(TBB_FOUND)
+  set(Tbb_LIBRARIES
+    ${Tbb_LIB_COMPONENTS}
+  )
+  set(Tbb_INCLUDE_DIRS ${Tbb_INCLUDE_DIR})
+  set(Tbb_DEFINITIONS ${PC_Tbb_CFLAGS_OTHER})
 
-ENDIF ( TBB_FOUND )
+  set(Tbb_LIBRARY_DIRS "")
+  foreach(LIB ${Tbb_LIB_COMPONENTS})
+    get_filename_component(_TBB_LIBDIR ${LIB} DIRECTORY)
+    list(APPEND Tbb_LIBRARY_DIRS ${_TBB_LIBDIR})
+  endforeach()
+  list(REMOVE_DUPLICATES Tbb_LIBRARY_DIRS)
+
+  # Configure imported targets
+
+  foreach(COMPONENT ${TBB_FIND_COMPONENTS})
+    if(NOT TARGET TBB::${COMPONENT})
+      add_library(TBB::${COMPONENT} UNKNOWN IMPORTED)
+      set_target_properties(TBB::${COMPONENT} PROPERTIES
+        IMPORTED_LOCATION "${Tbb_${COMPONENT}_LIBRARY}"
+        INTERFACE_COMPILE_OPTIONS "${Tbb_DEFINITIONS}"
+        INTERFACE_INCLUDE_DIRECTORIES "${Tbb_INCLUDE_DIR}"
+      )
+    endif()
+  endforeach()
+elseif(TBB_FIND_REQUIRED)
+  message(FATAL_ERROR "Unable to find TBB")
+endif()
Seulement dans openvdb-6.1.0/cmake: OpenVDBGLFW3Setup.cmake
Seulement dans openvdb-6.1.0/cmake: OpenVDBHoudiniSetup.cmake
Seulement dans openvdb-6.1.0/cmake: OpenVDBMayaSetup.cmake
Seulement dans openvdb-6.1.0/cmake: OpenVDBUtils.cmake
Seulement dans openvdb-6.1.0/cmake: Uninstall.cmake
diff -aur openvdb-6.0.0/CMakeLists.txt openvdb-6.1.0/CMakeLists.txt
--- openvdb-6.0.0/CMakeLists.txt	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/CMakeLists.txt	2019-05-07 22:58:35.000000000 +0200
@@ -1,4 +1,4 @@
-# Copyright (c) 2012-2016 DreamWorks Animation LLC
+# Copyright (c) 2012-2019 DreamWorks Animation LLC
 #
 # All rights reserved. This software is distributed under the
 # Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -24,72 +24,497 @@
 # IN NO EVENT SHALL THE COPYRIGHT HOLDERS' AND CONTRIBUTORS' AGGREGATE
 # LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 #
+#[=======================================================================[
 
-# yue.nicholas@gmail.com
-CMAKE_MINIMUM_REQUIRED(VERSION 3.1)
+  CMake Configuration for OpenVDB
 
-PROJECT ( OpenVDB )
-
-ENABLE_TESTING()
-
-find_program(CCACHE_FOUND ccache)
-if(CCACHE_FOUND)
+  The OpenVDB CMake build system generates targets depending on the
+  enabled components. It is designed for out of source CMake generation
+  (a build location for CMake to write to will be required). For example,
+  from the root of the repository:
+
+    mkdir build
+    cd build
+    cmake ../
+
+  Depending on the components you choose to build, a number of optional
+  and required dependencies are expected. See the dependency documentation
+  for more information:
+
+    https://www.openvdb.org/documentation/doxygen/dependencies.html
+
+  And the documentation on building OpenVDB for more in depth installation
+  instructions:
+
+    https://www.openvdb.org/documentation/doxygen/build.html
+
+  This CMakeLists file provides most available options for configuring the
+  build and installation of all OpenVDB components. By default the core
+  library, the vdb_print binary and python module are enabled.
+
+  Note that various packages have inbuilt CMake module support. See the
+  CMake documentation for more ZLib, Doxygen, OpenGL, Boost and Python
+  controls:
+
+    https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html
+
+  OpenVDB's CMake supports building the various components of against a
+  prior installation of OpenVDB.
+
+#]=======================================================================]
+
+project(OpenVDB)
+cmake_minimum_required(VERSION 3.3)
+# Monitoring <PackageName>_ROOT variables
+if(POLICY CMP0048)
+  cmake_policy(SET CMP0048 NEW)
+endif()
+
+###### OpenVDB Build/Component Options
+
+include(CMakeDependentOption)
+
+# todo SSE/AVX instruction options
+# todo epydoc and pdflatex
+option(OPENVDB_BUILD_CORE "Enable the core OpenVDB library. Both static and shared versions are enabled by default" ON)
+option(OPENVDB_BUILD_BINARIES "Enable the vdb binaries. Only vdb_print is enabled by default" ON)
+option(OPENVDB_BUILD_PYTHON_MODULE "Build the pyopenvdb Python module" ON)
+option(OPENVDB_BUILD_UNITTESTS "Build the OpenVDB unit tests" OFF)
+option(OPENVDB_BUILD_DOCS "Build the OpenVDB documentation" OFF)
+option(OPENVDB_BUILD_HOUDINI_PLUGIN "Build the Houdini plugin" OFF)
+option(OPENVDB_BUILD_MAYA_PLUGIN "Build the Maya plugin" OFF)
+option(OPENVDB_ENABLE_RPATH "Build with RPATH information" ON)
+option(OPENVDB_CXX_STRICT "Enable or disable pre-defined compiler warnings" OFF)
+CMAKE_DEPENDENT_option(OPENVDB_INSTALL_CMAKE_MODULES
+  "Install the provided OpenVDB CMake modules when building the core library"
+  ON "OPENVDB_BUILD_CORE" OFF)
+
+option(USE_HOUDINI [=[
+Build the library against a Houdini installation. Turns on automatically if OPENVDB_BUILD_HOUDINI_PLUGIN is enabled.
+When enabled, you do not need to provide dependency locations for TBB, Blosc, IlmBase and OpenEXR. Boost must be
+provided if Houdini Version >= 16.5. IlmBase/OpenEXR can optionally be provided if Houdini Version >= 17.5.]=] OFF)
+option(USE_MAYA [=[
+Build the library against a Maya installation. Turns on automatically if OPENVDB_BUILD_MAYA_PLUGIN is enabled.
+When enabled, you do not need to provide dependency locations for TBB. All other dependencies must be provided.]=] OFF)
+option(USE_BLOSC [=[
+Use blosc while building openvdb components. If OPENVDB_BUILD_CORE is OFF, CMake attempts to query the located
+openvdb build configuration to decide on blosc support. You may set this to on to force blosc to be used if you
+know it to be required.]=] ON)
+option(USE_LOG4CPLUS [=[
+Use log4cplus while building openvdb components. If OPENVDB_BUILD_CORE is OFF, CMake attempts to query the
+located openvdb build configuration to decide on log4cplus support. You may set this to on to force log4cplus
+to be used if you know it to be required.]=] OFF)
+option(USE_EXR [=[
+Use OpenEXR while building openvdb components. If OPENVDB_BUILD_CORE is OFF, CMake attempts to query the located
+openvdb build configuration to decide on OpenEXR support. You may set this to on to force OpenEXR to be used if you
+know it to be required.]=] OFF)
+CMAKE_DEPENDENT_option(OPENVDB_DISABLE_BOOST_IMPLICIT_LINKING
+  "Disable the implicit linking of Boost libraries on Windows" ON "WIN32" OFF)
+option(USE_SYSTEM_LIBRARY_PATHS "Build with system library paths" ON)
+option(USE_CCACHE "Build using Ccache if found on the path" ON)
+option(DISABLE_DEPENDENCY_VERSION_CHECKS [=[
+Disable minimum version checks for OpenVDB dependencies. It is strongly recommended that this remains disabled.
+Consider updating your dependencies where possible if encountering minimum requirement CMake errors.]=] OFF)
+
+###### Deprecated options
+
+option(OPENVDB_BUILD_HOUDINI_SOPS "Build the Houdini plugin  (deprecated - see OPENVDB_BUILD_HOUDINI_PLUGIN)" OFF)
+option(OPENVDB_ENABLE_3_ABI_COMPATIBLE "Build with OpenVDB ABI 3 (deprecated - see OPENVDB_ABI_VERSION_NUMBER)" OFF)
+
+# Alias deprecated vars
+
+if(OPENVDB_BUILD_HOUDINI_SOPS)
+  # Support for legacy OPENVDB_BUILD_HOUDINI_SOPS variable
+  message(DEPRECATION "The OPENVDB_BUILD_HOUDINI_SOPS option is deprecated and will be removed. "
+    "Use OPENVDB_BUILD_HOUDINI_PLUGIN.")
+  set(OPENVDB_BUILD_HOUDINI_PLUGIN ON)
+endif()
+
+if(OPENVDB_ENABLE_3_ABI_COMPATIBLE)
+  message(DEPRECATION "OPENVDB_ENABLE_3_ABI_COMPATIBLE is deprecated and will be removed. Use "
+    "-D OPENVDB_ABI_VERSION_NUMBER=N, where N is the abi version.")
+  if(OPENVDB_ABI_VERSION_NUMBER)
+    if(NOT (${OPENVDB_ABI_VERSION_NUMBER} EQUAL 3))
+      message(WARNING "OPENVDB_ABI_VERSION_NUMBER holds a different ABI value to "
+        "OPENVDB_ENABLE_3_ABI_COMPATIBLE, which will be ignored.")
+    endif()
+  else()
+    # Don't bother setting the docstring as we'll update it later
+    set(OPENVDB_ABI_VERSION_NUMBER "3" CACHE STRING "" FORCE)
+  endif()
+endif()
+
+# Various root level CMake options which are marked as advanced
+
+mark_as_advanced(
+  OPENVDB_CXX_STRICT
+  OPENVDB_ENABLE_3_ABI_COMPATIBLE
+  OPENVDB_ENABLE_RPATH
+  USE_HOUDINI
+  USE_MAYA
+  USE_LOG4CPLUS
+  USE_SYSTEM_LIBRARY_PATHS
+  USE_CCACHE
+  OPENVDB_BUILD_HOUDINI_SOPS
+  DISABLE_DEPENDENCY_VERSION_CHECKS
+)
+
+# Configure minimum version requirements
+
+# @note  Blosc version is currently treated as exception which must be adhered
+# to. The minimum version must be at least 1.5. Previous versions are incompatible.
+set(MINIMUM_BLOSC_VERSION 1.5)
+
+if(NOT DISABLE_DEPENDENCY_VERSION_CHECKS)
+  # @note  Currently tracking CY2017 of the VFX platform where avaiable
+  set(MINIMUM_GCC_VERSION 4.8)
+  set(MINIMUM_CLANG_VERSION 3.8)
+  set(MINIMUM_ICC_VERSION 15)
+
+  set(MINIMUM_BOOST_VERSION 1.61)
+  set(MINIMUM_ILMBASE_VERSION 2.2)
+  set(MINIMUM_OPENEXR_VERSION 2.2)
+  set(MINIMUM_ZLIB_VERSION 1.2.7)
+  set(MINIMUM_TBB_VERSION 4.4)
+
+  set(MINIMUM_PYTHON_VERSION 2.7)
+  set(MINIMUM_NUMPY_VERSION 1.9.2)
+
+  set(MINIMUM_CPPUNIT_VERSION 1.10)
+  set(MINIMUM_GLFW_VERSION 3.0)
+  set(MINIMUM_LOG4CPLUS_VERSION 1.1.2)
+  set(MINIMUM_HOUDINI_VERSION 16.5)
+
+  # These always promote warnings rather than errors
+  set(MINIMUM_MAYA_VERSION 2017)
+  set(MINIMUM_OPENVDB_ABI_VERSION 4)
+  set(MINIMUM_DOXYGEN_VERSION 1.8.8)
+endif()
+
+#########################################################################
+
+# General CMake and CXX settings
+
+set(CMAKE_CXX_STANDARD 11)
+set(CMAKE_CXX_STANDARD_REQUIRED ON)
+set(CMAKE_CXX_EXTENSIONS OFF)
+
+set(CMAKE_DISABLE_SOURCE_CHANGES ON)
+set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)
+
+if(OPENVDB_ENABLE_RPATH)
+  # Configure rpath for installation base on the following:
+  # https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/RPATH-handling
+  set(CMAKE_SKIP_BUILD_RPATH FALSE)
+  set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
+  set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
+endif()
+
+# For CMake's find Threads module which brings in pthread - This flag
+# forces the compiler -pthread flag vs -lpthread
+set(THREADS_PREFER_PTHREAD_FLAG TRUE)
+
+enable_testing()
+
+# Add our cmake modules
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")
+
+# Add backports to support older versions of CMake
+
+if(${CMAKE_VERSION} VERSION_LESS 3.8)
+  list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake/backports")
+endif()
+
+# Add cmake modules to installation command
+# @todo fix our glew cmake module
+
+if(OPENVDB_INSTALL_CMAKE_MODULES)
+  set(OPENVDB_CMAKE_MODULES
+    cmake/FindBlosc.cmake
+    cmake/FindCppUnit.cmake
+    cmake/FindIlmBase.cmake
+    cmake/FindLog4cplus.cmake
+    cmake/FindOpenEXR.cmake
+    cmake/FindOpenVDB.cmake
+    cmake/FindTBB.cmake
+    cmake/OpenVDBGLFW3Setup.cmake
+    cmake/OpenVDBHoudiniSetup.cmake
+    cmake/OpenVDBMayaSetup.cmake
+    cmake/OpenVDBUtils.cmake
+  )
+  install(FILES ${OPENVDB_CMAKE_MODULES} DESTINATION lib/cmake/OpenVDB)
+endif()
+
+# Add the doxygen command if required - do this here so we guarantee not to error on
+# unrelated build issues
+
+if(OPENVDB_BUILD_DOCS)
+  find_package(Doxygen REQUIRED)
+  if(DOXYGEN_VERSION VERSION_LESS MINIMUM_DOXYGEN_VERSION)
+    message(WARNING "The doxygen-config doxyfile has been generated with version "
+      "\"${MINIMUM_DOXYGEN_VERSION}\". Found Doxygen version \"${DOXYGEN_VERSION}\". "
+      "Documentation may contain errors."
+    )
+  endif()
+
+  # @todo use cmake doxygen functions available from cmake 3.9
+  file(READ ${CMAKE_CURRENT_SOURCE_DIR}/openvdb/doxygen-config DOXYGEN_CONFIG_CONTENT)
+  file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/openvdb/cmake-doxygen-config ${DOXYGEN_CONFIG_CONTENT})
+  file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/openvdb/cmake-doxygen-config
+    "QUIET=YES\nOUTPUT_DIRECTORY=${CMAKE_CURRENT_BINARY_DIR}/openvdb/doc\n"
+  )
+
+  add_custom_target(doc ALL
+    COMMAND ${DOXYGEN_EXECUTABLE} ${CMAKE_CURRENT_BINARY_DIR}/openvdb/cmake-doxygen-config
+    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}/openvdb
+    COMMENT "Generating API documentation with Doxygen" VERBATIM
+  )
+
+  install(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/openvdb/doc/html DESTINATION docs)
+endif()
+
+# Early exit if there's nothing to build
+
+if(NOT (
+    OPENVDB_BUILD_CORE OR
+    OPENVDB_BUILD_BINARIES OR
+    OPENVDB_BUILD_PYTHON_MODULE OR
+    OPENVDB_BUILD_UNITTESTS OR
+    OPENVDB_BUILD_HOUDINI_PLUGIN OR
+    OPENVDB_BUILD_MAYA_PLUGIN)
+  )
+  return()
+endif()
+
+#########################################################################
+
+# ccache setup
+
+if(USE_CCACHE)
+  find_program(CCACHE_PATH ccache)
+  if(CCACHE_PATH)
     set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ccache)
     set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ccache)
-endif(CCACHE_FOUND)
-
-OPTION ( OPENVDB_BUILD_UNITTESTS "Build the OpenVDB unit tests" ON )
-OPTION ( OPENVDB_BUILD_DOCS "Build the OpenVDB documentation" OFF )
-OPTION ( OPENVDB_BUILD_PYTHON_MODULE "Build the pyopenvdb Python module" ON )
-OPTION ( OPENVDB_BUILD_HOUDINI_SOPS "Build the Houdini SOPs" OFF )
-OPTION ( OPENVDB_BUILD_MAYA_PLUGIN "Build the Maya plugin" OFF )
-OPTION ( OPENVDB_BUILD_CORE "Build the OpenVDB core" ON )
-OPTION ( OPENVDB_ENABLE_RPATH "Build with RPATH information" ON )
-OPTION ( OPENVDB_ENABLE_3_ABI_COMPATIBLE "Build with OpenVDB v3 ABI" ON )
-OPTION ( OPENVDB_DISABLE_BOOST_IMPLICIT_LINKING "Disable the implicit linking of Boost libraries on Windows" ON )
-
-SET ( OPENVDB_ABI_VERSION_NUMBER "" CACHE STRING "build for compatibility
-with version N of the OpenVDB Grid ABI, where N is 2, 3, 4, etc. 
-(some newer features will be disabled)")
-
-IF (OPENVDB_BUILD_HOUDINI_SOPS)
-  SET ( OPENVDB_BUILD_PYTHON_MODULE OFF )
-ENDIF ()
-
-IF ( APPLE )
-  IF ( OPENVDB_BUILD_HOUDINI_SOPS AND OPENVDB_BUILD_MAYA_PLUGIN )
-	MESSAGE ( FATAL_ERROR "On OSX, Houdini linked with libc++ whereas Maya is linked with libstdc++, the different runtimes are not mutually compatible, build them Houdini SOPs and Maya plugins separately with the requisite DCC's compiler" )
-  ENDIF ()
-ENDIF ()
-
-LIST(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")
-
-SET ( OPENVDB_TOP_LEVEL_DIR ${PROJECT_SOURCE_DIR} CACHE PATH "OpenVDB Top Level Directory to share among sub projects" )
-
-INCLUDE_DIRECTORIES ( ${OPENVDB_TOP_LEVEL_DIR} ) # To make sure we pick up headers from this version of OpenVDB we are building
-IF ( ${OPENVDB_ABI_VERSION_NUMBER} )
-  MESSAGE( STATUS "Using openvdb abi version ${OPENVDB_ABI_VERSION_NUMBER}")
-  
-  ADD_DEFINITIONS (-DOPENVDB_ABI_VERSION_NUMBER=${OPENVDB_ABI_VERSION_NUMBER} )
-ELSEIF ( OPENVDB_ENABLE_3_ABI_COMPATIBLE )
-
-  MESSAGE( DEPRECATION "OPENVDB_ENABLE_3_ABI_COMPATIBLE is deprecated. Instead use OPENVDB_ABI_VERSION_NUMBER=N, where N is the abi version.")
-
-  ADD_DEFINITIONS ( -DOPENVDB_3_ABI_COMPATIBLE )
-ENDIF ()
-
-IF ( OPENVDB_BUILD_CORE )
-  ADD_SUBDIRECTORY ( openvdb )
-ENDIF ()
-
-IF (OPENVDB_BUILD_PYTHON_MODULE)
-  ADD_SUBDIRECTORY ( openvdb/python )
-ENDIF ()
-
-IF ( OPENVDB_BUILD_HOUDINI_SOPS )
-  ADD_SUBDIRECTORY ( openvdb_houdini )
-ENDIF ()
-
-IF ( OPENVDB_BUILD_MAYA_PLUGIN )
-  ADD_SUBDIRECTORY ( openvdb_maya )
-ENDIF ()
+    message(STATUS "Using ccache: ${CCACHE_PATH}")
+  endif()
+endif()
+
+# Build type configuration - default to Release if none is set
+
+if(NOT CMAKE_BUILD_TYPE)
+  set(CMAKE_BUILD_TYPE Release CACHE STRING
+    "Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel." FORCE
+  )
+endif()
+message(STATUS "CMake Build Type: ${CMAKE_BUILD_TYPE}")
+
+if(USE_SYSTEM_LIBRARY_PATHS)
+  set(SYSTEM_LIBRARY_PATHS
+    ~/Library/Frameworks
+    /Library/Frameworks
+    /usr/local
+    /usr
+    /sw  # Fink
+    /opt/local  # DarwinPorts
+    /opt/csw  # Blastwave
+    /opt
+  )
+endif()
+
+#########################################################################
+
+# Compiler configuration. Add definitions for a number of compiler warnings
+# for sub projects and verify version requirements
+# @todo  add definitions for MSVC and Intel.
+# @todo  add minimum version for MSVC
+
+set(HAS_AVAILABLE_WARNINGS FALSE)
+
+if(CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
+  if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS MINIMUM_CLANG_VERSION)
+    message(FATAL_ERROR "Insufficient clang++ version. Minimum required is "
+      "\"${MINIMUM_CLANG_VERSION}\". Found version \"${CMAKE_CXX_COMPILER_VERSION}\""
+    )
+  endif()
+  if(OPENVDB_CXX_STRICT)
+    message(STATUS "Configuring Clang CXX warnings")
+    set(HAS_AVAILABLE_WARNINGS TRUE)
+    add_definitions(
+      -Werror
+      -Wall
+      -Wextra
+      -Wconversion
+      -Wno-sign-conversion
+    )
+  endif()
+elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
+  if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS MINIMUM_GCC_VERSION)
+    message(FATAL_ERROR "Insufficient g++ version. Minimum required is "
+      "\"${MINIMUM_GCC_VERSION}\". Found version \"${CMAKE_CXX_COMPILER_VERSION}\""
+    )
+  endif()
+  if(OPENVDB_CXX_STRICT)
+    message(STATUS "Configuring GCC CXX warnings")
+    set(HAS_AVAILABLE_WARNINGS TRUE)
+    add_definitions(
+      -Werror
+      -Wall
+      -Wextra
+      -pedantic
+      -Wcast-align
+      -Wcast-qual
+      -Wconversion
+      -Wdisabled-optimization
+      -Woverloaded-virtual
+    )
+  endif()
+elseif(CMAKE_CXX_COMPILER_ID STREQUAL "Intel")
+  if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS MINIMUM_ICC_VERSION})
+    message(FATAL_ERROR "Insufficient ICC version. Minimum required is "
+      "\"${MINIMUM_ICC_VERSION}\". Found version \"${CMAKE_CXX_COMPILER_VERSION}\""
+    )
+  endif()
+elseif(CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
+  # Increase the number of sections that an object file can contain
+  add_definitions("/bigobj")
+endif()
+
+if(OPENVDB_CXX_STRICT AND NOT HAS_AVAILABLE_WARNINGS)
+  message(WARNING "No available CXX warnings for compiler ${CMAKE_CXX_COMPILER_ID}")
+endif()
+unset(HAS_AVAILABLE_WARNINGS)
+
+##########################################################################
+
+# Configure DCC installation if necessary
+
+if(OPENVDB_BUILD_HOUDINI_PLUGIN)
+  set(USE_HOUDINI ON)
+endif()
+
+if(OPENVDB_BUILD_MAYA_PLUGIN)
+  set(USE_MAYA ON)
+endif()
+
+if(USE_MAYA AND USE_HOUDINI)
+  # @todo technically this is possible so long as library versions match
+  # exactly but it's difficult to validate and dangerous
+  message(FATAL_ERROR "Cannot build both Houdini and Maya plugins against "
+    "the same core dependencies. Plugins must be compiled separately to "
+    "ensure the required DCC dependencies are met."
+  )
+endif()
+
+# Configure component dependencies by loading the Houdini/Maya setup
+# scripts. These also find the Houdini/Maya installations
+
+if(USE_HOUDINI)
+  include(OpenVDBHoudiniSetup)
+endif()
+
+if(USE_MAYA)
+  include(OpenVDBMayaSetup)
+endif()
+
+#########################################################################
+
+# Configure OpenVDB Library and ABI versions
+
+if(NOT OPENVDB_BUILD_CORE)
+  # Find VDB installation and determine lib/abi versions
+  find_package(OpenVDB REQUIRED)
+  # Check ABI version was found and explicitly error if attempting to build against
+  # an incompatible Houdini version
+  if(OpenVDB_ABI AND OPENVDB_HOUDINI_ABI)
+    if(NOT ${OpenVDB_ABI} EQUAL ${OPENVDB_HOUDINI_ABI})
+      message(FATAL_ERROR "Located OpenVDB installation is not ABI compatible with "
+        "Houdini Version ${Houdini_VERSION}. Requires ABI ${OPENVDB_HOUDINI_ABI}, found "
+        "ABI ${OpenVDB_ABI}.")
+    endif()
+  endif()
+else()
+  include("${CMAKE_SOURCE_DIR}/cmake/OpenVDBUtils.cmake")
+  OPENVDB_VERSION_FROM_HEADER("${CMAKE_CURRENT_SOURCE_DIR}/openvdb/version.h"
+    VERSION OpenVDB_VERSION
+    MAJOR   OpenVDB_MAJOR_VERSION
+    MINOR   OpenVDB_MINOR_VERSION
+    PATCH   OpenVDB_PATCH_VERSION
+  )
+  message(STATUS "Configuring for OpenVDB Version ${OpenVDB_VERSION}")
+endif()
+
+# Validate the OpenVDB ABI Version. If OpenVDB_ABI is not set, we're either building
+# the core library OR the ABI hasn't been deduced from a VDB installation. Use the
+# value from OPENVDB_ABI_VERSION_NUMBER, falling back to the lib major version number
+
+if(NOT OpenVDB_ABI)
+  if(OPENVDB_ABI_VERSION_NUMBER)
+    set(OpenVDB_ABI ${OPENVDB_ABI_VERSION_NUMBER})
+  else()
+    set(OpenVDB_ABI ${OpenVDB_MAJOR_VERSION})
+  endif()
+endif()
+
+# From the deduced ABI, check against the required ABI for Houdini (if set).
+# Forcefully set the ABI to the required value if necessary - do this after to
+# explicitly warn the user if their chosen value is different.
+
+if(OPENVDB_HOUDINI_ABI AND (NOT "${OpenVDB_ABI}" EQUAL "${OPENVDB_HOUDINI_ABI}"))
+  message(WARNING "CMake will explicitly set the value of OPENVDB_ABI_VERSION_NUMBER to "
+    "${OPENVDB_HOUDINI_ABI} to match the ABI of the target Houdini Version.")
+  set(OpenVDB_ABI ${OPENVDB_HOUDINI_ABI})
+endif()
+
+if(OpenVDB_ABI LESS MINIMUM_OPENVDB_ABI_VERSION)
+  message(WARNING "OpenVDB ABI versions earlier than ${MINIMUM_OPENVDB_ABI_VERSION} are "
+    "deprecated and will soon be removed.")
+endif()
+
+# The ABI is a global target definition, applicable to all components, so just add it
+# via ADD_DEFINITIONS
+
+if(OpenVDB_ABI EQUAL 3)
+  add_definitions(-DOPENVDB_3_ABI_COMPATIBLE)
+endif()
+
+add_definitions(-DOPENVDB_ABI_VERSION_NUMBER=${OpenVDB_ABI})
+message(STATUS "Configuring for OpenVDB ABI Version ${OpenVDB_ABI}")
+
+# Always force set as we may need to change it if it's incompatible with Houdini
+set(OPENVDB_ABI_VERSION_NUMBER ${OpenVDB_ABI} CACHE STRING [=[
+Build for compatibility with version N of the OpenVDB Grid ABI, where N is 3, 4, 5 etc. (some newer features
+will be disabled). If OPENVDB_BUILD_CORE is OFF, CMake attempts to query the installed vdb_print binary to
+determine the ABI number. You may set this to force a given ABI number.]=] FORCE)
+
+##########################################################################
+
+if(OPENVDB_BUILD_CORE)
+  add_subdirectory(openvdb)
+endif()
+
+if(OPENVDB_BUILD_PYTHON_MODULE)
+  add_subdirectory(openvdb/python)
+endif()
+
+if(OPENVDB_BUILD_BINARIES)
+  add_subdirectory(openvdb/cmd)
+endif()
+
+if(OPENVDB_BUILD_UNITTESTS)
+  add_subdirectory(openvdb/unittest)
+endif()
+
+if(OPENVDB_BUILD_HOUDINI_PLUGIN)
+  add_subdirectory(openvdb_houdini)
+endif()
+
+if(OPENVDB_BUILD_MAYA_PLUGIN)
+  add_subdirectory(openvdb_maya)
+endif()
+
+##########################################################################
+
+add_custom_target(uninstall
+  COMMAND ${CMAKE_COMMAND} -P ${PROJECT_SOURCE_DIR}/cmake/Uninstall.cmake
+)
diff -aur openvdb-6.0.0/CONTRIBUTING.md openvdb-6.1.0/CONTRIBUTING.md
--- openvdb-6.0.0/CONTRIBUTING.md	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/CONTRIBUTING.md	2019-05-07 22:58:35.000000000 +0200
@@ -32,7 +32,7 @@
 * Monitor Slack (delayed response is perfectly acceptable).
 * Triage GitHub issues and perform pull request reviews for other committers and the community.
 * Make sure that ongoing PRs are moving forward at the right pace or close them.
-* In general continue to be willing to spend at least 25% of one's time working on the project (~1.25 business days per week).
+* Remain an active contributor to the project in general and the code base in particular.
 
 ### When does a committer lose committer status?
 
diff -aur openvdb-6.0.0/openvdb/CHANGES openvdb-6.1.0/openvdb/CHANGES
--- openvdb-6.0.0/openvdb/CHANGES	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/CHANGES	2019-05-07 22:58:35.000000000 +0200
@@ -1,12 +1,102 @@
 OpenVDB Version History
 =======================
 
+Version 6.1.0 - May 8, 2019
+
+      As of this release, the oldest supported Houdini version is 16.5.
+
+    New features:
+    - Added new QuatTraits, MatTraits and ValueTraits type traits to complement
+      VecTraits and added an IsSpecializationOf helper metafunction.
+    - Added support for Vec4s, Vec4d and Vec4i metadata.
+    - Added a generic TypeList class.
+    - Added GridBase::apply(), which invokes a functor on a grid
+      if the resolved grid type is a member of a given type list.
+    - Added util::printTime(), which outputs nicely formatted time information.
+    - Added a std::hash<Coord> template specialization.
+    - Added CoordBBox::moveMin() and CoordBBox::moveMax() to move a CoordBBox.
+
+    Improvements:
+    - util::CpuTimer now makes use of util::printTime() for nicer output,
+      and its API has been improved.
+    - Significantly improved the performance of point data grid string
+      attribute generation.
+    - AttributeArray::copy() and the copy assignment operator for
+      AttributeArrays are now thread-safe.
+    - The command-line tools (vdb_print, etc.) now include the library
+      ABI version in their -version output.
+    - Further improved the responsiveness of the mesh to volume converter
+      to interrupt requests.
+    - The CMake build system has been significantly improved to support a
+      wider range of build options and use cases. This includes better
+      dependency handling and status reporting, find module installation for
+      external use, more robust handling of different platform configurations
+      and the introduction of dependency and build documentation.
+
+    Bug fixes:
+    - Fixed a bug in tools::clip() that caused some grid metadata
+      to be discarded.
+    - Added a check to points::setGroup to compare the maximum index of the
+      provided PointIndexTree to the size of the membership vector.
+    - Fixed a race condition introduced in ABI 6 when moving points
+      in point data grids, due to non-const access to an AttributArray
+      triggering a copy-on-write.
+    - Fixed a bug that caused the mesh to volume converter to consume
+      unlimited memory when it encountered NaNs in vertex positions.
+    - Fixed a rounding error bug in point conversion when using
+      single-precision floating-point.
+    - Addressed some type conversion issues and other issues reported by GCC 6.
+    - Fixed a crash in tools::extractActiveVoxelSegmentMasks() when the first
+      leaf node had no active voxels.
+      [Reported by Rick Hankins]
+    - Fixed a bug in tools::segmentActiveVoxels() and tools::segmentSDF() where
+      inactive leaf nodes were only pruned when there was more than one segment.
+    - Fixed a crash in point moving when using group filters.
+    - Fixed a bug where the stride of existing attributes was being ignored
+      during copy-construction of an AttributeSet.
+    - Fixed a bug that caused AttributeArray equality operators to fail for
+      attributes with non-constant strides.
+
+    API changes:
+    - Moved the CopyConstness metafunction from TreeIterator.h to Types.h.
+
+    Houdini:
+    - The Points Convert SOP now reports NaN Positions as warnings when
+      converting from Houdini Points to VDB Points.
+    - Fixed a bug where the Points Convert SOP was incorrectly ignoring
+      point attributes with the same name as an existing point group.
+    - The Transform SOP now supports frustum transforms by applying the
+      transformation to the internal affine map.
+    - Changed the labels (but not the opnames) of several SOPs to match
+      the corresponding native Houdini SOPs.  The new labels are
+      Morph SDF, Project Non-Divergent, Rebuild SDF, Renormalize SDF,
+      Reshape SDF, Segment by Connectivity, Smooth SDF, Topology to SDF,
+      and Visualize Tree.
+    - Added a houdini_utils::OpPolicy::getFirstName() method to allow
+      OpPolicy subclasses to provide their own first name scheme.
+    - Added a houdini_utils::OpPolicy::getLabelName() method to allow
+      OpPolicy subclasses to provide their own label naming scheme
+      for tab menus.
+    - Added type lists for sets of commonly used grid types, including
+      ScalarGridTypes, Vec3GridTypes, AllGridTypes, etc.
+    - The Vector Merge SOP now copies metadata from the representative
+      scalar grid.
+    - Deprecated SOP_NodeVDB::duplicateSourceStealable(),
+      houdini_utils::getNodeChain() and houdini_utils::OP_EvalScope.
+
+    Python:
+    - Added limited support for point data grids, comprising I/O and
+      metadata functionality for now.
+    - Added support for Mat4s and Mat4d metadata, in the form of nested
+      Python lists (e.g., [[1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,1]]).
+
+
 Version 6.0.0 - December 18, 2018
 
       Some changes in this release (see "ABI changes" below) alter
       the grid ABI so that it is incompatible with earlier versions
       of the OpenVDB library, such as the ones built into Houdini
-      up to and including Houdini 16.  To preserve ABI compatibility,
+      up to and including Houdini 17.  To preserve ABI compatibility,
       when compiling OpenVDB or any dependent code define the macro
       OPENVDB_ABI_VERSION_NUMBER=N, where, for example, N is 3 for
       Houdini 15, 15.5 and 16, 4 for Houdini 16.5 and 5 for Houdini 17.0
@@ -18,7 +108,7 @@
       particlesToMask() and particleTrailsToMask() for common particle
       rasterization use cases.
     - Added batch copying of AttributeArray values that significantly
-      out-performs the older method that relied on a virtual function.
+      outperforms the older method that relied on a virtual function.
 
     Improvements:
     - Improved the responsiveness of the mesh to volume converter to interrupt
@@ -26,31 +116,36 @@
     - Attempts to use a partially deserialized AttributeArray now errors.
     - Updated point deletion to use faster batch copying for ABI=6+.
     - Methods relating to in-memory Blosc compression for AttributeArrays now
-      do nothing and have been marked deprecated resulting in memory savings for
-      ABI=6+.
+      do nothing and have been marked deprecated resulting in memory savings
+      for ABI=6+.
 
     Bug fixes:
-    - Fixed various signed/unsigned casting issues when moving points in point
-      data grids to resolve compiler warnings.
+    - Fixed various signed/unsigned casting issues to resolve compiler warnings
+      when moving points in point data grids.
 
     ABI changes:
     - Added new virtual functions to AttributeArray.
     - Changed the order and size of member variables in AttributeArray
-      and TypedAttributeArray classes.
+      and TypedAttributeArray.
 
     API changes:
     - Removed a number of methods that were deprecated in version 5.0.0 or
       earlier.
     - Removed the experimental ValueAccessor::newSetValue method.
+    - Deprecated AttributeArray methods relating to in-memory
+      Blosc compression.
 
     Houdini:
+    - The Convert and To Polygons SOPs now correctly transfer vertex
+      attributes when the output is a polygon soup.
     - Added an option to the Visualize SOP to display leaf nodes as points.
     - Renamed the Visualize SOP's "leafmode", "internalmode", "tilemode"
       and "voxelmode" parameters to "leafstyle", "internalstyle", etc.
       and converted them from ordinal to string-valued.
     - Made various improvements to viewport rendering of point data grids.
-    - Updated ParmFactory to allow parameters to be marked as hidden, this is
-      useful for multi-parms where it is not possible to mark them as obsolete.
+    - Added a ParmFactory::setInvisible() method to allow parameters
+      to be marked as hidden.  This is useful for multi-parms,
+      whose child parameters cannot be made obsolete.
     - Removed the option to use in-memory Blosc compression from the Points
       Convert SOP as this feature has now been deprecated.
     - Made various small changes for Houdini 17 compatibility.
@@ -707,14 +802,14 @@
     - Fixed bugs in tree::NodeUnion that could cause crashes.
     - Fixed memory leak in
       tools::mesh_to_volume_internal::ExpandNarrowband
-      [Reported by Kvin Dietrich]
+      [Reported by Kvin Dietrich]
     - Fixed parameter type inconsistencies in math/Stencils.h and
       tools/RayIntersector.h.
-      [Contributed by Kvin Dietrich and Nick Avramoussis]
+      [Contributed by Kvin Dietrich and Nick Avramoussis]
     - Fixed a bug in the VolumeToMesh tool that produced artifacts for
       adaptive surface extraction on clipped level sets.
       [Reported by Jeff Lait]
-    - Corrected empty grid background value intools::meshToVolume().
+    - Corrected empty grid background value intools::meshToVolume().
       [Contributed by Jeff Lait]
     - Fixed a bug in tools::volumeToMesh that could produce NaNs.
       [Reported by Rick Hankins]
@@ -857,7 +952,7 @@
       rather than the square of the magnitude.
     - Fixed parameter type inconsistencies in math/Ray.h and
       tools/RayIntersector.h.
-      [Contributed by Kvin Dietrich]
+      [Contributed by Kvin Dietrich]
     - Fixed incorrect handling of signed values in tools::clip()
       (and the Clip SOP).
 
diff -aur openvdb-6.0.0/openvdb/CMakeLists.txt openvdb-6.1.0/openvdb/CMakeLists.txt
--- openvdb-6.0.0/openvdb/CMakeLists.txt	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/CMakeLists.txt	2019-05-07 22:58:35.000000000 +0200
@@ -1,4 +1,4 @@
-# Copyright (c) 2012-2016 DreamWorks Animation LLC
+# Copyright (c) 2012-2019 DreamWorks Animation LLC
 #
 # All rights reserved. This software is distributed under the
 # Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -24,128 +24,149 @@
 # IN NO EVENT SHALL THE COPYRIGHT HOLDERS' AND CONTRIBUTORS' AGGREGATE
 # LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
 #
-cmake_minimum_required(VERSION 3.1)
-PROJECT ( OpenVDBCore )
+#[=======================================================================[
 
-set(CMAKE_CXX_STANDARD 11)
+  CMake Configuration for OpenVDB Core
 
-IF ( USE_GLFW3 )
-  FIND_PACKAGE ( GLFW3 REQUIRED )
-  SET ( OPENVDB_USE_GLFW_FLAG "-DOPENVDB_USE_GLFW_3" )
-  IF ( UNIX AND NOT APPLE )
-    SET ( GLFW_DEPENDENT_LIBRARIES "X11;Xi;Xrandr;Xinerama;Xcursor;Xxf86vm" )
-  ENDIF ( UNIX AND NOT APPLE )
-  SET ( GLFW_LINK_LIBRARY ${GLFW3_glfw_LIBRARY} )
-  SET ( GLFW_INCLUDE_DIRECTORY  ${GLFW3_INCLUDE_DIR} CACHE STRING "GLFW3 include directory")
-ELSE ()
-  FIND_PACKAGE ( GLFW REQUIRED )
-  IF ( UNIX AND NOT APPLE )
-    SET ( GLFW_DEPENDENT_LIBRARIES "X11;Xi;Xrandr;Xinerama;Xcursor;Xxf86vm" )
-  ENDIF ()
-  SET ( GLFW_LINK_LIBRARY ${GLFW_glfw_LIBRARY} )
-  SET ( GLFW_INCLUDE_DIRECTORY  ${GLFW_INCLUDE_DIR} CACHE STRING "GLFW include directory")
-ENDIF ()
-
-IF (WIN32)
-  FIND_PACKAGE ( GLEW REQUIRED )
-ELSE ()
-  FIND_PACKAGE ( Threads REQUIRED )
-ENDIF()
-
-# Determine OpenVDB version
-#define OPENVDB_LIBRARY_MAJOR_VERSION_NUMBER 4
-#define OPENVDB_LIBRARY_MINOR_VERSION_NUMBER 0
-#define OPENVDB_LIBRARY_PATCH_VERSION_NUMBER 0
-SET ( OPENVDB_VERSION_FILE ${CMAKE_CURRENT_SOURCE_DIR}/version.h )
-
-FILE ( STRINGS "${OPENVDB_VERSION_FILE}" openvdb_major_version_str REGEX "^#define[\t ]+OPENVDB_LIBRARY_MAJOR_VERSION_NUMBER[\t ]+.*")
-FILE ( STRINGS "${OPENVDB_VERSION_FILE}" openvdb_minor_version_str REGEX "^#define[\t ]+OPENVDB_LIBRARY_MINOR_VERSION_NUMBER[\t ]+.*")
-FILE ( STRINGS "${OPENVDB_VERSION_FILE}" openvdb_patch_version_str REGEX "^#define[\t ]+OPENVDB_LIBRARY_PATCH_VERSION_NUMBER[\t ]+.*")
-
-STRING (REGEX REPLACE "^.*OPENVDB_LIBRARY_MAJOR_VERSION_NUMBER[\t ]+([0-9]*).*$" "\\1"
-  _openvdb_major_version_number "${openvdb_major_version_str}")
-STRING (REGEX REPLACE "^.*OPENVDB_LIBRARY_MINOR_VERSION_NUMBER[\t ]+([0-9]*).*$" "\\1"
-  _openvdb_minor_version_number "${openvdb_minor_version_str}")
-STRING (REGEX REPLACE "^.*OPENVDB_LIBRARY_PATCH_VERSION_NUMBER[\t ]+([0-9]*).*$" "\\1"
-  _openvdb_patch_version_number "${openvdb_patch_version_str}")
-
-SET ( OPENVDB_MAJOR_VERSION_NUMBER ${_openvdb_major_version_number} CACHE STRING "OpenVDB major version number" )
-SET ( OPENVDB_MINOR_VERSION_NUMBER ${_openvdb_minor_version_number} CACHE STRING "OpenVDB minor version number" )
-SET ( OPENVDB_PATCH_VERSION_NUMBER ${_openvdb_patch_version_number} CACHE STRING "OpenVDB build version number" )
-
-# MESSAGE ( "OPENVDB_VERSION_FILE = ${OPENVDB_VERSION_FILE}")
-# MESSAGE ( "OPENVDB_MAJOR_VERSION_NUMBER = ${OPENVDB_MAJOR_VERSION_NUMBER}" )
-# MESSAGE ( "OPENVDB_MINOR_VERSION_NUMBER = ${OPENVDB_MINOR_VERSION_NUMBER}" )
-# MESSAGE ( "OPENVDB_PATCH_VERSION_NUMBER = ${OPENVDB_PATCH_VERSION_NUMBER}" )
-
-FIND_PACKAGE ( Boost ${MINIMUM_BOOST_VERSION} REQUIRED COMPONENTS iostreams system thread ${OPENVDB_BOOST_PYTHON_LIBRARY_COMPONENT_NAME} )
-IF (WIN32 AND OPENVDB_DISABLE_BOOST_IMPLICIT_LINKING)
-  ADD_DEFINITIONS ( -DBOOST_ALL_NO_LIB )
-ENDIF ()
-
-FIND_PACKAGE ( Blosc REQUIRED )
-FIND_PACKAGE ( TBB REQUIRED )
-FIND_PACKAGE ( ZLIB REQUIRED )
-FIND_PACKAGE ( ILMBase REQUIRED )
-FIND_PACKAGE ( OpenEXR REQUIRED )
-FIND_PACKAGE ( OpenGL REQUIRED )
-IF (OPENVDB_BUILD_DOCS)
-  FIND_PACKAGE ( Doxygen REQUIRED )
-ENDIF ()
-IF (OPENVDB_BUILD_UNITTESTS)
-  FIND_PACKAGE ( CPPUnit REQUIRED )
-ENDIF ()
-
-IF (APPLE)
-  FIND_LIBRARY ( COCOA_LIBRARY Cocoa )
-  FIND_LIBRARY ( IOKIT_LIBRARY IOKit )
-  FIND_LIBRARY ( COREVIDEO_LIBRARY CoreVideo )
-ENDIF ()
-
-IF ( NOT OPENVDB_BUILD_HOUDINI_SOPS )
-  # If we are building OpenVDB Houdini SOP, we need to use the headers
-  # shipped with Houdini to ensure version compatibility
-  INCLUDE_DIRECTORIES ( SYSTEM ${Boost_INCLUDE_DIR} )
-  INCLUDE_DIRECTORIES ( SYSTEM ${TBB_INCLUDE_DIR} )
-  # INCLUDE_DIRECTORIES ( ${OPENGL_INCLUDE_DIR} )
-  INCLUDE_DIRECTORIES ( SYSTEM ${ZLIB_INCLUDE_DIR} )
-ENDIF ()
-
-INCLUDE_DIRECTORIES ( SYSTEM ${ILMBASE_INCLUDE_DIRS} )
-INCLUDE_DIRECTORIES ( SYSTEM ${OPENEXR_INCLUDE_DIRS} )
-INCLUDE_DIRECTORIES ( SYSTEM ${GLFW_INCLUDE_DIRECTORY} )
-
-IF (WIN32)
-  INCLUDE_DIRECTORIES ( SYSTEM ${GLEW_INCLUDE_DIR} )
-ENDIF ()
+#]=======================================================================]
 
-INCLUDE_DIRECTORIES ( . ) # So they can simulate referencing installed headers
+project(OpenVDBCore)
+cmake_minimum_required(VERSION 3.3)
+# Monitoring <PackageName>_ROOT variables
+if(POLICY CMP0074)
+  cmake_policy(SET CMP0074 NEW)
+endif()
 
-IF (WIN32)
-  # Because of implicit linking!
-  LINK_DIRECTORIES ( ${Boost_LIBRARY_DIR} )
-ENDIF ()
+###### OpenVDB Core Options
+
+option(OPENVDB_CORE_SHARED "Build dynamically linked version of the core library." ON)
+option(OPENVDB_CORE_STATIC "Build statically linked version of the core library." ON)
+
+set(OPENVDB_SHARED_LIBRARY_NAME "openvdb" CACHE STRING
+  "The base name of the built shared openvdb library. Prefixed by \"lib\" on UNIX platforms."
+)
+set(OPENVDB_STATIC_LIBRARY_NAME "openvdb" CACHE STRING
+  "The base name of the built static openvdb library. Prefixed by \"lib\"."
+)
+
+mark_as_advanced(
+  OPENVDB_STATIC_LIBRARY_NAME
+  OPENVDB_SHARED_LIBRARY_NAME
+)
+
+if(NOT OPENVDB_CORE_SHARED AND NOT OPENVDB_CORE_STATIC)
+  message(FATAL_ERROR "Both static and shared core OpenVDB libraries have been disabled. "
+    "At least one must be enabled when building the core library."
+  )
+endif()
+
+#########################################################################
+
+message(STATUS "----------------------------------------------------")
+message(STATUS "------------- Configuring OpenVDBCore --------------")
+message(STATUS "----------------------------------------------------")
+
+##########################################################################
+
+# Collect and configure lib dependencies
+
+if(USE_EXR)
+  find_package(IlmBase ${MINIMUM_ILMBASE_VERSION} REQUIRED)
+  find_package(OpenEXR ${MINIMUM_OPENEXR_VERSION} REQUIRED)
+else()
+  find_package(IlmBase ${MINIMUM_ILMBASE_VERSION} REQUIRED COMPONENTS Half)
+endif()
 
-INCLUDE_DIRECTORIES ( SYSTEM ${BLOSC_INCLUDE_DIR} )
-INCLUDE_DIRECTORIES ( SYSTEM ${CPPUNIT_INCLUDE_DIR} )
+find_package(TBB ${MINIMUM_TBB_VERSION} REQUIRED COMPONENTS tbb)
+find_package(ZLIB ${MINIMUM_ZLIB_VERSION} REQUIRED)
 
-IF (WIN32)
-  ADD_DEFINITIONS ( -D_WIN32 -DNOMINMAX -DHALF_EXPORTS -DOPENVDB_DLL )
-ELSE ()
-  ADD_DEFINITIONS ( -pthread -fPIC )
-ENDIF ()
-
-# Working around hardcoding of path at DWA
-FILE ( GLOB VIEWER_SOURCE_FILES RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} viewer/* )
-FILE ( MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/dwa/openvdb_viewer )
-FILE ( COPY ${VIEWER_SOURCE_FILES} DESTINATION ${CMAKE_BINARY_DIR}/dwa/openvdb_viewer )
-INCLUDE_DIRECTORIES ( ${CMAKE_BINARY_DIR}/dwa )
+if(USE_LOG4CPLUS)
+  find_package(Log4cplus ${MINIMUM_LOG4CPLUS_VERSION} REQUIRED)
+endif()
 
-SET ( OPENVDB_LIBRARY_SOURCE_FILES
+if(USE_BLOSC)
+  find_package(Blosc ${MINIMUM_BLOSC_VERSION} REQUIRED)
+  if(Blosc_FOUND AND Blosc_VERSION VERSION_GREATER MINIMUM_BLOSC_VERSION)
+    message(WARNING "The version of Blosc located is greater than ${MINIMUM_BLOSC_VERSION}. "
+      "There have been reported issues with using later versions of Blosc with OpenVDB. "
+      "OpenVDB has been tested fully against Blosc ${MINIMUM_BLOSC_VERSION}, it is "
+      "recommended that you use this version where possible."
+    )
+  endif()
+else()
+  message(WARNING "Blosc support is disabled. It is strongly recommended to "
+    "enable blosc for optimal builds of OpenVDB and to support compatible "
+    "serialization of other OpenVDB installations."
+  )
+endif()
+
+find_package(Boost ${MINIMUM_BOOST_VERSION} REQUIRED COMPONENTS iostreams system)
+
+if(UNIX)
+  find_package(Threads REQUIRED)
+endif()
+
+# Set deps. Note that the order here is important. If we're building against
+# Houdini 17.5 we must include OpenEXR and IlmBase deps first to ensure the
+# users chosen namespaced headers are correctly prioritized. Otherwise other
+# include paths from shared installs (including houdini) may pull in the wrong
+# headers
+
+set(OPENVDB_CORE_DEPENDENT_LIBS
+  Boost::iostreams
+  Boost::system
+  IlmBase::Half
+)
+
+if(USE_EXR)
+  list(APPEND OPENVDB_CORE_DEPENDENT_LIBS
+    IlmBase::IlmThread
+    IlmBase::Iex
+    IlmBase::Imath
+    OpenEXR::IlmImf
+  )
+endif()
+
+if(USE_LOG4CPLUS)
+  list(APPEND OPENVDB_CORE_DEPENDENT_LIBS Log4cplus::log4cplus)
+endif()
+
+# @todo blosc and zlib should be hidden (privately linked in):
+# See FindOpenVDB.cmake
+
+if(USE_BLOSC)
+  list(APPEND OPENVDB_CORE_DEPENDENT_LIBS Blosc::blosc)
+endif()
+
+list(APPEND OPENVDB_CORE_DEPENDENT_LIBS
+  TBB::tbb
+  ZLIB::ZLIB
+)
+if(UNIX)
+  list(APPEND OPENVDB_CORE_DEPENDENT_LIBS
+    Threads::Threads
+  )
+endif()
+
+##########################################################################
+
+if(WIN32)
+  # Because of implicit linking!
+  link_directories(${Boost_LIBRARY_DIR})
+  if(OPENVDB_DISABLE_BOOST_IMPLICIT_LINKING)
+    add_definitions(-DBOOST_ALL_NO_LIB)
+  endif()
+endif()
+
+# @todo Should be target definitions
+if(WIN32)
+  add_definitions(-D_WIN32 -DNOMINMAX -DOPENVDB_DLL)
+endif()
+
+##### Core library configuration
+
+set(OPENVDB_LIBRARY_SOURCE_FILES
   Grid.cc
-  MetaMap.cc
-  Metadata.cc
-  Platform.cc
   io/Archive.cc
   io/Compression.cc
   io/File.cc
@@ -157,305 +178,314 @@
   math/Proximity.cc
   math/QuantizedUnitVec.cc
   math/Transform.cc
+  Metadata.cc
+  MetaMap.cc
+  openvdb.cc
+  Platform.cc
   points/AttributeArray.cc
   points/AttributeArrayString.cc
   points/AttributeGroup.cc
   points/AttributeSet.cc
   points/StreamCompression.cc
   points/points.cc
-  openvdb.cc
   util/Formats.cc
   util/Util.cc
-  )
+)
 
-SET_SOURCE_FILES_PROPERTIES ( ${OPENVDB_LIBRARY_SOURCE_FILES}
-  PROPERTIES
-  COMPILE_FLAGS "-DOPENVDB_PRIVATE -DOPENVDB_USE_BLOSC ${OPENVDB_USE_GLFW_FLAG}"
-  )
-
-ADD_LIBRARY ( openvdb_static STATIC
-  ${OPENVDB_LIBRARY_SOURCE_FILES}
-  )
-ADD_LIBRARY ( openvdb_shared SHARED
-  ${OPENVDB_LIBRARY_SOURCE_FILES}
-  )
-
-TARGET_LINK_LIBRARIES ( openvdb_static
-  ${Boost_IOSTREAMS_LIBRARY}
-  ${Boost_SYSTEM_LIBRARY}
-  ${Tbb_TBB_LIBRARY}
-  ${Ilmbase_HALF_LIBRARY}
-  ${ZLIB_LIBRARY}
-  ${BLOSC_blosc_LIBRARY}
-  )
-TARGET_LINK_LIBRARIES ( openvdb_shared
-  ${Boost_IOSTREAMS_LIBRARY}
-  ${Boost_SYSTEM_LIBRARY}
-  ${Tbb_TBB_LIBRARY}
-  ${Ilmbase_HALF_LIBRARY}
-  ${ZLIB_LIBRARY}
-  ${BLOSC_blosc_LIBRARY}
-  )
-
-IF (WIN32)
-  SET_TARGET_PROPERTIES ( openvdb_static
-	PROPERTIES OUTPUT_NAME libopenvdb
-	)
-ELSE()
-  SET_TARGET_PROPERTIES ( openvdb_static
-	PROPERTIES OUTPUT_NAME openvdb
-	)
-ENDIF()
-
-SET_TARGET_PROPERTIES(
-  openvdb_shared
-  PROPERTIES
-  OUTPUT_NAME openvdb
-  SOVERSION ${OPENVDB_MAJOR_VERSION_NUMBER}.${OPENVDB_MINOR_VERSION_NUMBER}
-  VERSION ${OPENVDB_MAJOR_VERSION_NUMBER}.${OPENVDB_MINOR_VERSION_NUMBER}.${OPENVDB_PATCH_VERSION_NUMBER}
-  )
-
-SET ( VDB_PRINT_SOURCE_FILES  cmd/openvdb_print/main.cc )
-SET_SOURCE_FILES_PROPERTIES ( ${VDB_PRINT_SOURCE_FILES}
-  PROPERTIES
-  COMPILE_FLAGS "-DOPENVDB_USE_BLOSC ${OPENVDB_USE_GLFW_FLAG}"
-  )
-
-ADD_EXECUTABLE ( vdb_print
-  ${VDB_PRINT_SOURCE_FILES}
-  )
-
-TARGET_LINK_LIBRARIES ( vdb_print
-  openvdb_shared
-  ${CMAKE_THREAD_LIBS_INIT}
-  ${BLOSC_blosc_LIBRARY}
-  m
-  stdc++
-  )
-
-SET ( VDB_RENDER_SOURCE_FILES cmd/openvdb_render/main.cc )
-SET_SOURCE_FILES_PROPERTIES ( ${VDB_RENDER_SOURCE_FILES}
-  PROPERTIES
-  COMPILE_FLAGS "-DOPENVDB_USE_BLOSC ${OPENVDB_USE_GLFW_FLAG}"
-  )
-ADD_EXECUTABLE ( vdb_render
-  ${VDB_RENDER_SOURCE_FILES}
-  )
-
-TARGET_LINK_LIBRARIES ( vdb_render
-  openvdb_shared
-  ${CMAKE_THREAD_LIBS_INIT}
-  ${BLOSC_blosc_LIBRARY}
-  ${Openexr_ILMIMF_LIBRARY}
-  ${Ilmbase_ILMTHREAD_LIBRARY}
-  ${Ilmbase_IEX_LIBRARY}
-  m
-  stdc++
-  )
-
-SET ( VDB_VIEW_SOURCE_FILES
-  cmd/openvdb_view/main.cc
-  viewer/Camera.cc
-  viewer/ClipBox.cc
-  viewer/Font.cc
-  viewer/RenderModules.cc
-  viewer/Viewer.cc
-  )
-SET_SOURCE_FILES_PROPERTIES ( ${VDB_VIEW_SOURCE_FILES}
-  PROPERTIES
-  COMPILE_FLAGS "-DOPENVDB_USE_BLOSC ${OPENVDB_USE_GLFW_FLAG} -DGL_GLEXT_PROTOTYPES=1"
-  )
-IF (NOT WIN32)
-  ADD_EXECUTABLE ( vdb_view
-    ${VDB_VIEW_SOURCE_FILES}
+set(OPENVDB_LIBRARY_INCLUDE_FILES
+  Exceptions.h
+  Grid.h
+  Metadata.h
+  MetaMap.h
+  openvdb.h
+  Platform.h
+  PlatformConfig.h
+  Types.h
+  version.h
+)
+
+set(OPENVDB_LIBRARY_IO_INCLUDE_FILES
+  io/Archive.h
+  io/Compression.h
+  io/File.h
+  io/GridDescriptor.h
+  io/io.h
+  io/Queue.h
+  io/Stream.h
+  io/TempFile.h
+)
+
+set(OPENVDB_LIBRARY_MATH_INCLUDE_FILES
+  math/BBox.h
+  math/ConjGradient.h
+  math/Coord.h
+  math/DDA.h
+  math/FiniteDifference.h
+  math/LegacyFrustum.h
+  math/Maps.h
+  math/Mat.h
+  math/Mat3.h
+  math/Mat4.h
+  math/Math.h
+  math/Operators.h
+  math/Proximity.h
+  math/QuantizedUnitVec.h
+  math/Quat.h
+  math/Ray.h
+  math/Stats.h
+  math/Stencils.h
+  math/Transform.h
+  math/Tuple.h
+  math/Vec2.h
+  math/Vec3.h
+  math/Vec4.h
+)
+
+set(OPENVDB_LIBRARY_POINTS_INCLUDE_FILES
+  points/AttributeArray.h
+  points/AttributeArrayString.h
+  points/AttributeGroup.h
+  points/AttributeSet.h
+  points/IndexFilter.h
+  points/IndexIterator.h
+  points/PointAdvect.h
+  points/PointAttribute.h
+  points/PointConversion.h
+  points/PointCount.h
+  points/PointDataGrid.h
+  points/PointDelete.h
+  points/PointGroup.h
+  points/PointMask.h
+  points/PointMove.h
+  points/PointSample.h
+  points/PointScatter.h
+  points/StreamCompression.h
+)
+
+set(OPENVDB_LIBRARY_TOOLS_INCLUDE_FILES
+  tools/ChangeBackground.h
+  tools/Clip.h
+  tools/Composite.h
+  tools/Dense.h
+  tools/DenseSparseTools.h
+  tools/Diagnostics.h
+  tools/Filter.h
+  tools/GridOperators.h
+  tools/GridTransformer.h
+  tools/Interpolation.h
+  tools/LevelSetAdvect.h
+  tools/LevelSetFilter.h
+  tools/LevelSetFracture.h
+  tools/LevelSetMeasure.h
+  tools/LevelSetMorph.h
+  tools/LevelSetPlatonic.h
+  tools/LevelSetRebuild.h
+  tools/LevelSetSphere.h
+  tools/LevelSetTracker.h
+  tools/LevelSetUtil.h
+  tools/Mask.h
+  tools/MeshToVolume.h
+  tools/Morphology.h
+  tools/MultiResGrid.h
+  tools/ParticleAtlas.h
+  tools/ParticlesToLevelSet.h
+  tools/PointAdvect.h
+  tools/PointIndexGrid.h
+  tools/PointPartitioner.h
+  tools/PointScatter.h
+  tools/PointsToMask.h
+  tools/PoissonSolver.h
+  tools/PotentialFlow.h
+  tools/Prune.h
+  tools/RayIntersector.h
+  tools/RayTracer.h
+  tools/SignedFloodFill.h
+  tools/Statistics.h
+  tools/TopologyToLevelSet.h
+  tools/ValueTransformer.h
+  tools/VectorTransformer.h
+  tools/VelocityFields.h
+  tools/VolumeAdvect.h
+  tools/VolumeToMesh.h
+  tools/VolumeToSpheres.h
+)
+
+set(OPENVDB_LIBRARY_TREE_INCLUDE_FILES
+  tree/InternalNode.h
+  tree/Iterator.h
+  tree/LeafBuffer.h
+  tree/LeafManager.h
+  tree/LeafNode.h
+  tree/LeafNodeBool.h
+  tree/LeafNodeMask.h
+  tree/NodeManager.h
+  tree/NodeUnion.h
+  tree/RootNode.h
+  tree/Tree.h
+  tree/TreeIterator.h
+  tree/ValueAccessor.h
+)
+
+set(OPENVDB_LIBRARY_UTIL_INCLUDE_FILES
+  util/CpuTimer.h
+  util/Formats.h
+  util/logging.h
+  util/MapsUtil.h
+  util/Name.h
+  util/NodeMasks.h
+  util/NullInterrupter.h
+  util/PagedArray.h
+  util/Util.h
+)
+
+# @todo CMake >= 3.12, use an object library to consolidate shared/static
+# builds. There are limitations with earlier versions of CMake when used with
+# imported targets.
+
+if(OPENVDB_CORE_SHARED)
+  add_library(openvdb_shared SHARED ${OPENVDB_LIBRARY_SOURCE_FILES})
+endif()
+
+if(OPENVDB_CORE_STATIC)
+  add_library(openvdb_static STATIC ${OPENVDB_LIBRARY_SOURCE_FILES})
+endif()
+
+# Alias either the shared or static library to the generic OpenVDB
+# target. Dependent components should use this target to build against
+# such that they are always able to find a valid build of OpenVDB
+
+if(OPENVDB_CORE_SHARED)
+  add_library(openvdb ALIAS openvdb_shared)
+else()
+  add_library(openvdb ALIAS openvdb_static)
+endif()
+
+
+##########################################################################
+
+# Configure c flags
+
+set(OPENVDB_CORE_PRIVATE_DEFINES)
+set(OPENVDB_CORE_PUBLIC_DEFINES)
+
+# Private defines (not inherited by dependent projects)
+
+list(APPEND OPENVDB_CORE_PRIVATE_DEFINES "-DOPENVDB_PRIVATE")
+if(USE_BLOSC)
+  list(APPEND OPENVDB_CORE_PRIVATE_DEFINES "-DOPENVDB_USE_BLOSC")
+endif()
+
+# Public defines
+
+if(USE_EXR)
+  list(APPEND OPENVDB_CORE_PUBLIC_DEFINES "-DOPENVDB_TOOLS_RAYTRACER_USE_EXR")
+endif()
+if(USE_LOG4CPLUS)
+  list(APPEND OPENVDB_CORE_PUBLIC_DEFINES "-DOPENVDB_USE_LOG4CPLUS")
+endif()
+
+##########################################################################
+
+# Configure static build
+
+if(OPENVDB_CORE_STATIC)
+  target_include_directories(openvdb_static
+    PUBLIC ../
+    PRIVATE .
+  )
+
+  target_compile_definitions(openvdb_static PRIVATE ${OPENVDB_CORE_PRIVATE_DEFINES})
+  target_compile_definitions(openvdb_static PUBLIC ${OPENVDB_CORE_PUBLIC_DEFINES})
+
+  set_target_properties(openvdb_static
+    PROPERTIES OUTPUT_NAME ${OPENVDB_STATIC_LIBRARY_NAME}
+  )
+
+  if(WIN32)
+    set_target_properties(openvdb_static
+      PROPERTIES PREFIX "lib"
     )
-  
-  target_include_directories ( vdb_view SYSTEM PRIVATE ${Boost_INCLUDE_DIR} )
+  endif()
 
-  TARGET_LINK_LIBRARIES ( vdb_view
-    openvdb_shared
-    ${Boost_THREAD_LIBRARY}
-    ${OPENGL_gl_LIBRARY}
-    ${OPENGL_glu_LIBRARY}
-    ${COCOA_LIBRARY}
-    ${IOKIT_LIBRARY}
-    ${COREVIDEO_LIBRARY}
-    ${GLFW_LINK_LIBRARY}
-    ${GLFW_DEPENDENT_LIBRARIES}
-    ${GLEW_GLEW_LIBRARY}
-    m
-    stdc++
-    )
-ENDIF ()
-
-SET ( UNITTEST_SOURCE_FILES
-  unittest/main.cc
-  unittest/TestAttributeArray.cc
-  unittest/TestAttributeArrayString.cc
-  unittest/TestAttributeGroup.cc
-  unittest/TestAttributeSet.cc
-  unittest/TestBBox.cc
-  unittest/TestConjGradient.cc
-  unittest/TestCoord.cc
-  unittest/TestCpt.cc
-  unittest/TestCurl.cc
-  unittest/TestDense.cc
-  unittest/TestDenseSparseTools.cc
-  unittest/TestDiagnostics.cc
-  unittest/TestDivergence.cc
-  unittest/TestDoubleMetadata.cc
-  unittest/TestExceptions.cc
-  unittest/TestFile.cc
-  unittest/TestFloatMetadata.cc
-  unittest/TestGradient.cc
-  unittest/TestGrid.cc
-  unittest/TestGridBbox.cc
-  unittest/TestGridDescriptor.cc
-  unittest/TestGridIO.cc
-  unittest/TestGridTransformer.cc
-  unittest/TestIndexFilter.cc
-  unittest/TestIndexIterator.cc
-  unittest/TestInit.cc
-  unittest/TestInt32Metadata.cc
-  unittest/TestInt64Metadata.cc
-  unittest/TestInternalOrigin.cc
-  unittest/TestLaplacian.cc
-  unittest/TestLeaf.cc
-  unittest/TestLeafBool.cc
-  unittest/TestLeafManager.cc
-  unittest/TestLeafMask.cc
-  unittest/TestLeafIO.cc
-  unittest/TestLeafOrigin.cc
-  unittest/TestLevelSetRayIntersector.cc
-  unittest/TestLevelSetUtil.cc
-  unittest/TestLinearInterp.cc
-  unittest/TestMaps.cc
-  unittest/TestMat4Metadata.cc
-  unittest/TestMath.cc
-  unittest/TestMeanCurvature.cc
-  unittest/TestMeshToVolume.cc
-  unittest/TestMetadata.cc
-  unittest/TestMetadataIO.cc
-  unittest/TestMetaMap.cc
-  unittest/TestMultiResGrid.cc
-  unittest/TestName.cc
-  unittest/TestNodeIterator.cc
-  unittest/TestNodeManager.cc
-  unittest/TestNodeMask.cc
-  unittest/TestParticleAtlas.cc
-  unittest/TestParticlesToLevelSet.cc
-  unittest/TestPointAttribute.cc
-  unittest/TestPointConversion.cc
-  unittest/TestPointCount.cc
-  unittest/TestPointDataLeaf.cc
-  unittest/TestPointGroup.cc
-  unittest/TestPointIndexGrid.cc
-  unittest/TestPointPartitioner.cc
-  unittest/TestPointsToMask.cc
-  unittest/TestPoissonSolver.cc
-  unittest/TestPrePostAPI.cc
-  unittest/TestQuadraticInterp.cc
-  unittest/TestQuantizedUnitVec.cc
-  unittest/TestQuat.cc
-  unittest/TestRay.cc
-  unittest/TestStats.cc
-  unittest/TestStream.cc
-  unittest/TestStreamCompression.cc
-  unittest/TestStringMetadata.cc
-  unittest/TestTools.cc
-  unittest/TestTopologyToLevelSet.cc
-  unittest/TestTransform.cc
-  unittest/TestTree.cc
-  unittest/TestTreeCombine.cc
-  unittest/TestTreeGetSetValues.cc
-  unittest/TestTreeIterators.cc
-  unittest/TestTreeVisitor.cc
-  unittest/TestUtil.cc
-  unittest/TestValueAccessor.cc
-  unittest/TestVec2Metadata.cc
-  unittest/TestVec3Metadata.cc
-  unittest/TestVolumeRayIntersector.cc
-  unittest/TestVolumeToMesh.cc
-  )
-
-SET_SOURCE_FILES_PROPERTIES ( ${UNITTEST_SOURCE_FILES}
-  PROPERTIES
-  COMPILE_FLAGS "-DOPENVDB_USE_BLOSC"
+  target_link_libraries(openvdb_static
+    ${OPENVDB_CORE_DEPENDENT_LIBS}
   )
+endif()
 
-IF ( OPENVDB_BUILD_UNITTESTS )
-
-  ADD_EXECUTABLE ( vdb_test
-    ${UNITTEST_SOURCE_FILES}
-    )
-
-  TARGET_LINK_LIBRARIES ( vdb_test
-    ${CPPUnit_cppunit_LIBRARY}
-    openvdb_shared
-    m
-    stdc++
-    )
+# Configure shared build
 
-  ADD_TEST ( vdb_unit_test vdb_test )
+if(OPENVDB_CORE_SHARED)
+  target_include_directories(openvdb_shared
+    PUBLIC ../
+    PRIVATE .
+  )
 
-ENDIF (OPENVDB_BUILD_UNITTESTS)
+  target_compile_definitions(openvdb_shared PRIVATE ${OPENVDB_CORE_PRIVATE_DEFINES})
+  target_compile_definitions(openvdb_shared PUBLIC ${OPENVDB_CORE_PUBLIC_DEFINES})
 
-# Doxygen docmentation
-IF (OPENVDB_BUILD_DOCS)
+  set_target_properties(openvdb_shared
+    PROPERTIES
+      OUTPUT_NAME ${OPENVDB_SHARED_LIBRARY_NAME}
+      SOVERSION ${OpenVDB_MAJOR_VERSION}.${OpenVDB_MINOR_VERSION}
+      VERSION ${OpenVDB_MAJOR_VERSION}.${OpenVDB_MINOR_VERSION}.${OpenVDB_PATCH_VERSION}
+  )
 
-  FILE ( READ ${CMAKE_CURRENT_SOURCE_DIR}/doxygen-config DOXYGEN_CONFIG_CONTENT )
-  FILE ( WRITE ${CMAKE_CURRENT_BINARY_DIR}/cmake-doxygen-config ${DOXYGEN_CONFIG_CONTENT} )
-  FILE ( APPEND ${CMAKE_CURRENT_BINARY_DIR}/cmake-doxygen-config "OUTPUT_DIRECTORY=${CMAKE_CURRENT_BINARY_DIR}/doc\n" )
+  target_link_libraries(openvdb_shared
+    ${OPENVDB_CORE_DEPENDENT_LIBS}
+  )
 
-  ADD_CUSTOM_TARGET ( doc
-    ${DOXYGEN_EXECUTABLE} ${CMAKE_CURRENT_BINARY_DIR}/cmake-doxygen-config
-    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
-    COMMENT "Generating API documentation with Doxygen" VERBATIM
+  if(OPENVDB_ENABLE_RPATH)
+    # @todo There is probably a better way to do this for imported targets
+    list(APPEND RPATHS
+      ${Boost_LIBRARY_DIRS}
+      ${IlmBase_LIBRARY_DIRS}
+      ${OpenEXR_LIBRARY_DIRS}
+      ${Log4cplus_LIBRARY_DIRS}
+      ${Blosc_LIBRARY_DIRS}
+      ${Tbb_LIBRARY_DIRS}
     )
+    list(REMOVE_DUPLICATES RPATHS)
+    set_target_properties(openvdb_shared
+      PROPERTIES INSTALL_RPATH "${RPATHS}"
+    )
+  endif()
+endif()
 
-  INSTALL ( CODE "EXECUTE_PROCESS(COMMAND \"${CMAKE_COMMAND}\" --build  \"${PROJECT_BINARY_DIR}\" --target doc)")
-  INSTALL ( DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/doc/html DESTINATION docs)
+unset(OPENVDB_CORE_PRIVATE_DEFINES)
+unset(OPENVDB_CORE_PUBLIC_DEFINES)
 
-ENDIF ()
+##########################################################################
 
 # Installation
-IF ( NOT WIN32 )
-  INSTALL ( TARGETS
-    vdb_view
+
+if(OPENVDB_CORE_STATIC)
+  install(TARGETS
+    openvdb_static
     DESTINATION
-    bin
-    )
-ENDIF ()
-INSTALL ( TARGETS
-  vdb_print
-  vdb_render
-  DESTINATION
-  bin
-  )
-
-INSTALL ( TARGETS
-  openvdb_static
-  DESTINATION
-  lib
-  )
-
-IF (WIN32)
-  INSTALL ( TARGETS
-	openvdb_shared
-	RUNTIME DESTINATION bin COMPONENT Runtime
-	ARCHIVE DESTINATION lib COMPONENT Runtime
-	)
-ELSE()
-  INSTALL ( TARGETS
-	openvdb_shared
-	DESTINATION
-	lib
-	)
-ENDIF ()
-
-INSTALL ( DIRECTORY ${PROJECT_SOURCE_DIR} DESTINATION include
-  FILES_MATCHING PATTERN "*.h"
-  PATTERN "python" EXCLUDE
-  PATTERN "cmd" EXCLUDE
-  PATTERN "doc" EXCLUDE
+    lib
   )
+endif()
+
+if(OPENVDB_CORE_SHARED)
+  if(WIN32)
+    install(TARGETS
+      openvdb_shared
+      RUNTIME DESTINATION bin COMPONENT Runtime
+      ARCHIVE DESTINATION lib COMPONENT Runtime
+    )
+  else()
+    install(TARGETS
+      openvdb_shared
+      DESTINATION
+      lib
+    )
+  endif()
+endif()
+
+install(FILES ${OPENVDB_LIBRARY_INCLUDE_FILES} DESTINATION include/openvdb)
+install(FILES ${OPENVDB_LIBRARY_IO_INCLUDE_FILES} DESTINATION include/openvdb/io)
+install(FILES ${OPENVDB_LIBRARY_MATH_INCLUDE_FILES} DESTINATION include/openvdb/math)
+install(FILES ${OPENVDB_LIBRARY_POINTS_INCLUDE_FILES} DESTINATION include/openvdb/points)
+install(FILES ${OPENVDB_LIBRARY_TOOLS_INCLUDE_FILES} DESTINATION include/openvdb/tools)
+install(FILES ${OPENVDB_LIBRARY_TREE_INCLUDE_FILES} DESTINATION include/openvdb/tree)
+install(FILES ${OPENVDB_LIBRARY_UTIL_INCLUDE_FILES} DESTINATION include/openvdb/util)
Seulement dans openvdb-6.1.0/openvdb/cmd: CMakeLists.txt
Seulement dans openvdb-6.0.0/openvdb/cmd: openvdb_lod
Seulement dans openvdb-6.1.0/openvdb/cmd: openvdb_lod.cc
Seulement dans openvdb-6.0.0/openvdb/cmd: openvdb_print
Seulement dans openvdb-6.1.0/openvdb/cmd: openvdb_print.cc
Seulement dans openvdb-6.0.0/openvdb/cmd: openvdb_render
Seulement dans openvdb-6.1.0/openvdb/cmd: openvdb_render.cc
Seulement dans openvdb-6.0.0/openvdb/cmd: openvdb_view
Seulement dans openvdb-6.1.0/openvdb/cmd: openvdb_view.cc
Seulement dans openvdb-6.1.0/openvdb/doc: build.txt
diff -aur openvdb-6.0.0/openvdb/doc/changes.txt openvdb-6.1.0/openvdb/doc/changes.txt
--- openvdb-6.0.0/openvdb/doc/changes.txt	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/doc/changes.txt	2019-05-07 22:58:35.000000000 +0200
@@ -2,11 +2,149 @@
 
 @page changes Release Notes
 
+@htmlonly <a name="v6_1_0_changes"></a>@endhtmlonly
+@par
+<B>Version 6.1.0</B> - <I>May 8, 2019</I>
+
+@par
+<BLOCKQUOTE>
+As of this release, the oldest supported Houdini version is&nbsp;16.5.
+</BLOCKQUOTE>
+
+@par
+New features:
+- Added new @vdblink::QuatTraits QuatTraits@endlink,
+  @vdblink::MatTraits MatTraits@endlink and
+  @vdblink::ValueTraits ValueTraits@endlink type traits to complement
+  @vdblink::VecTraits VecTraits@endlink and added an
+  @vdblink::IsSpecializationOf IsSpecializationOf@endlink
+  helper metafunction.
+- Added support for @vdblink::Vec4SMetadata Vec4s@endlink,
+  @vdblink::Vec4DMetadata Vec4d@endlink
+  and @vdblink::Vec4IMetadata Vec4i@endlink metadata.
+- Added a generic @vdblink::TypeList TypeList@endlink class.
+- Added @vdblink::GridBase::apply() GridBase::apply@endlink,
+  which invokes a functor on a grid if the resolved grid type
+  is a member of a given type list.
+- Added @vdblink::util::printTime() printTime@endlink, which outputs
+  nicely formatted time information.
+- Added a @link std::hash<openvdb::math::Coord> std::hash<Coord>@endlink
+  template specialization.
+- Added @vdblink::math::CoordBBox::moveMin moveMin@endlink and
+  @vdblink::math::CoordBBox::moveMax moveMax@endlink methods to
+  @vdblink::math::CoordBBox CoordBBox@endlink.
+
+@par
+Improvements:
+- @vdblink::util::CpuTimer CpuTimer@endlink now makes use of
+  @vdblink::util::printTime() printTime@endlink for nicer output,
+  and its API has been improved.
+- Significantly improved the performance of point data grid string attribute
+  generation.
+- @vdblink::points::AttributeArray::copy() AttributeArray::copy@endlink
+  and the
+  @vdblink::points::AttributeArray::operator=() AttributeArray@endlink
+  copy assignment operator are now thread-safe.
+- The command-line tools (<TT>vdb_print</TT>, etc.) now include
+  the library ABI version in their <TT>-version</TT> output.
+- Further improved the responsiveness of the
+  @link MeshToVolume.h mesh to volume@endlink converter to interrupt requests.
+- The CMake build system has been significantly improved to support a
+  wider range of build options and use cases.
+  This includes better dependency handling and status reporting, find module
+  installation for external use, more robust handling of different platform
+  configurations and the introduction of dependency and build documentation.
+
+@par
+Bug fixes:
+- Fixed a bug in the @link tools/Clip.h clip@endlink tool that caused
+  some grid metadata to be discarded.
+- Added a check to @vdblink::points::setGroup() points::setGroup@endlink
+  to compare the maximum index of the provided
+  @vdblink::tools::PointIndexTree PointIndexTree@endlink
+  to the size of the membership vector.
+- Fixed a race condition introduced in ABI&nbsp;6 when moving points
+  in point data grids, due to non-const access to an
+  @vdblink::points::AttributeArray AttributeArray@endlink
+  triggering a copy-on-write.
+- Fixed a bug that caused the @link MeshToVolume.h mesh to volume@endlink
+  converter to consume unlimited memory when it encountered NaNs
+  in vertex positions.
+- Fixed a rounding error bug in
+  @link PointConversion.h point conversion@endlink when using
+  single-precision floating-point.
+- Addressed some type conversion issues and other issues reported by
+  GCC&nbsp;6.
+- Fixed a crash in @vdblink::tools::extractActiveVoxelSegmentMasks()
+  extractActiveVoxelSegmentMasks@endlink
+  when the first leaf node had no active voxels.
+  <I>[Reported&nbsp;by&nbsp;Rick&nbsp;Hankins]</I>
+- Fixed a bug in @vdblink::tools::segmentActiveVoxels() segmentActiveVoxels@endlink
+  and @vdblink::tools::segmentSDF() segmentSDF@endlink where inactive leaf
+  nodes were only pruned when there was more than one segment.
+- Fixed a crash in point moving when using group filters.
+- Fixed a bug where the stride of existing attributes was being ignored during
+  copy-construction of an @vdblink::points::AttributeSet AttributeSet@endlink.
+- Fixed a bug that caused @vdblink::points::AttributeArray::operator==()
+  AttributeArray@endlink equality operators to fail for attributes
+  with non-constant strides.
+
+@par
+API changes:
+- Moved the @vdblink::CopyConstness CopyConstness@endlink metafunction from
+  @link tree/TreeIterator.h TreeIterator.h@endlink to @link Types.h@endlink.
+
+@par
+Houdini:
+- The Points&nbsp;Convert SOP now reports NaN Positions as warnings when
+  converting from Houdini Points to VDB Points.
+- Fixed a bug where the Points&nbsp;Convert&nbsp;SOP was incorrectly ignoring
+  point attributes with the same name as an existing point group.
+- The Transform&nbsp;SOP now supports frustum transforms by applying the
+  transformation to the internal affine map.
+- Changed the labels (but not the opnames) of several SOPs to match
+  the corresponding native Houdini SOPs.
+  The new labels are Morph&nbsp;SDF, Project&nbsp;Non-Divergent,
+  Rebuild&nbsp;SDF, Renormalize&nbsp;SDF, Reshape&nbsp;SDF,
+  Segment&nbsp;by&nbsp;Connectivity, Smooth&nbsp;SDF,
+  Topology&nbsp;to&nbsp;SDF, and Visualize&nbsp;Tree.
+- Added an @b OpPolicy::getFirstName method to allow @b OpPolicy subclasses
+  to provide their own first name scheme.
+- Added an @b OpPolicy::getLabelName method to allow @b OpPolicy subclasses
+  to provide their own label naming scheme for tab menus.
+- Added type lists for sets of commonly used grid types, including
+  @b ScalarGridTypes, @b Vec3GridTypes, @b AllGridTypes, etc.
+- The Vector&nbsp;Merge SOP now copies metadata from the representative
+  scalar grid.
+- Deprecated @b SOP_NodeVDB::duplicateSourceStealable,
+  @b houdini_utils::getNodeChain and @b houdini_utils::OP_EvalScope.
+
+@par
+Python:
+- Added limited support for @ref secPtContents "point data grids",
+  comprising I/O and metadata functionality for now.
+- Added support for @vdblink::Mat4SMetadata Mat4s@endlink
+  and @vdblink::Mat4DMetadata Mat4d@endlink metadata, in the form of nested
+  Python lists (e.g., <TT>[[1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,1]]</TT>).
+
+
 @htmlonly <a name="v6_0_0_changes"></a>@endhtmlonly
 @par
 <B>Version 6.0.0</B> - <I>December 18, 2018</I>
 
 @par
+<BLOCKQUOTE>
+Some changes in this release (see @ref v6_0_0_ABI_changes "ABI changes" below)
+alter the grid&nbsp;ABI so that it is incompatible with earlier versions of
+the OpenVDB library, such as the ones built into Houdini up to and including
+Houdini&nbsp;17.
+To preserve ABI compatibility, when compiling OpenVDB or any dependent code
+define the macro <TT>OPENVDB_ABI_VERSION_NUMBER=</TT><I>N</I>, where,
+for example, <I>N</I> is 3 for Houdini&nbsp;15, 15.5 and&nbsp;16,
+4 for Houdini&nbsp;16.5 and 5 for Houdini&nbsp;17.0.
+</BLOCKQUOTE>
+
+@par
 New features:
 - Added support to the
   @link ParticlesToLevelSet.h ParticlesToLevelSet@endlink tool
@@ -17,11 +155,12 @@
   @vdblink::tools::particlesToMask() particlesToMask@endlink
   and @vdblink::tools::particleTrailsToMask() particleTrailsToMask@endlink
   for common particle rasterization use cases.
-- Added batch copying functions
-  @vdblink::points::AttributeArray::copyValues() AttributeArray::copyValues()@endlink
-  @vdblink::points::AttributeArray::copyValuesUnsafe() AttributeArray::copyValuesUnsafe()@endlink
-  that significantly out-performs the older
-  @vdblink::points::AttributeArray::set() AttributeArray@endlink method.
+- Added batch copying functions @vdblink::points::AttributeArray::copyValues()
+  AttributeArray::copyValues@endlink and
+  @vdblink::points::AttributeArray::copyValuesUnsafe()
+  AttributeArray::copyValuesUnsafe@endlink that significantly outperform
+  the older @vdblink::points::AttributeArray::set()
+  AttributeArray::set@endlink method.
 
 @par
 Improvements:
@@ -31,41 +170,45 @@
   @vdblink::points::AttributeArray AttributeArray@endlink now errors.
 - Updated point deletion to use faster batch copying for ABI=6+.
 - Methods relating to in-memory Blosc compression for
-  @vdblink::points::AttributeArray AttributeArray@endlink now do nothing and
-  have been marked deprecated resulting in memory savings for ABI=6+.
+  @vdblink::points::AttributeArray::compress() AttributeArray@endlink
+  now do nothing and have been marked deprecated resulting in memory savings
+  for ABI=6+.
 
 @par
 Bug fixes:
-- Fixed various signed/unsigned casting issues when moving points in point
-  data grids to resolve compiler warnings.
+- Fixed various signed/unsigned casting issues to resolve compiler warnings
+  when moving points in point data grids.
 
+@anchor v6_0_0_ABI_changes
 @par
 ABI changes:
 - Added multiple new virtual functions to
   @vdblink::points::AttributeArray AttributeArray@endlink.
 - Changed the order and size of member variables in
   @vdblink::points::AttributeArray AttributeArray@endlink
-  and @vdblink::points::TypedAttributeArray TypedAttributeArray@endlink
-  classes.
+  and @vdblink::points::TypedAttributeArray TypedAttributeArray@endlink.
 
 @par
 API changes:
 - Removed a number of methods that were deprecated in version&nbsp;5.0.0 or
   earlier.
-- Removed the experimental
-  @vdblink::tree::ValueAccessor::newSetValue() ValueAccessor::newSetValue@endlink
-  method.
+- Removed the experimental @b ValueAccessor::newSetValue method.
+- Deprecated @vdblink::points::AttributeArray::compress()
+  AttributeArray@endlink methods relating to in-memory Blosc compression.
 
 @par
 Houdini:
+- The Convert and To&nbsp;Polygons SOPs now correctly transfer vertex
+  attributes when the output is a polygon soup.
 - Added an option to the Visualize&nbsp;SOP to display leaf nodes as points.
 - Renamed the Visualize&nbsp;SOP&rsquo;s <TT>leafmode</TT>,
   <TT>internalmode</TT>, <TT>tilemode</TT> and <TT>voxelmode</TT> parameters
   to <TT>leafstyle</TT>, <TT>internalstyle</TT>, etc. and converted them
   from ordinals to strings.
 - Made various improvements to viewport rendering of point data grids.
-- Updated ParmFactory to allow parameters to be marked as hidden, this is
-  useful for multi-parms where it is not possible to mark them as obsolete.
+- Added a <B>ParmFactory::setInvisible</B> method to allow parameters
+  to be marked as hidden.  This is useful for multi-parms,
+  whose child parameters cannot be made obsolete.
 - Removed the option to use in-memory Blosc compression from the
   Points&nbsp;Convert&nbsp;SOP as this feature has now been deprecated.
 - Made various small changes for Houdini&nbsp;17 compatibility.
Seulement dans openvdb-6.1.0/openvdb/doc: dependencies.txt
diff -aur openvdb-6.0.0/openvdb/doc/doc.txt openvdb-6.1.0/openvdb/doc/doc.txt
--- openvdb-6.0.0/openvdb/doc/doc.txt	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/doc/doc.txt	2019-05-07 22:58:35.000000000 +0200
@@ -23,6 +23,10 @@
 See the @subpage changes "Release Notes" for what&rsquo;s new in this version
 of @b OpenVDB.
 
+See the @subpage dependencies "Dependencies" page for @b OpenVDB requirements.
+
+See @subpage build "Building OpenVDB" for information on building @b OpenVDB.
+
 See the @subpage overview "Overview" for an introduction to the library.
 
 See @subpage transformsAndMaps "Transforms and Maps" for more
diff -aur openvdb-6.0.0/openvdb/doc/faq.txt openvdb-6.1.0/openvdb/doc/faq.txt
--- openvdb-6.0.0/openvdb/doc/faq.txt	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/doc/faq.txt	2019-05-07 22:58:35.000000000 +0200
@@ -36,22 +36,22 @@
 a collection of algorithms specifically optimized for the data structure
 for common tasks such as filtering, constructive solid geometry (CSG),
 discretization of partial differential equations, voxelization of polygons,
-skinning of particles, volumetric compositing and sampling. The technical 
+skinning of particles, volumetric compositing and sampling. The technical
 details of VDB are described in the paper
 <a href="http://www.museth.org/Ken/Publications.html" target="_blank">"VDB: High-Resolution Sparse Volumes with Dynamic Topology"</a>.
 
 @section sWhatLicense What license is OpenVDB distributed under?
-OpenVDB is released under the Mozilla Public License Version 2.0, which is a 
-free, open source, and detailed software license developed and maintained by 
-the Mozilla Foundation. It is characterized as a hybridization of the modified 
-BSD license and GNU General Public License (GPL) that seeks to balance the 
+OpenVDB is released under the Mozilla Public License Version 2.0, which is a
+free, open source, and detailed software license developed and maintained by
+the Mozilla Foundation. It is characterized as a hybridization of the modified
+BSD license and GNU General Public License (GPL) that seeks to balance the
 concerns of proprietary and open source developers. For more information
-about this license, see the 
-<a href="http://www.mozilla.org/MPL" target="_blank">Mozilla FAQ</a>. 
+about this license, see the
+<a href="http://www.mozilla.org/MPL" target="_blank">Mozilla FAQ</a>.
 
 @section sWhatCLA Is there a Contributor License Agreement for OpenVDB?
-Yes, developers who wish to contribute code to be considered for inclusion 
-in the OpenVDB distribution must first complete this 
+Yes, developers who wish to contribute code to be considered for inclusion
+in the OpenVDB distribution must first complete this
 <a href="http://www.openvdb.org//download/OpenVDBContributorLicenseAgreement.pdf" target="_blank">Contributor License Agreement</a>
 and submit it to DreamWorks (directions are in the CLA).
 
@@ -103,7 +103,7 @@
 
 @section sLevelSet Is OpenVDB primarily for level set applications?
 No! Don't let the fact that OpenVDB can represent and operate so well on
-level sets mislead you into thinking that it is limited to or even focusing 
+level sets mislead you into thinking that it is limited to or even focusing
 on this special type of sparse volumetric application. OpenVDB was developed
 for general-purpose volumetric processing and numerical simulation, and we
 have even had success using it for volumetric applications that traditionally
@@ -132,7 +132,7 @@
 structures like DT-Grid or DB-Grid. The simple truth is that "VDB" is just a
 name. :-)
 
-@section sAccessor Why are there no coordinate-based access methods on the grid? 
+@section sAccessor Why are there no coordinate-based access methods on the grid?
 It might surprise you that the @c Grid class doesn't directly provide access
 to voxels via their @ijk coordinates.  Instead, the recommended procedure
 is to ask the grid for a "value accessor", which is an accelerator object
@@ -172,13 +172,13 @@
 @section sTile What are tiles?
 Values stored in nodes of type @c RootNode or @c InternalNode correspond to
 regions of index space with a constant value and active state and with
-power of two dimensions. We refer to such regions as "tiles".  By 
+power of two dimensions. We refer to such regions as "tiles".  By
 construction, tiles have no child nodes.
 
 @section sBackground What is the background value?
 A tree's background value is the value that is returned whenever
-one accesses a region of index space that is not explicitly represented by 
-voxels or tiles in the tree. Thus, you can think of the background value 
+one accesses a region of index space that is not explicitly represented by
+voxels or tiles in the tree. Thus, you can think of the background value
 as the default value associated with an empty tree.
 Note that the background value is always inactive!
 
@@ -211,17 +211,17 @@
 voxel access.
 
 @section sReplaceDense Does OpenVDB replace dense grids?
-This depends a lot on your application of dense grids and your configuration 
-of OpenVDB. Clearly, if you are storing or processing sparse data, OpenVDB 
-will offer a smaller memory footprint and faster (sparse) data processing. 
-However, even in some cases where both data and computation are dense, OpenVDB 
-can offer benefits like improved CPU cache performance due to its underlying 
-blocking and hierarchical tree structure. Exceptions are of course algorithms 
-that expect dense data to be laid out linearly in memory, or applications that 
-use very small grids. The simple truth is only a benchmark comparison can tell 
-you the preferred data structure, but for what it's worth it is our experience 
-that for the volumetric applications we encounter in production, OpenVDB is 
-almost always superior. 
+This depends a lot on your application of dense grids and your configuration
+of OpenVDB. Clearly, if you are storing or processing sparse data, OpenVDB
+will offer a smaller memory footprint and faster (sparse) data processing.
+However, even in some cases where both data and computation are dense, OpenVDB
+can offer benefits like improved CPU cache performance due to its underlying
+blocking and hierarchical tree structure. Exceptions are of course algorithms
+that expect dense data to be laid out linearly in memory, or applications that
+use very small grids. The simple truth is only a benchmark comparison can tell
+you the preferred data structure, but for what it's worth it is our experience
+that for the volumetric applications we encounter in production, OpenVDB is
+almost always superior.
 
 @section sFuture What future improvements to OpenVDB are planned?
 We are continuing to expand the OpenVDB toolset and improve its performance.
diff -aur openvdb-6.0.0/openvdb/doc/python.txt openvdb-6.1.0/openvdb/doc/python.txt
--- openvdb-6.0.0/openvdb/doc/python.txt	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/doc/python.txt	2019-05-07 22:58:35.000000000 +0200
@@ -376,7 +376,7 @@
 ...         if tiles < N:
 ...             tiles += 1
 ...             print 'tile', item.min, item.max
-... 
+...
 tile (0, 0, 0) (7, 7, 7)
 tile (0, 0, 8) (7, 7, 15)
 tile (0, 0, 16) (7, 7, 23)
@@ -542,7 +542,7 @@
 array([[-14.05082607,  -0.10118673,  -0.40250054],
        [-14.05230808,  -0.05570767,  -0.45693323],
        [-14.05613995,  -0.0734246 ,  -0.42150033],
-       ..., 
+       ...,
        [  7.25201273,  13.25417805,   6.45283508],
        [  7.25596714,  13.31225586,   6.40827513],
        [  7.30518484,  13.21096039,   6.40724468]], dtype=float32)
@@ -553,7 +553,7 @@
 array([[      5,       2,       1,       4],
        [     11,       7,       6,      10],
        [     14,       9,       8,      13],
-       ..., 
+       ...,
        [1327942, 1327766, 1339685, 1339733],
        [1339728, 1327921, 1327942, 1339733],
        [1339733, 1339685, 1339661, 1339728]], dtype=uint32)
@@ -573,7 +573,7 @@
 array([[-14.02906322,  -0.07213751,  -0.49265194],
        [-14.11877823,  -0.11127799,  -0.17118289],
        [-13.85006142,  -0.08145611,  -0.86669081],
-       ..., 
+       ...,
        [  7.31098318,  12.97358608,   6.55133963],
        [  7.20240211,  12.80632019,   6.80356836],
        [  7.23679161,  13.28100395,   6.45595646]], dtype=float32)
@@ -584,7 +584,7 @@
 array([[    8,     7,     0],
        [   14,     9,     8],
        [   14,    11,     9],
-       ..., 
+       ...,
        [22794, 22796, 22797],
        [22784, 22783, 22810],
        [22796, 22795, 22816]], dtype=uint32)
@@ -595,7 +595,7 @@
 array([[    4,     3,     6,     5],
        [    8,     9,    10,     7],
        [   11,    12,    10,     9],
-       ..., 
+       ...,
        [23351, 23349, 23341, 23344],
        [23344, 23117, 23169, 23351],
        [23169, 23167, 23349, 23351]], dtype=uint32)
diff -aur openvdb-6.0.0/openvdb/doxygen-config openvdb-6.1.0/openvdb/doxygen-config
--- openvdb-6.0.0/openvdb/doxygen-config	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/doxygen-config	2019-05-07 22:58:35.000000000 +0200
@@ -38,10 +38,10 @@
 # could be handy for archiving the generated documentation or if some version
 # control system is used.
 
-PROJECT_NUMBER         = 6.0.0
+PROJECT_NUMBER         = 6.1.0
 
-ALIASES += vdbnamespace="openvdb::v6_0"
-PREDEFINED = OPENVDB_VERSION_NAME=v6_0
+ALIASES += vdbnamespace="openvdb::v6_1"
+PREDEFINED = OPENVDB_VERSION_NAME=v6_1
 PREDEFINED += OPENVDB_ABI_VERSION_NUMBER=6
 
 PREDEFINED += __declspec(x):= __attribute__(x):=
@@ -785,6 +785,8 @@
                          tree \
                          util \
                          doc/doc.txt \
+                         doc/build.txt \
+                         doc/dependencies.txt \
                          doc/faq.txt \
                          doc/math.txt \
                          doc/changes.txt \
diff -aur openvdb-6.0.0/openvdb/Grid.h openvdb-6.1.0/openvdb/Grid.h
--- openvdb-6.0.0/openvdb/Grid.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/Grid.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -112,17 +112,22 @@
 
     ~GridBase() override {}
 
+
+    /// @name Copying
+    /// @{
+
 #if OPENVDB_ABI_VERSION_NUMBER <= 3
     /// @brief Return a new grid of the same type as this grid and whose
     /// metadata and transform are deep copies of this grid's.
-    virtual GridBase::Ptr copyGrid(CopyPolicy treePolicy = CP_SHARE) const = 0;
+    /// @deprecated ABI versions older than 4 are deprecated.
+    OPENVDB_DEPRECATED virtual GridBase::Ptr copyGrid(CopyPolicy treePolicy = CP_SHARE) const = 0;
 #else
-    //@{
-    /// @brief Return a new grid of the same type as this grid whose metadata and
-    /// transform are deep copies of this grid's and whose tree is shared with this grid.
+    /// @brief Return a new grid of the same type as this grid whose metadata is a
+    /// deep copy of this grid's and whose tree and transform are shared with this grid.
     virtual GridBase::Ptr copyGrid() = 0;
+    /// @brief Return a new grid of the same type as this grid whose metadata is a
+    /// deep copy of this grid's and whose tree and transform are shared with this grid.
     virtual GridBase::ConstPtr copyGrid() const = 0;
-    //@}
     /// @brief Return a new grid of the same type as this grid whose metadata and
     /// transform are deep copies of this grid's and whose tree is default-constructed.
     virtual GridBase::Ptr copyGridWithNewTree() const = 0;
@@ -130,10 +135,12 @@
     /// Return a new grid whose metadata, transform and tree are deep copies of this grid's.
     virtual GridBase::Ptr deepCopyGrid() const = 0;
 
+    /// @}
+
+
+    /// @name Registry
+    /// @{
 
-    //
-    // Registry methods
-    //
     /// Create a new grid of the given (registered) type.
     static Ptr createGrid(const Name& type);
 
@@ -143,10 +150,11 @@
     /// Clear the grid type registry.
     static void clearRegistry();
 
+    /// @}
+
+    /// @name Type access
+    /// @{
 
-    //
-    // Grid type methods
-    //
     /// Return the name of this grid's type.
     virtual Name type() const = 0;
     /// Return the name of the type of a voxel's value (e.g., "float" or "vec3d").
@@ -156,6 +164,8 @@
     template<typename GridType>
     bool isType() const { return (this->type() == GridType::gridType()); }
 
+    /// @}
+
     //@{
     /// @brief Return the result of downcasting a GridBase pointer to a Grid pointer
     /// of the specified type, or return a null pointer if the types are incompatible.
@@ -169,39 +179,57 @@
     static typename GridType::ConstPtr constGrid(const GridBase::ConstPtr&);
     //@}
 
-    //@{
+    /// @name Tree
+    /// @{
+
     /// @brief Return a pointer to this grid's tree, which might be
     /// shared with other grids.  The pointer is guaranteed to be non-null.
     TreeBase::Ptr baseTreePtr();
+    /// @brief Return a pointer to this grid's tree, which might be
+    /// shared with other grids.  The pointer is guaranteed to be non-null.
     TreeBase::ConstPtr baseTreePtr() const { return this->constBaseTreePtr(); }
+    /// @brief Return a pointer to this grid's tree, which might be
+    /// shared with other grids.  The pointer is guaranteed to be non-null.
     virtual TreeBase::ConstPtr constBaseTreePtr() const = 0;
-    //@}
 
-    //@{
     /// @brief Return a reference to this grid's tree, which might be
     /// shared with other grids.
-    /// @note Calling setTree() on this grid invalidates all references
-    /// previously returned by this method.
+    /// @note Calling @vdblink::GridBase::setTree() setTree@endlink
+    /// on this grid invalidates all references previously returned by this method.
     TreeBase& baseTree() { return const_cast<TreeBase&>(this->constBaseTree()); }
+    /// @brief Return a reference to this grid's tree, which might be
+    /// shared with other grids.
+    /// @note Calling @vdblink::GridBase::setTree() setTree@endlink
+    /// on this grid invalidates all references previously returned by this method.
     const TreeBase& baseTree() const { return this->constBaseTree(); }
+    /// @brief Return a reference to this grid's tree, which might be
+    /// shared with other grids.
+    /// @note Calling @vdblink::GridBase::setTree() setTree@endlink
+    /// on this grid invalidates all references previously returned by this method.
     const TreeBase& constBaseTree() const { return *(this->constBaseTreePtr()); }
-    //@}
 
     /// @brief Associate the given tree with this grid, in place of its existing tree.
     /// @throw ValueError if the tree pointer is null
     /// @throw TypeError if the tree is not of the appropriate type
-    /// @note Invalidates all references previously returned by baseTree()
-    /// or constBaseTree().
+    /// @note Invalidates all references previously returned by
+    /// @vdblink::GridBase::baseTree() baseTree@endlink
+    /// or @vdblink::GridBase::constBaseTree() constBaseTree@endlink.
     virtual void setTree(TreeBase::Ptr) = 0;
 
     /// Set a new tree with the same background value as the previous tree.
     virtual void newTree() = 0;
 
+    /// @}
+
     /// Return @c true if this grid contains only background voxels.
     virtual bool empty() const = 0;
     /// Empty this grid, setting all voxels to the background.
     virtual void clear() = 0;
 
+
+    /// @name Tools
+    /// @{
+
     /// @brief Reduce the memory footprint of this grid by increasing its sparseness
     /// either losslessly (@a tolerance = 0) or lossily (@a tolerance > 0).
     /// @details With @a tolerance > 0, sparsify regions where voxels have the same
@@ -223,10 +251,39 @@
     virtual void clip(const CoordBBox&) = 0;
 #endif
 
+    /// @}
+
+    /// @{
+    /// @brief If this grid resolves to one of the listed grid types,
+    /// invoke the given functor on the resolved grid.
+    /// @return @c false if this grid's type is not one of the listed types
+    ///
+    /// @par Example:
+    /// @code
+    /// using AllowedGridTypes = openvdb::TypeList<
+    ///     openvdb::Int32Grid, openvdb::Int64Grid,
+    ///     openvdb::FloatGrid, openvdb::DoubleGrid>;
+    ///
+    /// const openvdb::CoordBBox bbox{
+    ///     openvdb::Coord{0,0,0}, openvdb::Coord{10,10,10}};
+    ///
+    /// // Fill the grid if it is one of the allowed types.
+    /// myGridBasePtr->apply<AllowedGridTypes>(
+    ///     [&bbox](auto& grid) { // C++14
+    ///         using GridType = typename std::decay<decltype(grid)>::type;
+    ///         grid.fill(bbox, typename GridType::ValueType(1));
+    ///     }
+    /// );
+    /// @endcode
+    ///
+    /// @see @vdblink::TypeList TypeList@endlink
+    template<typename GridTypeListT, typename OpT> inline bool apply(OpT&) const;
+    template<typename GridTypeListT, typename OpT> inline bool apply(OpT&);
+    /// @}
+
+    /// @name Metadata
+    /// @{
 
-    //
-    // Metadata
-    //
     /// Return this grid's user-specified name.
     std::string getName() const;
     /// Specify a name for this grid.
@@ -242,31 +299,45 @@
     bool saveFloatAsHalf() const;
     void setSaveFloatAsHalf(bool);
 
-    /// Return the class of volumetric data (level set, fog volume, etc.) stored in this grid.
+    /// @brief Return the class of volumetric data (level set, fog volume, etc.)
+    /// that is stored in this grid.
+    /// @sa gridClassToString, gridClassToMenuName, stringToGridClass
     GridClass getGridClass() const;
-    /// Specify the class of volumetric data (level set, fog volume, etc.) stored in this grid.
+    /// @brief Specify the class of volumetric data (level set, fog volume, etc.)
+    /// that is stored in this grid.
+    /// @sa gridClassToString, gridClassToMenuName, stringToGridClass
     void setGridClass(GridClass);
     /// Remove the setting specifying the class of this grid's volumetric data.
     void clearGridClass();
 
+    /// @}
+
     /// Return the metadata string value for the given class of volumetric data.
     static std::string gridClassToString(GridClass);
     /// Return a formatted string version of the grid class.
     static std::string gridClassToMenuName(GridClass);
     /// @brief Return the class of volumetric data specified by the given string.
-    /// @details If the string is not one of the ones returned by gridClassToString(),
+    /// @details If the string is not one of the ones returned by
+    /// @vdblink::GridBase::gridClassToString() gridClassToString@endlink,
     /// return @c GRID_UNKNOWN.
     static GridClass stringToGridClass(const std::string&);
 
+    /// @name Metadata
+    /// @{
+
     /// @brief Return the type of vector data (invariant, covariant, etc.) stored
     /// in this grid, assuming that this grid contains a vector-valued tree.
+    /// @sa vecTypeToString, vecTypeExamples, vecTypeDescription, stringToVecType
     VecType getVectorType() const;
     /// @brief Specify the type of vector data (invariant, covariant, etc.) stored
     /// in this grid, assuming that this grid contains a vector-valued tree.
+    /// @sa vecTypeToString, vecTypeExamples, vecTypeDescription, stringToVecType
     void setVectorType(VecType);
     /// Remove the setting specifying the type of vector data stored in this grid.
     void clearVectorType();
 
+    /// @}
+
     /// Return the metadata string value for the given type of vector data.
     static std::string vecTypeToString(VecType);
     /// Return a string listing examples of the given type of vector data
@@ -277,6 +348,9 @@
     static std::string vecTypeDescription(VecType);
     static VecType stringToVecType(const std::string&);
 
+    /// @name Metadata
+    /// @{
+
     /// Return @c true if this grid's voxel values are in world space and should be
     /// affected by transformations, @c false if they are in local space and should
     /// not be affected by transformations.
@@ -284,6 +358,8 @@
     /// Specify whether this grid's voxel values are in world space or in local space.
     void setIsInWorldSpace(bool);
 
+    /// @}
+
     // Standard metadata field names
     // (These fields should normally not be accessed directly, but rather
     // via the accessor methods above, when available.)
@@ -301,9 +377,9 @@
     static const char* const META_FILE_VOXEL_COUNT;
 
 
-    //
-    // Statistics
-    //
+    /// @name Statistics
+    /// @{
+
     /// Return the number of active voxels.
     virtual Index64 activeVoxelCount() const = 0;
 
@@ -323,15 +399,18 @@
     /// changes to this grid.
     void addStatsMetadata();
     /// @brief Return a new MetaMap containing just the metadata that
-    /// was added to this grid with addStatsMetadata().
-    /// @details If addStatsMetadata() was never called on this grid,
-    /// return an empty MetaMap.
+    /// was added to this grid with @vdblink::GridBase::addStatsMetadata()
+    /// addStatsMetadata@endlink.
+    /// @details If @vdblink::GridBase::addStatsMetadata() addStatsMetadata@endlink
+    /// was never called on this grid, return an empty MetaMap.
     MetaMap::Ptr getStatsMetadata() const;
 
+    /// @}
+
+
+    /// @name Transform
+    /// @{
 
-    //
-    // Transform methods
-    //
     //@{
     /// @brief Return a pointer to this grid's transform, which might be
     /// shared with other grids.
@@ -342,17 +421,24 @@
     //@{
     /// @brief Return a reference to this grid's transform, which might be
     /// shared with other grids.
-    /// @note Calling setTransform() on this grid invalidates all references
-    /// previously returned by this method.
+    /// @note Calling @vdblink::GridBase::setTransform() setTransform@endlink
+    /// on this grid invalidates all references previously returned by this method.
     math::Transform& transform() { return *mTransform; }
     const math::Transform& transform() const { return *mTransform; }
     const math::Transform& constTransform() const { return *mTransform; }
     //@}
+
+    /// @}
+
+    /// @name Transform
+    /// @{
+
     /// @brief Associate the given transform with this grid, in place of
     /// its existing transform.
     /// @throw ValueError if the transform pointer is null
-    /// @note Invalidates all references previously returned by transform()
-    /// or constTransform().
+    /// @note Invalidates all references previously returned by
+    /// @vdblink::GridBase::transform() transform@endlink
+    /// or @vdblink::GridBase::constTransform() constTransform@endlink.
     void setTransform(math::Transform::Ptr);
 
     /// Return the size of this grid's voxels.
@@ -362,18 +448,19 @@
     Vec3d voxelSize(const Vec3d& xyz) const { return transform().voxelSize(xyz); }
     /// Return true if the voxels in world space are uniformly sized cubes
     bool hasUniformVoxels() const { return mTransform->hasUniformScale(); }
-    //@{
     /// Apply this grid's transform to the given coordinates.
     Vec3d indexToWorld(const Vec3d& xyz) const { return transform().indexToWorld(xyz); }
+    /// Apply this grid's transform to the given coordinates.
     Vec3d indexToWorld(const Coord& ijk) const { return transform().indexToWorld(ijk); }
-    //@}
     /// Apply the inverse of this grid's transform to the given coordinates.
     Vec3d worldToIndex(const Vec3d& xyz) const { return transform().worldToIndex(xyz); }
 
+    /// @}
+
+
+    /// @name I/O
+    /// @{
 
-    //
-    // I/O methods
-    //
     /// @brief Read the grid topology from a stream.
     /// This will read only the grid structure, not the actual data buffers.
     virtual void readTopology(std::istream&) = 0;
@@ -404,6 +491,8 @@
     /// Output a human-readable description of this grid.
     virtual void print(std::ostream& = std::cout, int verboseLevel = 1) const = 0;
 
+    /// @}
+
 
 protected:
     /// @brief Initialize with an identity linear transform.
@@ -414,7 +503,8 @@
 
 #if OPENVDB_ABI_VERSION_NUMBER <= 3
     /// @brief Copy another grid's metadata but share its transform.
-    GridBase(const GridBase& other, ShallowCopy): MetaMap(other), mTransform(other.mTransform) {}
+    /// @deprecated ABI versions older than 4 are deprecated.
+    OPENVDB_DEPRECATED GridBase(const GridBase& other, ShallowCopy): MetaMap(other), mTransform(other.mTransform) {}
 #else
     /// @brief Copy another grid's metadata but share its transform.
     GridBase(GridBase& other, ShallowCopy): MetaMap(other), mTransform(other.mTransform) {}
@@ -562,7 +652,8 @@
     explicit Grid(const Grid<OtherTreeType>&);
 #if OPENVDB_ABI_VERSION_NUMBER <= 3
     /// Deep copy another grid's metadata, but share its tree and transform.
-    Grid(const Grid&, ShallowCopy);
+    /// @deprecated ABI versions older than 4 are deprecated.
+    OPENVDB_DEPRECATED Grid(const Grid&, ShallowCopy);
 #else
     /// Deep copy another grid's metadata and transform, but share its tree.
     Grid(Grid&, ShallowCopy);
@@ -585,8 +676,9 @@
     /// and it shares its transform with this grid;
     /// if @c CP_SHARE, the new grid shares this grid's tree and transform;
     /// if @c CP_COPY, the new grid's tree and transform are deep copies of this grid's.
-    Ptr copy(CopyPolicy treePolicy = CP_SHARE) const;
-    GridBase::Ptr copyGrid(CopyPolicy treePolicy = CP_SHARE) const override;
+    /// @deprecated ABI versions older than 4 are deprecated.
+    OPENVDB_DEPRECATED Ptr copy(CopyPolicy treePolicy = CP_SHARE) const;
+    OPENVDB_DEPRECATED GridBase::Ptr copyGrid(CopyPolicy treePolicy = CP_SHARE) const override;
     //@}
 #else
     //@{
@@ -1355,7 +1447,10 @@
 inline void
 Grid<TreeT>::pruneGrid(float tolerance)
 {
-    this->tree().prune(ValueType(zeroVal<ValueType>() + tolerance));
+    OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+    const auto value = zeroVal<ValueType>() + tolerance;
+    OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+    this->tree().prune(static_cast<ValueType>(value));
 }
 
 #if OPENVDB_ABI_VERSION_NUMBER >= 3
@@ -1619,11 +1714,53 @@
     return grid;
 }
 
+
+////////////////////////////////////////
+
+
+namespace internal {
+
+/// @private
+template<typename OpT, typename GridBaseT, typename T, typename ...Ts>
+struct GridApplyImpl { static bool apply(GridBaseT&, OpT&) { return false; } };
+
+// Partial specialization for (nonempty) TypeLists
+/// @private
+template<typename OpT, typename GridBaseT, typename GridT, typename ...GridTs>
+struct GridApplyImpl<OpT, GridBaseT, TypeList<GridT, GridTs...>>
+{
+    static bool apply(GridBaseT& grid, OpT& op)
+    {
+        if (grid.template isType<GridT>()) {
+            op(static_cast<typename CopyConstness<GridBaseT, GridT>::Type&>(grid));
+            return true;
+        }
+        return GridApplyImpl<OpT, GridBaseT, TypeList<GridTs...>>::apply(grid, op);
+    }
+};
+
+} // namespace internal
+
+
+template<typename GridTypeListT, typename OpT>
+inline bool
+GridBase::apply(OpT& op) const
+{
+    return internal::GridApplyImpl<OpT, const GridBase, GridTypeListT>::apply(*this, op);
+}
+
+template<typename GridTypeListT, typename OpT>
+inline bool
+GridBase::apply(OpT& op)
+{
+    return internal::GridApplyImpl<OpT, GridBase, GridTypeListT>::apply(*this, op);
+}
+
 } // namespace OPENVDB_VERSION_NAME
 } // namespace openvdb
 
 #endif // OPENVDB_GRID_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/INSTALL openvdb-6.1.0/openvdb/INSTALL
--- openvdb-6.0.0/openvdb/INSTALL	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/INSTALL	2019-05-07 22:58:35.000000000 +0200
@@ -33,11 +33,11 @@
 - CppUnit (www.freedesktop.org/wiki/Software/cppunit), version 1.10 or later
   (Linux: yum install cppunit-devel)
 
-- Houdini HDK (http://www.sidefx.com/get/download-houdini/), version 15.0
+- Houdini HDK (http://www.sidefx.com/get/download-houdini/), version 16.5
   or later
 
 - Blosc compression library (www.blosc.org), version 1.5.0 or later
-  (included in the Houdini HDK as of version 14.0)
+  (included in the Houdini HDK)
 
 - Ghostscript (www.ghostscript.com), version 8.70 or later, for documentation
   in PDF format
@@ -195,8 +195,8 @@
     A default local build generates the following libraries and executables
     (but see the Makefile for additional targets and build options):
 
-    openvdb/libopenvdb.so.6.0.0         the OpenVDB library
-    openvdb/libopenvdb.so               symlink to libopenvdb.so.6.0.0
+    openvdb/libopenvdb.so.6.1.0         the OpenVDB library
+    openvdb/libopenvdb.so               symlink to libopenvdb.so.6.1.0
     openvdb/pyopenvdb.so                the OpenVDB Python module (if Python
                                         and Boost.Python are available)
     openvdb/vdb_print                   command-line tool that prints info
@@ -242,8 +242,8 @@
                 version.h
         lib/
             libopenvdb.so
-            libopenvdb.so.6.0
-            libopenvdb.so.6.0.0
+            libopenvdb.so.6.1
+            libopenvdb.so.6.1.0
 
         python/
             include/
@@ -252,7 +252,7 @@
             lib/
                 python$(PYTHON_VERSION)/
                     pyopenvdb.so
-                    pyopenvdb.so.6.0
+                    pyopenvdb.so.6.1
 
         share/
             doc/
diff -aur openvdb-6.0.0/openvdb/io/io.h openvdb-6.1.0/openvdb/io/io.h
--- openvdb-6.0.0/openvdb/io/io.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/io/io.h	2019-05-07 22:58:35.000000000 +0200
@@ -41,6 +41,7 @@
 #include <memory>
 #include <string>
 
+class TestMappedFile;
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -178,6 +179,7 @@
 
 private:
     friend class File;
+    friend class ::TestMappedFile;
 
     explicit MappedFile(const std::string& filename, bool autoDelete = false);
 
diff -aur openvdb-6.0.0/openvdb/LICENSE openvdb-6.1.0/openvdb/LICENSE
--- openvdb-6.0.0/openvdb/LICENSE	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/LICENSE	2019-05-07 22:58:35.000000000 +0200
@@ -35,7 +35,7 @@
     means any form of the work other than Source Code Form.
 
 1.7. "Larger Work"
-    means a work that combines Covered Software with other material, in 
+    means a work that combines Covered Software with other material, in
     a separate file or files, that is not Covered Software.
 
 1.8. "License"
diff -aur openvdb-6.0.0/openvdb/Makefile openvdb-6.1.0/openvdb/Makefile
--- openvdb-6.0.0/openvdb/Makefile	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/Makefile	2019-05-07 22:58:35.000000000 +0200
@@ -1,4 +1,4 @@
-# Copyright (c) 2012-2018 DreamWorks Animation LLC
+# Copyright (c) 2012-2019 DreamWorks Animation LLC
 #
 # All rights reserved. This software is distributed under the
 # Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -62,6 +62,8 @@
 #                       (default: link against shared libraries)
 #   debug=yes           build with debugging symbols and without optimization
 #   verbose=yes         run commands (e.g., doxygen) in verbose mode
+#   strict=yes          Enable a collection of pre defined compiler warnings
+#                       for GCC and clang
 
 
 #
@@ -282,6 +284,32 @@
     CXXFLAGS += -DOPENVDB_USE_GLFW_3
 endif
 
+ifeq (yes,$(strip $(strict)))
+    USING_CLANG=$(shell ${CXX} --version | grep clang)
+    USING_GCC=$(shell ${CXX} --version | grep GCC)
+    ifneq (,$(USING_CLANG))
+        CXXFLAGS += \
+            -Werror \
+            -Wall \
+            -Wextra \
+            -Wconversion \
+            -Wno-sign-conversion \
+        #
+    else ifneq (,$(USING_GCC))
+        CXXFLAGS += \
+            -Werror \
+            -Wall \
+            -Wextra \
+            -pedantic \
+            -Wcast-align \
+            -Wcast-qual \
+            -Wconversion \
+            -Wdisabled-optimization \
+            -Woverloaded-virtual \
+        #
+    endif
+endif
+
 LIBS := \
     -ldl -lm -lz \
     -L$(ILMBASE_LIB_DIR) $(HALF_LIB) \
@@ -560,6 +588,7 @@
     unittest/TestTreeGetSetValues.cc \
     unittest/TestTreeIterators.cc \
     unittest/TestTreeVisitor.cc \
+    unittest/TestTypes.cc \
     unittest/TestUtil.cc \
     unittest/TestValueAccessor.cc \
     unittest/TestVec2Metadata.cc \
@@ -602,9 +631,10 @@
 #
 
 CMD_SRC_NAMES := \
-    cmd/openvdb_print/main.cc \
-    cmd/openvdb_render/main.cc \
-    cmd/openvdb_view/main.cc \
+    cmd/openvdb_lod.cc \
+    cmd/openvdb_print.cc \
+    cmd/openvdb_render.cc \
+    cmd/openvdb_view.cc \
 #
 
 
@@ -623,6 +653,7 @@
     python/pyIntGrid.cc \
     python/pyMetadata.cc \
     python/pyOpenVDBModule.cc \
+    python/pyPointGrid.cc \
     python/pyTransform.cc \
     python/pyVec3Grid.cc \
 #
@@ -794,21 +825,21 @@
 	@echo "$@"': $$DOXYGEN is undefined'
 endif
 
-vdb_lod: $(LIBOPENVDB) cmd/openvdb_lod/main.cc
+vdb_lod: $(LIBOPENVDB) cmd/openvdb_lod.cc
 	@echo "Building $@ because of $(list_deps)"
-	$(CXX) $(CXXFLAGS) -o $@ cmd/openvdb_lod/main.cc -I . \
+	$(CXX) $(CXXFLAGS) -o $@ cmd/openvdb_lod.cc -I . \
 	    $(LIBOPENVDB_RPATH) -L$(CURDIR) $(LIBOPENVDB) \
 	    $(LIBS_RPATH) $(CONCURRENT_MALLOC_LIB)
 
-vdb_print: $(LIBOPENVDB) cmd/openvdb_print/main.cc
+vdb_print: $(LIBOPENVDB) cmd/openvdb_print.cc
 	@echo "Building $@ because of $(list_deps)"
-	$(CXX) $(CXXFLAGS) -o $@ cmd/openvdb_print/main.cc -I . \
+	$(CXX) $(CXXFLAGS) -o $@ cmd/openvdb_print.cc -I . \
 	    $(LIBOPENVDB_RPATH) -L$(CURDIR) $(LIBOPENVDB) \
 	    $(LIBS_RPATH) $(CONCURRENT_MALLOC_LIB)
 
-vdb_render: $(LIBOPENVDB) cmd/openvdb_render/main.cc
+vdb_render: $(LIBOPENVDB) cmd/openvdb_render.cc
 	@echo "Building $@ because of $(list_deps)"
-	$(CXX) $(CXXFLAGS) -o $@ cmd/openvdb_render/main.cc -I . \
+	$(CXX) $(CXXFLAGS) -o $@ cmd/openvdb_render.cc -I . \
 	    -isystem $(EXR_INCL_DIR) -isystem $(ILMBASE_INCL_DIR) \
 	    -Wl,-rpath,$(EXR_LIB_DIR) -L$(EXR_LIB_DIR) $(EXR_LIB) \
 	    -Wl,-rpath,$(ILMBASE_LIB_DIR) -L$(ILMBASE_LIB_DIR) $(ILMBASE_LIB) \
@@ -831,9 +862,9 @@
 	@echo "Building $@ because of $(list_deps)"
 	$(CXX) -c $(CXXFLAGS) -I . -isystem $(GLFW_INCL_DIR) -DGL_GLEXT_PROTOTYPES=1 -fPIC -o $@ $<
 
-vdb_view: $(LIBOPENVDB) $(LIBVIEWER_OBJ_NAMES) cmd/openvdb_view/main.cc
+vdb_view: $(LIBOPENVDB) $(LIBVIEWER_OBJ_NAMES) cmd/openvdb_view.cc
 	@echo "Building $@ because of $(list_deps)"
-	$(CXX) $(CXXFLAGS) -o $@ cmd/openvdb_view/main.cc $(LIBVIEWER_OBJ_NAMES) \
+	$(CXX) $(CXXFLAGS) -o $@ cmd/openvdb_view.cc $(LIBVIEWER_OBJ_NAMES) \
 	    -I . $(LIBOPENVDB_RPATH) -L$(CURDIR) $(LIBOPENVDB) \
 	    $(LIBVIEWER_FLAGS) $(LIBS_RPATH) $(BOOST_THREAD_LIB) $(CONCURRENT_MALLOC_LIB) \
 	    -Wl,-rpath,$(GLFW_LIB_DIR) -L$(GLFW_LIB_DIR) $(GLFW_LIB)
@@ -1032,6 +1063,6 @@
     include $(DEPEND)
 endif
 
-# Copyright (c) 2012-2018 DreamWorks Animation LLC
+# Copyright (c) 2012-2019 DreamWorks Animation LLC
 # All rights reserved. This software is distributed under the
 # Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/math/Coord.h openvdb-6.1.0/openvdb/math/Coord.h
--- openvdb-6.0.0/openvdb/math/Coord.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/math/Coord.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -31,6 +31,7 @@
 #ifndef OPENVDB_MATH_COORD_HAS_BEEN_INCLUDED
 #define OPENVDB_MATH_COORD_HAS_BEEN_INCLUDED
 
+#include <functional>// for std::hash
 #include <algorithm> // for std::min(), std::max()
 #include <array> // for std::array
 #include <iostream>
@@ -249,6 +250,12 @@
         os.write(reinterpret_cast<const char*>(mVec.data()), sizeof(mVec));
     }
 
+    /// @brief Return a hash value for this coordinate
+    /// @note Log2N is the binary logarithm of the hash table size.
+    /// @details The hash function is taken from the SIGGRAPh paper: "VDB: High-resolution sparse volumes with dynamic topology"
+    template <int Log2N = 20>
+    inline size_t hash() const { return ( (1<<Log2N)-1 ) & (mVec[0]*73856093 ^ mVec[1]*19349663 ^ mVec[2]*83492791); }
+
 private:
     std::array<Int32, 3> mVec;
 }; // class Coord
@@ -369,13 +376,23 @@
     bool operator!=(const CoordBBox& rhs) const { return !(*this == rhs); }
 
     /// @brief Return @c true if this bounding box is empty (i.e., encloses no coordinates).
-    bool empty() const { return (mMin[0] > mMax[0] || mMin[1] > mMax[1] || mMin[2] > mMax[2]); }
-    /// Return @c true if this bounding box is nonempty (i.e., encloses at least one coordinate).
+    bool empty() const
+    {
+#if defined(__GNUC__) && !defined(__INTEL_COMPILER)
+  #pragma GCC diagnostic push
+  #pragma GCC diagnostic ignored "-Wstrict-overflow"
+#endif
+        return (mMin[0] > mMax[0] || mMin[1] > mMax[1] || mMin[2] > mMax[2]);
+#if defined(__GNUC__) && !defined(__INTEL_COMPILER)
+  #pragma GCC diagnostic pop
+#endif
+    }
+    /// @brief Return @c true if this bounding box is nonempty (i.e., encloses at least one coordinate).
     operator bool() const { return !this->empty(); }
-    /// Return @c true if this bounding box is nonempty (i.e., encloses at least one coordinate).
+    /// @brief Return @c true if this bounding box is nonempty (i.e., encloses at least one coordinate).
     bool hasVolume() const { return !this->empty(); }
 
-    /// Return the floating-point position of the center of this bounding box.
+    /// @brief Return the floating-point position of the center of this bounding box.
     Vec3d getCenter() const { return 0.5 * Vec3d((mMin + mMax).asPointer()); }
 
     /// @brief Return the dimensions of the coordinates spanned by this bounding box.
@@ -391,7 +408,7 @@
         const Coord d = this->dim();
         return Index64(d[0]) * Index64(d[1]) * Index64(d[2]);
     }
-    /// Return @c true if this bounding box can be subdivided [mainly for use by TBB].
+    /// @brief Return @c true if this bounding box can be subdivided [mainly for use by TBB].
     bool is_divisible() const { return mMin[0]<mMax[0] && mMin[1]<mMax[1] && mMin[2]<mMax[2]; }
 
     /// @brief Return the index (0, 1 or 2) of the shortest axis.
@@ -400,51 +417,51 @@
     /// @brief Return the index (0, 1 or 2) of the longest axis.
     size_t maxExtent() const { return this->dim().maxIndex(); }
 
-    /// Return @c true if point (x, y, z) is inside this bounding box.
+    /// @brief Return @c true if point (x, y, z) is inside this bounding box.
     bool isInside(const Coord& xyz) const
     {
         return !(Coord::lessThan(xyz,mMin) || Coord::lessThan(mMax,xyz));
     }
 
-    /// Return @c true if the given bounding box is inside this bounding box.
+    /// @brief Return @c true if the given bounding box is inside this bounding box.
     bool isInside(const CoordBBox& b) const
     {
         return !(Coord::lessThan(b.mMin,mMin) || Coord::lessThan(mMax,b.mMax));
     }
 
-    /// Return @c true if the given bounding box overlaps with this bounding box.
+    /// @brief Return @c true if the given bounding box overlaps with this bounding box.
     bool hasOverlap(const CoordBBox& b) const
     {
         return !(Coord::lessThan(mMax,b.mMin) || Coord::lessThan(b.mMax,mMin));
     }
 
-    /// Pad this bounding box with the specified padding.
+    /// @brief Pad this bounding box with the specified padding.
     void expand(ValueType padding)
     {
         mMin.offset(-padding);
         mMax.offset( padding);
     }
 
-    /// Return a new instance that is expanded by the specified padding.
+    /// @brief Return a new instance that is expanded by the specified padding.
     CoordBBox expandBy(ValueType padding) const
     {
         return CoordBBox(mMin.offsetBy(-padding),mMax.offsetBy(padding));
     }
 
-    /// Expand this bounding box to enclose point (x, y, z).
+    /// @brief Expand this bounding box to enclose point (x, y, z).
     void expand(const Coord& xyz)
     {
         mMin.minComponent(xyz);
         mMax.maxComponent(xyz);
     }
 
-    /// Union this bounding box with the given bounding box.
+    /// @brief Union this bounding box with the given bounding box.
     void expand(const CoordBBox& bbox)
     {
           mMin.minComponent(bbox.min());
           mMax.maxComponent(bbox.max());
     }
-    /// Intersect this bounding box with the given bounding box.
+    /// @brief Intersect this bounding box with the given bounding box.
     void intersect(const CoordBBox& bbox)
     {
         mMin.maxComponent(bbox.min());
@@ -457,10 +474,16 @@
         mMin.minComponent(min);
         mMax.maxComponent(min.offsetBy(dim-1));
     }
-    /// Translate this bounding box by
+    /// @brief Translate this bounding box by
     /// (<i>t<sub>x</sub></i>, <i>t<sub>y</sub></i>, <i>t<sub>z</sub></i>).
     void translate(const Coord& t) { mMin += t; mMax += t; }
 
+    /// @brief Move this bounding box to the specified min
+    void moveMin(const Coord& min) { mMax += min - mMin; mMin = min; }
+
+    /// @brief Move this bounding box to the specified max
+    void moveMax(const Coord& max) { mMin += max - mMax; mMax = max; }
+
     /// @brief Populates an array with the eight corner points of this bounding box.
     /// @details The ordering of the corner points is lexicographic.
     /// @warning It is assumed that the pointer can be incremented at
@@ -490,9 +513,9 @@
     CoordBBox& operator|= (Coord::Int32 n) { mMin |= n; mMax |= n; return *this; }
     //@}
 
-    /// Unserialize this bounding box from the given stream.
+    /// @brief Unserialize this bounding box from the given stream.
     void read(std::istream& is) { mMin.read(is); mMax.read(is); }
-    /// Serialize this bounding box to the given stream.
+    /// @brief Serialize this bounding box to the given stream.
     void write(std::ostream& os) const { mMin.write(os); mMax.write(os); }
 
 private:
@@ -578,8 +601,25 @@
 } // namespace OPENVDB_VERSION_NAME
 } // namespace openvdb
 
+////////////////////////////////////////
+
+// template specialization of std::hash with Coord, which
+// allows for Coord to be used as the key in std::unordered_map
+namespace std {// injected in namespace std
+
+template<>
+struct hash<openvdb::math::Coord>
+{
+    using Coord = openvdb::math::Coord;
+    using argument_type = Coord;
+    using result_type = std::size_t;
+    std::size_t operator()(const Coord& ijk) const noexcept { return ijk.Coord::hash<>(); }
+};// std::hash<openvdb::math::Coord>
+
+}// namespace std
+
 #endif // OPENVDB_MATH_COORD_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/math/DDA.h openvdb-6.1.0/openvdb/math/DDA.h
--- openvdb-6.0.0/openvdb/math/DDA.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/math/DDA.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -41,8 +41,8 @@
 #include "Math.h"
 #include "Vec3.h"
 #include <openvdb/Types.h>
-#include <iostream>// for std::ostream
-#include <limits>// for std::numeric_limits<Type>::max()
+#include <iostream> // for std::ostream
+#include <limits> // for std::numeric_limits<Type>::max()
 #include <boost/mpl/at.hpp>
 
 namespace openvdb {
@@ -62,10 +62,10 @@
 class DDA
 {
 public:
-    typedef typename RayT::RealType RealType;
-    typedef RealType                RealT;
-    typedef typename RayT::Vec3Type Vec3Type;
-    typedef Vec3Type                Vec3T;
+    using RealType = typename RayT::RealType;
+    using RealT = RealType;
+    using Vec3Type = typename RayT::Vec3Type;
+    using Vec3T = Vec3Type;
 
     /// @brief uninitialized constructor
     DDA() {}
@@ -141,11 +141,11 @@
     /// @brief Print information about this DDA for debugging.
     /// @param os    a stream to which to write textual information.
     void print(std::ostream& os = std::cout) const
-      {
-          os << "Dim=" << (1<<Log2Dim) << " time=" << mT0 << " next()="
-             << this->next() << " voxel=" << mVoxel << " next=" << mNext
-             << " delta=" << mDelta << " step=" << mStep << std::endl;
-      }
+    {
+        os << "Dim=" << (1<<Log2Dim) << " time=" << mT0 << " next()="
+            << this->next() << " voxel=" << mVoxel << " next=" << mNext
+            << " delta=" << mDelta << " step=" << mStep << std::endl;
+    }
 
 private:
     RealT mT0, mT1;
@@ -171,8 +171,8 @@
 template<typename TreeT, int NodeLevel>
 struct LevelSetHDDA
 {
-    typedef typename TreeT::RootNodeType::NodeChainType ChainT;
-    typedef typename boost::mpl::at<ChainT, boost::mpl::int_<NodeLevel> >::type NodeT;
+    using ChainT = typename TreeT::RootNodeType::NodeChainType;
+    using NodeT = typename boost::mpl::at<ChainT, boost::mpl::int_<NodeLevel> >::type;
 
     template <typename TesterT>
     static bool test(TesterT& tester)
@@ -216,9 +216,9 @@
 {
 public:
 
-    typedef typename TreeT::RootNodeType::NodeChainType ChainT;
-    typedef typename boost::mpl::at<ChainT, boost::mpl::int_<ChildNodeLevel> >::type NodeT;
-    typedef typename RayT::TimeSpan TimeSpanT;
+    using ChainT = typename TreeT::RootNodeType::NodeChainType;
+    using NodeT = typename boost::mpl::at<ChainT, boost::mpl::int_<ChildNodeLevel> >::type;
+    using TimeSpanT = typename RayT::TimeSpan;
 
     VolumeHDDA() {}
 
@@ -252,7 +252,7 @@
     {
         mDDA.init(ray);
         do {
-            if (acc.template probeConstNode<NodeT>(mDDA.voxel()) != NULL) {//child node
+            if (acc.template probeConstNode<NodeT>(mDDA.voxel()) != nullptr) {//child node
                 ray.setTimes(mDDA.time(), mDDA.next());
                 if (mHDDA.march(ray, acc, t)) return true;//terminate
             } else if (acc.isValueOn(mDDA.voxel())) {//hit an active tile
@@ -276,7 +276,7 @@
     {
         mDDA.init(ray);
         do {
-            if (acc.template probeConstNode<NodeT>(mDDA.voxel()) != NULL) {//child node
+            if (acc.template probeConstNode<NodeT>(mDDA.voxel()) != nullptr) {//child node
                 ray.setTimes(mDDA.time(), mDDA.next());
                 mHDDA.hits(ray, acc, times, t);
             } else if (acc.isValueOn(mDDA.voxel())) {//hit an active tile
@@ -301,8 +301,8 @@
 {
 public:
 
-    typedef typename TreeT::LeafNodeType LeafT;
-    typedef typename RayT::TimeSpan TimeSpanT;
+    using LeafT = typename TreeT::LeafNodeType;
+    using TimeSpanT = typename RayT::TimeSpan;
 
     VolumeHDDA() {}
 
@@ -370,6 +370,6 @@
 
 #endif // OPENVDB_MATH_DDA_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/math/Mat3.h openvdb-6.1.0/openvdb/math/Mat3.h
--- openvdb-6.0.0/openvdb/math/Mat3.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/math/Mat3.h	2019-05-07 22:58:35.000000000 +0200
@@ -79,15 +79,15 @@
          Source d, Source e, Source f,
          Source g, Source h, Source i)
     {
-        MyBase::mm[0] = static_cast<ValueType>(a);
-        MyBase::mm[1] = static_cast<ValueType>(b);
-        MyBase::mm[2] = static_cast<ValueType>(c);
-        MyBase::mm[3] = static_cast<ValueType>(d);
-        MyBase::mm[4] = static_cast<ValueType>(e);
-        MyBase::mm[5] = static_cast<ValueType>(f);
-        MyBase::mm[6] = static_cast<ValueType>(g);
-        MyBase::mm[7] = static_cast<ValueType>(h);
-        MyBase::mm[8] = static_cast<ValueType>(i);
+        MyBase::mm[0] = static_cast<T>(a);
+        MyBase::mm[1] = static_cast<T>(b);
+        MyBase::mm[2] = static_cast<T>(c);
+        MyBase::mm[3] = static_cast<T>(d);
+        MyBase::mm[4] = static_cast<T>(e);
+        MyBase::mm[5] = static_cast<T>(f);
+        MyBase::mm[6] = static_cast<T>(g);
+        MyBase::mm[7] = static_cast<T>(h);
+        MyBase::mm[8] = static_cast<T>(i);
     } // constructor1Test
 
     /// Construct matrix from rows or columns vectors (defaults to rows
@@ -109,15 +109,15 @@
     template<typename Source>
     Mat3(Source *a)
     {
-        MyBase::mm[0] = a[0];
-        MyBase::mm[1] = a[1];
-        MyBase::mm[2] = a[2];
-        MyBase::mm[3] = a[3];
-        MyBase::mm[4] = a[4];
-        MyBase::mm[5] = a[5];
-        MyBase::mm[6] = a[6];
-        MyBase::mm[7] = a[7];
-        MyBase::mm[8] = a[8];
+        MyBase::mm[0] = static_cast<T>(a[0]);
+        MyBase::mm[1] = static_cast<T>(a[1]);
+        MyBase::mm[2] = static_cast<T>(a[2]);
+        MyBase::mm[3] = static_cast<T>(a[3]);
+        MyBase::mm[4] = static_cast<T>(a[4]);
+        MyBase::mm[5] = static_cast<T>(a[5]);
+        MyBase::mm[6] = static_cast<T>(a[6]);
+        MyBase::mm[7] = static_cast<T>(a[7]);
+        MyBase::mm[8] = static_cast<T>(a[8]);
     } // constructor1Test
 
     /// Copy constructor
diff -aur openvdb-6.0.0/openvdb/math/Mat4.h openvdb-6.1.0/openvdb/math/Mat4.h
--- openvdb-6.0.0/openvdb/math/Mat4.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/math/Mat4.h	2019-05-07 22:58:35.000000000 +0200
@@ -76,7 +76,7 @@
     Mat4(Source *a)
     {
         for (int i = 0; i < 16; i++) {
-            MyBase::mm[i] = a[i];
+            MyBase::mm[i] = static_cast<T>(a[i]);
         }
     }
 
@@ -93,25 +93,25 @@
          Source i, Source j, Source k, Source l,
          Source m, Source n, Source o, Source p)
     {
-        MyBase::mm[ 0] = T(a);
-        MyBase::mm[ 1] = T(b);
-        MyBase::mm[ 2] = T(c);
-        MyBase::mm[ 3] = T(d);
+        MyBase::mm[ 0] = static_cast<T>(a);
+        MyBase::mm[ 1] = static_cast<T>(b);
+        MyBase::mm[ 2] = static_cast<T>(c);
+        MyBase::mm[ 3] = static_cast<T>(d);
 
-        MyBase::mm[ 4] = T(e);
-        MyBase::mm[ 5] = T(f);
-        MyBase::mm[ 6] = T(g);
-        MyBase::mm[ 7] = T(h);
+        MyBase::mm[ 4] = static_cast<T>(e);
+        MyBase::mm[ 5] = static_cast<T>(f);
+        MyBase::mm[ 6] = static_cast<T>(g);
+        MyBase::mm[ 7] = static_cast<T>(h);
 
-        MyBase::mm[ 8] = T(i);
-        MyBase::mm[ 9] = T(j);
-        MyBase::mm[10] = T(k);
-        MyBase::mm[11] = T(l);
+        MyBase::mm[ 8] = static_cast<T>(i);
+        MyBase::mm[ 9] = static_cast<T>(j);
+        MyBase::mm[10] = static_cast<T>(k);
+        MyBase::mm[11] = static_cast<T>(l);
 
-        MyBase::mm[12] = T(m);
-        MyBase::mm[13] = T(n);
-        MyBase::mm[14] = T(o);
-        MyBase::mm[15] = T(p);
+        MyBase::mm[12] = static_cast<T>(m);
+        MyBase::mm[13] = static_cast<T>(n);
+        MyBase::mm[14] = static_cast<T>(o);
+        MyBase::mm[15] = static_cast<T>(p);
     }
 
     /// Construct matrix from rows or columns vectors (defaults to rows
diff -aur openvdb-6.0.0/openvdb/math/Mat.h openvdb-6.1.0/openvdb/math/Mat.h
--- openvdb-6.0.0/openvdb/math/Mat.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/math/Mat.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -811,7 +811,7 @@
 /// @brief Write 0s along Mat4's last row and column, and a 1 on its diagonal.
 /// @details Useful initialization when we're initializing just the 3&times;3 block.
 template<class MatType>
-static MatType&
+inline MatType&
 padMat4(MatType& dest)
 {
     dest[0][3] = dest[1][3] = dest[2][3] = 0;
@@ -1045,6 +1045,6 @@
 
 #endif // OPENVDB_MATH_MAT_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/math/Operators.h openvdb-6.1.0/openvdb/math/Operators.h
--- openvdb-6.0.0/openvdb/math/Operators.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/math/Operators.h	2019-05-07 22:58:35.000000000 +0200
@@ -765,9 +765,14 @@
         using Vec3Type = typename internal::ReturnValue<Accessor>::Vec3Type;
 
         Vec3Type iGradient( ISGradient<CD_2NDT>::result(grid, ijk) );
-        return  Vec3Type(ValueType(iGradient[0] * map.getInvTwiceScale()[0]),
-                         ValueType(iGradient[1] * map.getInvTwiceScale()[1]),
-                         ValueType(iGradient[2] * map.getInvTwiceScale()[2]) );
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+        const auto gradient0 = iGradient[0] * map.getInvTwiceScale()[0];
+        const auto gradient1 = iGradient[1] * map.getInvTwiceScale()[1];
+        const auto gradient2 = iGradient[2] * map.getInvTwiceScale()[2];
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+        return  Vec3Type(ValueType(gradient0),
+                         ValueType(gradient1),
+                         ValueType(gradient2));
     }
 
     // stencil access version
@@ -779,9 +784,14 @@
         using Vec3Type = typename internal::ReturnValue<StencilT>::Vec3Type;
 
         Vec3Type iGradient( ISGradient<CD_2NDT>::result(stencil) );
-        return  Vec3Type(ValueType(iGradient[0] * map.getInvTwiceScale()[0]),
-                         ValueType(iGradient[1] * map.getInvTwiceScale()[1]),
-                         ValueType(iGradient[2] * map.getInvTwiceScale()[2]) );
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+        const auto gradient0 = iGradient[0] * map.getInvTwiceScale()[0];
+        const auto gradient1 = iGradient[1] * map.getInvTwiceScale()[1];
+        const auto gradient2 = iGradient[2] * map.getInvTwiceScale()[2];
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+        return  Vec3Type(ValueType(gradient0),
+                         ValueType(gradient1),
+                         ValueType(gradient2));
     }
 };
 
@@ -799,9 +809,14 @@
         using Vec3Type = typename internal::ReturnValue<Accessor>::Vec3Type;
 
         Vec3Type iGradient( ISGradient<CD_2NDT>::result(grid, ijk) );
-        return  Vec3Type(ValueType(iGradient[0] * map.getInvTwiceScale()[0]),
-                         ValueType(iGradient[1] * map.getInvTwiceScale()[1]),
-                         ValueType(iGradient[2] * map.getInvTwiceScale()[2]) );
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+        const auto gradient0 = iGradient[0] * map.getInvTwiceScale()[0];
+        const auto gradient1 = iGradient[1] * map.getInvTwiceScale()[1];
+        const auto gradient2 = iGradient[2] * map.getInvTwiceScale()[2];
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+        return  Vec3Type(ValueType(gradient0),
+                         ValueType(gradient1),
+                         ValueType(gradient2));
     }
 
     // Stencil access version
@@ -813,9 +828,14 @@
         using Vec3Type = typename internal::ReturnValue<StencilT>::Vec3Type;
 
         Vec3Type iGradient( ISGradient<CD_2NDT>::result(stencil) );
-        return  Vec3Type(ValueType(iGradient[0] * map.getInvTwiceScale()[0]),
-                         ValueType(iGradient[1] * map.getInvTwiceScale()[1]),
-                         ValueType(iGradient[2] * map.getInvTwiceScale()[2]) );
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+        const auto gradient0 = iGradient[0] * map.getInvTwiceScale()[0];
+        const auto gradient1 = iGradient[1] * map.getInvTwiceScale()[1];
+        const auto gradient2 = iGradient[2] * map.getInvTwiceScale()[2];
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+        return  Vec3Type(ValueType(gradient0),
+                         ValueType(gradient1),
+                         ValueType(gradient2));
     }
 };
 //@}
@@ -1596,8 +1616,11 @@
         ValueType iddy = D2<DiffScheme>::inY(grid, ijk);
         ValueType iddz = D2<DiffScheme>::inZ(grid, ijk);
         const Vec3d& invScaleSqr = map.getInvScaleSqr();
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
         // scale them by the appropriate 1/dx^2, 1/dy^2, 1/dz^2 and sum
-        return ValueType(iddx * invScaleSqr[0] + iddy * invScaleSqr[1] + iddz * invScaleSqr[2]);
+        const ValueType value = iddx * invScaleSqr[0] + iddy * invScaleSqr[1] + iddz * invScaleSqr[2];
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+        return value;
     }
 
     // stencil access version
@@ -1611,8 +1634,11 @@
         ValueType iddy = D2<DiffScheme>::inY(stencil);
         ValueType iddz = D2<DiffScheme>::inZ(stencil);
         const Vec3d& invScaleSqr = map.getInvScaleSqr();
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
         // scale them by the appropriate 1/dx^2, 1/dy^2, 1/dz^2 and sum
-        return ValueType(iddx * invScaleSqr[0] + iddy * invScaleSqr[1] + iddz * invScaleSqr[2]);
+        const ValueType value = iddx * invScaleSqr[0] + iddy * invScaleSqr[1] + iddz * invScaleSqr[2];
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+        return value;
     }
 };
 
@@ -1630,8 +1656,11 @@
         ValueType iddy = D2<DiffScheme>::inY(grid, ijk);
         ValueType iddz = D2<DiffScheme>::inZ(grid, ijk);
         const Vec3d& invScaleSqr = map.getInvScaleSqr();
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
         // scale them by the appropriate 1/dx^2, 1/dy^2, 1/dz^2 and sum
-        return ValueType(iddx * invScaleSqr[0] + iddy * invScaleSqr[1] + iddz * invScaleSqr[2]);
+        const ValueType value = iddx * invScaleSqr[0] + iddy * invScaleSqr[1] + iddz * invScaleSqr[2];
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+        return value;
     }
 
     // stencil access version
@@ -1644,8 +1673,11 @@
         ValueType iddy = D2<DiffScheme>::inY(stencil);
         ValueType iddz = D2<DiffScheme>::inZ(stencil);
         const Vec3d& invScaleSqr = map.getInvScaleSqr();
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
         // scale them by the appropriate 1/dx^2, 1/dy^2, 1/dz^2 and sum
-        return ValueType(iddx * invScaleSqr[0] + iddy * invScaleSqr[1] + iddz * invScaleSqr[2]);
+        const ValueType value = iddx * invScaleSqr[0] + iddy * invScaleSqr[1] + iddz * invScaleSqr[2];
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+        return value;
     }
 };
 
diff -aur openvdb-6.0.0/openvdb/math/Quat.h openvdb-6.1.0/openvdb/math/Quat.h
--- openvdb-6.0.0/openvdb/math/Quat.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/math/Quat.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -105,6 +105,10 @@
 class Quat
 {
 public:
+    using value_type = T;
+    using ValueType = T;
+    static const int size = 4;
+
     /// Trivial constructor, the quaternion is NOT initialized
     Quat() {}
 
@@ -653,6 +657,6 @@
 
 #endif //OPENVDB_MATH_QUAT_H_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/math/Stencils.h openvdb-6.1.0/openvdb/math/Stencils.h
--- openvdb-6.0.0/openvdb/math/Stencils.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/math/Stencils.h	2019-05-07 22:58:35.000000000 +0200
@@ -159,7 +159,7 @@
     {
         ValueType sum = 0.0;
         for (int n = 0, s = int(mStencil.size()); n < s; ++n) sum += mStencil[n];
-        return sum / mStencil.size();
+        return sum / ValueType(mStencil.size());
     }
 
     /// @brief Return the smallest value in the stencil buffer.
@@ -334,9 +334,15 @@
     ///     + v100 u(1-v)(1-w)     + v101 u(1-v)w     + v110 uv(1-w)     + v111 uvw
     inline ValueType interpolation(const math::Vec3<ValueType>& xyz) const
     {
-        const ValueType u = xyz[0] - BaseType::mCenter[0]; assert(u>=0 && u<=1);
-        const ValueType v = xyz[1] - BaseType::mCenter[1]; assert(v>=0 && v<=1);
-        const ValueType w = xyz[2] - BaseType::mCenter[2]; assert(w>=0 && w<=1);
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+        const ValueType u = xyz[0] - BaseType::mCenter[0];
+        const ValueType v = xyz[1] - BaseType::mCenter[1];
+        const ValueType w = xyz[2] - BaseType::mCenter[2];
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+
+        assert(u>=0 && u<=1);
+        assert(v>=0 && v<=1);
+        assert(w>=0 && w<=1);
 
         ValueType V = BaseType::template getValue<0,0,0>();
         ValueType A = static_cast<ValueType>(V + (BaseType::template getValue<0,0,1>() - V) * w);
@@ -362,9 +368,15 @@
     ///     + v100 u(1-v)(1-w)     + v101 u(1-v)w     + v110 uv(1-w)     + v111 uvw
     inline math::Vec3<ValueType> gradient(const math::Vec3<ValueType>& xyz) const
     {
-        const ValueType u = xyz[0] - BaseType::mCenter[0]; assert(u>=0 && u<=1);
-        const ValueType v = xyz[1] - BaseType::mCenter[1]; assert(v>=0 && v<=1);
-        const ValueType w = xyz[2] - BaseType::mCenter[2]; assert(w>=0 && w<=1);
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+        const ValueType u = xyz[0] - BaseType::mCenter[0];
+        const ValueType v = xyz[1] - BaseType::mCenter[1];
+        const ValueType w = xyz[2] - BaseType::mCenter[2];
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+
+        assert(u>=0 && u<=1);
+        assert(v>=0 && v<=1);
+        assert(w>=0 && w<=1);
 
         ValueType D[4]={BaseType::template getValue<0,0,1>()-BaseType::template getValue<0,0,0>(),
                         BaseType::template getValue<0,1,1>()-BaseType::template getValue<0,1,0>(),
@@ -1307,17 +1319,20 @@
     {
         const Coord& ijk = BaseType::getCenterCoord();
         const ValueType d = ValueType(mStencil[0] * 0.5 * mInvDx2); // distance in voxels / (2dx^2)
-        return math::Vec3<ValueType>(ijk[0] - d*(mStencil[2] - mStencil[1]),
-                                     ijk[1] - d*(mStencil[4] - mStencil[3]),
-                                     ijk[2] - d*(mStencil[6] - mStencil[5]));
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+        const auto value = math::Vec3<ValueType>(   ijk[0] - d*(mStencil[2] - mStencil[1]),
+                                                    ijk[1] - d*(mStencil[4] - mStencil[3]),
+                                                    ijk[2] - d*(mStencil[6] - mStencil[5]));
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+        return value;
     }
 
     /// Return linear offset for the specified stencil point relative to its center
     template<int i, int j, int k>
     unsigned int pos() const { return GradPt<i,j,k>::idx; }
-    
+
 private:
-    
+
     inline void init(const Coord& ijk)
     {
         BaseType::template setValue<-1, 0, 0>(mCache.getValue(ijk.offsetBy(-1, 0, 0)));
@@ -1329,7 +1344,7 @@
         BaseType::template setValue< 0, 0,-1>(mCache.getValue(ijk.offsetBy( 0, 0,-1)));
         BaseType::template setValue< 0, 0, 1>(mCache.getValue(ijk.offsetBy( 0, 0, 1)));
     }
-    
+
     template<typename, typename, bool> friend class BaseStencil; // allow base class to call init()
     using BaseType::mCache;
     using BaseType::mStencil;
diff -aur openvdb-6.0.0/openvdb/math/Vec2.h openvdb-6.1.0/openvdb/math/Vec2.h
--- openvdb-6.0.0/openvdb/math/Vec2.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/math/Vec2.h	2019-05-07 22:58:35.000000000 +0200
@@ -70,8 +70,8 @@
     template <typename Source>
     Vec2(Source *a)
     {
-        this->mm[0] = a[0];
-        this->mm[1] = a[1];
+        this->mm[0] = static_cast<T>(a[0]);
+        this->mm[1] = static_cast<T>(a[1]);
     } // trivial
 
     /// Conversion constructor
diff -aur openvdb-6.0.0/openvdb/math/Vec3.h openvdb-6.1.0/openvdb/math/Vec3.h
--- openvdb-6.0.0/openvdb/math/Vec3.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/math/Vec3.h	2019-05-07 22:58:35.000000000 +0200
@@ -71,9 +71,9 @@
     template <typename Source>
     Vec3(Source *a)
     {
-        this->mm[0] = a[0];
-        this->mm[1] = a[1];
-        this->mm[2] = a[2];
+        this->mm[0] = static_cast<T>(a[0]);
+        this->mm[1] = static_cast<T>(a[1]);
+        this->mm[2] = static_cast<T>(a[2]);
     }
 
     /// @brief Construct a Vec3 from a 3-Tuple with a possibly different value type.
@@ -265,9 +265,14 @@
     template <typename S>
     const Vec3<T> &operator*=(S scalar)
     {
-        this->mm[0] = static_cast<T>(this->mm[0] * scalar);
-        this->mm[1] = static_cast<T>(this->mm[1] * scalar);
-        this->mm[2] = static_cast<T>(this->mm[2] * scalar);
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+        const auto value0 = this->mm[0] * scalar;
+        const auto value1 = this->mm[1] * scalar;
+        const auto value2 = this->mm[2] * scalar;
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+        this->mm[0] = static_cast<T>(value0);
+        this->mm[1] = static_cast<T>(value1);
+        this->mm[2] = static_cast<T>(value2);
         return *this;
     }
 
@@ -305,9 +310,14 @@
     template <typename S>
     const Vec3<T> &operator+=(S scalar)
     {
-        this->mm[0] = static_cast<T>(this->mm[0] + scalar);
-        this->mm[1] = static_cast<T>(this->mm[1] + scalar);
-        this->mm[2] = static_cast<T>(this->mm[2] + scalar);
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+        const auto value0 = this->mm[0] + scalar;
+        const auto value1 = this->mm[1] + scalar;
+        const auto value2 = this->mm[2] + scalar;
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+        this->mm[0] = static_cast<T>(value0);
+        this->mm[1] = static_cast<T>(value1);
+        this->mm[2] = static_cast<T>(value2);
         return *this;
     }
 
diff -aur openvdb-6.0.0/openvdb/math/Vec4.h openvdb-6.1.0/openvdb/math/Vec4.h
--- openvdb-6.0.0/openvdb/math/Vec4.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/math/Vec4.h	2019-05-07 22:58:35.000000000 +0200
@@ -73,10 +73,10 @@
     template <typename Source>
     Vec4(Source *a)
     {
-        this->mm[0] = a[0];
-        this->mm[1] = a[1];
-        this->mm[2] = a[2];
-        this->mm[3] = a[3];
+        this->mm[0] = static_cast<T>(a[0]);
+        this->mm[1] = static_cast<T>(a[1]);
+        this->mm[2] = static_cast<T>(a[2]);
+        this->mm[3] = static_cast<T>(a[3]);
     }
 
     /// Conversion constructor
diff -aur openvdb-6.0.0/openvdb/Metadata.h openvdb-6.1.0/openvdb/Metadata.h
--- openvdb-6.0.0/openvdb/Metadata.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/Metadata.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -417,6 +417,9 @@
 using Vec3DMetadata  = TypedMetadata<Vec3d>;
 using Vec3IMetadata  = TypedMetadata<Vec3i>;
 using Vec3SMetadata  = TypedMetadata<Vec3s>;
+using Vec4DMetadata  = TypedMetadata<Vec4d>;
+using Vec4IMetadata  = TypedMetadata<Vec4i>;
+using Vec4SMetadata  = TypedMetadata<Vec4s>;
 using Mat4SMetadata  = TypedMetadata<Mat4s>;
 using Mat4DMetadata  = TypedMetadata<Mat4d>;
 
@@ -460,6 +463,6 @@
 
 #endif // OPENVDB_METADATA_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/openvdb.cc openvdb-6.1.0/openvdb/openvdb.cc
--- openvdb-6.0.0/openvdb/openvdb.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/openvdb.cc	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -74,6 +74,9 @@
     Vec3IMetadata::registerType();
     Vec3SMetadata::registerType();
     Vec3DMetadata::registerType();
+    Vec4IMetadata::registerType();
+    Vec4SMetadata::registerType();
+    Vec4DMetadata::registerType();
     Mat4SMetadata::registerType();
     Mat4DMetadata::registerType();
 
@@ -168,6 +171,6 @@
 } // namespace OPENVDB_VERSION_NAME
 } // namespace openvdb
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/Platform.h openvdb-6.1.0/openvdb/Platform.h
--- openvdb-6.0.0/openvdb/Platform.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/Platform.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -37,6 +37,26 @@
 
 #define PRAGMA(x) _Pragma(#x)
 
+/// @name Utilities
+/// @{
+/// @cond OPENVDB_VERSION_INTERNAL
+#define OPENVDB_PREPROC_STRINGIFY_(x) #x
+/// @endcond
+/// @brief Return @a x as a string literal.  If @a x is a macro,
+/// return its value as a string literal.
+/// @hideinitializer
+#define OPENVDB_PREPROC_STRINGIFY(x) OPENVDB_PREPROC_STRINGIFY_(x)
+
+/// @cond OPENVDB_VERSION_INTERNAL
+#define OPENVDB_PREPROC_CONCAT_(x, y) x ## y
+/// @endcond
+/// @brief Form a new token by concatenating two existing tokens.
+/// If either token is a macro, concatenate its value.
+/// @hideinitializer
+#define OPENVDB_PREPROC_CONCAT(x, y) OPENVDB_PREPROC_CONCAT_(x, y)
+/// @}
+
+
 /// Use OPENVDB_DEPRECATED to mark functions as deprecated.
 /// It should be placed right before the signature of the function,
 /// e.g., "OPENVDB_DEPRECATED void functionName();".
@@ -131,6 +151,80 @@
 #endif
 
 
+/// @brief Bracket code with OPENVDB_NO_DEPRECATION_WARNING_BEGIN/_END,
+/// to inhibit warnings about deprecated code.
+/// @note Use this sparingly.  Remove references to deprecated code if at all possible.
+/// @details Example:
+/// @code
+/// OPENVDB_DEPRECATED void myDeprecatedFunction() {}
+///
+/// {
+///     OPENVDB_NO_DEPRECATION_WARNING_BEGIN
+///     myDeprecatedFunction();
+///     OPENVDB_NO_DEPRECATION_WARNING_END
+/// }
+/// @endcode
+#if defined __INTEL_COMPILER
+    #define OPENVDB_NO_DEPRECATION_WARNING_BEGIN \
+        _Pragma("warning (push)") \
+        _Pragma("warning (disable:1478)") \
+        PRAGMA(message("NOTE: ignoring deprecation warning at " __FILE__  \
+            ":" OPENVDB_PREPROC_STRINGIFY(__LINE__)))
+    #define OPENVDB_NO_DEPRECATION_WARNING_END \
+        _Pragma("warning (pop)")
+#elif defined __clang__
+    #define OPENVDB_NO_DEPRECATION_WARNING_BEGIN \
+        _Pragma("clang diagnostic push") \
+        _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
+        // note: no #pragma message, since Clang treats them as warnings
+    #define OPENVDB_NO_DEPRECATION_WARNING_END \
+        _Pragma("clang diagnostic pop")
+#elif defined __GNUC__
+    #define OPENVDB_NO_DEPRECATION_WARNING_BEGIN \
+        _Pragma("GCC diagnostic push") \
+        _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"") \
+        _Pragma("message(\"NOTE: ignoring deprecation warning\")")
+    #define OPENVDB_NO_DEPRECATION_WARNING_END \
+        _Pragma("GCC diagnostic pop")
+#else
+    #define OPENVDB_NO_DEPRECATION_WARNING_BEGIN
+    #define OPENVDB_NO_DEPRECATION_WARNING_END
+#endif
+
+
+/// @brief Bracket code with OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN/_END,
+/// to inhibit warnings about type conversion.
+/// @note Use this sparingly.  Use static casts and explicit type conversion if at all possible.
+/// @details Example:
+/// @code
+/// float value = 0.1f;
+/// OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+/// int valueAsInt = value;
+/// OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+/// @endcode
+#if defined __INTEL_COMPILER
+    #define OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+    #define OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+#elif defined __GNUC__
+    // -Wfloat-conversion was only introduced in GCC 4.9
+    #if OPENVDB_CHECK_GCC(4, 9)
+        #define OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN \
+            _Pragma("GCC diagnostic push") \
+            _Pragma("GCC diagnostic ignored \"-Wconversion\"") \
+            _Pragma("GCC diagnostic ignored \"-Wfloat-conversion\"")
+    #else
+        #define OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN \
+            _Pragma("GCC diagnostic push") \
+            _Pragma("GCC diagnostic ignored \"-Wconversion\"")
+    #endif
+    #define OPENVDB_NO_TYPE_CONVERSION_WARNING_END \
+        _Pragma("GCC diagnostic pop")
+#else
+    #define OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+    #define OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+#endif
+
+
 #ifdef _MSC_VER
     /// Visual C++ does not have constants like M_PI unless this is defined.
     /// @note This is needed even though the core library is built with this but
@@ -204,6 +298,6 @@
 
 #endif // OPENVDB_PLATFORM_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/points/AttributeArray.cc openvdb-6.1.0/openvdb/points/AttributeArray.cc
--- openvdb-6.0.0/openvdb/points/AttributeArray.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/points/AttributeArray.cc	2019-05-07 22:58:35.000000000 +0200
@@ -193,8 +193,8 @@
     this->loadData();
     other.loadData();
 
-    if(this->mSerializationFlags != other.mSerializationFlags ||
-       this->mFlags != other.mFlags) return false;
+    if (this->mUsePagedRead != other.mUsePagedRead ||
+        this->mFlags != other.mFlags) return false;
     return this->isEqual(other);
 }
 
diff -aur openvdb-6.0.0/openvdb/points/AttributeArray.h openvdb-6.1.0/openvdb/points/AttributeArray.h
--- openvdb-6.0.0/openvdb/points/AttributeArray.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/points/AttributeArray.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -148,7 +148,11 @@
 
     template <typename ValueType, typename CodecType> friend class AttributeHandle;
 
-    AttributeArray() : mPageHandle() { }
+#if OPENVDB_ABI_VERSION_NUMBER >= 5
+    AttributeArray(): mPageHandle() { mOutOfCore = 0; }
+#else
+    AttributeArray(): mPageHandle() {}
+#endif
     virtual ~AttributeArray()
     {
         // if this AttributeArray has been partially read, zero the compressed bytes,
@@ -159,7 +163,7 @@
     AttributeArray(const AttributeArray& rhs)
         : mIsUniform(rhs.mIsUniform)
         , mFlags(rhs.mFlags)
-        , mSerializationFlags(rhs.mSerializationFlags)
+        , mUsePagedRead(rhs.mUsePagedRead)
         , mOutOfCore(rhs.mOutOfCore)
         , mPageHandle()
     {
@@ -173,7 +177,7 @@
         if (mFlags & PARTIALREAD)       mCompressedBytes = 0;
         mIsUniform = rhs.mIsUniform;
         mFlags = rhs.mFlags;
-        mSerializationFlags = rhs.mSerializationFlags;
+        mUsePagedRead = rhs.mUsePagedRead;
         mOutOfCore = rhs.mOutOfCore;
         if (mFlags & PARTIALREAD)       mCompressedBytes = rhs.mCompressedBytes;
         else if (rhs.mPageHandle)       mPageHandle = rhs.mPageHandle->copy();
@@ -188,9 +192,11 @@
     AttributeArray& operator=(AttributeArray&&) = default;
 
     /// Return a copy of this attribute.
+    /// @note This method is thread-safe.
     virtual AttributeArray::Ptr copy() const = 0;
 
     /// Return an uncompressed copy of this attribute (will return a copy if not compressed).
+    /// @note This method is thread-safe.
     virtual AttributeArray::Ptr copyUncompressed() const = 0;
 
     /// Return the number of elements in this array.
@@ -285,9 +291,13 @@
     /// and both value types are floating-point or both integer.
     /// @note It is possible to use this method to write to a uniform target array
     /// if the iterator does not have non-zero target indices.
+    /// @note This method is not thread-safe, it must be guaranteed that this array is not
+    /// concurrently modified by another thread and that the source array is also not modified.
     template<typename IterT>
     void copyValuesUnsafe(const AttributeArray& sourceArray, const IterT& iter);
     /// @brief Like copyValuesUnsafe(), but if @a compact is true, attempt to collapse this array.
+    /// @note This method is not thread-safe, it must be guaranteed that this array is not
+    /// concurrently modified by another thread and that the source array is also not modified.
     template<typename IterT>
     void copyValues(const AttributeArray& sourceArray, const IterT& iter, bool compact = true);
 #endif
@@ -414,19 +424,19 @@
 
     size_t mCompressedBytes = 0;
     uint8_t mFlags = 0;
-    uint8_t mSerializationFlags = 0;
+    uint8_t mUsePagedRead = 0;
 #if OPENVDB_ABI_VERSION_NUMBER >= 5
-    tbb::atomic<Index32> mOutOfCore = 0; // interpreted as bool
+    tbb::atomic<Index32> mOutOfCore; // interpreted as bool
 #endif
     compression::PageHandle::Ptr mPageHandle;
 
 #else // #if OPENVDB_ABI_VERSION_NUMBER < 6
 
     bool mIsUniform = true;
-    tbb::spin_mutex mMutex;
+    mutable tbb::spin_mutex mMutex;
     uint8_t mFlags = 0;
-    uint8_t mSerializationFlags = 0;
-    tbb::atomic<Index32> mOutOfCore = 0; // interpreted as bool
+    uint8_t mUsePagedRead = 0;
+    tbb::atomic<Index32> mOutOfCore; // interpreted as bool
     /// used for out-of-core, paged reading
     union {
         compression::PageHandle::Ptr mPageHandle;
@@ -589,21 +599,25 @@
     /// Default constructor, always constructs a uniform attribute.
     explicit TypedAttributeArray(Index n = 1, Index strideOrTotalSize = 1, bool constantStride = true,
         const ValueType& uniformValue = zeroVal<ValueType>());
-    /// Deep copy constructor (optionally decompress during copy).
+    /// Deep copy constructor.
+    /// @note not thread-safe, use TypedAttributeArray::copy() to ensure thread-safety
     TypedAttributeArray(const TypedAttributeArray&, bool uncompress = false);
     /// Deep copy assignment operator.
+    /// @note this operator is thread-safe.
     TypedAttributeArray& operator=(const TypedAttributeArray&);
     /// Move constructor disabled.
     TypedAttributeArray(TypedAttributeArray&&) = delete;
     /// Move assignment operator disabled.
     TypedAttributeArray& operator=(TypedAttributeArray&&) = delete;
 
-    virtual ~TypedAttributeArray() { this->deallocate(); }
+    ~TypedAttributeArray() override { this->deallocate(); }
 
     /// Return a copy of this attribute.
+    /// @note This method is thread-safe.
     AttributeArray::Ptr copy() const override;
 
     /// Return an uncompressed copy of this attribute (will just return a copy if not compressed).
+    /// @note This method is thread-safe.
     AttributeArray::Ptr copyUncompressed() const override;
 
     /// Return a new attribute array of the given length @a n and @a stride with uniform value zero.
@@ -818,7 +832,7 @@
     Index                               mStrideOrTotalSize;
 #if OPENVDB_ABI_VERSION_NUMBER < 6 // as of ABI=6, this data lives in the base class to reduce memory
     bool                                mIsUniform = true;
-    tbb::spin_mutex                     mMutex;
+    mutable tbb::spin_mutex             mMutex;
 #endif
 }; // class TypedAttributeArray
 
@@ -1105,6 +1119,12 @@
     // if the target array is uniform, expand it first
     this->expand();
 
+    // TODO: Acquire mutex locks for source and target arrays to ensure that
+    // value copying is always thread-safe. Note that the unsafe method will be
+    // faster, but can only be used if neither the source or target arrays are
+    // modified during copying. Note that this will require a new private
+    // virtual method with ABI=7 to access the mutex from the derived class.
+
     this->doCopyValues(sourceArray, iter, true);
 
     // attempt to compact target array
@@ -1172,12 +1192,14 @@
 TypedAttributeArray<ValueType_, Codec_>::operator=(const TypedAttributeArray& rhs)
 {
     if (&rhs != this) {
+        // lock both the source and target arrays to ensure thread-safety
         tbb::spin_mutex::scoped_lock lock(mMutex);
+        tbb::spin_mutex::scoped_lock rhsLock(rhs.mMutex);
 
         this->deallocate();
 
         mFlags = rhs.mFlags;
-        mSerializationFlags = rhs.mSerializationFlags;
+        mUsePagedRead = rhs.mUsePagedRead;
         mSize = rhs.mSize;
         mStrideOrTotalSize = rhs.mStrideOrTotalSize;
         mIsUniform = rhs.mIsUniform;
@@ -1257,6 +1279,7 @@
 AttributeArray::Ptr
 TypedAttributeArray<ValueType_, Codec_>::copy() const
 {
+    tbb::spin_mutex::scoped_lock lock(mMutex);
     return AttributeArray::Ptr(new TypedAttributeArray<ValueType, Codec>(*this));
 }
 
@@ -1265,6 +1288,7 @@
 AttributeArray::Ptr
 TypedAttributeArray<ValueType_, Codec_>::copyUncompressed() const
 {
+    tbb::spin_mutex::scoped_lock lock(mMutex);
     return AttributeArray::Ptr(new TypedAttributeArray<ValueType, Codec>(*this, /*decompress = */true));
 }
 
@@ -1689,7 +1713,6 @@
 
     uint8_t serializationFlags = uint8_t(0);
     is.read(reinterpret_cast<char*>(&serializationFlags), sizeof(uint8_t));
-    mSerializationFlags = serializationFlags;
 
     Index size = Index(0);
     is.read(reinterpret_cast<char*>(&size), sizeof(Index));
@@ -1701,19 +1724,20 @@
     }
     // error if an unknown serialization flag has been set,
     // as this will adjust the layout of the data and corrupt the ability to read
-    if (mSerializationFlags >= 0x10) {
+    if (serializationFlags >= 0x10) {
         OPENVDB_THROW(IoError, "Unknown attribute serialization flags for VDB file format.");
     }
 
-    // read uniform and compressed state
+    // set uniform, compressed and page read state
 
-    mIsUniform = mSerializationFlags & WRITEUNIFORM;
+    mIsUniform = serializationFlags & WRITEUNIFORM;
+    mUsePagedRead = serializationFlags & WRITEPAGED;
     mCompressedBytes = bytes;
     mFlags |= PARTIALREAD; // mark data as having been partially read
 
     // read strided value (set to 1 if array is not strided)
 
-    if (mSerializationFlags & WRITESTRIDED) {
+    if (serializationFlags & WRITESTRIDED) {
         Index stride = Index(0);
         is.read(reinterpret_cast<char*>(&stride), sizeof(Index));
         mStrideOrTotalSize = stride;
@@ -1728,7 +1752,7 @@
 void
 TypedAttributeArray<ValueType_, Codec_>::readBuffers(std::istream& is)
 {
-    if ((mSerializationFlags & WRITEPAGED)) {
+    if (mUsePagedRead) {
         // use readBuffers(PagedInputStream&) for paged buffers
         OPENVDB_THROW(IoError, "Cannot read paged AttributeArray buffers.");
     }
@@ -1760,11 +1784,6 @@
     // set data to buffer
 
     mData.reset(reinterpret_cast<StorageType*>(buffer.release()));
-
-    // clear all write flags
-
-    if (mIsUniform)     mSerializationFlags &= uint8_t(~WRITEUNIFORM & ~WRITEMEMCOMPRESS & ~WRITEPAGED);
-    else                mSerializationFlags &= uint8_t(~WRITEUNIFORM & ~WRITEPAGED);
 }
 
 
@@ -1772,7 +1791,7 @@
 void
 TypedAttributeArray<ValueType_, Codec_>::readPagedBuffers(compression::PagedInputStream& is)
 {
-    if (!(mSerializationFlags & WRITEPAGED)) {
+    if (!mUsePagedRead) {
         if (!is.sizeOnly()) this->readBuffers(is.getInputStream());
         return;
     }
@@ -1806,10 +1825,9 @@
         mData.reset(reinterpret_cast<StorageType*>(buffer.release()));
     }
 
-    // clear all write flags
+    // clear page state
 
-    if (mIsUniform)     mSerializationFlags &= uint8_t(~WRITEUNIFORM & ~WRITEMEMCOMPRESS & ~WRITEPAGED);
-    else                mSerializationFlags &= uint8_t(~WRITEUNIFORM & ~WRITEPAGED);
+    mUsePagedRead = 0;
 }
 
 
@@ -1969,6 +1987,7 @@
     auto* self = const_cast<TypedAttributeArray<ValueType_, Codec_>*>(this);
 
     assert(self->mPageHandle);
+    assert(!(self->mFlags & PARTIALREAD));
 
     std::unique_ptr<char[]> buffer = self->mPageHandle->read();
 
@@ -1983,7 +2002,6 @@
 #else
     self->mFlags &= uint8_t(~OUTOFCORE);
 #endif
-    self->mSerializationFlags &= uint8_t(~WRITEUNIFORM & ~WRITEMEMCOMPRESS & ~WRITEPAGED);
 }
 
 
@@ -2011,7 +2029,7 @@
     if(this->mSize != otherT->mSize ||
        this->mStrideOrTotalSize != otherT->mStrideOrTotalSize ||
        this->mIsUniform != otherT->mIsUniform ||
-       *this->sTypeName != *otherT->sTypeName) return false;
+       this->attributeType() != this->attributeType()) return false;
 
     this->doLoad();
     otherT->doLoad();
@@ -2301,6 +2319,6 @@
 
 #endif // OPENVDB_POINTS_ATTRIBUTE_ARRAY_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/points/AttributeArrayString.cc openvdb-6.1.0/openvdb/points/AttributeArrayString.cc
--- openvdb-6.0.0/openvdb/points/AttributeArrayString.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/points/AttributeArrayString.cc	2019-05-07 22:58:35.000000000 +0200
@@ -35,7 +35,9 @@
 #include <openvdb/Metadata.h>
 #include <openvdb/MetaMap.h>
 
-#include <sstream>
+#include <tbb/parallel_sort.h>
+
+#include <string>
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -45,7 +47,7 @@
 
 namespace {
 
-    bool isStringMeta(const Name& key, const Metadata::Ptr& meta)
+    bool isStringMeta(const Name& key, const Metadata::ConstPtr& meta)
     {
         // ensure the metadata is StringMetadata
         if (meta->typeName() != "string")           return false;
@@ -57,21 +59,14 @@
 
     Name getStringKey(const StringIndexType index)
     {
-        std::stringstream ss;
-        ss << "string:" << (index - 1);
-        return ss.str();
+        return "string:" + std::to_string(index - 1);
     }
 
     StringIndexType getStringIndex(const Name& key)
     {
-        Name indexStr = key.substr(7, key.size() - 7);
-
+        const Name indexStr = key.substr(7, key.size() - 7);
         // extract the index as an unsigned integer
-        std::istringstream indexSS(indexStr);
-        Index index;
-        indexSS >> index;
-
-        return (index + 1);
+        return static_cast<StringIndexType>(std::stoul(indexStr)) + 1;
     }
 
 } // namespace
@@ -85,6 +80,8 @@
 
 StringMetaInserter::StringMetaInserter(MetaMap& metadata)
     : mMetadata(metadata)
+    , mIdBlocks()
+    , mValues()
 {
     // populate the cache
     resetCache();
@@ -93,54 +90,113 @@
 
 void StringMetaInserter::insert(const Name& name)
 {
-    // name already exists, so do nothing
+    using IterT = std::vector<std::pair<Index, Index>>::iterator;
+
+    // if name already exists, do nothing
 
-    if (std::binary_search(mValues.begin(), mValues.end(), name))  return;
+    if (mValues.count(name))  return;
 
-    // find first unused index in the cache
+    // look through the id blocks for the next available index
 
     Index index = 1;
-    for (const Index& idx : mIndices) {
-        if (idx != index)   break;
-        ++index;
+    IterT iter = mIdBlocks.begin();
+    for (; iter != mIdBlocks.end(); ++iter) {
+        const Index start = iter->first;
+        const Index end = start + iter->second;
+
+        if (index < start || index >= end) break;
+        index = end;
+    }
+
+    // index now holds the next valid index. if it's 1 (the beginning
+    // iterator) no initial block exists - add it
+
+    IterT block;
+    if (iter == mIdBlocks.begin()) {
+        block = mIdBlocks.insert(iter, {1, 1});
+        iter = std::next(block);
+    }
+    else {
+        // accumulate the id block size where the next index is going
+        block = std::prev(iter);
+        block->second += 1;
+    }
+
+    // see if this block and the next block can be compacted
+
+    if (iter != mIdBlocks.end() &&
+        block->second + 1 == iter->first) {
+        block->second += iter->second;
+        mIdBlocks.erase(iter);
     }
 
-    // now insert into metadata
+    // insert into metadata
 
     const Name key = getStringKey(index);
     mMetadata.insertMeta(key, StringMetadata(name));
 
-    // finally update the caches (insertion sort)
+    // update the cache
 
-    mIndices.insert(std::upper_bound(mIndices.begin(), mIndices.end(), index), index);
-    mValues.insert(std::upper_bound(mValues.begin(), mValues.end(), name), name);
+    mValues.emplace(name);
 }
 
 
 void StringMetaInserter::resetCache()
 {
-    mIndices.clear();
     mValues.clear();
+    mIdBlocks.clear();
+
+    std::vector<Index> stringIndices;
 
     for (auto it = mMetadata.beginMeta(), itEnd = mMetadata.endMeta(); it != itEnd; ++it) {
         const Name& key = it->first;
-        const Metadata::Ptr meta = it->second;
+        const Metadata::ConstPtr meta = it->second;
 
         // ensure the metadata is StringMetadata and key starts "string:"
         if (!isStringMeta(key, meta))   continue;
 
-        // extract index and add to cache
-        Index index = getStringIndex(key);
-        mIndices.push_back(index);
+        // extract index
+        stringIndices.emplace_back(getStringIndex(key));
 
         // extract value from metadata and add to cache
-        StringMetadata* stringMeta = static_cast<StringMetadata*>(meta.get());
+        const StringMetadata* stringMeta = static_cast<const StringMetadata*>(meta.get());
         assert(stringMeta);
-        mValues.push_back(stringMeta->value());
+        mValues.insert(stringMeta->value());
+    }
+
+    if (stringIndices.empty()) return;
+
+    tbb::parallel_sort(stringIndices.begin(), stringIndices.end());
+
+    // bucket string indices
+
+    Index key = stringIndices.front();
+    Index size = 0;
+
+    // For each id, see if it's adjacent id is sequentially increasing and continue to
+    // track how many are until we find a value that isn't. Store the start and length
+    // of each of these blocks. For example, the following container could be created
+    // consisting of 3 elements:
+    //   key  ->  size
+    //   -------------
+    //   7    ->  1000  (values 7->1007)
+    //   1020 ->  5     (values 1020->1025)
+    //   2013 ->  30    (values 2013->2043)
+    // Note that the end value is exclusive (values 1007, 1025 and 2043 do not exist
+    // given the above example)
+
+    for (const Index id : stringIndices) {
+        if (key + size != id) {
+            assert(size > 0);
+            mIdBlocks.emplace_back(key, size);
+            size = 0;
+            key = id;
+        }
+        ++size;
     }
 
-    std::sort(mIndices.begin(), mIndices.end());
-    std::sort(mValues.begin(), mValues.end());
+    // add the last block
+    mIdBlocks.emplace_back(key, size);
 }
 
 
@@ -200,6 +256,11 @@
     name = meta->value();
 }
 
+const AttributeArray& StringAttributeHandle::array() const
+{
+    return mHandle.array();
+}
+
 
 ////////////////////////////////////////
 
@@ -295,7 +356,21 @@
 }
 
 
-Index StringAttributeWriteHandle::getIndex(const Name& name)
+AttributeArray& StringAttributeWriteHandle::array()
+{
+    return mWriteHandle.array();
+}
+
+
+bool StringAttributeWriteHandle::contains(const Name& name) const
+{
+    // empty strings always have an index at index zero
+    if (name.empty())   return true;
+    return mCache.find(name) != mCache.end();
+}
+
+
+Index StringAttributeWriteHandle::getIndex(const Name& name) const
 {
     // zero used for an empty string
     if (name.empty())   return Index(0);
diff -aur openvdb-6.0.0/openvdb/points/AttributeArrayString.h openvdb-6.1.0/openvdb/points/AttributeArrayString.h
--- openvdb-6.0.0/openvdb/points/AttributeArrayString.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/points/AttributeArrayString.h	2019-05-07 22:58:35.000000000 +0200
@@ -39,6 +39,8 @@
 
 #include "AttributeArray.h"
 #include <memory>
+#include <unordered_set>
+#include <unordered_map>
 
 
 namespace openvdb {
@@ -93,8 +95,8 @@
 
 private:
     MetaMap& mMetadata;
-    std::vector<Index> mIndices;
-    std::vector<Name> mValues;
+    std::vector<std::pair<Index, Index>> mIdBlocks;
+    std::unordered_set<Name> mValues;
 }; // StringMetaInserter
 
 
@@ -142,12 +144,18 @@
                             const MetaMap& metadata,
                             const bool preserveCompression = true);
 
+    Index stride() const { return mHandle.stride(); }
     Index size() const { return mHandle.size(); }
+
     bool isUniform() const { return mHandle.isUniform(); }
+    bool hasConstantStride() const { return mHandle.hasConstantStride(); }
 
     Name get(Index n, Index m = 0) const;
     void get(Name& name, Index n, Index m = 0) const;
 
+    /// @brief Returns a reference to the array held in the Handle.
+    const AttributeArray& array() const;
+
 protected:
     AttributeHandle<StringIndexType, StringCodec<false>>    mHandle;
     const MetaMap&                                          mMetadata;
@@ -192,12 +200,19 @@
     /// Reset the value cache from the metadata
     void resetCache();
 
+    /// @brief Returns a reference to the array held in the Write Handle.
+    AttributeArray& array();
+
+    /// @brief  Returns whether or not the metadata cache contains a given value.
+    /// @param  name Name of the String.
+    bool contains(const Name& name) const;
+
 private:
     /// Retrieve the index of this string value from the cache
     /// @note throws if name does not exist in cache
-    Index getIndex(const Name& name);
+    Index getIndex(const Name& name) const;
 
-    using ValueMap = std::map<std::string, Index>;
+    using ValueMap = std::unordered_map<std::string, Index>;
 
     ValueMap                                                    mCache;
     AttributeWriteHandle<StringIndexType, StringCodec<false>>   mWriteHandle;
diff -aur openvdb-6.0.0/openvdb/points/AttributeSet.cc openvdb-6.1.0/openvdb/points/AttributeSet.cc
--- openvdb-6.0.0/openvdb/points/AttributeSet.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/points/AttributeSet.cc	2019-05-07 22:58:35.000000000 +0200
@@ -96,11 +96,16 @@
 {
     for (const auto& namePos : mDescr->map()) {
         const size_t& pos = namePos.second;
-        AttributeArray::Ptr array = AttributeArray::create(mDescr->type(pos), arrayLength, 1);
+        const AttributeArray* existingArray = attrSet.getConst(pos);
+        const bool constantStride = existingArray->hasConstantStride();
+        const Index stride = constantStride ? existingArray->stride() : existingArray->dataSize();
+
+        AttributeArray::Ptr array = AttributeArray::create(mDescr->type(pos), arrayLength,
+            stride, constantStride);
 
         // transfer hidden and transient flags
-        if (attrSet.getConst(pos)->isHidden())      array->setHidden(true);
-        if (attrSet.getConst(pos)->isTransient())   array->setTransient(true);
+        if (existingArray->isHidden())      array->setHidden(true);
+        if (existingArray->isTransient())   array->setTransient(true);
 
         mAttrs[pos] = array;
     }
diff -aur openvdb-6.0.0/openvdb/points/IndexFilter.h openvdb-6.1.0/openvdb/points/IndexFilter.h
--- openvdb-6.0.0/openvdb/points/IndexFilter.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/points/IndexFilter.h	2019-05-07 22:58:35.000000000 +0200
@@ -280,7 +280,7 @@
                 mLeafMap[iter->origin()] = SeedCountPair(dist(generator), leafPoints);
                 break;
             }
-            totalPointsFloat += factor * iter->pointCount();
+            totalPointsFloat += factor * static_cast<float>(iter->pointCount());
             const auto leafPoints = static_cast<int>(math::Floor(totalPointsFloat));
             totalPointsFloat -= static_cast<float>(leafPoints);
             totalPoints += leafPoints;
diff -aur openvdb-6.0.0/openvdb/points/PointConversion.h openvdb-6.1.0/openvdb/points/PointConversion.h
--- openvdb-6.0.0/openvdb/points/PointConversion.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/points/PointConversion.h	2019-05-07 22:58:35.000000000 +0200
@@ -278,107 +278,6 @@
     }
 }; // ConversionTraits<openvdb::Name>
 
-
-template<typename PointDataTreeType, typename PointIndexTreeType>
-struct InitialiseAttributesOp {
-
-    using LeafManagerT          = typename tree::LeafManager<PointDataTreeType>;
-    using LeafRangeT            = typename LeafManagerT::LeafRange;
-
-    using PointIndexLeafNode    = typename PointIndexTreeType::LeafNodeType;
-    using IndexArray            = typename PointIndexLeafNode::IndexArray;
-
-    InitialiseAttributesOp( const PointIndexTreeType& pointIndexTree,
-                            const AttributeSet::Descriptor::Ptr& attributeDescriptor)
-        : mPointIndexTree(pointIndexTree)
-        , mAttributeDescriptor(attributeDescriptor) { }
-
-    void operator()(const typename LeafManagerT::LeafRange& range) const {
-        for (auto leaf = range.begin(); leaf; ++leaf) {
-
-            // obtain the PointIndexLeafNode (using the origin of the current leaf)
-
-            const PointIndexLeafNode* pointIndexLeaf = mPointIndexTree.probeConstLeaf(leaf->origin());
-
-            if (!pointIndexLeaf)    continue;
-
-            // initialise the attribute storage
-
-            const IndexArray& indices = pointIndexLeaf->indices();
-
-            auto pointCount = static_cast<Index>(indices.size());
-
-            leaf->initializeAttributes(mAttributeDescriptor, pointCount);
-        }
-    }
-
-    //////////
-
-    const PointIndexTreeType&               mPointIndexTree;
-    const AttributeSet::Descriptor::Ptr&    mAttributeDescriptor;
-};
-
-template<   typename PointDataTreeType,
-            typename PointIndexTreeType,
-            typename PositionListType>
-struct PopulatePositionAttributeOp {
-
-    using LeafManagerT          = typename tree::LeafManager<PointDataTreeType>;
-    using LeafRangeT            = typename LeafManagerT::LeafRange;
-
-    using PointIndexLeafNode    = typename PointIndexTreeType::LeafNodeType;
-    using IndexArray            = typename PointIndexLeafNode::IndexArray;
-
-    using ValueType             = typename PositionListType::value_type;
-
-    PopulatePositionAttributeOp(const PointIndexTreeType& pointIndexTree,
-                                const math::Transform& transform,
-                                const PositionListType& positions)
-        : mPointIndexTree(pointIndexTree)
-        , mTransform(transform)
-        , mPositions(positions) { }
-
-    void operator()(const typename LeafManagerT::LeafRange& range) const {
-
-        for (auto leaf = range.begin(); leaf; ++leaf) {
-
-            // obtain the PointIndexLeafNode (using the origin of the current leaf)
-
-            const PointIndexLeafNode* pointIndexLeaf = mPointIndexTree.probeConstLeaf(leaf->origin());
-
-            if (!pointIndexLeaf)    continue;
-
-            auto attributeWriteHandle = AttributeWriteHandle<Vec3f>::create(leaf->attributeArray("P"));
-
-            Index64 index = 0;
-
-            const IndexArray& indices = pointIndexLeaf->indices();
-
-            for (const Index64 i: indices) {
-                ValueType positionWorldSpace;
-                mPositions.getPos(i, positionWorldSpace);
-
-                const ValueType positionIndexSpace = mTransform.worldToIndex(positionWorldSpace);
-
-                const ValueType positionVoxelSpace = ValueType(
-                            positionIndexSpace.x() - math::Round(positionIndexSpace.x()),
-                            positionIndexSpace.y() - math::Round(positionIndexSpace.y()),
-                            positionIndexSpace.z() - math::Round(positionIndexSpace.z()));
-
-                attributeWriteHandle->set(static_cast<Index>(index), Vec3f(positionVoxelSpace));
-
-                index++;
-            }
-        }
-    }
-
-    //////////
-
-    const PointIndexTreeType&   mPointIndexTree;
-    const math::Transform&      mTransform;
-    const PositionListType&     mPositions;
-};
-
 template<   typename PointDataTreeType,
             typename PointIndexTreeType,
             typename AttributeListType>
@@ -745,24 +644,19 @@
                     const math::Transform& xform, Metadata::Ptr positionDefaultValue)
 {
     using PointDataTreeT        = typename PointDataGridT::TreeType;
-    using PointIndexTreeT       = typename PointIndexGridT::TreeType;
+    using LeafT                 = typename PointDataTree::LeafNodeType;
+    using PointIndexLeafT       = typename PointIndexGridT::TreeType::LeafNodeType;
+    using PointIndexT           = typename PointIndexLeafT::ValueType;
     using LeafManagerT          = typename tree::LeafManager<PointDataTreeT>;
-    using LeafRangeT            = typename LeafManagerT::LeafRange;
     using PositionAttributeT    = TypedAttributeArray<Vec3f, CompressionT>;
 
-    using point_conversion_internal::InitialiseAttributesOp;
-    using point_conversion_internal::PopulatePositionAttributeOp;
-
     const NamePair positionType = PositionAttributeT::attributeType();
 
     // construct the Tree using a topology copy of the PointIndexGrid
 
-    const PointIndexTreeT& pointIndexTree(pointIndexGrid.tree());
+    const auto& pointIndexTree = pointIndexGrid.tree();
     typename PointDataTreeT::Ptr treePtr(new PointDataTreeT(pointIndexTree));
 
-    LeafManagerT leafManager = LeafManagerT(*treePtr);
-    LeafRangeT leafRange = leafManager.leafRange();
-
     // create attribute descriptor from position type
 
     auto descriptor = AttributeSet::Descriptor::create(positionType);
@@ -771,21 +665,68 @@
 
     if (positionDefaultValue)   descriptor->setDefaultValue("P", *positionDefaultValue);
 
-    // create point attribute storage on each leaf
+    // retrieve position index
 
-    InitialiseAttributesOp<PointDataTreeT, PointIndexTreeT> initialise(
-                                pointIndexGrid.tree(), descriptor);
-    tbb::parallel_for(leafRange, initialise);
+    const size_t positionIndex = descriptor->find("P");
+    assert(positionIndex != AttributeSet::INVALID_POS);
 
     // populate position attribute
 
-    PopulatePositionAttributeOp<PointDataTreeT,
-                                PointIndexTreeT,
-                                PositionArrayT> populate(pointIndexTree,
-                                                        xform,
-                                                        positions);
+    LeafManagerT leafManager(*treePtr);
+    leafManager.foreach(
+        [&](LeafT& leaf, size_t /*idx*/) {
 
-    tbb::parallel_for(leafRange, populate);
+            // obtain the PointIndexLeafNode (using the origin of the current leaf)
+
+            const auto* pointIndexLeaf = pointIndexTree.probeConstLeaf(leaf.origin());
+            assert(pointIndexLeaf);
+
+            // initialise the attribute storage
+
+            Index pointCount(static_cast<Index>(pointIndexLeaf->indices().size()));
+            leaf.initializeAttributes(descriptor, pointCount);
+
+            // create write handle for position
+
+            auto attributeWriteHandle = AttributeWriteHandle<Vec3f, CompressionT>::create(
+                leaf.attributeArray(positionIndex));
+
+            Index index = 0;
+
+            const PointIndexT
+                *begin = static_cast<PointIndexT*>(nullptr),
+                *end = static_cast<PointIndexT*>(nullptr);
+
+            // iterator over every active voxel in the point index leaf
+
+            for (auto iter = pointIndexLeaf->cbeginValueOn(); iter; ++iter) {
+
+                // find the voxel center
+
+                const Coord& ijk = iter.getCoord();
+                const Vec3d& positionCellCenter(ijk.asVec3d());
+
+                // obtain pointers for this voxel from begin to end in the indices array
+
+                pointIndexLeaf->getIndices(ijk, begin, end);
+
+                while (begin < end) {
+
+                    typename PositionArrayT::value_type positionWorldSpace;
+                    positions.getPos(*begin, positionWorldSpace);
+
+                    // compute the index-space position and then subtract the voxel center
+
+                    const Vec3d positionIndexSpace = xform.worldToIndex(positionWorldSpace);
+                    const Vec3f positionVoxelSpace(positionIndexSpace - positionCellCenter);
+
+                    attributeWriteHandle->set(index++, positionVoxelSpace);
+
+                    ++begin;
+                }
+            }
+        },
+    /*threaded=*/true);
 
     auto grid = PointDataGridT::create(treePtr);
     grid->setTransform(xform.copy());
@@ -1082,7 +1023,7 @@
 
         previousVoxelCount = voxelCount;
         voxelCount = mask->activeVoxelCount();
-        volume = math::Pow3(voxelSize) * voxelCount;
+        volume = math::Pow3(voxelSize) * static_cast<float>(voxelCount);
 
         // stop if no change in the volume or the volume has increased
 
diff -aur openvdb-6.0.0/openvdb/points/PointDataGrid.h openvdb-6.1.0/openvdb/points/PointDataGrid.h
--- openvdb-6.0.0/openvdb/points/PointDataGrid.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/points/PointDataGrid.h	2019-05-07 22:58:35.000000000 +0200
@@ -407,12 +407,18 @@
     void validateOffsets() const;
 
     /// @brief Read-write attribute array reference from index
+    /// @details Attribute arrays can be shared across leaf nodes, so non-const
+    /// access will deep-copy the array to make it unique. Always prefer
+    /// accessing const arrays where possible to eliminate this copying.
     /// {
     AttributeArray& attributeArray(const size_t pos);
     const AttributeArray& attributeArray(const size_t pos) const;
     const AttributeArray& constAttributeArray(const size_t pos) const;
     /// }
     /// @brief Read-write attribute array reference from name
+    /// @details Attribute arrays can be shared across leaf nodes, so non-const
+    /// access will deep-copy the array to make it unique. Always prefer
+    /// accessing const arrays where possible to eliminate this copying.
     /// {
     AttributeArray& attributeArray(const Name& attributeName);
     const AttributeArray& attributeArray(const Name& attributeName) const;
@@ -695,18 +701,18 @@
     /// @brief Leaf index iterator
     IndexAllIter beginIndexAll() const
     {
-	NullFilter filter;
-	return this->beginIndex<ValueAllCIter, NullFilter>(filter);
+        NullFilter filter;
+        return this->beginIndex<ValueAllCIter, NullFilter>(filter);
     }
     IndexOnIter beginIndexOn() const
     {
-	NullFilter filter;
-	return this->beginIndex<ValueOnCIter, NullFilter>(filter);
+        NullFilter filter;
+        return this->beginIndex<ValueOnCIter, NullFilter>(filter);
     }
     IndexOffIter beginIndexOff() const
     {
-	NullFilter filter;
-	return this->beginIndex<ValueOffCIter, NullFilter>(filter);
+        NullFilter filter;
+        return this->beginIndex<ValueOffCIter, NullFilter>(filter);
     }
 
     template<typename IterT, typename FilterT>
@@ -716,17 +722,17 @@
     template<typename FilterT>
     IndexIter<ValueAllCIter, FilterT> beginIndexAll(const FilterT& filter) const
     {
-	return this->beginIndex<ValueAllCIter, FilterT>(filter);
+        return this->beginIndex<ValueAllCIter, FilterT>(filter);
     }
     template<typename FilterT>
     IndexIter<ValueOnCIter, FilterT> beginIndexOn(const FilterT& filter) const
     {
-	return this->beginIndex<ValueOnCIter, FilterT>(filter);
+        return this->beginIndex<ValueOnCIter, FilterT>(filter);
     }
     template<typename FilterT>
     IndexIter<ValueOffCIter, FilterT> beginIndexOff(const FilterT& filter) const
     {
-	return this->beginIndex<ValueOffCIter, FilterT>(filter);
+        return this->beginIndex<ValueOffCIter, FilterT>(filter);
     }
 
     /// @brief Leaf index iterator from voxel
diff -aur openvdb-6.0.0/openvdb/points/PointGroup.h openvdb-6.1.0/openvdb/points/PointGroup.h
--- openvdb-6.0.0/openvdb/points/PointGroup.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/points/PointGroup.h	2019-05-07 22:58:35.000000000 +0200
@@ -46,6 +46,8 @@
 #include "PointAttribute.h"
 #include "PointCount.h"
 
+#include <tbb/parallel_reduce.h>
+
 #include <algorithm>
 #include <random>
 #include <string>
@@ -696,15 +698,9 @@
 {
     using Descriptor    = AttributeSet::Descriptor;
     using LeafManagerT  = typename tree::template LeafManager<PointDataTree>;
-
-    if (membership.size() != pointCount(tree)) {
-        OPENVDB_THROW(LookupError, "Membership vector size must match number of points.");
-    }
-
     using point_group_internal::SetGroupFromIndexOp;
 
     auto iter = tree.cbeginLeaf();
-
     if (!iter)  return;
 
     const AttributeSet& attributeSet = iter->attributeSet();
@@ -714,19 +710,47 @@
         OPENVDB_THROW(LookupError, "Group must exist on Tree before defining membership.");
     }
 
+    {
+        // Check that that the largest index in the PointIndexTree is smaller than the size
+        // of the membership vector. The index tree will be used to lookup membership
+        // values. If the index tree was constructed with nan positions, this index will
+        // differ from the PointDataTree count
+
+        using IndexTreeManager = tree::LeafManager<const PointIndexTree>;
+        IndexTreeManager leafManager(indexTree);
+
+        const int64_t max = tbb::parallel_reduce(leafManager.leafRange(), -1,
+            [](const typename IndexTreeManager::LeafRange& range, int64_t value) -> int64_t {
+                for (auto leaf = range.begin(); leaf; ++leaf) {
+                    auto it = std::max_element(leaf->indices().begin(), leaf->indices().end());
+                    value = std::max(value, static_cast<int64_t>(*it));
+                }
+                return value;
+            },
+            [](const int64_t a, const int64_t b) {
+                return std::max(a, b);
+            }
+        );
+
+        if (max != -1 && membership.size() <= static_cast<size_t>(max)) {
+            OPENVDB_THROW(IndexError, "Group membership vector size must be larger than "
+                " the maximum index within the provided index tree.");
+        }
+    }
+
     const Descriptor::GroupIndex index = attributeSet.groupIndex(group);
     LeafManagerT leafManager(tree);
 
     // set membership
 
     if (remove) {
-        SetGroupFromIndexOp<PointDataTree,
-                            PointIndexTree, false> set(indexTree, membership, index);
+        SetGroupFromIndexOp<PointDataTree, PointIndexTree, true>
+            set(indexTree, membership, index);
         tbb::parallel_for(leafManager.leafRange(), set);
     }
     else {
-        SetGroupFromIndexOp<PointDataTree,
-                            PointIndexTree, true> set(indexTree, membership, index);
+        SetGroupFromIndexOp<PointDataTree, PointIndexTree, false>
+            set(indexTree, membership, index);
         tbb::parallel_for(leafManager.leafRange(), set);
     }
 }
@@ -830,7 +854,7 @@
     using RandomFilter =  RandomLeafFilter<PointDataTree, std::mt19937>;
 
     const int currentPoints = static_cast<int>(pointCount(tree));
-    const int targetPoints = int(math::Round((percentage * currentPoints)/100.0f));
+    const int targetPoints = int(math::Round((percentage * float(currentPoints))/100.0f));
 
     RandomFilter filter(tree, targetPoints, seed);
 
diff -aur openvdb-6.0.0/openvdb/points/PointMove.h openvdb-6.1.0/openvdb/points/PointMove.h
--- openvdb-6.0.0/openvdb/points/PointMove.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/points/PointMove.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -175,7 +175,6 @@
     friend class ::TestPointMove;
 
     Cache& mCache;
-    LeafVecT mLocalLeafVec;
     const LeafVecT* mLeafVec = nullptr;
     const LeafMapT* mLeafMap = nullptr;
 }; // class CachedDeformer
@@ -186,26 +185,378 @@
 
 namespace point_move_internal {
 
+using IndexArray = std::vector<Index>;
 
 using IndexTriple = std::tuple<LeafIndex, Index, Index>;
 using IndexTripleArray = tbb::concurrent_vector<IndexTriple>;
 using GlobalPointIndexMap = std::vector<IndexTripleArray>;
+using GlobalPointIndexIndices = std::vector<IndexArray>;
 
 using IndexPair = std::pair<Index, Index>;
 using IndexPairArray = std::vector<IndexPair>;
 using LocalPointIndexMap = std::vector<IndexPairArray>;
 
-using IndexArray = std::vector<Index>;
-
 using LeafIndexArray = std::vector<LeafIndex>;
 using LeafOffsetArray = std::vector<LeafIndexArray>;
 using LeafMap = std::map<Coord, LeafIndex>;
 
-// TODO: The following infrastructure - ArrayProcessor, PerformTypedMoveOp, processTypedArray()
+
+template <typename DeformerT, typename TreeT, typename FilterT>
+struct BuildMoveMapsOp
+{
+    using LeafT = typename TreeT::LeafNodeType;
+    using LeafArrayT = std::vector<LeafT*>;
+    using LeafManagerT = typename tree::LeafManager<TreeT>;
+
+    BuildMoveMapsOp(const DeformerT& deformer,
+                    GlobalPointIndexMap& globalMoveLeafMap,
+                    LocalPointIndexMap& localMoveLeafMap,
+                    const LeafMap& targetLeafMap,
+                    const math::Transform& targetTransform,
+                    const math::Transform& sourceTransform,
+                    const FilterT& filter)
+        : mDeformer(deformer)
+        , mGlobalMoveLeafMap(globalMoveLeafMap)
+        , mLocalMoveLeafMap(localMoveLeafMap)
+        , mTargetLeafMap(targetLeafMap)
+        , mTargetTransform(targetTransform)
+        , mSourceTransform(sourceTransform)
+        , mFilter(filter) { }
+
+    void operator()(LeafT& leaf, size_t idx) const
+    {
+        DeformerT deformer(mDeformer);
+        deformer.reset(leaf, idx);
+
+        // determine source leaf node origin and offset in the source leaf vector
+
+        Coord sourceLeafOrigin = leaf.origin();
+
+        auto sourceHandle = AttributeWriteHandle<Vec3f>::create(leaf.attributeArray("P"));
+
+        for (auto iter = leaf.beginIndexOn(mFilter); iter; iter++) {
+
+            const bool useIndexSpace = DeformerTraits<DeformerT>::IndexSpace;
+
+            // extract index-space position and apply index-space deformation (if applicable)
+
+            Vec3d positionIS = sourceHandle->get(*iter) + iter.getCoord().asVec3d();
+            if (useIndexSpace) {
+               deformer.apply(positionIS, iter);
+            }
+
+            // transform to world-space position and apply world-space deformation (if applicable)
+
+            Vec3d positionWS = mSourceTransform.indexToWorld(positionIS);
+            if (!useIndexSpace) {
+                deformer.apply(positionWS, iter);
+            }
+
+            // transform to index-space position of target grid
+
+            positionIS = mTargetTransform.worldToIndex(positionWS);
+
+            // determine target voxel and offset
+
+            Coord targetVoxel = Coord::round(positionIS);
+            Index targetOffset = LeafT::coordToOffset(targetVoxel);
+
+            // set new local position in source transform space (if point has been deformed)
+
+            Vec3d voxelPosition(positionIS - targetVoxel.asVec3d());
+            sourceHandle->set(*iter, voxelPosition);
+
+            // determine target leaf node origin and offset in the target leaf vector
+
+            Coord targetLeafOrigin = targetVoxel & ~(LeafT::DIM - 1);
+            assert(mTargetLeafMap.find(targetLeafOrigin) != mTargetLeafMap.end());
+            const LeafIndex targetLeafOffset(mTargetLeafMap.at(targetLeafOrigin));
+
+            // insert into move map based on whether point ends up in a new leaf node or not
+
+            if (targetLeafOrigin == sourceLeafOrigin) {
+                mLocalMoveLeafMap[targetLeafOffset].emplace_back(targetOffset, *iter);
+            }
+            else {
+                mGlobalMoveLeafMap[targetLeafOffset].push_back(IndexTriple(
+                    LeafIndex(static_cast<LeafIndex>(idx)), targetOffset, *iter));
+            }
+        }
+    }
+
+private:
+    const DeformerT& mDeformer;
+    GlobalPointIndexMap& mGlobalMoveLeafMap;
+    LocalPointIndexMap& mLocalMoveLeafMap;
+    const LeafMap& mTargetLeafMap;
+    const math::Transform& mTargetTransform;
+    const math::Transform& mSourceTransform;
+    const FilterT& mFilter;
+}; // struct BuildMoveMapsOp
+
+template <typename LeafT>
+inline Index
+indexOffsetFromVoxel(const Index voxelOffset, const LeafT& leaf, IndexArray& offsets)
+{
+    // compute the target point index by summing the point index of the previous
+    // voxel with the current number of points added to this voxel, tracked by the
+    // offsets array
+
+    Index targetOffset = offsets[voxelOffset]++;
+    if (voxelOffset > 0) {
+        targetOffset += static_cast<Index>(leaf.getValue(voxelOffset - 1));
+    }
+    return targetOffset;
+}
+
+
+#if OPENVDB_ABI_VERSION_NUMBER >= 6
+
+
+template <typename TreeT>
+struct GlobalMovePointsOp
+{
+    using LeafT = typename TreeT::LeafNodeType;
+    using LeafArrayT = std::vector<LeafT*>;
+    using LeafManagerT = typename tree::LeafManager<TreeT>;
+    using AttributeArrays = std::vector<AttributeArray*>;
+
+    GlobalMovePointsOp(LeafOffsetArray& offsetMap,
+                       LeafManagerT& sourceLeafManager,
+                       const Index attributeIndex,
+                       const GlobalPointIndexMap& moveLeafMap,
+                       const GlobalPointIndexIndices& moveLeafIndices)
+        : mOffsetMap(offsetMap)
+        , mSourceLeafManager(sourceLeafManager)
+        , mAttributeIndex(attributeIndex)
+        , mMoveLeafMap(moveLeafMap)
+        , mMoveLeafIndices(moveLeafIndices) { }
+
+    // A CopyIterator is designed to use the indices in a GlobalPointIndexMap for this leaf
+    // and match the interface required for AttributeArray::copyValues()
+    struct CopyIterator
+    {
+        CopyIterator(const LeafT& leaf, const IndexArray& sortedIndices,
+            const IndexTripleArray& moveIndices, IndexArray& offsets)
+            : mLeaf(leaf)
+            , mSortedIndices(sortedIndices)
+            , mMoveIndices(moveIndices)
+            , mOffsets(offsets) { }
+
+        operator bool() const { return bool(mIt); }
+
+        void reset(Index startIndex, Index endIndex)
+        {
+            mIndex = startIndex;
+            mEndIndex = endIndex;
+            this->advance();
+        }
+
+        CopyIterator& operator++()
+        {
+            this->advance();
+            return *this;
+        }
+
+        Index leafIndex(Index i) const
+        {
+            if (i < mSortedIndices.size()) {
+                return std::get<0>(this->leafIndexTriple(i));
+            }
+            return std::numeric_limits<Index>::max();
+        }
+
+        Index sourceIndex() const
+        {
+            assert(mIt);
+            return std::get<2>(*mIt);
+        }
+
+        Index targetIndex() const
+        {
+            assert(mIt);
+            return indexOffsetFromVoxel(std::get<1>(*mIt), mLeaf, mOffsets);
+        }
+
+    private:
+        void advance()
+        {
+            if (mIndex >= mEndIndex || mIndex >= mSortedIndices.size()) {
+                mIt = nullptr;
+            }
+            else {
+                mIt = &this->leafIndexTriple(mIndex);
+            }
+            ++mIndex;
+        }
+
+        const IndexTriple& leafIndexTriple(Index i) const
+        {
+            return mMoveIndices[mSortedIndices[i]];
+        }
+
+    private:
+        const LeafT& mLeaf;
+        Index mIndex;
+        Index mEndIndex;
+        const IndexArray& mSortedIndices;
+        const IndexTripleArray& mMoveIndices;
+        IndexArray& mOffsets;
+        const IndexTriple* mIt = nullptr;
+    }; // struct CopyIterator
+
+    void operator()(LeafT& leaf, size_t idx) const
+    {
+        const IndexTripleArray& moveIndices = mMoveLeafMap[idx];
+        if (moveIndices.empty())  return;
+        const IndexArray& sortedIndices = mMoveLeafIndices[idx];
+
+        // extract per-voxel offsets for this leaf
+
+        LeafIndexArray& offsets = mOffsetMap[idx];
+
+        // extract target array and ensure data is out-of-core and non-uniform
+
+        auto& targetArray = leaf.attributeArray(mAttributeIndex);
+        targetArray.loadData();
+        targetArray.expand();
+
+        // perform the copy
+
+        CopyIterator copyIterator(leaf, sortedIndices, moveIndices, offsets);
+
+        // use the sorted indices to track the index of the source leaf
+
+        Index sourceLeafIndex = copyIterator.leafIndex(0);
+        Index startIndex = 0;
+
+        for (size_t i = 1; i <= sortedIndices.size(); i++) {
+            Index endIndex = static_cast<Index>(i);
+            Index newSourceLeafIndex = copyIterator.leafIndex(endIndex);
+
+            // when it changes, do a batch-copy of all the indices that lie within this range
+            // TODO: this step could use nested parallelization for cases where there are a
+            // large number of points being moved per attribute
+
+            if (newSourceLeafIndex > sourceLeafIndex) {
+                copyIterator.reset(startIndex, endIndex);
+
+                const LeafT& sourceLeaf = mSourceLeafManager.leaf(sourceLeafIndex);
+                const auto& sourceArray = sourceLeaf.constAttributeArray(mAttributeIndex);
+                sourceArray.loadData();
+
+                targetArray.copyValuesUnsafe(sourceArray, copyIterator);
+
+                sourceLeafIndex = newSourceLeafIndex;
+                startIndex = endIndex;
+            }
+        }
+    }
+
+private:
+    LeafOffsetArray& mOffsetMap;
+    LeafManagerT& mSourceLeafManager;
+    const Index mAttributeIndex;
+    const GlobalPointIndexMap& mMoveLeafMap;
+    const GlobalPointIndexIndices& mMoveLeafIndices;
+}; // struct GlobalMovePointsOp
+
+
+template <typename TreeT>
+struct LocalMovePointsOp
+{
+    using LeafT = typename TreeT::LeafNodeType;
+    using LeafArrayT = std::vector<LeafT*>;
+    using LeafManagerT = typename tree::LeafManager<TreeT>;
+    using AttributeArrays = std::vector<AttributeArray*>;
+
+    LocalMovePointsOp( LeafOffsetArray& offsetMap,
+                       const LeafIndexArray& sourceIndices,
+                       LeafManagerT& sourceLeafManager,
+                       const Index attributeIndex,
+                       const LocalPointIndexMap& moveLeafMap)
+        : mOffsetMap(offsetMap)
+        , mSourceIndices(sourceIndices)
+        , mSourceLeafManager(sourceLeafManager)
+        , mAttributeIndex(attributeIndex)
+        , mMoveLeafMap(moveLeafMap) { }
+
+    // A CopyIterator is designed to use the indices in a LocalPointIndexMap for this leaf
+    // and match the interface required for AttributeArray::copyValues()
+    struct CopyIterator
+    {
+        CopyIterator(const LeafT& leaf, const IndexPairArray& indices, IndexArray& offsets)
+            : mLeaf(leaf)
+            , mIndices(indices)
+            , mOffsets(offsets) { }
+
+        operator bool() const { return mIndex < static_cast<int>(mIndices.size()); }
+
+        CopyIterator& operator++() { ++mIndex; return *this; }
+
+        Index sourceIndex() const
+        {
+            return mIndices[mIndex].second;
+        }
+
+        Index targetIndex() const
+        {
+            return indexOffsetFromVoxel(mIndices[mIndex].first, mLeaf, mOffsets);
+        }
+
+    private:
+        const LeafT& mLeaf;
+        const IndexPairArray& mIndices;
+        IndexArray& mOffsets;
+        int mIndex = 0;
+    }; // struct CopyIterator
+
+    void operator()(LeafT& leaf, size_t idx) const
+    {
+        const IndexPairArray& moveIndices = mMoveLeafMap[idx];
+        if (moveIndices.empty())  return;
+
+        // extract per-voxel offsets for this leaf
+
+        LeafIndexArray& offsets = mOffsetMap[idx];
+
+        // extract source array that has the same origin as the target leaf
+
+        assert(idx < mSourceIndices.size());
+        const Index sourceLeafOffset(mSourceIndices[idx]);
+        LeafT& sourceLeaf = mSourceLeafManager.leaf(sourceLeafOffset);
+        const auto& sourceArray = sourceLeaf.constAttributeArray(mAttributeIndex);
+        sourceArray.loadData();
+
+        // extract target array and ensure data is out-of-core and non-uniform
+
+        auto& targetArray = leaf.attributeArray(mAttributeIndex);
+        targetArray.loadData();
+        targetArray.expand();
+
+        // perform the copy
+
+        CopyIterator copyIterator(leaf, moveIndices, offsets);
+        targetArray.copyValuesUnsafe(sourceArray, copyIterator);
+    }
+
+private:
+    LeafOffsetArray& mOffsetMap;
+    const LeafIndexArray& mSourceIndices;
+    LeafManagerT& mSourceLeafManager;
+    const Index mAttributeIndex;
+    const LocalPointIndexMap& mMoveLeafMap;
+}; // struct LocalMovePointsOp
+
+
+#else
+
+
+// The following infrastructure - ArrayProcessor, PerformTypedMoveOp, processTypedArray()
 // is required to improve AttributeArray copying performance beyond using the virtual function
-// AttributeArray::set(Index, AttributeArray&, Index), however an ABI=6+ addition to AttributeArray
-// could eliminate this cost for the typical case where ValueType and CodecType are the same in
-// source and target arrays, as they are here.
+// AttributeArray::set(Index, AttributeArray&, Index). An ABI=6 addition to AttributeArray
+// improves this by introducing an AttributeArray::copyValues() method to significantly
+// simplify this logic without incurring the same virtual function cost.
 
 
 /// Helper class used internally by processTypedArray()
@@ -220,6 +571,7 @@
     }
 };
 
+
 /// @brief Utility function that, given a generic attribute array,
 /// calls a functor with the fully-resolved value type of the array
 template<typename ArrayType, typename OpType>
@@ -315,7 +667,7 @@
         CacheHandleOp op(mHandles);
 
         for (auto leaf = range.begin(); leaf; ++leaf) {
-            auto& array = leaf->attributeArray(attributeIndex);
+            const auto& array = leaf->constAttributeArray(attributeIndex);
             processTypedArray(array, op);
         }
     }
@@ -325,114 +677,6 @@
 }; // struct AttributeHandles
 
 
-template <typename DeformerT, typename TreeT, typename FilterT>
-struct BuildMoveMapsOp
-{
-    using LeafT = typename TreeT::LeafNodeType;
-    using LeafArrayT = std::vector<LeafT*>;
-    using LeafManagerT = typename tree::LeafManager<TreeT>;
-
-    BuildMoveMapsOp(const DeformerT& deformer,
-                    GlobalPointIndexMap& globalMoveLeafMap,
-                    LocalPointIndexMap& localMoveLeafMap,
-                    const LeafMap& targetLeafMap,
-                    const math::Transform& targetTransform,
-                    const math::Transform& sourceTransform,
-                    const FilterT& filter)
-        : mDeformer(deformer)
-        , mGlobalMoveLeafMap(globalMoveLeafMap)
-        , mLocalMoveLeafMap(localMoveLeafMap)
-        , mTargetLeafMap(targetLeafMap)
-        , mTargetTransform(targetTransform)
-        , mSourceTransform(sourceTransform)
-        , mFilter(filter) { }
-
-    void operator()(LeafT& leaf, size_t idx) const
-    {
-        DeformerT deformer(mDeformer);
-        deformer.reset(leaf, idx);
-
-        // determine source leaf node origin and offset in the source leaf vector
-
-        Coord sourceLeafOrigin = leaf.origin();
-
-        auto sourceHandle = AttributeWriteHandle<Vec3f>::create(leaf.attributeArray("P"));
-
-        for (auto iter = leaf.beginIndexOn(mFilter); iter; iter++) {
-
-            const bool useIndexSpace = DeformerTraits<DeformerT>::IndexSpace;
-
-            // extract index-space position and apply index-space deformation (if applicable)
-
-            Vec3d positionIS = sourceHandle->get(*iter) + iter.getCoord().asVec3d();
-            if (useIndexSpace) {
-               deformer.apply(positionIS, iter);
-            }
-
-            // transform to world-space position and apply world-space deformation (if applicable)
-
-            Vec3d positionWS = mSourceTransform.indexToWorld(positionIS);
-            if (!useIndexSpace) {
-                deformer.apply(positionWS, iter);
-            }
-
-            // transform to index-space position of target grid
-
-            positionIS = mTargetTransform.worldToIndex(positionWS);
-
-            // determine target voxel and offset
-
-            Coord targetVoxel = Coord::round(positionIS);
-            Index targetOffset = LeafT::coordToOffset(targetVoxel);
-
-            // set new local position in source transform space (if point has been deformed)
-
-            Vec3d voxelPosition(positionIS - targetVoxel.asVec3d());
-            sourceHandle->set(*iter, voxelPosition);
-
-            // determine target leaf node origin and offset in the target leaf vector
-
-            Coord targetLeafOrigin = targetVoxel & ~(LeafT::DIM - 1);
-            assert(mTargetLeafMap.find(targetLeafOrigin) != mTargetLeafMap.end());
-            const LeafIndex targetLeafOffset(mTargetLeafMap.at(targetLeafOrigin));
-
-            // insert into move map based on whether point ends up in a new leaf node or not
-
-            if (targetLeafOrigin == sourceLeafOrigin) {
-                mLocalMoveLeafMap[targetLeafOffset].emplace_back(targetOffset, *iter);
-            }
-            else {
-                mGlobalMoveLeafMap[targetLeafOffset].push_back(IndexTriple(
-                    LeafIndex(static_cast<LeafIndex>(idx)), targetOffset, *iter));
-            }
-        }
-    }
-
-private:
-    const DeformerT& mDeformer;
-    GlobalPointIndexMap& mGlobalMoveLeafMap;
-    LocalPointIndexMap& mLocalMoveLeafMap;
-    const LeafMap& mTargetLeafMap;
-    const math::Transform& mTargetTransform;
-    const math::Transform& mSourceTransform;
-    const FilterT& mFilter;
-}; // struct BuildMoveMapsOp
-
-template <typename LeafT>
-inline Index
-indexOffsetFromVoxel(const Index voxelOffset, const LeafT& leaf, IndexArray& offsets)
-{
-    // compute the target point index by summing the point index of the previous
-    // voxel with the current number of points added to this voxel, tracked by the
-    // offsets array
-
-    Index targetOffset = offsets[voxelOffset]++;
-    if (voxelOffset > 0) {
-        targetOffset += static_cast<Index>(leaf.getValue(voxelOffset - 1));
-    }
-    return targetOffset;
-}
-
 template <typename TreeT>
 struct GlobalMovePointsOp
 {
@@ -444,24 +688,28 @@
                        AttributeHandles& targetHandles,
                        AttributeHandles& sourceHandles,
                        const Index attributeIndex,
-                       const GlobalPointIndexMap& moveLeafMap)
+                       const GlobalPointIndexMap& moveLeafMap,
+                       const GlobalPointIndexIndices& moveLeafIndices)
         : mOffsetMap(offsetMap)
         , mTargetHandles(targetHandles)
         , mSourceHandles(sourceHandles)
         , mAttributeIndex(attributeIndex)
-        , mMoveLeafMap(moveLeafMap) { }
+        , mMoveLeafMap(moveLeafMap)
+        , mMoveLeafIndices(moveLeafIndices) { }
 
     struct PerformTypedMoveOp
     {
         PerformTypedMoveOp(AttributeHandles& targetHandles, AttributeHandles& sourceHandles,
             Index targetOffset, const LeafT& targetLeaf,
-            IndexArray& offsets, const IndexTripleArray& indices)
+            IndexArray& offsets, const IndexTripleArray& indices,
+            const IndexArray& sortedIndices)
             : mTargetHandles(targetHandles)
             , mSourceHandles(sourceHandles)
             , mTargetOffset(targetOffset)
             , mTargetLeaf(targetLeaf)
             , mOffsets(offsets)
-            , mIndices(indices) { }
+            , mIndices(indices)
+            , mSortedIndices(sortedIndices) { }
 
         template<typename ValueT>
         void operator()(const AttributeArray&) const
@@ -469,23 +717,7 @@
             auto& targetHandle = mTargetHandles.getWriteHandle<ValueT>(mTargetOffset);
             targetHandle.expand();
 
-            // build a sorted index vector that references the indices in order of their source
-            // leafs and voxels to ensure determinism in the resulting point orders
-
-            std::vector<int> sortedIndices(mIndices.size());
-            std::iota(std::begin(sortedIndices), std::end(sortedIndices), 0);
-            std::sort(std::begin(sortedIndices), std::end(sortedIndices),
-                [&](int i, int j)
-                {
-                    const Index& indexI0(std::get<0>(mIndices[i]));
-                    const Index& indexJ0(std::get<0>(mIndices[j]));
-                    if (indexI0 < indexJ0)          return true;
-                    if (indexI0 > indexJ0)          return false;
-                    return std::get<2>(mIndices[i]) < std::get<2>(mIndices[j]);
-                }
-            );
-
-            for (const auto& index : sortedIndices) {
+            for (const auto& index : mSortedIndices) {
                 const auto& it = mIndices[index];
                 const auto& sourceHandle = mSourceHandles.getHandle<ValueT>(std::get<0>(it));
                 const Index targetIndex = indexOffsetFromVoxel(std::get<1>(it), mTargetLeaf, mOffsets);
@@ -503,25 +735,35 @@
         const LeafT& mTargetLeaf;
         IndexArray& mOffsets;
         const IndexTripleArray& mIndices;
+        const IndexArray& mSortedIndices;
     }; // struct PerformTypedMoveOp
 
     void performMove(Index targetOffset, const LeafT& targetLeaf,
-        IndexArray& offsets, const IndexTripleArray& indices) const
+        IndexArray& offsets, const IndexTripleArray& indices,
+        const IndexArray& sortedIndices) const
     {
         auto& targetArray = mTargetHandles.getArray(targetOffset);
+        targetArray.loadData();
+        targetArray.expand();
+
+        for (const auto& index : sortedIndices) {
+            const auto& it = indices[index];
 
-        for (const auto& it : indices) {
             const auto& sourceArray = mSourceHandles.getConstArray(std::get<0>(it));
-            const Index tgtOffset = indexOffsetFromVoxel(std::get<1>(it), targetLeaf, offsets);
-            targetArray.set(tgtOffset, sourceArray, std::get<2>(it));
+
+            const Index sourceOffset = std::get<2>(it);
+            const Index targetOffset = indexOffsetFromVoxel(std::get<1>(it), targetLeaf, offsets);
+
+            targetArray.set(targetOffset, sourceArray, sourceOffset);
         }
     }
 
     void operator()(LeafT& leaf, size_t aIdx) const
     {
         const Index idx(static_cast<Index>(aIdx));
-        const auto& moveIndices = mMoveLeafMap.at(aIdx);
+        const auto& moveIndices = mMoveLeafMap[aIdx];
         if (moveIndices.empty())  return;
+        const auto& sortedIndices = mMoveLeafIndices[aIdx];
 
         // extract per-voxel offsets for this leaf
 
@@ -529,9 +771,10 @@
 
         const auto& array = leaf.constAttributeArray(mAttributeIndex);
 
-        PerformTypedMoveOp op(mTargetHandles, mSourceHandles, idx, leaf, offsets, moveIndices);
+        PerformTypedMoveOp op(mTargetHandles, mSourceHandles, idx, leaf, offsets,
+            moveIndices, sortedIndices);
         if (!processTypedArray(array, op)) {
-            this->performMove(idx, leaf, offsets, moveIndices);
+            this->performMove(idx, leaf, offsets, moveIndices, sortedIndices);
         }
     }
 
@@ -541,8 +784,10 @@
     AttributeHandles& mSourceHandles;
     const Index mAttributeIndex;
     const GlobalPointIndexMap& mMoveLeafMap;
+    const GlobalPointIndexIndices& mMoveLeafIndices;
 }; // struct GlobalMovePointsOp
 
+
 template <typename TreeT>
 struct LocalMovePointsOp
 {
@@ -628,8 +873,10 @@
         const auto& sourceArray = mSourceHandles.getConstArray(sourceOffset);
 
         for (const auto& it : indices) {
-            const Index tgtOffset = indexOffsetFromVoxel(it.first, targetLeaf, offsets);
-            targetArray.set(tgtOffset, sourceArray, it.second);
+            const Index sourceOffset = it.second;
+            const Index targetOffset = indexOffsetFromVoxel(it.first, targetLeaf, offsets);
+
+            targetArray.set(targetOffset, sourceArray, sourceOffset);
         }
     }
 
@@ -666,6 +913,10 @@
     const LocalPointIndexMap& mMoveLeafMap;
 }; // struct LocalMovePointsOp
 
+
+#endif // OPENVDB_ABI_VERSION_NUMBER >= 6
+
+
 } // namespace point_move_internal
 
 
@@ -710,10 +961,6 @@
     LeafManagerT sourceLeafManager(tree);
     LeafManagerT targetLeafManager(newTree);
 
-    // initialize attribute handles
-    AttributeHandles sourceHandles(sourceLeafManager.leafCount());
-    AttributeHandles targetHandles(targetLeafManager.leafCount());
-
     // extract the existing attribute set
     const auto& existingAttributeSet = points.tree().cbeginLeaf()->attributeSet();
 
@@ -779,6 +1026,39 @@
         sourceLeafManager.foreach(op, threaded);
     }
 
+    // build a sorted index vector for each leaf that references the global move map
+    // indices in order of their source leafs and voxels to ensure determinism in the
+    // resulting point orders
+
+    GlobalPointIndexIndices globalMoveLeafIndices(globalMoveLeafMap.size());
+
+    targetLeafManager.foreach(
+        [&](LeafT& /*leaf*/, size_t idx) {
+            const IndexTripleArray& moveIndices = globalMoveLeafMap[idx];
+            if (moveIndices.empty())  return;
+
+            IndexArray& sortedIndices = globalMoveLeafIndices[idx];
+            sortedIndices.resize(moveIndices.size());
+            std::iota(std::begin(sortedIndices), std::end(sortedIndices), 0);
+            std::sort(std::begin(sortedIndices), std::end(sortedIndices),
+                [&](int i, int j)
+                {
+                    const Index& indexI0(std::get<0>(moveIndices[i]));
+                    const Index& indexJ0(std::get<0>(moveIndices[j]));
+                    if (indexI0 < indexJ0)          return true;
+                    if (indexI0 > indexJ0)          return false;
+                    return std::get<2>(moveIndices[i]) < std::get<2>(moveIndices[j]);
+                }
+            );
+        },
+    threaded);
+
+#if OPENVDB_ABI_VERSION_NUMBER < 6
+    // initialize attribute handles
+    AttributeHandles sourceHandles(sourceLeafManager.leafCount());
+    AttributeHandles targetHandles(targetLeafManager.leafCount());
+#endif
+
     for (const auto& it : existingAttributeSet.descriptor().map()) {
 
         const Index attributeIndex = static_cast<Index>(it.second);
@@ -790,6 +1070,20 @@
             },
         threaded);
 
+#if OPENVDB_ABI_VERSION_NUMBER >= 6
+
+        // move points between leaf nodes
+
+        GlobalMovePointsOp<PointDataTreeT> globalMoveOp(offsetMap,
+            sourceLeafManager, attributeIndex, globalMoveLeafMap, globalMoveLeafIndices);
+        targetLeafManager.foreach(globalMoveOp, threaded);
+
+        // move points within leaf nodes
+
+        LocalMovePointsOp<PointDataTreeT> localMoveOp(offsetMap,
+            sourceIndices, sourceLeafManager, attributeIndex, localMoveLeafMap);
+        targetLeafManager.foreach(localMoveOp, threaded);
+#else
         // cache attribute handles
 
         sourceHandles.cache(sourceLeafManager.leafRange(), attributeIndex);
@@ -798,7 +1092,7 @@
         // move points between leaf nodes
 
         GlobalMovePointsOp<PointDataTreeT> globalMoveOp(offsetMap, targetHandles,
-            sourceHandles, attributeIndex, globalMoveLeafMap);
+            sourceHandles, attributeIndex, globalMoveLeafMap, globalMoveLeafIndices);
         targetLeafManager.foreach(globalMoveOp, threaded);
 
         // move points within leaf nodes
@@ -807,6 +1101,7 @@
             sourceIndices, sourceHandles,
             attributeIndex, localMoveLeafMap);
         targetLeafManager.foreach(localMoveOp, threaded);
+#endif // OPENVDB_ABI_VERSION_NUMBER >= 6
     }
 
     points.setTree(newPoints->treePtr());
@@ -859,10 +1154,6 @@
 
         DeformerT newDeformer(deformer);
 
-        // if more than half the number of total points are evaluated by the filter, prefer
-        // accessing the data from a vector instead of a hash map for faster performance
-        const Index64 vectorThreshold = totalPointCount / 2;
-
         newDeformer.reset(leaf, idx);
 
         auto handle = AttributeHandle<Vec3f>::create(leaf.constAttributeArray("P"));
@@ -870,10 +1161,10 @@
         auto& cache = leafs[idx];
         cache.clear();
 
-        // only insert into a vector directly if the filter evaluates all points and the
-        // number of active points is greater than the vector threshold
+        // only insert into a vector directly if the filter evaluates all points
+        // and all points are stored in active voxels
         const bool useVector = filter.state() == index::ALL &&
-            (leaf.isDense() || (leaf.onPointCount() > vectorThreshold));
+            (leaf.isDense() || (leaf.onPointCount() == leaf.pointCount()));
         if (useVector) {
             cache.vecData.resize(totalPointCount);
         }
@@ -906,16 +1197,6 @@
             }
         }
 
-        // after insertion, move the data into a vector if the threshold is reached
-
-        if (!useVector && cache.mapData.size() > vectorThreshold) {
-            cache.vecData.resize(totalPointCount);
-            for (const auto& it : cache.mapData) {
-                cache.vecData[it.first] = it.second;
-            }
-            cache.mapData.clear();
-        }
-
         // store the total number of points to allow use of an expanded vector on access
 
         if (!cache.mapData.empty()) {
@@ -940,26 +1221,8 @@
     }
     auto& cache = mCache.leafs[idx];
     if (!cache.mapData.empty()) {
-        // expand into a local vector if there are greater than 16 values in the hash map
-        // and the expanded vector would contain fewer values than 256 times those in the
-        // hash map, this trades a little extra storage for faster random access performance
-        if (cache.mapData.size() > 16 &&
-            cache.totalSize < (cache.mapData.size() * 256)) {
-            if (cache.totalSize < cache.mapData.size()) {
-                throw ValueError("Cache total size is not valid.");
-            }
-            mLocalLeafVec.resize(cache.totalSize);
-            for (const auto& it : cache.mapData) {
-                assert(it.first < cache.totalSize);
-                mLocalLeafVec[it.first] = it.second;
-            }
-            mLeafVec = &mLocalLeafVec;
-            mLeafMap = nullptr;
-        }
-        else {
-            mLeafMap = &cache.mapData;
-            mLeafVec = nullptr;
-        }
+        mLeafMap = &cache.mapData;
+        mLeafVec = nullptr;
     }
     else {
         mLeafVec = &cache.vecData;
@@ -995,6 +1258,6 @@
 
 #endif // OPENVDB_POINTS_POINT_MOVE_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/points/PointSample.h openvdb-6.1.0/openvdb/points/PointSample.h
--- openvdb-6.0.0/openvdb/points/PointSample.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/points/PointSample.h	2019-05-07 22:58:35.000000000 +0200
@@ -482,6 +482,8 @@
                 pointDataSampler.template sample<SourceGridT, Vec3d>(sourceGrid, targetIdx);
             } else if (targetType == typeNameAsString<Vec3i>()) {
                 pointDataSampler.template sample<SourceGridT, Vec3i>(sourceGrid, targetIdx);
+            } else if (targetType == typeNameAsString<int8_t>()) {
+                pointDataSampler.template sample<SourceGridT, int8_t>(sourceGrid, targetIdx);
             } else if (targetType == typeNameAsString<int16_t>()) {
                 pointDataSampler.template sample<SourceGridT, int16_t>(sourceGrid, targetIdx);
             } else if (targetType == typeNameAsString<int32_t>()) {
diff -aur openvdb-6.0.0/openvdb/points/points.cc openvdb-6.1.0/openvdb/points/points.cc
--- openvdb-6.0.0/openvdb/points/points.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/points/points.cc	2019-05-07 22:58:35.000000000 +0200
@@ -42,6 +42,7 @@
 {
     // Register attribute arrays with no compression
     TypedAttributeArray<bool>::registerType();
+    TypedAttributeArray<int8_t>::registerType();
     TypedAttributeArray<int16_t>::registerType();
     TypedAttributeArray<int32_t>::registerType();
     TypedAttributeArray<int64_t>::registerType();
diff -aur openvdb-6.0.0/openvdb/points/StreamCompression.cc openvdb-6.1.0/openvdb/points/StreamCompression.cc
--- openvdb-6.0.0/openvdb/points/StreamCompression.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/points/StreamCompression.cc	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -513,9 +513,9 @@
 
 #if OPENVDB_ABI_VERSION_NUMBER >= 6
     // TODO: C++14 introduces std::make_unique
-    PageHandle::Ptr pageHandle(new PageHandle(mPage, mByteIndex, n));
+    PageHandle::Ptr pageHandle(new PageHandle(mPage, mByteIndex, int(n)));
 #else
-    PageHandle::Ptr pageHandle = std::make_shared<PageHandle>(mPage, mByteIndex, n);
+    PageHandle::Ptr pageHandle = std::make_shared<PageHandle>(mPage, mByteIndex, int(n));
 #endif
 
     mByteIndex += int(n);
@@ -659,6 +659,6 @@
 } // namespace OPENVDB_VERSION_NAME
 } // namespace openvdb
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/python/CMakeLists.txt openvdb-6.1.0/openvdb/python/CMakeLists.txt
--- openvdb-6.0.0/openvdb/python/CMakeLists.txt	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/python/CMakeLists.txt	2019-05-07 22:58:35.000000000 +0200
@@ -1,112 +1,229 @@
+# Copyright (c) 2012-2019 DreamWorks Animation LLC
+#
+# All rights reserved. This software is distributed under the
+# Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
+#
+# Redistributions of source code must retain the above copyright
+# and license notice and the following restrictions and disclaimer.
+#
+# *     Neither the name of DreamWorks Animation nor the names of
+# its contributors may be used to endorse or promote products derived
+# from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+# IN NO EVENT SHALL THE COPYRIGHT HOLDERS' AND CONTRIBUTORS' AGGREGATE
+# LIABILITY FOR ALL CLAIMS REGARDLESS OF THEIR BASIS EXCEED US$250.00.
+#
+#[=======================================================================[
+
+  CMake Configuration for OpenVDB Python bindings
+
+#]=======================================================================]
+
+project(OpenVDBPython)
+cmake_minimum_required(VERSION 3.3)
+# Monitoring <PackageName>_ROOT variables
+if(POLICY CMP0074)
+  cmake_policy(SET CMP0074 NEW)
+endif()
+
+###### OpenVDB Python Options
+
+option(USE_NUMPY [=[
+Build the python library with numpy support. Currently requires CMake 3.14.]=] OFF)
+option(OPENVDB_PYTHON_WRAP_ALL_GRID_TYPES [=[
+Expose (almost) all of the grid types in the python module. Otherwise, only FloatGrid, BoolGrid and
+Vec3SGrid will be exposed (see, e.g., exportIntGrid() in python/pyIntGrid.cc). Compiling the Python
+module with this ON can be very memory-intensive.]=] OFF)
+
+#########################################################################
+
+message(STATUS "----------------------------------------------------")
+message(STATUS "------------ Configuring OpenVDBPython -------------")
+message(STATUS "----------------------------------------------------")
+
+##########################################################################
+
+# Collect and configure lib dependencies
+
+if(NOT OPENVDB_BUILD_CORE)
+  set(OPENVDB_LIB OpenVDB::openvdb)
+else()
+  set(OPENVDB_LIB openvdb)
+endif()
+
+# NumPy requires CMake 3.14
+if(USE_NUMPY AND (${CMAKE_VERSION} VERSION_LESS 3.14))
+  message(FATAL_ERROR "No CMake support for FindPackage ( NumPy) currently "
+    "available for OpenVDB. Requires CMake 3.14."
+  )
+endif()
+
+set(OPENVDB_PYTHON_DEPS)
+set(OPENVDB_PYTHON_INCLUDES)
+
+# If CMake is < 3.12, use the old style python search and alias the variables
+# Note that the Interpreter component is only required for the python test
+if(${CMAKE_VERSION} VERSION_LESS 3.12)
+  find_package(PythonInterp ${MINIMUM_PYTHON_VERSION} REQUIRED)
+  find_package(PythonLibs ${MINIMUM_PYTHON_VERSION} REQUIRED)
+
+  set(Python_VERSION_MAJOR ${PYTHON_VERSION_MAJOR})
+  set(Python_VERSION_MINOR ${PYTHON_VERSION_MINOR})
+  set(Python_EXECUTABLE ${PYTHON_EXECUTABLE})
+  set(OPENVDB_PYTHON_DEPS ${PYTHON_LIBRARIES})
+  get_filename_component(Python_LIBRARY_DIRS ${OPENVDB_PYTHON_DEPS} DIRECTORY)
+
+  list(APPEND OPENVDB_PYTHON_INCLUDES ${PYTHON_INCLUDE_DIR})
+else()
+  # To ensure consistent versions between components Interpreter, Compiler,
+  # Development and NumPy, specify all components at the same time when using
+  # FindPython
+  if(USE_NUMPY)
+    find_package(Python ${MINIMUM_PYTHON_VERSION} REQUIRED COMPONENTS Interpreter Development NumPy)
+    if(Python_NumPy_VERSION VERSION_LESS MINIMUM_NUMPY_VERSION)
+      message(FATAL_ERROR "Could NOT find NumPy (Required is at least version "
+        "\"${MINIMUM_NUMPY_VERSION}\")"
+      )
+    else()
+      message(STATUS "Found NumPy: ${Python_NumPy_INCLUDE_DIRS} (found suitable "
+        "version \"${Python_NumPy_VERSION}\", minimum required is "
+        "\"${MINIMUM_NUMPY_VERSION}\")"
+      )
+    endif()
+    list(APPEND OPENVDB_PYTHON_DEPS Python::NumPy)
+  else()
+    find_package(Python ${MINIMUM_PYTHON_VERSION} REQUIRED COMPONENTS Interpreter Development)
+  endif()
+  list(APPEND OPENVDB_PYTHON_DEPS Python::Python)
+endif()
+
+
+# Boost python handling - try and find both python and pythonXx (version suffixed).
+# Prioritize the version suffixed library, failing if neither exist.
+
+find_package(Boost ${MINIMUM_BOOST_VERSION}
+  QUIET COMPONENTS python${Python_VERSION_MAJOR}${Python_VERSION_MINOR}
+)
+
+if(TARGET Boost::python${Python_VERSION_MAJOR}${Python_VERSION_MINOR})
+  set(BOOST_PYTHON_LIB "python${Python_VERSION_MAJOR}${Python_VERSION_MINOR}")
+  message(STATUS "Found boost_python${Python_VERSION_MAJOR}${Python_VERSION_MINOR}")
+else()
+  find_package(Boost ${MINIMUM_BOOST_VERSION}
+    QUIET COMPONENTS python
+  )
+  if(TARGET Boost::python)
+    set(BOOST_PYTHON_LIB "python")
+    message(STATUS "Found non-suffixed boost_python, assuming to be python version "
+      "\"${Python_VERSION_MAJOR}.${Python_VERSION_MINOR}\" compatible"
+    )
+  else()
+    message(FATAL_ERROR "Unable to find boost_python or "
+      "boost_python${Python_VERSION_MAJOR}${Python_VERSION_MINOR}."
+    )
+  endif()
+endif()
 
-PROJECT ( PyOpenVDB )
+set(OPENVDB_PYTHON_DEPENDENT_LIBS
+  ${OPENVDB_LIB}
+  Boost::${BOOST_PYTHON_LIB}
+  ${OPENVDB_PYTHON_DEPS}
+)
 
-FIND_PACKAGE ( PythonInterp REQUIRED )
-FIND_PACKAGE ( PythonLibs REQUIRED )
-FIND_PACKAGE ( Boost ${MINIMUM_BOOST_VERSION} REQUIRED COMPONENTS python${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR} )
-
-
-IF ( NOT OPENVDB_BUILD_CORE )
-  FIND_PACKAGE ( OpenVDB REQUIRED )
-
-  FIND_PACKAGE ( ILMBase REQUIRED )
-  FIND_PACKAGE ( OpenEXR REQUIRED )
-  FIND_PACKAGE ( Blosc REQUIRED )
-  FIND_PACKAGE ( TBB REQUIRED )
-  FIND_PACKAGE ( ZLIB REQUIRED )
-
-
-  # Set the variables that are otherwise defined in the core module.
-  SET ( OPENVDB_MAJOR_VERSION_NUMBER ${OpenVDB_MAJOR_VERSION} )
-  SET ( OPENVDB_MINOR_VERSION_NUMBER ${OpenVDB_MINOR_VERSION} )
-  SET ( OPENVDB_PATCH_VERSION_NUMBER ${OpenVDB_PATCH_VERSION} )
-
-  # Use the library installed
-  SET ( OPENVDB_LIB ${OpenVDB_OPENVDB_LIBRARY} )
-
-ELSE ()
-  # Use the target
-  SET ( OPENVDB_LIB openvdb_shared)
-ENDIF ( NOT OPENVDB_BUILD_CORE )
-
-INCLUDE_DIRECTORIES ( SYSTEM ${ILMBASE_INCLUDE_DIRS} )
-INCLUDE_DIRECTORIES ( SYSTEM ${OPENEXR_INCLUDE_DIRS} )
-INCLUDE_DIRECTORIES ( SYSTEM ${Boost_INCLUDE_DIR} )
-INCLUDE_DIRECTORIES ( SYSTEM ${BLOSC_INCLUDE_DIR} )
-INCLUDE_DIRECTORIES ( SYSTEM ${TBB_INCLUDE_DIR} )
-INCLUDE_DIRECTORIES ( SYSTEM ${ZLIB_INCLUDE_DIR} )
-INCLUDE_DIRECTORIES ( SYSTEM ${PYTHON_INCLUDE_DIR} )
-# MESSAGE ( "PYTHON_VERSION_STRING = ${PYTHON_VERSION_STRING}" )
-
-# MESSAGE ( "PYTHON_VERSION_MAJOR = ${PYTHON_VERSION_MAJOR}" )
-# MESSAGE ( "PYTHON_VERSION_MINOR = ${PYTHON_VERSION_MINOR}" )
-SET ( OPENVDB_PYTHON_MODULE_SOURCE_FILES
+##########################################################################
+
+set(OPENVDB_PYTHON_MODULE_SOURCE_FILES
   pyFloatGrid.cc
   pyIntGrid.cc
   pyMetadata.cc
+  pyPointGrid.cc
   pyOpenVDBModule.cc
+  pyPointGrid.cc
   pyTransform.cc
   pyVec3Grid.cc
-  )
+)
 
-IF ( NOT DEFINED PYOPENVDB_INSTALL_DIRECTORY )
-  SET ( PYOPENVDB_INSTALL_DIRECTORY
-    lib/python${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR}
+if(NOT DEFINED PYOPENVDB_INSTALL_DIRECTORY)
+  set(PYOPENVDB_INSTALL_DIRECTORY
+    lib/python${Python_VERSION_MAJOR}.${Python_VERSION_MINOR}
     CACHE STRING "The directory to install the pyopenvdb.so module."
-    )
-ENDIF ( NOT DEFINED PYOPENVDB_INSTALL_DIRECTORY )
-
-SET_SOURCE_FILES_PROPERTIES ( ${OPENVDB_PYTHON_MODULE_SOURCE_FILES}
-  PROPERTIES
-  COMPILE_FLAGS "-DOPENVDB_PRIVATE -DOPENVDB_USE_BLOSC ${OPENVDB_USE_GLFW_FLAG}"
   )
+endif()
 
-# RPath handling
-IF ( OPENVDB_ENABLE_RPATH )
+add_library(pyopenvdb SHARED
+  ${OPENVDB_PYTHON_MODULE_SOURCE_FILES}
+)
 
-  SET(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)
+target_include_directories(pyopenvdb
+  SYSTEM PUBLIC ${OPENVDB_PYTHON_INCLUDES}
+)
 
-  IF( OpenVDB_LIBRARY_DIR )
-    SET(CMAKE_INSTALL_RPATH ${OpenVDB_LIBRARY_DIR})
-  ELSE ()
-    MESSAGE ( WARNING "Assumes the openvdb shared library is one level up")
-    MESSAGE ( WARNING "If this is wrong set OpenVDB_LIBRARY_DIR to correct path")
-    SET(CMAKE_INSTALL_RPATH "$ORIGIN/..")
-  ENDIF ()
-ENDIF ( OPENVDB_ENABLE_RPATH )
+if(OPENVDB_PYTHON_WRAP_ALL_GRID_TYPES)
+  target_compile_definitions(pyopenvdb PRIVATE "-DPY_OPENVDB_WRAP_ALL_GRID_TYPES")
+endif()
 
-ADD_LIBRARY ( pyopenvdb SHARED
-  ${OPENVDB_PYTHON_MODULE_SOURCE_FILES}
-  )
+if(USE_NUMPY)
+  target_compile_definitions(pyopenvdb PUBLIC "-DPY_OPENVDB_USE_NUMPY")
+endif()
 
-TARGET_LINK_LIBRARIES ( pyopenvdb
-  ${OPENVDB_LIB}
-  ${OPENGL_gl_LIBRARY}
-  ${OPENGL_glu_LIBRARY}
-  ${COCOA_LIBRARY}
-  ${IOKIT_LIBRARY}
-  ${COREVIDEO_LIBRARY}
-  ${GLFW_LINK_LIBRARY}
-  ${GLFW_DEPENDENT_LIBRARIES}
-  ${GLEW_GLEW_LIBRARY}
-  ${Boost_PYTHON_LIBRARY}
-  ${PYTHON_LIBRARY}
-  ${Ilmbase_HALF_LIBRARY}
-  )
+target_link_libraries(pyopenvdb
+  ${OPENVDB_PYTHON_DEPENDENT_LIBS}
+)
 
-SET_TARGET_PROPERTIES ( pyopenvdb PROPERTIES
+set_target_properties(pyopenvdb PROPERTIES
   PREFIX ""
-  )
+)
 
-ADD_TEST ( pytest ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/test/TestOpenVDB.py )
-SET_TESTS_PROPERTIES ( pytest PROPERTIES ENVIRONMENT "PYTHONPATH=${CMAKE_CURRENT_BINARY_DIR}")
+if(OPENVDB_ENABLE_RPATH)
+  # @todo There is probably a better way to do this for imported targets
+  set(RPATHS "")
+  list(APPEND RPATHS
+    ${Boost_LIBRARY_DIRS}
+    ${IlmBase_LIBRARY_DIRS}
+    ${Log4cplus_LIBRARY_DIRS}
+    ${Blosc_LIBRARY_DIRS}
+    ${Tbb_LIBRARY_DIRS}
+    ${Python_LIBRARY_DIRS}
+  )
+  if(OPENVDB_BUILD_CORE)
+    list(APPEND RPATHS ${CMAKE_INSTALL_PREFIX}/lib)
+  else()
+    list(APPEND RPATHS ${OpenVDB_LIBRARY_DIRS})
+  endif()
+
+  list(REMOVE_DUPLICATES RPATHS)
+  set_target_properties(pyopenvdb
+    PROPERTIES INSTALL_RPATH "${RPATHS}"
+  )
+  unset(RPATHS)
+endif()
+
+set(PYTHON_PUBLIC_INCLUDE_NAMES
+  pyopenvdb.h
+)
 
-INSTALL ( TARGETS
+install(TARGETS
   pyopenvdb
   DESTINATION
   ${PYOPENVDB_INSTALL_DIRECTORY}
-  )       
+)
+
+install(FILES ${PYTHON_PUBLIC_INCLUDE_NAMES} DESTINATION include/openvdb/python)
+
+# pytest
+
+add_test(pytest ${Python_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/test/TestOpenVDB.py)
+set_tests_properties(pytest PROPERTIES ENVIRONMENT "PYTHONPATH=${CMAKE_CURRENT_BINARY_DIR}")
+
 
-INSTALL ( DIRECTORY ${PROJECT_SOURCE_DIR} DESTINATION include
-  FILES_MATCHING PATTERN "*.h"
-  )
diff -aur openvdb-6.0.0/openvdb/python/pyAccessor.h openvdb-6.1.0/openvdb/python/pyAccessor.h
--- openvdb-6.0.0/openvdb/python/pyAccessor.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/python/pyAccessor.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -46,11 +46,11 @@
 template<typename _GridT>
 struct AccessorTraits
 {
-    typedef _GridT                              GridT;
-    typedef GridT                               NonConstGridT;
-    typedef typename NonConstGridT::Ptr         GridPtrT;
-    typedef typename NonConstGridT::Accessor    AccessorT;
-    typedef typename AccessorT::ValueType       ValueT;
+    using GridT = _GridT;
+    using NonConstGridT = GridT;
+    using GridPtrT = typename NonConstGridT::Ptr;
+    using AccessorT = typename NonConstGridT::Accessor;
+    using ValueT = typename AccessorT::ValueType;
 
     static const bool IsConst = false;
 
@@ -76,11 +76,11 @@
 template<typename _GridT>
 struct AccessorTraits<const _GridT>
 {
-    typedef const _GridT                            GridT;
-    typedef _GridT                                  NonConstGridT;
-    typedef typename NonConstGridT::ConstPtr        GridPtrT;
-    typedef typename NonConstGridT::ConstAccessor   AccessorT;
-    typedef typename AccessorT::ValueType           ValueT;
+    using GridT = const _GridT;
+    using NonConstGridT = _GridT;
+    using GridPtrT = typename NonConstGridT::ConstPtr;
+    using AccessorT = typename NonConstGridT::ConstAccessor;
+    using ValueT = typename AccessorT::ValueType;
 
     static const bool IsConst = true;
 
@@ -124,7 +124,7 @@
     py::object obj,
     const char* functionName,
     int argIdx = 0, // args are numbered starting from 1
-    const char* expectedType = NULL)
+    const char* expectedType = nullptr)
 {
     return pyutil::extractArg<typename GridT::ValueType>(
         obj, functionName, AccessorTraits<GridT>::typeName(), argIdx, expectedType);
@@ -156,11 +156,11 @@
 class AccessorWrap
 {
 public:
-    typedef AccessorTraits<_GridType>       Traits;
-    typedef typename Traits::AccessorT      Accessor;
-    typedef typename Traits::ValueT         ValueType;
-    typedef typename Traits::NonConstGridT  GridType;
-    typedef typename Traits::GridPtrT       GridPtrType;
+    using Traits = AccessorTraits<_GridType>;
+    using Accessor = typename Traits::AccessorT;
+    using ValueType = typename Traits::ValueT;
+    using GridType = typename Traits::NonConstGridT;
+    using GridPtrType = typename Traits::GridPtrT;
 
     AccessorWrap(GridPtrType grid): mGrid(grid), mAccessor(grid->getAccessor()) {}
 
@@ -338,6 +338,6 @@
 
 #endif // OPENVDB_PYACCESSOR_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/python/pyGrid.h openvdb-6.1.0/openvdb/python/pyGrid.h
--- openvdb-6.0.0/openvdb/python/pyGrid.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/python/pyGrid.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -62,6 +62,7 @@
 #include "openvdb/openvdb.h"
 #include "openvdb/io/Stream.h"
 #include "openvdb/math/Math.h" // for math::isExactlyEqual()
+#include "openvdb/points/PointDataGrid.h"
 #include "openvdb/tools/LevelSetSphere.h"
 #include "openvdb/tools/Dense.h"
 #include "openvdb/tools/ChangeBackground.h"
@@ -114,6 +115,7 @@
     CONVERT_BASE_TO_GRID(Int64Grid, grid);
     CONVERT_BASE_TO_GRID(Vec3IGrid, grid);
     CONVERT_BASE_TO_GRID(Vec3DGrid, grid);
+    CONVERT_BASE_TO_GRID(points::PointDataGrid, grid);
 #endif
 #undef CONVERT_BASE_TO_GRID
 
@@ -143,6 +145,7 @@
     CONVERT_GRID_TO_BASE(Int64Grid::Ptr);
     CONVERT_GRID_TO_BASE(Vec3IGrid::Ptr);
     CONVERT_GRID_TO_BASE(Vec3DGrid::Ptr);
+    CONVERT_GRID_TO_BASE(points::PointDataGrid::Ptr);
 #endif
 #undef CONVERT_GRID_TO_BASE
 
@@ -1063,6 +1066,12 @@
         }
     }
 
+#ifdef __clang__
+    // Suppress "enum value not explicitly handled" warnings
+    PRAGMA(clang diagnostic push)
+    PRAGMA(clang diagnostic ignored "-Wswitch-enum")
+#endif
+
     void copyFromArray() const override
     {
         switch (this->mArrayTypeId) {
@@ -1092,6 +1101,11 @@
         default: throw openvdb::TypeError(); break;
         }
     }
+
+#ifdef __clang__
+    PRAGMA(clang diagnostic pop)
+#endif
+
 }; // class CopyOp
 
 // Specialization for Vec3 grids
@@ -1126,6 +1140,12 @@
         }
     }
 
+#ifdef __clang__
+    // Suppress "enum value not explicitly handled" warnings
+    PRAGMA(clang diagnostic push)
+    PRAGMA(clang diagnostic ignored "-Wswitch-enum")
+#endif
+
     void copyFromArray() const override
     {
         switch (this->mArrayTypeId) {
@@ -1171,6 +1191,11 @@
         default: throw openvdb::TypeError(); break;
         }
     }
+
+#ifdef __clang__
+    PRAGMA(clang diagnostic pop)
+#endif
+
 }; // class CopyOp
 
 
@@ -1195,6 +1220,28 @@
     op();
 }
 
+
+template<>
+inline void
+copyFromArray(points::PointDataGrid& /*grid*/, py::object /*arrayObj*/,
+    py::object /*coordObj*/, py::object /*toleranceObj*/)
+{
+    PyErr_SetString(PyExc_NotImplementedError,
+        "copying NumPy arrays for PointDataGrids is not supported");
+    boost::python::throw_error_already_set();
+}
+
+
+template<>
+inline void
+copyToArray(points::PointDataGrid& /*grid*/, py::object /*arrayObj*/, py::object /*coordObj*/)
+{
+    PyErr_SetString(PyExc_NotImplementedError,
+        "copying NumPy arrays for PointDataGrids is not supported");
+    boost::python::throw_error_already_set();
+}
+
+
 #endif // defined(PY_OPENVDB_USE_NUMPY)
 
 
@@ -2542,6 +2589,6 @@
 
 #endif // OPENVDB_PYGRID_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/python/pyOpenVDBModule.cc openvdb-6.1.0/openvdb/python/pyOpenVDBModule.cc
--- openvdb-6.0.0/openvdb/python/pyOpenVDBModule.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/python/pyOpenVDBModule.cc	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -28,6 +28,7 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 
+#include <iostream> // must be included before python on macos
 #include <cstring> // for strncmp(), strrchr(), etc.
 #include <limits>
 #include <string>
@@ -61,6 +62,7 @@
 void exportFloatGrid();
 void exportIntGrid();
 void exportVec3Grid();
+void exportPointGrid();
 
 
 namespace _openvdbmodule {
@@ -214,6 +216,145 @@
 ////////////////////////////////////////
 
 
+/// Helper class to convert between a 2D Python numeric sequence
+/// (tuple, list, etc.) and an openvdb::Mat
+template<typename MatT>
+struct MatConverter
+{
+    /// Return the given matrix as a Python list of lists.
+    static py::object toList(const MatT& m)
+    {
+        py::list obj;
+        for (int i = 0; i < MatT::size; ++i) {
+            py::list rowObj;
+            for (int j = 0; j < MatT::size; ++j) { rowObj.append(m(i, j)); }
+            obj.append(rowObj);
+        }
+        return std::move(obj);
+    }
+
+    /// Extract a matrix from a Python sequence of numeric sequences.
+    static MatT fromSeq(py::object obj)
+    {
+        MatT m = MatT::zero();
+        if (py::len(obj) == MatT::size) {
+            for (int i = 0; i < MatT::size; ++i) {
+                py::object rowObj = obj[i];
+                if (py::len(rowObj) != MatT::size) return MatT::zero();
+                for (int j = 0; j < MatT::size; ++j) {
+                    m(i, j) = py::extract<typename MatT::value_type>(rowObj[j]);
+                }
+            }
+        }
+        return m;
+    }
+
+    static PyObject* convert(const MatT& m)
+    {
+        py::object obj = toList(m);
+        Py_INCREF(obj.ptr());
+        return obj.ptr();
+    }
+
+    static void* convertible(PyObject* obj)
+    {
+        if (!PySequence_Check(obj)) return nullptr; // not a Python sequence
+
+        Py_ssize_t len = PySequence_Length(obj);
+        if (len != MatT::size) return nullptr;
+
+        py::object seq = pyutil::pyBorrow(obj);
+        for (int i = 0; i < MatT::size; ++i) {
+            py::object rowObj = seq[i];
+            if (py::len(rowObj) != MatT::size) return nullptr;
+            // Check that all elements of the Python sequence are convertible
+            // to the Mat's value type.
+            for (int j = 0; j < MatT::size; ++j) {
+                if (!py::extract<typename MatT::value_type>(rowObj[j]).check()) {
+                    return nullptr;
+                }
+            }
+        }
+        return obj;
+    }
+
+    static void construct(PyObject* obj,
+        py::converter::rvalue_from_python_stage1_data* data)
+    {
+        // Construct a Mat in the provided memory location.
+        using StorageT = py::converter::rvalue_from_python_storage<MatT>;
+        void* storage = reinterpret_cast<StorageT*>(data)->storage.bytes;
+        new (storage) MatT; // placement new
+        data->convertible = storage;
+        *(static_cast<MatT*>(storage)) = fromSeq(pyutil::pyBorrow(obj));
+    }
+
+    static void registerConverter()
+    {
+        py::to_python_converter<MatT, MatConverter<MatT> >();
+        py::converter::registry::push_back(
+            &MatConverter<MatT>::convertible,
+            &MatConverter<MatT>::construct,
+            py::type_id<MatT>());
+    }
+}; // struct MatConverter
+
+
+////////////////////////////////////////
+
+
+/// Helper class to convert between a Python integer and a openvdb::PointIndex
+template <typename PointIndexT>
+struct PointIndexConverter
+{
+    using IntType = typename PointIndexT::IntType;
+
+    /// @return a Python integer object equivalent to the given PointIndex.
+    static PyObject* convert(const PointIndexT& index)
+    {
+        py::object obj(static_cast<IntType>(index));
+        Py_INCREF(obj.ptr());
+        return obj.ptr();
+    }
+
+    /// @return nullptr if the given Python object is not convertible to the PointIndex.
+    static void* convertible(PyObject* obj)
+    {
+        if (!PyInt_Check(obj)) return nullptr; // not a Python integer
+        return obj;
+    }
+
+    /// Convert from a Python object to a PointIndex.
+    static void construct(PyObject* obj,
+        py::converter::rvalue_from_python_stage1_data* data)
+    {
+        // Construct a PointIndex in the provided memory location.
+        using StorageT = py::converter::rvalue_from_python_storage<PointIndexT>;
+        void* storage = reinterpret_cast<StorageT*>(data)->storage.bytes;
+        new (storage) PointIndexT; // placement new
+        data->convertible = storage;
+
+        // Extract the PointIndex from the python integer
+        PointIndexT* index = static_cast<PointIndexT*>(storage);
+
+        *index = static_cast<IntType>(PyInt_AsLong(obj));
+    }
+
+    /// Register both the PointIndex-to-integer and the integer-to-PointIndex converters.
+    static void registerConverter()
+    {
+        py::to_python_converter<PointIndexT, PointIndexConverter>();
+        py::converter::registry::push_back(
+            &PointIndexConverter::convertible,
+            &PointIndexConverter::construct,
+            py::type_id<PointIndexT>());
+    }
+}; // struct PointIndexConverter
+
+
+////////////////////////////////////////
+
+
 /// Helper class to convert between a Python dict and an openvdb::MetaMap
 /// @todo Consider implementing a separate, templated converter for
 /// the various Metadata types.
@@ -258,6 +399,21 @@
                 } else if (typeName == Vec3SMetadata::staticTypeName()) {
                     const Vec3s v = static_cast<Vec3SMetadata&>(*meta).value();
                     obj = py::make_tuple(v[0], v[1], v[2]);
+                } else if (typeName == Vec4DMetadata::staticTypeName()) {
+                    const Vec4d v = static_cast<Vec4DMetadata&>(*meta).value();
+                    obj = py::make_tuple(v[0], v[1], v[2], v[3]);
+                } else if (typeName == Vec4IMetadata::staticTypeName()) {
+                    const Vec4i v = static_cast<Vec4IMetadata&>(*meta).value();
+                    obj = py::make_tuple(v[0], v[1], v[2], v[3]);
+                } else if (typeName == Vec4SMetadata::staticTypeName()) {
+                    const Vec4s v = static_cast<Vec4SMetadata&>(*meta).value();
+                    obj = py::make_tuple(v[0], v[1], v[2], v[3]);
+                } else if (typeName == Mat4SMetadata::staticTypeName()) {
+                    const Mat4s m = static_cast<Mat4SMetadata&>(*meta).value();
+                    obj = MatConverter<Mat4s>::toList(m);
+                } else if (typeName == Mat4DMetadata::staticTypeName()) {
+                    const Mat4d m = static_cast<Mat4DMetadata&>(*meta).value();
+                    obj = MatConverter<Mat4d>::toList(m);
                 }
                 ret[it->first] = obj;
             }
@@ -304,9 +460,8 @@
             py::object val = pyDict[keys[i]];
             Metadata::Ptr value;
             if (py::extract<std::string>(val).check()) {
-                value.reset(
-                    new StringMetadata(py::extract<std::string>(val)));
-            } else if (PyBool_Check(val.ptr())) {
+                value.reset(new StringMetadata(py::extract<std::string>(val)));
+            } else if (bool(PyBool_Check(val.ptr()))) {
                 value.reset(new BoolMetadata(py::extract<bool>(val)));
             } else if (py::extract<Int64>(val).check()) {
                 const Int64 n = py::extract<Int64>(val);
@@ -333,6 +488,16 @@
                 value.reset(new Vec3DMetadata(py::extract<Vec3d>(val)));
             } else if (py::extract<Vec3s>(val).check()) {
                 value.reset(new Vec3SMetadata(py::extract<Vec3s>(val)));
+            } else if (py::extract<Vec4i>(val).check()) {
+                value.reset(new Vec4IMetadata(py::extract<Vec4i>(val)));
+            } else if (py::extract<Vec4d>(val).check()) {
+                value.reset(new Vec4DMetadata(py::extract<Vec4d>(val)));
+            } else if (py::extract<Vec4s>(val).check()) {
+                value.reset(new Vec4SMetadata(py::extract<Vec4s>(val)));
+            } else if (py::extract<Mat4d>(val).check()) {
+                value.reset(new Mat4DMetadata(py::extract<Mat4d>(val)));
+            } else if (py::extract<Mat4s>(val).check()) {
+                value.reset(new Mat4SMetadata(py::extract<Mat4s>(val)));
             } else if (py::extract<Metadata::Ptr>(val).check()) {
                 value = py::extract<Metadata::Ptr>(val);
             } else {
@@ -707,6 +872,11 @@
     _openvdbmodule::VecConverter<Vec4s>::registerConverter();
     _openvdbmodule::VecConverter<Vec4d>::registerConverter();
 
+    _openvdbmodule::MatConverter<Mat4s>::registerConverter();
+    _openvdbmodule::MatConverter<Mat4d>::registerConverter();
+
+    _openvdbmodule::PointIndexConverter<PointDataIndex32>::registerConverter();
+
     _openvdbmodule::MetaMapConverter::registerConverter();
 
 #define PYOPENVDB_TRANSLATE_EXCEPTION(_classname) \
@@ -733,6 +903,7 @@
     exportFloatGrid();
     exportIntGrid();
     exportVec3Grid();
+    exportPointGrid();
 
 
     py::def("read",
@@ -806,6 +977,6 @@
 
 } // BOOST_PYTHON_MODULE
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
Seulement dans openvdb-6.1.0/openvdb/python: pyPointGrid.cc
diff -aur openvdb-6.0.0/openvdb/python/pyutil.h openvdb-6.1.0/openvdb/python/pyutil.h
--- openvdb-6.0.0/openvdb/python/pyutil.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/python/pyutil.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -32,6 +32,7 @@
 #define OPENVDB_PYUTIL_HAS_BEEN_INCLUDED
 
 #include "openvdb/openvdb.h"
+#include "openvdb/points/PointDataGrid.h"
 #include <boost/python.hpp>
 #include <tbb/mutex.h>
 #include <map> // for std::pair
@@ -113,6 +114,7 @@
 GRID_TRAITS(openvdb::Int64Grid, "Int64Grid");
 GRID_TRAITS(openvdb::Vec3IGrid, "Vec3IGrid");
 GRID_TRAITS(openvdb::Vec3DGrid, "Vec3DGrid");
+GRID_TRAITS(openvdb::points::PointDataGrid, "PointDataGrid");
 #endif
 
 #undef GRID_TRAITS
@@ -226,9 +228,9 @@
 extractArg(
     boost::python::object obj,
     const char* functionName,
-    const char* className = NULL,
+    const char* className = nullptr,
     int argIdx = 0, // args are numbered starting from 1
-    const char* expectedType = NULL)
+    const char* expectedType = nullptr)
 {
     boost::python::extract<T> val(obj);
     if (!val.check()) {
@@ -279,6 +281,6 @@
 
 #endif // OPENVDB_PYUTIL_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/python/test/TestOpenVDB.py openvdb-6.1.0/openvdb/python/test/TestOpenVDB.py
--- openvdb-6.0.0/openvdb/python/test/TestOpenVDB.py	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/python/test/TestOpenVDB.py	2019-05-07 22:58:35.000000000 +0200
@@ -1,5 +1,5 @@
 #!/usr/local/bin/python
-# Copyright (c) 2012-2018 DreamWorks Animation LLC
+# Copyright (c) 2012-2019 DreamWorks Animation LLC
 #
 # All rights reserved. This software is distributed under the
 # Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -36,9 +36,6 @@
 import sys
 import unittest
 try:
-    import studioenv
-    from studio.ani import Ani
-    from studio import logging
     from studio import openvdb
 except ImportError:
     import pyopenvdb as openvdb
@@ -165,7 +162,15 @@
 
         self.assertEqual(grid.metadata, {})
 
-        meta = dict(name='test', saveFloatAsHalf=True, xyz=(-1, 0, 1), intval=42, floatval=1.25)
+        meta = {
+            'name':     'test',
+            'xyz':      (-1, 0, 1),
+            'xyzw':     (1.0, 2.25, 3.5, 4.0),
+            'intval':   42,
+            'floatval': 1.25,
+            'mat4val':  [[1]*4]*4,
+            'saveFloatAsHalf': True,
+        }
         grid.metadata = meta
         self.assertEqual(grid.metadata, meta)
 
@@ -311,6 +316,9 @@
         coords = set([(-10, -10, -10), (0, 0, 0), (1, 1, 1)])
 
         for factory in openvdb.GridTypes:
+            # skip value accessor tests for PointDataGrids (value setting methods are disabled)
+            if factory.valueTypeName.startswith('ptdataidx'):
+                continue
             grid = factory()
             zero, one = grid.zeroValue, grid.oneValue
             acc = grid.getAccessor()
@@ -543,6 +551,9 @@
 
         # Test copying from arrays of various types to grids of various types.
         for cls in openvdb.GridTypes:
+            # skip copying test for PointDataGrids
+            if cls.valueTypeName.startswith('ptdataidx'):
+                continue
             for arr in createArrays():
                 isScalarArray = (len(arr.shape) == 3)
                 isScalarGrid = False
@@ -634,6 +645,9 @@
 
         # Test copying from arrays of various types to grids of various types.
         for cls in openvdb.GridTypes:
+            # skip copying test for PointDataGrids
+            if cls.valueTypeName.startswith('ptdataidx'):
+                continue
             for arr in createArrays():
                 isScalarArray = (len(arr.shape) == 3)
                 isScalarGrid = False
@@ -780,11 +794,7 @@
     print('Testing %s' % os.path.dirname(openvdb.__file__))
     sys.stdout.flush()
 
-    try:
-        logging.configure(sys.argv)
-        args = Ani(sys.argv).userArgs() # strip out ANI-related arguments
-    except NameError:
-        args = sys.argv
+    args = sys.argv
 
     # Unlike CppUnit, PyUnit doesn't use the "-t" flag to identify
     # test names, so for consistency, strip out any "-t" arguments,
@@ -795,6 +805,6 @@
     unittest.main(argv=args)
 
 
-# Copyright (c) 2012-2018 DreamWorks Animation LLC
+# Copyright (c) 2012-2019 DreamWorks Animation LLC
 # All rights reserved. This software is distributed under the
 # Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/README openvdb-6.1.0/openvdb/README
--- openvdb-6.0.0/openvdb/README	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/README	2019-05-07 22:58:35.000000000 +0200
@@ -2,9 +2,9 @@
                                OpenVDB
 ========================================================================
 
-The OpenVDB library comprises a hierarchical data structure and a suite 
-of tools for the efficient manipulation of sparse, possibly time-varying, 
-volumetric data discretized on a three-dimensional grid. 
+The OpenVDB library comprises a hierarchical data structure and a suite
+of tools for the efficient manipulation of sparse, possibly time-varying,
+volumetric data discretized on a three-dimensional grid.
 
 For instructions on library installation and dependencies see INSTALL
 
diff -aur openvdb-6.0.0/openvdb/tools/Clip.h openvdb-6.1.0/openvdb/tools/Clip.h
--- openvdb-6.0.0/openvdb/tools/Clip.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/Clip.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -329,13 +329,17 @@
         gridMask.topologyDifference(clipMask.constTree());
     }
 
-    typename GridType::Ptr outGrid;
+#if OPENVDB_ABI_VERSION_NUMBER <= 3
+    auto outGrid = grid.copy(CP_NEW);
+#else
+    auto outGrid = grid.copyWithNewTree();
+#endif
     {
         // Copy voxel values and states.
         tree::LeafManager<const MaskTreeT> leafNodes(gridMask);
         CopyLeafNodes<TreeT> maskOp(tree, leafNodes);
         maskOp.run();
-        outGrid = GridType::create(maskOp.tree());
+        outGrid->setTree(maskOp.tree());
     }
     {
         // Copy tile values and states.
@@ -597,6 +601,6 @@
 
 #endif // OPENVDB_TOOLS_CLIP_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tools/Composite.h openvdb-6.1.0/openvdb/tools/Composite.h
--- openvdb-6.0.0/openvdb/tools/Composite.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/Composite.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -176,13 +176,13 @@
 template<typename TreeType, CSGOperation Operation>
 struct BuildPrimarySegment
 {
-    typedef typename TreeType::ValueType                                            ValueType;
-    typedef typename TreeType::Ptr                                                  TreePtrType;
-    typedef typename TreeType::LeafNodeType                                         LeafNodeType;
-    typedef typename LeafNodeType::NodeMaskType                                     NodeMaskType;
-    typedef typename TreeType::RootNodeType                                         RootNodeType;
-    typedef typename RootNodeType::NodeChainType                                    NodeChainType;
-    typedef typename boost::mpl::at<NodeChainType, boost::mpl::int_<1> >::type      InternalNodeType;
+    using ValueType = typename TreeType::ValueType;
+    using TreePtrType = typename TreeType::Ptr;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using NodeMaskType = typename LeafNodeType::NodeMaskType;
+    using RootNodeType = typename TreeType::RootNodeType;
+    using NodeChainType = typename RootNodeType::NodeChainType;
+    using InternalNodeType = typename boost::mpl::at<NodeChainType, boost::mpl::int_<1> >::type;
 
     BuildPrimarySegment(const TreeType& lhs, const TreeType& rhs)
         : mSegment(new TreeType(lhs.background()))
@@ -213,9 +213,10 @@
 
     struct ProcessInternalNodes {
 
-        ProcessInternalNodes(std::vector<const InternalNodeType*>& lhsNodes, const TreeType& rhsTree,
-            TreeType& outputTree, std::vector<const LeafNodeType*>& outputLeafNodes)
-            : mLhsNodes(lhsNodes.empty() ? NULL : &lhsNodes.front())
+        ProcessInternalNodes(std::vector<const InternalNodeType*>& lhsNodes,
+            const TreeType& rhsTree, TreeType& outputTree,
+            std::vector<const LeafNodeType*>& outputLeafNodes)
+            : mLhsNodes(lhsNodes.empty() ? nullptr : &lhsNodes.front())
             , mRhsTree(&rhsTree)
             , mLocalTree(mRhsTree->background())
             , mOutputTree(&outputTree)
@@ -252,7 +253,8 @@
 
                 const InternalNodeType& lhsNode = *mLhsNodes[n];
                 const Coord& ijk = lhsNode.origin();
-                const InternalNodeType * rhsNode = rhsAcc.template probeConstNode<InternalNodeType>(ijk);
+                const InternalNodeType * rhsNode =
+                    rhsAcc.template probeConstNode<InternalNodeType>(ijk);
 
                 if (rhsNode) {
                     lhsNode.getNodes(*mOutputLeafNodes);
@@ -289,8 +291,9 @@
 
     struct ProcessLeafNodes {
 
-        ProcessLeafNodes(std::vector<const LeafNodeType*>& lhsNodes, const TreeType& rhsTree, TreeType& output)
-            : mLhsNodes(lhsNodes.empty() ? NULL : &lhsNodes.front())
+        ProcessLeafNodes(std::vector<const LeafNodeType*>& lhsNodes,
+            const TreeType& rhsTree, TreeType& output)
+            : mLhsNodes(lhsNodes.empty() ? nullptr : &lhsNodes.front())
             , mRhsTree(&rhsTree)
             , mLocalTree(mRhsTree->background())
             , mOutputTree(&output)
@@ -381,13 +384,13 @@
 template<typename TreeType, CSGOperation Operation>
 struct BuildSecondarySegment
 {
-    typedef typename TreeType::ValueType                                            ValueType;
-    typedef typename TreeType::Ptr                                                  TreePtrType;
-    typedef typename TreeType::LeafNodeType                                         LeafNodeType;
-    typedef typename LeafNodeType::NodeMaskType                                     NodeMaskType;
-    typedef typename TreeType::RootNodeType                                         RootNodeType;
-    typedef typename RootNodeType::NodeChainType                                    NodeChainType;
-    typedef typename boost::mpl::at<NodeChainType, boost::mpl::int_<1> >::type      InternalNodeType;
+    using ValueType = typename TreeType::ValueType;
+    using TreePtrType = typename TreeType::Ptr;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using NodeMaskType = typename LeafNodeType::NodeMaskType;
+    using RootNodeType = typename TreeType::RootNodeType;
+    using NodeChainType = typename RootNodeType::NodeChainType;
+    using InternalNodeType = typename boost::mpl::at<NodeChainType, boost::mpl::int_<1> >::type;
 
     BuildSecondarySegment(const TreeType& lhs, const TreeType& rhs)
         : mSegment(new TreeType(lhs.background()))
@@ -418,9 +421,10 @@
 
     struct ProcessInternalNodes {
 
-        ProcessInternalNodes(std::vector<const InternalNodeType*>& rhsNodes, const TreeType& lhsTree,
-            TreeType& outputTree, std::vector<const LeafNodeType*>& outputLeafNodes)
-            : mRhsNodes(rhsNodes.empty() ? NULL : &rhsNodes.front())
+        ProcessInternalNodes(std::vector<const InternalNodeType*>& rhsNodes,
+            const TreeType& lhsTree, TreeType& outputTree,
+            std::vector<const LeafNodeType*>& outputLeafNodes)
+            : mRhsNodes(rhsNodes.empty() ? nullptr : &rhsNodes.front())
             , mLhsTree(&lhsTree)
             , mLocalTree(mLhsTree->background())
             , mOutputTree(&outputTree)
@@ -457,7 +461,8 @@
 
                 const InternalNodeType& rhsNode = *mRhsNodes[n];
                 const Coord& ijk = rhsNode.origin();
-                const InternalNodeType * lhsNode = lhsAcc.template probeConstNode<InternalNodeType>(ijk);
+                const InternalNodeType * lhsNode =
+                    lhsAcc.template probeConstNode<InternalNodeType>(ijk);
 
                 if (lhsNode) {
                    rhsNode.getNodes(*mOutputLeafNodes);
@@ -504,8 +509,9 @@
 
     struct ProcessLeafNodes {
 
-        ProcessLeafNodes(std::vector<const LeafNodeType*>& rhsNodes, const TreeType& lhsTree, TreeType& output)
-            : mRhsNodes(rhsNodes.empty() ? NULL : &rhsNodes.front())
+        ProcessLeafNodes(std::vector<const LeafNodeType*>& rhsNodes,
+            const TreeType& lhsTree, TreeType& output)
+            : mRhsNodes(rhsNodes.empty() ? nullptr : &rhsNodes.front())
             , mLhsTree(&lhsTree)
             , mLocalTree(mLhsTree->background())
             , mOutputTree(&output)
@@ -594,7 +600,7 @@
 template<typename TreeType>
 struct GridOrTreeConstructor
 {
-    typedef typename TreeType::Ptr TreeTypePtr;
+    using TreeTypePtr = typename TreeType::Ptr;
     static TreeTypePtr construct(const TreeType&, TreeTypePtr& tree) { return tree; }
 };
 
@@ -602,9 +608,9 @@
 template<typename TreeType>
 struct GridOrTreeConstructor<Grid<TreeType> >
 {
-    typedef Grid<TreeType>                  GridType;
-    typedef typename Grid<TreeType>::Ptr    GridTypePtr;
-    typedef typename TreeType::Ptr          TreeTypePtr;
+    using GridType = Grid<TreeType>;
+    using GridTypePtr = typename Grid<TreeType>::Ptr;
+    using TreeTypePtr = typename TreeType::Ptr;
 
     static GridTypePtr construct(const GridType& grid, TreeTypePtr& tree) {
         GridTypePtr maskGrid(GridType::create(tree));
@@ -653,10 +659,11 @@
 /// Template specailization of compActiveLeafVoxels
 template <typename TreeT, typename OpT>
 inline
-typename std::enable_if<!std::is_same<typename TreeT::ValueType, bool>::value &&
-                        !std::is_same<typename TreeT::BuildType, ValueMask>::value &&
-                         std::is_same<typename TreeT::LeafNodeType::Buffer::ValueType,
-                                      typename TreeT::LeafNodeType::Buffer::StorageType>::value>::type
+typename std::enable_if<
+    !std::is_same<typename TreeT::ValueType, bool>::value &&
+    !std::is_same<typename TreeT::BuildType, ValueMask>::value &&
+    std::is_same<typename TreeT::LeafNodeType::Buffer::ValueType,
+    typename TreeT::LeafNodeType::Buffer::StorageType>::value>::type
 doCompActiveLeafVoxels(TreeT &srcTree, TreeT &dstTree, OpT op)
 {
     using LeafT  = typename TreeT::LeafNodeType;
@@ -666,7 +673,7 @@
     using RangeT = tbb::blocked_range<size_t>;
     tbb::parallel_for(RangeT(0, overlapping.size()), [op, &overlapping](const RangeT& r) {
         for (auto i = r.begin(); i != r.end(); ++i) {
-            auto *dstLeaf = overlapping[i].first, *srcLeaf = overlapping[i].second;
+            LeafT *dstLeaf = overlapping[i].first, *srcLeaf = overlapping[i].second;
             dstLeaf->getValueMask() |= srcLeaf->getValueMask();
             auto *ptr = dstLeaf->buffer().data();
             for (auto v = srcLeaf->cbeginValueOn(); v; ++v) op(ptr[v.pos()], *v);
@@ -680,8 +687,9 @@
 /// Template specailization of compActiveLeafVoxels
 template <typename TreeT, typename OpT>
 inline
-typename std::enable_if<std::is_same<typename TreeT::BuildType, ValueMask>::value &&
-                        std::is_same<typename TreeT::ValueType, bool>::value>::type
+typename std::enable_if<
+    std::is_same<typename TreeT::BuildType, ValueMask>::value &&
+    std::is_same<typename TreeT::ValueType, bool>::value>::type
 doCompActiveLeafVoxels(TreeT &srcTree, TreeT &dstTree, OpT)
 {
     using LeafT  = typename TreeT::LeafNodeType;
@@ -701,8 +709,9 @@
 /// Template specailization of compActiveLeafVoxels
 template <typename TreeT, typename OpT>
 inline
-typename std::enable_if<std::is_same<typename TreeT::ValueType, bool>::value &&
-                        !std::is_same<typename TreeT::BuildType, ValueMask>::value>::type
+typename std::enable_if<
+    std::is_same<typename TreeT::ValueType, bool>::value &&
+    !std::is_same<typename TreeT::BuildType, ValueMask>::value>::type
 doCompActiveLeafVoxels(TreeT &srcTree, TreeT &dstTree, OpT op)
 {
     using LeafT = typename TreeT::LeafNodeType;
@@ -747,9 +756,9 @@
 OPENVDB_STATIC_SPECIALIZATION inline void
 compMax(GridOrTreeT& aTree, GridOrTreeT& bTree)
 {
-    typedef TreeAdapter<GridOrTreeT>    Adapter;
-    typedef typename Adapter::TreeType  TreeT;
-    typedef typename TreeT::ValueType   ValueT;
+    using Adapter = TreeAdapter<GridOrTreeT>;
+    using TreeT = typename Adapter::TreeType;
+    using ValueT = typename TreeT::ValueType;
     struct Local {
         static inline void op(CombineArgs<ValueT>& args) {
             args.setResult(composite::max(args.a(), args.b()));
@@ -763,9 +772,9 @@
 OPENVDB_STATIC_SPECIALIZATION inline void
 compMin(GridOrTreeT& aTree, GridOrTreeT& bTree)
 {
-    typedef TreeAdapter<GridOrTreeT>    Adapter;
-    typedef typename Adapter::TreeType  TreeT;
-    typedef typename TreeT::ValueType   ValueT;
+    using Adapter = TreeAdapter<GridOrTreeT>;
+    using TreeT = typename Adapter::TreeType;
+    using ValueT = typename TreeT::ValueType;
     struct Local {
         static inline void op(CombineArgs<ValueT>& args) {
             args.setResult(composite::min(args.a(), args.b()));
@@ -779,8 +788,8 @@
 OPENVDB_STATIC_SPECIALIZATION inline void
 compSum(GridOrTreeT& aTree, GridOrTreeT& bTree)
 {
-    typedef TreeAdapter<GridOrTreeT> Adapter;
-    typedef typename Adapter::TreeType TreeT;
+    using Adapter = TreeAdapter<GridOrTreeT>;
+    using TreeT = typename Adapter::TreeType;
     struct Local {
         static inline void op(CombineArgs<typename TreeT::ValueType>& args) {
             args.setResult(args.a() + args.b());
@@ -794,8 +803,8 @@
 OPENVDB_STATIC_SPECIALIZATION inline void
 compMul(GridOrTreeT& aTree, GridOrTreeT& bTree)
 {
-    typedef TreeAdapter<GridOrTreeT> Adapter;
-    typedef typename Adapter::TreeType TreeT;
+    using Adapter = TreeAdapter<GridOrTreeT>;
+    using TreeT = typename Adapter::TreeType;
     struct Local {
         static inline void op(CombineArgs<typename TreeT::ValueType>& args) {
             args.setResult(args.a() * args.b());
@@ -809,8 +818,8 @@
 OPENVDB_STATIC_SPECIALIZATION inline void
 compDiv(GridOrTreeT& aTree, GridOrTreeT& bTree)
 {
-    typedef TreeAdapter<GridOrTreeT> Adapter;
-    typedef typename Adapter::TreeType TreeT;
+    using Adapter = TreeAdapter<GridOrTreeT>;
+    using TreeT = typename Adapter::TreeType;
     struct Local {
         static inline void op(CombineArgs<typename TreeT::ValueType>& args) {
             args.setResult(composite::divide(args.a(), args.b()));
@@ -854,9 +863,9 @@
 OPENVDB_STATIC_SPECIALIZATION inline void
 compReplace(GridOrTreeT& aTree, const GridOrTreeT& bTree)
 {
-    typedef TreeAdapter<GridOrTreeT> Adapter;
-    typedef typename Adapter::TreeType TreeT;
-    typedef typename TreeT::ValueOnCIter ValueOnCIterT;
+    using Adapter = TreeAdapter<GridOrTreeT>;
+    using TreeT = typename Adapter::TreeType;
+    using ValueOnCIterT = typename TreeT::ValueOnCIter;
 
     // Copy active states (but not values) from B to A.
     Adapter::tree(aTree).topologyUnion(Adapter::tree(bTree));
@@ -882,9 +891,9 @@
 class CsgVisitorBase
 {
 public:
-    typedef TreeType TreeT;
-    typedef typename TreeT::ValueType ValueT;
-    typedef typename TreeT::LeafNodeType::ChildAllIter ChildIterT;
+    using TreeT = TreeType;
+    using ValueT = typename TreeT::ValueType;
+    using ChildIterT = typename TreeT::LeafNodeType::ChildAllIter;
 
     enum { STOP = 3 };
 
@@ -924,9 +933,9 @@
 template<typename TreeType>
 struct CsgUnionVisitor: public CsgVisitorBase<TreeType>
 {
-    typedef TreeType TreeT;
-    typedef typename TreeT::ValueType ValueT;
-    typedef typename TreeT::LeafNodeType::ChildAllIter ChildIterT;
+    using TreeT = TreeType;
+    using ValueT = typename TreeT::ValueType;
+    using ChildIterT = typename TreeT::LeafNodeType::ChildAllIter;
 
     enum { STOP = CsgVisitorBase<TreeT>::STOP };
 
@@ -997,9 +1006,9 @@
 template<typename TreeType>
 struct CsgIntersectVisitor: public CsgVisitorBase<TreeType>
 {
-    typedef TreeType TreeT;
-    typedef typename TreeT::ValueType ValueT;
-    typedef typename TreeT::LeafNodeType::ChildAllIter ChildIterT;
+    using TreeT = TreeType;
+    using ValueT = typename TreeT::ValueType;
+    using ChildIterT = typename TreeT::LeafNodeType::ChildAllIter;
 
     enum { STOP = CsgVisitorBase<TreeT>::STOP };
 
@@ -1069,9 +1078,9 @@
 template<typename TreeType>
 struct CsgDiffVisitor: public CsgVisitorBase<TreeType>
 {
-    typedef TreeType TreeT;
-    typedef typename TreeT::ValueType ValueT;
-    typedef typename TreeT::LeafNodeType::ChildAllIter ChildIterT;
+    using TreeT = TreeType;
+    using ValueT = typename TreeT::ValueType;
+    using ChildIterT = typename TreeT::LeafNodeType::ChildAllIter;
 
     enum { STOP = CsgVisitorBase<TreeT>::STOP };
 
@@ -1144,8 +1153,8 @@
 OPENVDB_STATIC_SPECIALIZATION inline void
 csgUnion(GridOrTreeT& a, GridOrTreeT& b, bool prune)
 {
-    typedef TreeAdapter<GridOrTreeT> Adapter;
-    typedef typename Adapter::TreeType TreeT;
+    using Adapter = TreeAdapter<GridOrTreeT>;
+    using TreeT = typename Adapter::TreeType;
     TreeT &aTree = Adapter::tree(a), &bTree = Adapter::tree(b);
     CsgUnionVisitor<TreeT> visitor(aTree, bTree);
     aTree.visit2(bTree, visitor);
@@ -1156,8 +1165,8 @@
 OPENVDB_STATIC_SPECIALIZATION inline void
 csgIntersection(GridOrTreeT& a, GridOrTreeT& b, bool prune)
 {
-    typedef TreeAdapter<GridOrTreeT> Adapter;
-    typedef typename Adapter::TreeType TreeT;
+    using Adapter = TreeAdapter<GridOrTreeT>;
+    using TreeT = typename Adapter::TreeType;
     TreeT &aTree = Adapter::tree(a), &bTree = Adapter::tree(b);
     CsgIntersectVisitor<TreeT> visitor(aTree, bTree);
     aTree.visit2(bTree, visitor);
@@ -1168,8 +1177,8 @@
 OPENVDB_STATIC_SPECIALIZATION inline void
 csgDifference(GridOrTreeT& a, GridOrTreeT& b, bool prune)
 {
-    typedef TreeAdapter<GridOrTreeT> Adapter;
-    typedef typename Adapter::TreeType TreeT;
+    using Adapter = TreeAdapter<GridOrTreeT>;
+    using TreeT = typename Adapter::TreeType;
     TreeT &aTree = Adapter::tree(a), &bTree = Adapter::tree(b);
     CsgDiffVisitor<TreeT> visitor(aTree, bTree);
     aTree.visit2(bTree, visitor);
@@ -1181,8 +1190,8 @@
 OPENVDB_STATIC_SPECIALIZATION inline typename GridOrTreeT::Ptr
 csgUnionCopy(const GridOrTreeT& a, const GridOrTreeT& b)
 {
-    typedef TreeAdapter<GridOrTreeT>            Adapter;
-    typedef typename Adapter::TreeType::Ptr     TreePtrT;
+    using Adapter = TreeAdapter<GridOrTreeT>;
+    using TreePtrT = typename Adapter::TreeType::Ptr;
 
     TreePtrT output = composite::doCSGCopy<composite::CSG_UNION>(
                         Adapter::tree(a), Adapter::tree(b));
@@ -1195,8 +1204,8 @@
 OPENVDB_STATIC_SPECIALIZATION inline typename GridOrTreeT::Ptr
 csgIntersectionCopy(const GridOrTreeT& a, const GridOrTreeT& b)
 {
-    typedef TreeAdapter<GridOrTreeT>            Adapter;
-    typedef typename Adapter::TreeType::Ptr     TreePtrT;
+    using Adapter = TreeAdapter<GridOrTreeT>;
+    using TreePtrT = typename Adapter::TreeType::Ptr;
 
     TreePtrT output = composite::doCSGCopy<composite::CSG_INTERSECTION>(
                         Adapter::tree(a), Adapter::tree(b));
@@ -1209,8 +1218,8 @@
 OPENVDB_STATIC_SPECIALIZATION inline typename GridOrTreeT::Ptr
 csgDifferenceCopy(const GridOrTreeT& a, const GridOrTreeT& b)
 {
-    typedef TreeAdapter<GridOrTreeT>            Adapter;
-    typedef typename Adapter::TreeType::Ptr     TreePtrT;
+    using Adapter = TreeAdapter<GridOrTreeT>;
+    using TreePtrT = typename Adapter::TreeType::Ptr;
 
     TreePtrT output = composite::doCSGCopy<composite::CSG_DIFFERENCE>(
                         Adapter::tree(a), Adapter::tree(b));
@@ -1241,8 +1250,9 @@
 ///
 /// @warning This function only operated on leaf node values,
 ///          i.e. tile values are ignored.
-template <typename TreeT, typename OpT = composite::CopyOp<TreeT> >
-inline void compActiveLeafVoxels(TreeT &srcTree, TreeT &dstTree, OpT op = composite::CopyOp<TreeT>())
+template<typename TreeT, typename OpT = composite::CopyOp<TreeT> >
+inline void
+compActiveLeafVoxels(TreeT &srcTree, TreeT &dstTree, OpT op = composite::CopyOp<TreeT>())
 {
     composite::doCompActiveLeafVoxels<TreeT, OpT>(srcTree, dstTree, op);
 }
@@ -1254,6 +1264,6 @@
 
 #endif // OPENVDB_TOOLS_COMPOSITE_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tools/DenseSparseTools.h openvdb-6.1.0/openvdb/tools/DenseSparseTools.h
--- openvdb-6.0.0/openvdb/tools/DenseSparseTools.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/DenseSparseTools.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -38,6 +38,8 @@
 #include <openvdb/Types.h>
 #include <openvdb/tree/LeafManager.h>
 #include "Dense.h"
+#include <algorithm> // for std::min()
+#include <vector>
 
 
 namespace openvdb {
@@ -71,7 +73,7 @@
 /// @code
 /// struct ExampleOp
 /// {
-///     typedef DesiredTreeType   ResultTreeType;
+///     using ResultTreeType = DesiredTreeType;
 ///
 ///     template<typename IndexOrCoord>
 ///      void OpType::operator() (const DenseValueType a, const IndexOrCoord& ijk,
@@ -82,23 +84,23 @@
 /// For example, to generate a <ValueType, 5, 4, 3> tree with valuesOn
 /// at locations greater than a given maskvalue
 /// @code
-/// template <typename ValueType>
+/// template<typename ValueType>
 /// class Rule
 /// {
 /// public:
 ///     // Standard tree type (e.g. MaskTree or FloatTree in openvdb.h)
-///     typedef typename openvdb::tree::Tree4<ValueType, 5, 4, 3>::Type  ResultTreeType;
+///     using ResultTreeType = typename openvdb::tree::Tree4<ValueType, 5, 4, 3>::Type;
 ///
-///     typedef typename ResultTreeType::LeafNodeType  ResultLeafNodeType;
-///     typedef typename ResultTreeType::ValueType     ResultValueType;
+///     using ResultLeafNodeType = typename ResultTreeType::LeafNodeType;
+///     using ResultValueType = typename ResultTreeType::ValueType;
 ///
-///     typedef float                         DenseValueType;
+///     using DenseValueType = float;
 ///
-///     typedef vdbmath::Coord::ValueType     Index;
+///     using Index = vdbmath::Coord::ValueType;
 ///
 ///     Rule(const DenseValueType& value): mMaskValue(value){};
 ///
-///     template <typename IndexOrCoord>
+///     template<typename IndexOrCoord>
 ///     void operator()(const DenseValueType& a, const IndexOrCoord& offset,
 ///                 ResultLeafNodeType* leaf) const
 ///     {
@@ -120,10 +122,11 @@
 /// This struct that aids template resolution of a new tree type
 /// has the same configuration at TreeType, but the ValueType from
 /// DenseType.
-template <typename DenseType, typename TreeType> struct DSConverter {
-    typedef typename DenseType::ValueType  ValueType;
-
-    typedef typename TreeType::template ValueConverter<ValueType>::Type Type;
+template<typename DenseType, typename TreeType>
+struct DSConverter
+{
+    using ValueType = typename DenseType::ValueType;
+    using Type = typename TreeType::template ValueConverter<ValueType>::Type;
 };
 
 
@@ -196,22 +199,18 @@
 template<typename OpType, typename DenseType>
 class SparseExtractor
 {
-
 public:
+    using Index = openvdb::math::Coord::ValueType;
 
-    typedef openvdb::math::Coord::ValueType              Index;
-
-    typedef typename DenseType::ValueType                 DenseValueType;
-    typedef typename OpType::ResultTreeType               ResultTreeType;
-    typedef typename ResultTreeType::ValueType            ResultValueType;
-    typedef typename ResultTreeType::LeafNodeType         ResultLeafNodeType;
-    typedef typename ResultTreeType::template ValueConverter<ValueMask>::Type MaskTree;
-
-    typedef tbb::blocked_range3d<Index, Index, Index>     Range3d;
+    using DenseValueType = typename DenseType::ValueType;
+    using ResultTreeType = typename OpType::ResultTreeType;
+    using ResultValueType = typename ResultTreeType::ValueType;
+    using ResultLeafNodeType = typename ResultTreeType::LeafNodeType;
+    using MaskTree = typename ResultTreeType::template ValueConverter<ValueMask>::Type;
 
+    using Range3d = tbb::blocked_range3d<Index, Index, Index>;
 
 private:
-
     const DenseType&                     mDense;
     const OpType&                        mFunctor;
     const ResultValueType                mBackground;
@@ -220,9 +219,7 @@
     typename ResultTreeType::Ptr         mMask;
     openvdb::math::Coord                 mMin;
 
-
 public:
-
     SparseExtractor(const DenseType& dense, const OpType& functor,
                     const ResultValueType background) :
         mDense(dense), mFunctor(functor),
@@ -232,7 +229,6 @@
         mMask( new ResultTreeType(mBackground))
     {}
 
-
     SparseExtractor(const DenseType& dense,
                     const openvdb::math::CoordBBox& bbox,
                     const OpType& functor,
@@ -249,7 +245,6 @@
         }
     }
 
-
     SparseExtractor(SparseExtractor& other, tbb::split):
         mDense(other.mDense), mFunctor(other.mFunctor),
         mBackground(other.mBackground), mBBox(other.mBBox),
@@ -258,9 +253,8 @@
         mMin(other.mMin)
     {}
 
-    typename ResultTreeType::Ptr extract(bool threaded = true) {
-
-
+    typename ResultTreeType::Ptr extract(bool threaded = true)
+    {
         // Construct 3D range of leaf nodes that
         // intersect mBBox.
 
@@ -287,12 +281,10 @@
 
         mMin = padded_min;
 
-
         Range3d  leafRange(0, xleafCount, 1,
                            0, yleafCount, 1,
                            0, zleafCount, 1);
 
-
         // Iterate over the leafnodes applying *this as a functor.
         if (threaded) {
             tbb::parallel_reduce(leafRange, *this);
@@ -303,10 +295,9 @@
         return mMask;
     }
 
-
-    void operator()(const Range3d& range) {
-
-        ResultLeafNodeType* leaf = NULL;
+    void operator()(const Range3d& range)
+    {
+        ResultLeafNodeType* leaf = nullptr;
 
         // Unpack the range3d item.
         const Index imin = range.pages().begin();
@@ -332,7 +323,7 @@
                                                     mWidth * j,
                                                     mWidth * k );
 
-                    if (leaf == NULL) {
+                    if (leaf == nullptr) {
                         leaf = new ResultLeafNodeType(origin, mBackground);
                     } else {
                         leaf->setOrigin(origin);
@@ -398,7 +389,7 @@
 
                     if (!leaf->isEmpty()) {
                         mMask->addLeaf(leaf);
-                        leaf = NULL;
+                        leaf = nullptr;
                     }
 
                 }
@@ -407,7 +398,7 @@
 
         // Clean up an unused leaf.
 
-        if (leaf != NULL) delete leaf;
+        if (leaf != nullptr) delete leaf;
     }
 
     void join(SparseExtractor& rhs) {
@@ -422,7 +413,6 @@
                   const typename OpType::ResultValueType& background,
                   bool threaded)
 {
-
     // Construct the mask using a parallel reduce pattern.
     // Each thread computes disjoint mask-trees.  The join merges
     // into a single tree.
@@ -436,20 +426,19 @@
 /// @brief Functor-based class used to extract data from a dense grid, at
 /// the index-space intersection with a supplied mask in the form of a sparse tree.
 /// The @c extractSparseTreeWithMask function wraps this class.
-template <typename DenseType, typename MaskTreeType>
+template<typename DenseType, typename MaskTreeType>
 class SparseMaskedExtractor
 {
 public:
-
-    typedef typename DSConverter<DenseType, MaskTreeType>::Type  _ResultTreeType;
-    typedef _ResultTreeType                                      ResultTreeType;
-    typedef typename ResultTreeType::LeafNodeType                ResultLeafNodeType;
-    typedef typename ResultTreeType::ValueType                   ResultValueType;
-    typedef ResultValueType                                      DenseValueType;
-
-    typedef typename ResultTreeType::template ValueConverter<ValueMask>::Type  MaskTree;
-    typedef typename MaskTree::LeafCIter                         MaskLeafCIter;
-    typedef std::vector<const typename MaskTree::LeafNodeType*>  MaskLeafVec;
+    using _ResultTreeType = typename DSConverter<DenseType, MaskTreeType>::Type;
+    using ResultTreeType = _ResultTreeType;
+    using ResultLeafNodeType = typename ResultTreeType::LeafNodeType;
+    using ResultValueType = typename ResultTreeType::ValueType;
+    using DenseValueType = ResultValueType;
+
+    using MaskTree = typename ResultTreeType::template ValueConverter<ValueMask>::Type;
+    using MaskLeafCIter = typename MaskTree::LeafCIter;
+    using MaskLeafVec = std::vector<const typename MaskTree::LeafNodeType*>;
 
 
     SparseMaskedExtractor(const DenseType& dense,
@@ -461,15 +450,13 @@
         mResult(new ResultTreeType(mBackground))
     {}
 
-
-
     SparseMaskedExtractor(const SparseMaskedExtractor& other, tbb::split):
         mDense(other.mDense), mBackground(other.mBackground), mBBox(other.mBBox),
         mLeafVec(other.mLeafVec), mResult( new ResultTreeType(mBackground))
     {}
 
-    typename ResultTreeType::Ptr extract(bool threaded = true) {
-
+    typename ResultTreeType::Ptr extract(bool threaded = true)
+    {
         tbb::blocked_range<size_t> range(0, mLeafVec.size());
 
         if (threaded) {
@@ -481,13 +468,11 @@
         return mResult;
     }
 
-
     // Used in looping over leaf nodes in the masked grid
     // and using the active mask to select data to
-    void operator()(const tbb::blocked_range<size_t>& range) {
-
-        ResultLeafNodeType* leaf = NULL;
-
+    void operator()(const tbb::blocked_range<size_t>& range)
+    {
+        ResultLeafNodeType* leaf = nullptr;
 
         // loop over all the candidate leafs. Adding only those with 'true' values
         // to the tree
@@ -510,7 +495,7 @@
 
             // Reset or allocate the target leaf
 
-            if (leaf == NULL) {
+            if (leaf == nullptr) {
                 leaf = new ResultLeafNodeType(maskLeaf->origin(), mBackground);
             } else {
                 leaf->setOrigin(maskLeaf->origin());
@@ -518,14 +503,12 @@
                 leaf->setValuesOff();
             }
 
-
             // Iterate over the intersecting bounding box
             // copying active values to the result tree
 
             const openvdb::math::Coord start = localBBox.getStart();
             const openvdb::math::Coord end   = localBBox.getEnd();
 
-
             openvdb::math::Coord ijk;
 
             if (mDense.memoryLayout() == openvdb::tools::LayoutZYX
@@ -568,13 +551,13 @@
 
             if (!leaf->isEmpty()) {
                 mResult->addLeaf(leaf);
-                leaf = NULL;
+                leaf = nullptr;
             }
         }
 
         // Clean up an unused leaf.
 
-        if (leaf != NULL) delete leaf;
+        if (leaf != nullptr) delete leaf;
     }
 
     void join(SparseMaskedExtractor& rhs) {
@@ -597,8 +580,8 @@
 template<typename _ResultTreeType, typename DenseValueType>
 struct ExtractAll
 {
-    typedef  _ResultTreeType                       ResultTreeType;
-    typedef typename ResultTreeType::LeafNodeType  ResultLeafNodeType;
+    using ResultTreeType = _ResultTreeType;
+    using ResultLeafNodeType = typename ResultTreeType::LeafNodeType;
 
     template<typename CoordOrIndex> inline void
     operator()(const DenseValueType& a, const CoordOrIndex& offset, ResultLeafNodeType* leaf) const
@@ -608,20 +591,20 @@
 };
 
 
-template <typename DenseType, typename MaskTreeType>
+template<typename DenseType, typename MaskTreeType>
 typename DSConverter<DenseType, MaskTreeType>::Type::Ptr
 extractSparseTreeWithMask(const DenseType& dense,
                           const MaskTreeType& maskProxy,
                           const typename DenseType::ValueType& background,
                           bool threaded)
 {
-    typedef SparseMaskedExtractor<DenseType, MaskTreeType>       LeafExtractor;
-    typedef typename LeafExtractor::DenseValueType               DenseValueType;
-    typedef typename LeafExtractor::ResultTreeType               ResultTreeType;
-    typedef typename LeafExtractor::MaskLeafVec                  MaskLeafVec;
-    typedef typename LeafExtractor::MaskTree                     MaskTree;
-    typedef typename LeafExtractor::MaskLeafCIter                MaskLeafCIter;
-    typedef ExtractAll<ResultTreeType, DenseValueType>           ExtractionRule;
+    using LeafExtractor = SparseMaskedExtractor<DenseType, MaskTreeType>;
+    using DenseValueType = typename LeafExtractor::DenseValueType;
+    using ResultTreeType = typename LeafExtractor::ResultTreeType;
+    using MaskLeafVec = typename LeafExtractor::MaskLeafVec;
+    using MaskTree = typename LeafExtractor::MaskTree;
+    using MaskLeafCIter = typename LeafExtractor::MaskLeafCIter;
+    using ExtractionRule = ExtractAll<ResultTreeType, DenseValueType>;
 
     // Use Mask tree to hold the topology
 
@@ -684,27 +667,22 @@
 /// @brief Class that applies a functor to the index space intersection
 /// of a prescribed bounding box and the dense grid.
 /// NB: This class only supports DenseGrids with ZYX memory layout.
-template <typename _ValueT, typename OpType>
+template<typename _ValueT, typename OpType>
 class DenseTransformer
 {
 public:
-
-    typedef _ValueT                                 ValueT;
-    typedef Dense<ValueT, openvdb::tools::LayoutZYX>       DenseT;
-    typedef openvdb::math::Coord::ValueType         IntType;
-    typedef tbb::blocked_range2d<IntType, IntType>  RangeType;
-
+    using ValueT = _ValueT;
+    using DenseT = Dense<ValueT, openvdb::tools::LayoutZYX>;
+    using IntType = openvdb::math::Coord::ValueType;
+    using RangeType = tbb::blocked_range2d<IntType, IntType>;
 
 private:
-
     DenseT&                  mDense;
     const OpType&            mOp;
     openvdb::math::CoordBBox mBBox;
 
 public:
-    DenseTransformer(DenseT& dense,
-                     const openvdb::math::CoordBBox& bbox,
-                     const OpType& functor):
+    DenseTransformer(DenseT& dense, const openvdb::math::CoordBBox& bbox, const OpType& functor):
         mDense(dense), mOp(functor), mBBox(dense.bbox())
     {
         // The iteration space is the intersection of the
@@ -763,12 +741,12 @@
 /// @brief a wrapper struct used to avoid unnecessary computation of
 /// memory access from @c Coord when all offsets are guaranteed to be
 /// within the dense grid.
-template <typename ValueT, typename PointWiseOp>
+template<typename ValueT, typename PointWiseOp>
 struct ContiguousOp
 {
     ContiguousOp(const PointWiseOp& op) : mOp(op){}
 
-    typedef Dense<ValueT, openvdb::tools::LayoutZYX>  DenseT;
+    using DenseT = Dense<ValueT, openvdb::tools::LayoutZYX>;
     inline void transform(DenseT& dense, openvdb::math::Coord& ijk, size_t size) const
     {
         ValueT* dp = const_cast<ValueT*>(&dense.getValue(ijk));
@@ -783,13 +761,13 @@
 
 
 /// Apply a point-wise functor to the intersection of a dense grid and a given bounding box
-template <typename ValueT, typename PointwiseOpT>
+template<typename ValueT, typename PointwiseOpT>
 void
 transformDense(Dense<ValueT, openvdb::tools::LayoutZYX>& dense,
                const openvdb::CoordBBox& bbox,
                const PointwiseOpT& functor, bool parallel)
 {
-    typedef ContiguousOp<ValueT, PointwiseOpT>  OpT;
+    using OpT = ContiguousOp<ValueT, PointwiseOpT>;
 
     // Convert the Op so it operates on a contiguous line in memory
 
@@ -801,19 +779,18 @@
 }
 
 
-template <typename CompositeMethod, typename _TreeT>
+template<typename CompositeMethod, typename _TreeT>
 class SparseToDenseCompositor
 {
-
 public:
-    typedef _TreeT                                               TreeT;
-    typedef typename TreeT::ValueType                            ValueT;
-    typedef typename TreeT::LeafNodeType                         LeafT;
-    typedef typename TreeT::template ValueConverter<ValueMask>::Type  MaskTreeT;
-    typedef typename MaskTreeT::LeafNodeType                     MaskLeafT;
-    typedef Dense<ValueT, openvdb::tools::LayoutZYX>             DenseT;
-    typedef openvdb::math::Coord::ValueType                      Index;
-    typedef tbb::blocked_range3d<Index, Index, Index>            Range3d;
+    using TreeT = _TreeT;
+    using ValueT = typename TreeT::ValueType;
+    using LeafT = typename TreeT::LeafNodeType;
+    using MaskTreeT = typename TreeT::template ValueConverter<ValueMask>::Type;
+    using MaskLeafT = typename MaskTreeT::LeafNodeType;
+    using DenseT = Dense<ValueT, openvdb::tools::LayoutZYX>;
+    using Index = openvdb::math::Coord::ValueType;
+    using Range3d = tbb::blocked_range3d<Index, Index, Index>;
 
     SparseToDenseCompositor(DenseT& dense, const TreeT& source, const TreeT& alpha,
                             const ValueT beta, const ValueT strength) :
@@ -825,11 +802,10 @@
         mBeta(other.mBeta), mStrength(other.mStrength) {}
 
 
-
-    void sparseComposite(bool threaded) {
-
+    void sparseComposite(bool threaded)
+    {
         const ValueT beta = mBeta;
-        const ValueT strenght = mStrength;
+        const ValueT strength = mStrength;
 
         // construct a tree that defines the iteration space
 
@@ -863,7 +839,7 @@
             const ValueT sourceValue = sourceAccessor.getValue(org);
 
             if (openvdb::math::isZero(alphaValue) &&
-                openvdb::math::isZero(sourceValue) ) continue;
+                openvdb::math::isZero(sourceValue)) continue;
 
             // Compute overlap of tile with the dense grid
 
@@ -876,7 +852,7 @@
 
             // Composite the tile-uniform values into the dense grid.
             compositeFromTile(mDense, localBBox, sourceValue,
-                              alphaValue, beta, strenght, threaded);
+                              alphaValue, beta, strength, threaded);
         }
     }
 
@@ -884,8 +860,7 @@
     // Used in sparseComposite
     void inline operator()(const MaskLeafT& maskLeaf, size_t /*i*/) const
     {
-
-        typedef UniformLeaf   ULeaf;
+        using ULeaf = UniformLeaf;
         openvdb::math::CoordBBox localBBox = maskLeaf.getNodeBoundingBox();
         localBBox.intersect(mDense.bbox());
 
@@ -931,12 +906,12 @@
     }
     // i.e.  it assumes that all valueOff Alpha voxels have value 0.
 
-    template <typename LeafT1, typename LeafT2>
+    template<typename LeafT1, typename LeafT2>
     inline static void compositeFromLeaf(DenseT& dense, const openvdb::math::CoordBBox& bbox,
                                          const LeafT1& source, const LeafT2& alpha,
                                          const ValueT beta, const ValueT strength)
     {
-        typedef openvdb::math::Coord::ValueType  IntType;
+        using IntType = openvdb::math::Coord::ValueType;
 
         const ValueT sbeta = strength * beta;
         openvdb::math::Coord ijk = bbox.min();
@@ -969,12 +944,8 @@
                     for (ijk[2] = bbox.min().z(); ijk[2] < bbox.max().z() + 1; ++ijk[2]) {
 
                         if (alpha.isValueOn(ijk)) {
-
-                            dense.setValue(ijk,
-                             CompositeMethod::apply(dense.getValue(ijk),
-                                                    alpha.getValue(ijk), source.getValue(ijk),
-                                                    strength, beta, sbeta)
-                                           );
+                            dense.setValue(ijk, CompositeMethod::apply(dense.getValue(ijk),
+                                alpha.getValue(ijk), source.getValue(ijk), strength, beta, sbeta));
                         }
                     }
                 }
@@ -983,21 +954,18 @@
     }
 
     inline static void compositeFromTile(DenseT& dense, openvdb::math::CoordBBox& bbox,
-                                         const ValueT& sourceValue, const ValueT& alphaValue,
-                                         const ValueT& beta, const ValueT& strength,
-                                         bool threaded)
+        const ValueT& sourceValue, const ValueT& alphaValue,
+        const ValueT& beta, const ValueT& strength,
+        bool threaded)
     {
-
-        typedef UniformTransformer TileTransformer;
+        using TileTransformer = UniformTransformer;
         TileTransformer functor(sourceValue, alphaValue, beta, strength);
 
         // Transform the data inside the bbox according to the TileTranformer.
 
         transformDense(dense, bbox, functor, threaded);
-
     }
 
-
     void denseComposite(bool threaded)
     {
         /// Construct a range that corresponds to the
@@ -1016,12 +984,11 @@
         } else {
             (*this)(range);
         }
-
     }
 
     // Composites a dense region using value accessors
     // into a dense grid
-    void inline operator()(const Range3d& range) const
+    void operator()(const Range3d& range) const
     {
         // Use value accessors to alpha and source
 
@@ -1050,17 +1017,14 @@
                     const ValueT& alpha = alphaAccessor.getValue(ijk);
                     const ValueT& src   = sourceAccessor.getValue(ijk);
 
-                    mDense.setValue(ijk, CompositeMethod::apply(d_old, alpha, src,
-                                                                strength, beta, sbeta));
+                    mDense.setValue(ijk,
+                        CompositeMethod::apply(d_old, alpha, src, strength, beta, sbeta));
                 }
             }
         }
-
     }
 
-
 private:
-
     // Internal class that wraps the templated composite method
     // for use when both alpha and source are uniform over
     // a prescribed bbox (e.g. a tile).
@@ -1075,13 +1039,15 @@
 
         ValueT operator()(const ValueT& input) const
         {
-            return CompositeMethod::apply(input, mAlpha, mSource,
-                                          mStrength, mBeta, mSBeta);
+            return CompositeMethod::apply(input, mAlpha, mSource, mStrength, mBeta, mSBeta);
         }
 
     private:
-        const ValueT mSource;   const ValueT mAlpha; const ValueT mBeta;
-        const ValueT mStrength; const ValueT mSBeta;
+        const ValueT mSource;
+        const ValueT mAlpha;
+        const ValueT mBeta;
+        const ValueT mStrength;
+        const ValueT mSBeta;
     };
 
 
@@ -1092,9 +1058,9 @@
     class UniformLeaf : private Line
     {
     public:
-        typedef typename LeafT::ValueType ValueT;
+        using ValueT = typename LeafT::ValueType;
 
-        typedef Line   BaseT;
+        using BaseT = Line;
         UniformLeaf(const ValueT& value) : BaseT(init(value)) {}
 
         static const BaseT init(const ValueT& value) {
@@ -1108,8 +1074,7 @@
         bool isDense() const { return true; }
         bool isValueOn(openvdb::math::Coord&) const { return true; }
 
-        inline const ValueT& getValue(const openvdb::math::Coord& ) const
-        {return  BaseT::mValues[0];}
+        const ValueT& getValue(const openvdb::math::Coord&) const { return  BaseT::mValues[0]; }
     };
 
 private:
@@ -1125,7 +1090,7 @@
 {
     //@{
     /// @brief Point wise methods used to apply various compositing operations.
-    template <typename ValueT>
+    template<typename ValueT>
     struct OpOver
     {
         static inline ValueT apply(const ValueT u, const ValueT alpha,
@@ -1136,8 +1101,7 @@
         { return (u + strength * alpha * (beta * v - u)); }
     };
 
-
-    template <typename ValueT>
+    template<typename ValueT>
     struct OpAdd
     {
         static inline ValueT apply(const ValueT u, const ValueT alpha,
@@ -1148,7 +1112,7 @@
         { return (u + sbeta * alpha * v); }
     };
 
-    template <typename ValueT>
+    template<typename ValueT>
     struct OpSub
     {
         static inline ValueT apply(const ValueT u, const ValueT alpha,
@@ -1159,7 +1123,7 @@
         { return (u - sbeta * alpha * v); }
     };
 
-    template <typename ValueT>
+    template<typename ValueT>
     struct OpMin
     {
         static inline ValueT apply(const ValueT u, const ValueT alpha,
@@ -1170,8 +1134,7 @@
         { return ( ( 1 - s * alpha) * u + s * alpha * std::min(u, beta * v) ); }
     };
 
-
-    template <typename ValueT>
+    template<typename ValueT>
     struct OpMax
     {
         static inline ValueT apply(const ValueT u, const ValueT alpha,
@@ -1182,7 +1145,7 @@
         { return ( ( 1 - s * alpha ) * u + s * alpha * std::min(u, beta * v) ); }
     };
 
-    template <typename ValueT>
+    template<typename ValueT>
     struct OpMult
     {
         static inline ValueT apply(const ValueT u, const ValueT alpha,
@@ -1196,42 +1159,43 @@
 
     //@{
     /// Translator that converts an enum to compositing functor types
-    template <DSCompositeOp OP, typename ValueT>
+    template<DSCompositeOp OP, typename ValueT>
     struct CompositeFunctorTranslator{};
 
-    template <typename ValueT>
-    struct CompositeFunctorTranslator<DS_OVER, ValueT>{ typedef OpOver<ValueT>   OpT; };
+    template<typename ValueT>
+    struct CompositeFunctorTranslator<DS_OVER, ValueT>{ using OpT = OpOver<ValueT>; };
 
-    template <typename ValueT>
-    struct CompositeFunctorTranslator<DS_ADD, ValueT>{ typedef OpAdd<ValueT>   OpT; };
+    template<typename ValueT>
+    struct CompositeFunctorTranslator<DS_ADD, ValueT>{ using OpT = OpAdd<ValueT>; };
 
-    template <typename ValueT>
-    struct CompositeFunctorTranslator<DS_SUB, ValueT>{ typedef OpSub<ValueT>   OpT; };
+    template<typename ValueT>
+    struct CompositeFunctorTranslator<DS_SUB, ValueT>{ using OpT = OpSub<ValueT>; };
 
-    template <typename ValueT>
-    struct CompositeFunctorTranslator<DS_MIN, ValueT>{ typedef OpMin<ValueT>   OpT; };
+    template<typename ValueT>
+    struct CompositeFunctorTranslator<DS_MIN, ValueT>{ using OpT = OpMin<ValueT>; };
 
-    template <typename ValueT>
-    struct CompositeFunctorTranslator<DS_MAX, ValueT>{ typedef OpMax<ValueT>   OpT; };
+    template<typename ValueT>
+    struct CompositeFunctorTranslator<DS_MAX, ValueT>{ using OpT = OpMax<ValueT>; };
 
-    template <typename ValueT>
-    struct CompositeFunctorTranslator<DS_MULT, ValueT>{ typedef OpMult<ValueT>   OpT; };
+    template<typename ValueT>
+    struct CompositeFunctorTranslator<DS_MULT, ValueT>{ using OpT = OpMult<ValueT>; };
     //@}
 
 } // namespace ds
 
 
-template <DSCompositeOp OpT, typename TreeT>
-void compositeToDense(
+template<DSCompositeOp OpT, typename TreeT>
+inline void
+compositeToDense(
     Dense<typename TreeT::ValueType, LayoutZYX>& dense,
     const TreeT& source, const TreeT& alpha,
     const typename TreeT::ValueType beta,
     const typename TreeT::ValueType strength,
     bool threaded)
 {
-    typedef typename TreeT::ValueType  ValueT;
-    typedef ds::CompositeFunctorTranslator<OpT, ValueT> Translator;
-    typedef typename Translator::OpT  Method;
+    using ValueT = typename TreeT::ValueType;
+    using Translator = ds::CompositeFunctorTranslator<OpT, ValueT>;
+    using Method = typename Translator::OpT;
 
     if (openvdb::math::isZero(strength)) return;
 
@@ -1254,6 +1218,6 @@
 
 #endif //OPENVDB_TOOLS_DENSESPARSETOOLS_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tools/Filter.h openvdb-6.1.0/openvdb/tools/Filter.h
--- openvdb-6.0.0/openvdb/tools/Filter.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/Filter.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -84,7 +84,7 @@
     /// @param interrupt Optional interrupter.
     Filter(GridT& grid, InterruptT* interrupt = nullptr)
         : mGrid(&grid)
-        , mTask(0)
+        , mTask(nullptr)
         , mInterrupter(interrupt)
         , mMask(nullptr)
         , mGrainSize(1)
@@ -238,7 +238,10 @@
     ValueType sum = zeroVal<ValueType>();
     Int32 &i = xyz[Axis], j = i + width;
     for (i -= width; i <= j; ++i) filter_internal::accum(sum, acc.getValue(xyz));
-    return static_cast<ValueType>(sum * frac);
+    OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+    ValueType value = static_cast<ValueType>(sum * frac);
+    OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+    return value;
 }
 
 
@@ -370,7 +373,10 @@
             for (VoxelCIterT iter = leafIter->cbeginValueOn(); iter; ++iter) {
                 const Coord xyz = iter.getCoord();
                 if (alpha(xyz, a, b)) {
-                    buffer.setValue(iter.pos(), ValueType(b*(*iter) + a*avg(xyz)));
+                    OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+                    const ValueType value(b*(*iter) + a*avg(xyz));
+                    OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+                    buffer.setValue(iter.pos(), value);
                 }
             }
         }
@@ -400,7 +406,10 @@
             for (VoxelCIterT iter = leafIter->cbeginValueOn(); iter; ++iter) {
                 if (alpha(iter.getCoord(), a, b)) {
                     stencil.moveTo(iter);
-                    buffer.setValue(iter.pos(), ValueType(b*(*iter) + a*stencil.median()));
+                    OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+                    ValueType value(b*(*iter) + a*stencil.median());
+                    OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+                    buffer.setValue(iter.pos(), value);
                 }
             }
         }
@@ -427,7 +436,12 @@
         AlphaMaskT alpha(*mGrid, *mMask, mMinMask, mMaxMask, mInvertMask);
         for (LeafIterT leafIter=range.begin(); leafIter; ++leafIter) {
             for (VoxelIterT iter = leafIter->beginValueOn(); iter; ++iter) {
-                if (alpha(iter.getCoord(), a, b)) iter.setValue(ValueType(*iter + a*offset));
+                if (alpha(iter.getCoord(), a, b)) {
+                    OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+                    ValueType value(*iter + a*offset);
+                    OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+                    iter.setValue(value);
+                }
             }
         }
     } else {
@@ -457,6 +471,6 @@
 
 #endif // OPENVDB_TOOLS_FILTER_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tools/GridTransformer.h openvdb-6.1.0/openvdb/tools/GridTransformer.h
--- openvdb-6.0.0/openvdb/tools/GridTransformer.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/GridTransformer.h	2019-05-07 22:58:35.000000000 +0200
@@ -496,9 +496,13 @@
         // If the output grid is a level set, resample the input grid to have the output grid's
         // background value.  Otherwise, preserve the input grid's background value.
         using ValueT = typename GridType::ValueType;
-        const ValueT halfWidth = ((outGrid.getGridClass() == openvdb::GRID_LEVEL_SET)
+        const bool outIsLevelSet = outGrid.getGridClass() == openvdb::GRID_LEVEL_SET;
+
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+        const ValueT halfWidth = outIsLevelSet
             ? ValueT(outGrid.background() * (1.0 / outGrid.voxelSize()[0]))
-            : ValueT(inGrid.background() * (1.0 / inGrid.voxelSize()[0])));
+            : ValueT(inGrid.background() * (1.0 / inGrid.voxelSize()[0]));
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_END
 
         typename GridType::Ptr tempGrid;
         try {
diff -aur openvdb-6.0.0/openvdb/tools/Interpolation.h openvdb-6.1.0/openvdb/tools/Interpolation.h
--- openvdb-6.0.0/openvdb/tools/Interpolation.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/Interpolation.h	2019-05-07 22:58:35.000000000 +0200
@@ -738,23 +738,30 @@
 inline ValueT
 BoxSampler::trilinearInterpolation(ValueT (&data)[N][N][N], const Vec3R& uvw)
 {
+    auto _interpolate = [](const ValueT& a, const ValueT& b, double weight)
+    {
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+        const auto temp = (b - a) * weight;
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+        return static_cast<ValueT>(a + ValueT(temp));
+    };
+
     // Trilinear interpolation:
     // The eight surrounding latice values are used to construct the result. \n
     // result(x,y,z) =
     //     v000 (1-x)(1-y)(1-z) + v001 (1-x)(1-y)z + v010 (1-x)y(1-z) + v011 (1-x)yz
     //   + v100 x(1-y)(1-z)     + v101 x(1-y)z     + v110 xy(1-z)     + v111 xyz
 
-    ValueT resultA, resultB;
-
-    resultA = data[0][0][0] + ValueT((data[0][0][1] - data[0][0][0]) * uvw[2]);
-    resultB = data[0][1][0] + ValueT((data[0][1][1] - data[0][1][0]) * uvw[2]);
-    ValueT result1 = resultA + ValueT((resultB-resultA) * uvw[1]);
-
-    resultA = data[1][0][0] + ValueT((data[1][0][1] - data[1][0][0]) * uvw[2]);
-    resultB = data[1][1][0] + ValueT((data[1][1][1] - data[1][1][0]) * uvw[2]);
-    ValueT result2 = resultA + ValueT((resultB - resultA) * uvw[1]);
-
-    return result1 + ValueT(uvw[0] * (result2 - result1));
+    return  _interpolate(
+                _interpolate(
+                    _interpolate(data[0][0][0], data[0][0][1], uvw[2]),
+                    _interpolate(data[0][1][0], data[0][1][1], uvw[2]),
+                    uvw[1]),
+                _interpolate(
+                    _interpolate(data[1][0][0], data[1][0][1], uvw[2]),
+                    _interpolate(data[1][1][0], data[1][1][1], uvw[2]),
+                    uvw[1]),
+                uvw[0]);
 }
 
 
@@ -805,6 +812,18 @@
 inline ValueT
 QuadraticSampler::triquadraticInterpolation(ValueT (&data)[N][N][N], const Vec3R& uvw)
 {
+    auto _interpolate = [](const ValueT* value, double weight)
+    {
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+        const ValueT
+            a = static_cast<ValueT>(0.5 * (value[0] + value[2]) - value[1]),
+            b = static_cast<ValueT>(0.5 * (value[2] - value[0])),
+            c = static_cast<ValueT>(value[1]);
+        const auto temp = weight * (weight * a + b) + c;
+        OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+        return static_cast<ValueT>(temp);
+    };
+
     /// @todo For vector types, interpolate over each component independently.
     ValueT vx[3];
     for (int dx = 0; dx < 3; ++dx) {
@@ -821,28 +840,16 @@
             //
             // for a, b and c.
             const ValueT* vz = &data[dx][dy][0];
-            const ValueT
-                az = static_cast<ValueT>(0.5 * (vz[0] + vz[2]) - vz[1]),
-                bz = static_cast<ValueT>(0.5 * (vz[2] - vz[0])),
-                cz = static_cast<ValueT>(vz[1]);
-            vy[dy] = static_cast<ValueT>(uvw.z() * (uvw.z() * az + bz) + cz);
+            vy[dy] = _interpolate(vz, uvw.z());
         }//loop over y
         // Fit a parabola to three interpolated samples in y, then
         // evaluate the parabola at y', where y' is the fractional
         // part of inCoord.y.
-        const ValueT
-            ay = static_cast<ValueT>(0.5 * (vy[0] + vy[2]) - vy[1]),
-            by = static_cast<ValueT>(0.5 * (vy[2] - vy[0])),
-            cy = static_cast<ValueT>(vy[1]);
-        vx[dx] = static_cast<ValueT>(uvw.y() * (uvw.y() * ay + by) + cy);
+        vx[dx] = _interpolate(vy, uvw.y());
     }//loop over x
     // Fit a parabola to three interpolated samples in x, then
     // evaluate the parabola at the fractional part of inCoord.x.
-    const ValueT
-        ax = static_cast<ValueT>(0.5 * (vx[0] + vx[2]) - vx[1]),
-        bx = static_cast<ValueT>(0.5 * (vx[2] - vx[0])),
-        cx = static_cast<ValueT>(vx[1]);
-    return static_cast<ValueT>(uvw.x() * (uvw.x() * ax + bx) + cx);
+    return _interpolate(vx, uvw.x());
 }
 
 template<class TreeT>
diff -aur openvdb-6.0.0/openvdb/tools/LevelSetFracture.h openvdb-6.1.0/openvdb/tools/LevelSetFracture.h
--- openvdb-6.0.0/openvdb/tools/LevelSetFracture.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/LevelSetFracture.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -45,8 +45,10 @@
 #include "GridTransformer.h" // for resampleToMatch()
 #include "LevelSetUtil.h" // for sdfSegmentation()
 
+#include <algorithm> // for std::max(), std::min()
 #include <limits>
 #include <list>
+#include <vector>
 
 #include <tbb/blocked_range.h>
 #include <tbb/parallel_reduce.h>
@@ -62,16 +64,16 @@
 class LevelSetFracture
 {
 public:
-    typedef std::vector<Vec3s> Vec3sList;
-    typedef std::vector<math::Quats> QuatsList;
-    typedef std::list<typename GridType::Ptr> GridPtrList;
-    typedef typename GridPtrList::iterator GridPtrListIter;
+    using Vec3sList = std::vector<Vec3s>;
+    using QuatsList = std::vector<math::Quats>;
+    using GridPtrList = std::list<typename GridType::Ptr>;
+    using GridPtrListIter = typename GridPtrList::iterator;
 
 
     /// @brief Default constructor
     ///
     /// @param interrupter  optional interrupter object
-    explicit LevelSetFracture(InterruptType* interrupter = NULL);
+    explicit LevelSetFracture(InterruptType* interrupter = nullptr);
 
     /// @brief Divide volumes represented by level set grids into multiple,
     /// disjoint pieces by intersecting them with one or more "cutter" volumes,
@@ -92,7 +94,7 @@
     /// @param cutterOverlap  toggle to allow consecutive cutter instances to fracture
     ///                       previously generated fragments
     void fracture(GridPtrList& grids, const GridType& cutter, bool segment = false,
-        const Vec3sList* points = NULL, const QuatsList* rotations = NULL,
+        const Vec3sList* points = nullptr, const QuatsList* rotations = nullptr,
         bool cutterOverlap = true);
 
     /// Return a list of new fragments, not including the residuals from the input grids.
@@ -129,12 +131,12 @@
 template<typename LeafNodeType>
 struct FindMinMaxVoxelValue {
 
-    typedef typename LeafNodeType::ValueType    ValueType;
+    using ValueType = typename LeafNodeType::ValueType;
 
     FindMinMaxVoxelValue(const std::vector<const LeafNodeType*>& nodes)
         : minValue(std::numeric_limits<ValueType>::max())
         , maxValue(-minValue)
-        , mNodes(nodes.empty() ? NULL : &nodes.front())
+        , mNodes(nodes.empty() ? nullptr : &nodes.front())
     {
     }
 
@@ -220,7 +222,7 @@
 
             // Since there is no scaling, use the generic resampler instead of
             // the more expensive level set rebuild tool.
-            if (mInterrupter != NULL) {
+            if (mInterrupter != nullptr) {
 
                 if (hasInstanceRotations) {
                     doResampleToMatch<BoxSampler>(cutterGrid, instCutterGrid, *mInterrupter);
@@ -259,7 +261,7 @@
 bool
 LevelSetFracture<GridType, InterruptType>::isValidFragment(GridType& grid) const
 {
-    typedef typename GridType::TreeType::LeafNodeType LeafNodeType;
+    using LeafNodeType = typename GridType::TreeType::LeafNodeType;
 
     if (grid.tree().leafCount() < 9) {
 
@@ -309,7 +311,7 @@
 LevelSetFracture<GridType, InterruptType>::process(
     GridPtrList& grids, const GridType& cutter)
 {
-    typedef typename GridType::Ptr GridPtr;
+    using GridPtr = typename GridType::Ptr;
     GridPtrList newFragments;
 
     for (GridPtrListIter it = grids.begin(); it != grids.end(); ++it) {
@@ -341,6 +343,6 @@
 
 #endif // OPENVDB_TOOLS_LEVELSETFRACTURE_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tools/LevelSetMeasure.h openvdb-6.1.0/openvdb/tools/LevelSetMeasure.h
--- openvdb-6.0.0/openvdb/tools/LevelSetMeasure.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/LevelSetMeasure.h	2019-05-07 22:58:35.000000000 +0200
@@ -403,7 +403,7 @@
                 const Coord p = voxelIter.getCoord();
                 const Vec3T g = invDx*Grad::result(mAcc, p);//voxel units
                 sumA += dd * g.dot(g);
-                sumV += dd * (g[0]*p[0]+g[1]*p[1]+g[2]*p[2]);
+                sumV += dd * g.dot(Vec3T(p.data()));
             }
         }
         double* v = mParent->mArray + leafIter.pos();
@@ -435,7 +435,7 @@
                 const Vec3T g = invDx*Grad::result(mAcc, p);//voxel units
                 const Real dA = dd * g.dot(g);
                 sumA += dA;
-                sumV += dd * (g[0]*p[0]+g[1]*p[1]+g[2]*p[2]);
+                sumV += dd * g.dot(Vec3T(p.data()));
                 Curv::result(mAcc, p, alpha, beta);
                 sumC += dA * alpha/(2*math::Pow2(beta))*invDx;
             }
diff -aur openvdb-6.0.0/openvdb/tools/LevelSetMorph.h openvdb-6.1.0/openvdb/tools/LevelSetMorph.h
--- openvdb-6.0.0/openvdb/tools/LevelSetMorph.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/LevelSetMorph.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -353,7 +353,7 @@
     : mParent(&parent)
     , mMinAbsS(ValueType(1e-6))
     , mMap(parent.mTracker.grid().transform().template constMap<MapT>().get())
-    , mTask(0)
+    , mTask(nullptr)
 {
 }
 
@@ -670,6 +670,6 @@
 
 #endif // OPENVDB_TOOLS_LEVEL_SET_MORPH_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tools/LevelSetSphere.h openvdb-6.1.0/openvdb/tools/LevelSetSphere.h
--- openvdb-6.0.0/openvdb/tools/LevelSetSphere.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/LevelSetSphere.h	2019-05-07 22:58:35.000000000 +0200
@@ -166,13 +166,13 @@
         // Compute signed distances to sphere using leapfrogging in k
         for (i = imin; i <= imax; ++i) {
             if (util::wasInterrupted(mInterrupt)) return;
-            const auto x2 = math::Pow2(i - c[0]);
+            const auto x2 = math::Pow2(ValueT(i) - c[0]);
             for (j = jmin; j <= jmax; ++j) {
-                const auto x2y2 = math::Pow2(j - c[1]) + x2;
+                const auto x2y2 = math::Pow2(ValueT(j) - c[1]) + x2;
                 for (k = kmin; k <= kmax; k += m) {
                     m = 1;
                     /// Distance in voxel units to sphere
-                    const auto v = math::Sqrt(x2y2 + math::Pow2(k-c[2]))-r0;
+                    const auto v = math::Sqrt(x2y2 + math::Pow2(ValueT(k) - c[2])) - r0;
                     const auto d = math::Abs(v);
                     if (d < w) { // inside narrow band
                         accessor.setValue(ijk, dx*v);// distance in world units
diff -aur openvdb-6.0.0/openvdb/tools/LevelSetTracker.h openvdb-6.1.0/openvdb/tools/LevelSetTracker.h
--- openvdb-6.0.0/openvdb/tools/LevelSetTracker.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/LevelSetTracker.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -368,7 +368,7 @@
 {
     tools::erodeVoxels(*mLeafs, iterations);
     mLeafs->rebuildLeafArray();
-    const ValueType background = mGrid->background() - iterations*mDx;
+    const ValueType background = mGrid->background() - ValueType(iterations) * mDx;
     tools::changeLevelSetBackground(this->leafs(), background);
 }
 
@@ -545,7 +545,7 @@
     , mDt(tracker.voxelSize()*(TemporalScheme == math::TVD_RK1 ? 0.3f :
                                TemporalScheme == math::TVD_RK2 ? 0.9f : 1.0f))
     , mInvDx(1.0f/tracker.voxelSize())
-    , mTask(0)
+    , mTask(nullptr)
 {
 }
 
@@ -676,8 +676,6 @@
 Normalizer<SpatialScheme, TemporalScheme, MaskT>::
 euler(const LeafRange& range, Index phiBuffer, Index resultBuffer)
 {
-    using VoxelIterT = typename LeafType::ValueOnCIter;
-
     mTracker.checkInterrupter();
 
     StencilT stencil(mTracker.grid());
@@ -686,7 +684,7 @@
         const ValueType* phi = leafIter.buffer(phiBuffer).data();
         ValueType* result = leafIter.buffer(resultBuffer).data();
         if (mMask == nullptr) {
-            for (VoxelIterT iter = leafIter->cbeginValueOn(); iter; ++iter) {
+            for (auto iter = leafIter->cbeginValueOn(); iter; ++iter) {
                 stencil.moveTo(iter);
                 this->eval<Nominator, Denominator>(stencil, phi, result, iter.pos());
             }//loop over active voxels in the leaf of the level set
@@ -707,6 +705,6 @@
 
 #endif // OPENVDB_TOOLS_LEVEL_SET_TRACKER_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tools/LevelSetUtil.h openvdb-6.1.0/openvdb/tools/LevelSetUtil.h
--- openvdb-6.0.0/openvdb/tools/LevelSetUtil.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/LevelSetUtil.h	2019-05-07 22:58:35.000000000 +0200
@@ -2380,6 +2380,9 @@
 
     BoolTreeType topologyMask(tree, false, TopologyCopy());
 
+    // prune out any inactive leaf nodes or inactive tiles
+    tools::pruneInactive(topologyMask);
+
     if (topologyMask.hasActiveTiles()) {
         topologyMask.voxelizeActiveTiles();
     }
@@ -2461,6 +2464,8 @@
 
         BoolTreePtrType mask(new BoolTreeType(tree, false, TopologyCopy()));
 
+        tools::pruneInactive(*mask);
+
         if (mask->hasActiveTiles()) {
             mask->voxelizeActiveTiles();
         }
@@ -2533,30 +2538,35 @@
     std::vector<BoolTreePtrType> maskSegmentArray;
     extractActiveVoxelSegmentMasks(inputTree, maskSegmentArray);
 
-    const size_t numSegments = maskSegmentArray.size();
-
-    if (numSegments < 2) {
-        // single segment early-out
-        TreePtrType segment(new TreeType(inputTree));
-        segments.push_back(
-            level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::construct(
-                volume, segment));
-        return;
-    }
-
-    const tbb::blocked_range<size_t> segmentRange(0, numSegments);
-
     // 2. Export segments
+
+    const size_t numSegments = std::max(size_t(1), maskSegmentArray.size());
     std::vector<TreePtrType> outputSegmentArray(numSegments);
 
-    tbb::parallel_for(segmentRange,
-        level_set_util_internal::MaskedCopy<TreeType>(inputTree, outputSegmentArray,
-            maskSegmentArray));
+    if (maskSegmentArray.empty()) {
+        // if no active voxels in the original volume, copy just the background
+        // value of the input tree
+        outputSegmentArray[0] = TreePtrType(new TreeType(inputTree.background()));
+    } else if (numSegments == 1) {
+        // if there's only one segment with active voxels, copy the input tree
+        TreePtrType segment(new TreeType(inputTree));
+        // however, if the leaf counts do not match due to the pruning of inactive leaf
+        // nodes in the mask, do a topology intersection to drop these inactive leafs
+        if (segment->leafCount() != inputTree.leafCount()) {
+            segment->topologyIntersection(*maskSegmentArray[0]);
+        }
+        outputSegmentArray[0] = segment;
+    } else {
+        const tbb::blocked_range<size_t> segmentRange(0, numSegments);
+        tbb::parallel_for(segmentRange,
+            level_set_util_internal::MaskedCopy<TreeType>(inputTree, outputSegmentArray,
+                maskSegmentArray));
+    }
 
-    for (size_t n = 0, N = numSegments; n < N; ++n) {
+    for (auto& segment : outputSegmentArray) {
         segments.push_back(
             level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::construct(
-                volume, outputSegmentArray[n]));
+                volume, segment));
     }
 }
 
@@ -2579,38 +2589,33 @@
     std::vector<BoolTreePtrType> maskSegmentArray;
     extractActiveVoxelSegmentMasks(*mask, maskSegmentArray);
 
-    const size_t numSegments = maskSegmentArray.size();
-
-    if (numSegments < 2) {
-        // single segment early-out
-        TreePtrType segment(new TreeType(inputTree));
-        segments.push_back(
-            level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::construct(
-                volume, segment));
-        return;
-    }
-
-    const tbb::blocked_range<size_t> segmentRange(0, numSegments);
-
+    const size_t numSegments = std::max(size_t(1), maskSegmentArray.size());
+    std::vector<TreePtrType> outputSegmentArray(numSegments);
 
-    // 3. Expand zero crossing mask to capture sdf narrow band
-    tbb::parallel_for(segmentRange,
-        level_set_util_internal::ExpandNarrowbandMask<TreeType>(inputTree, maskSegmentArray));
+    if (maskSegmentArray.empty()) {
+        // if no active voxels in the original volume, copy just the background
+        // value of the input tree
+        outputSegmentArray[0] = TreePtrType(new TreeType(inputTree.background()));
+    } else {
+        const tbb::blocked_range<size_t> segmentRange(0, numSegments);
 
-    // 4. Export sdf segments
-    std::vector<TreePtrType> outputSegmentArray(numSegments);
+        // 3. Expand zero crossing mask to capture sdf narrow band
+        tbb::parallel_for(segmentRange,
+            level_set_util_internal::ExpandNarrowbandMask<TreeType>(inputTree, maskSegmentArray));
 
-    tbb::parallel_for(segmentRange, level_set_util_internal::MaskedCopy<TreeType>(
-        inputTree, outputSegmentArray, maskSegmentArray));
+        // 4. Export sdf segments
 
-    tbb::parallel_for(segmentRange,
-        level_set_util_internal::FloodFillSign<TreeType>(inputTree, outputSegmentArray));
+        tbb::parallel_for(segmentRange, level_set_util_internal::MaskedCopy<TreeType>(
+            inputTree, outputSegmentArray, maskSegmentArray));
 
+        tbb::parallel_for(segmentRange,
+            level_set_util_internal::FloodFillSign<TreeType>(inputTree, outputSegmentArray));
+    }
 
-    for (size_t n = 0, N = numSegments; n < N; ++n) {
+    for (auto& segment : outputSegmentArray) {
         segments.push_back(
             level_set_util_internal::GridOrTreeConstructor<GridOrTreeType>::construct(
-                volume, outputSegmentArray[n]));
+                volume, segment));
     }
 }
 
diff -aur openvdb-6.0.0/openvdb/tools/MeshToVolume.h openvdb-6.1.0/openvdb/tools/MeshToVolume.h
--- openvdb-6.0.0/openvdb/tools/MeshToVolume.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/MeshToVolume.h	2019-05-07 22:58:35.000000000 +0200
@@ -2053,7 +2053,7 @@
                 typename VoxelizationDataType::Ptr& dataPtr = mLocalDataTable->local();
                 if (!dataPtr) dataPtr.reset(new VoxelizationDataType());
 
-                voxelizeTriangle(mPrim, *dataPtr);
+                voxelizeTriangle(mPrim, *dataPtr, mInterrupter);
 
             } else if (!(mInterrupter && mInterrupter->wasInterrupted())) {
                 spawnTasks(mPrim, *mLocalDataTable, mSubdivisionCount, mPolygonCount, mInterrupter);
@@ -2088,7 +2088,7 @@
             polygonCount < SubTask::POLYGON_LIMIT ? evalSubdivisionCount(prim) : 0;
 
         if (subdivisionCount <= 0) {
-            voxelizeTriangle(prim, data);
+            voxelizeTriangle(prim, data, mInterrupter);
         } else {
             spawnTasks(prim, *mDataTable, subdivisionCount, polygonCount, mInterrupter);
         }
@@ -2136,7 +2136,7 @@
         tasks.wait();
     }
 
-    static void voxelizeTriangle(const Triangle& prim, VoxelizationDataType& data)
+    static void voxelizeTriangle(const Triangle& prim, VoxelizationDataType& data, Interrupter* const interrupter)
     {
         std::deque<Coord> coordList;
         Coord ijk, nijk;
@@ -2144,26 +2144,35 @@
         ijk = Coord::floor(prim.a);
         coordList.push_back(ijk);
 
-        computeDistance(ijk, prim, data);
+        // The first point may not be quite in bounds, and rely
+        // on one of the neighbours to have the first valid seed,
+        // so we cannot early-exit here.
+        updateDistance(ijk, prim, data);
 
         unsigned char primId = data.getNewPrimId();
         data.primIdAcc.setValueOnly(ijk, primId);
 
         while (!coordList.empty()) {
-            ijk = coordList.back();
-            coordList.pop_back();
-
-            for (Int32 i = 0; i < 26; ++i) {
-                nijk = ijk + util::COORD_OFFSETS[i];
-                if (primId != data.primIdAcc.getValue(nijk)) {
-                    data.primIdAcc.setValueOnly(nijk, primId);
-                    if(computeDistance(nijk, prim, data)) coordList.push_back(nijk);
+            if (interrupter && interrupter->wasInterrupted()) {
+                tbb::task::self().cancel_group_execution();
+                break;
+            }
+            for (Int32 pass = 0; pass < 1048576 && !coordList.empty(); ++pass) {
+                ijk = coordList.back();
+                coordList.pop_back();
+
+                for (Int32 i = 0; i < 26; ++i) {
+                    nijk = ijk + util::COORD_OFFSETS[i];
+                    if (primId != data.primIdAcc.getValue(nijk)) {
+                        data.primIdAcc.setValueOnly(nijk, primId);
+                        if(updateDistance(nijk, prim, data)) coordList.push_back(nijk);
+                    }
                 }
             }
         }
     }
 
-    static bool computeDistance(const Coord& ijk, const Triangle& prim, VoxelizationDataType& data)
+    static bool updateDistance(const Coord& ijk, const Triangle& prim, VoxelizationDataType& data)
     {
         Vec3d uvw, voxelCenter(ijk[0], ijk[1], ijk[2]);
 
@@ -2172,6 +2181,11 @@
         const ValueType dist = ValueType((voxelCenter -
             closestPointOnTriangleToPoint(prim.a, prim.c, prim.b, voxelCenter, uvw)).lengthSqr());
 
+        // Either the points may be NAN, or they could be far enough from
+        // the origin that computing distance fails.
+        if (std::isnan(dist))
+            return false;
+
         const ValueType oldDist = data.distAcc.getValue(ijk);
 
         if (dist < oldDist) {
diff -aur openvdb-6.0.0/openvdb/tools/Morphology.h openvdb-6.1.0/openvdb/tools/Morphology.h
--- openvdb-6.0.0/openvdb/tools/Morphology.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/Morphology.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -58,7 +58,9 @@
 #include <tbb/task_scheduler_init.h>
 #include <tbb/enumerable_thread_specific.h>
 #include <tbb/parallel_for.h>
+#include <functional>
 #include <type_traits>
+#include <vector>
 
 
 namespace openvdb {
@@ -231,10 +233,10 @@
 
 /// Mapping from a Log2Dim to a data type of size 2^Log2Dim bits
 template<Index Log2Dim> struct DimToWord {};
-template<> struct DimToWord<3> { typedef uint8_t Type; };
-template<> struct DimToWord<4> { typedef uint16_t Type; };
-template<> struct DimToWord<5> { typedef uint32_t Type; };
-template<> struct DimToWord<6> { typedef uint64_t Type; };
+template<> struct DimToWord<3> { using Type = uint8_t; };
+template<> struct DimToWord<4> { using Type = uint16_t; };
+template<> struct DimToWord<5> { using Type = uint32_t; };
+template<> struct DimToWord<6> { using Type = uint64_t; };
 
 
 ////////////////////////////////////////
@@ -244,7 +246,7 @@
 class Morphology
 {
 public:
-    typedef tree::LeafManager<TreeType> ManagerType;
+    using ManagerType = tree::LeafManager<TreeType>;
 
     Morphology(TreeType& tree):
         mOwnsManager(true), mManager(new ManagerType(tree)), mAcc(tree), mSteps(1) {}
@@ -276,9 +278,9 @@
 
     void doErosion(NearestNeighbors nn);
 
-    typedef typename TreeType::LeafNodeType LeafType;
-    typedef typename LeafType::NodeMaskType MaskType;
-    typedef tree::ValueAccessor<TreeType>   AccessorType;
+    using LeafType = typename TreeType::LeafNodeType;
+    using MaskType = typename LeafType::NodeMaskType;
+    using AccessorType = tree::ValueAccessor<TreeType>;
 
     const bool   mOwnsManager;
     ManagerType* mManager;
@@ -287,7 +289,7 @@
 
     static const int LEAF_DIM     = LeafType::DIM;
     static const int LEAF_LOG2DIM = LeafType::LOG2DIM;
-    typedef typename DimToWord<LEAF_LOG2DIM>::Type Word;
+    using Word = typename DimToWord<LEAF_LOG2DIM>::Type;
 
     struct Neighbor {
         LeafType* leaf;//null if a tile
@@ -389,9 +391,9 @@
     };// LeafCache
 
     struct ErodeVoxelsOp {
-        typedef tbb::blocked_range<size_t> RangeT;
+        using RangeT = tbb::blocked_range<size_t>;
         ErodeVoxelsOp(std::vector<MaskType>& masks, ManagerType& manager)
-            : mTask(0), mSavedMasks(masks) , mManager(manager) {}
+            : mTask(nullptr), mSavedMasks(masks) , mManager(manager) {}
         void runParallel(NearestNeighbors nn);
         void operator()(const RangeT& r) const {mTask(const_cast<ErodeVoxelsOp*>(this), r);}
         void erode6( const RangeT&) const;
@@ -892,7 +894,7 @@
 class ActivationOp
 {
 public:
-    typedef typename TreeType::ValueType ValueT;
+    using ValueT = typename TreeType::ValueType;
 
     ActivationOp(bool state, const ValueT& val, const ValueT& tol)
         : mActivate(state)
@@ -916,7 +918,7 @@
 
     void operator()(const typename TreeType::LeafIter& lit) const
     {
-        typedef typename TreeType::LeafNodeType LeafT;
+        using LeafT = typename TreeType::LeafNodeType;
         LeafT& leaf = *lit;
         if (mActivate) {
             for (typename LeafT::ValueOffIter it = leaf.beginValueOff(); it; ++it) {
@@ -946,8 +948,8 @@
 activate(GridOrTree& gridOrTree, const typename GridOrTree::ValueType& value,
     const typename GridOrTree::ValueType& tolerance)
 {
-    typedef TreeAdapter<GridOrTree> Adapter;
-    typedef typename Adapter::TreeType TreeType;
+    using Adapter = TreeAdapter<GridOrTree>;
+    using TreeType = typename Adapter::TreeType;
 
     TreeType& tree = Adapter::tree(gridOrTree);
 
@@ -969,8 +971,8 @@
 deactivate(GridOrTree& gridOrTree, const typename GridOrTree::ValueType& value,
     const typename GridOrTree::ValueType& tolerance)
 {
-    typedef TreeAdapter<GridOrTree> Adapter;
-    typedef typename Adapter::TreeType TreeType;
+    using Adapter = TreeAdapter<GridOrTree>;
+    using TreeType = typename Adapter::TreeType;
 
     TreeType& tree = Adapter::tree(gridOrTree);
 
@@ -991,9 +993,9 @@
 template<typename TreeT>
 class DilationOp
 {
-    typedef typename TreeT::template ValueConverter<ValueMask>::Type MaskT;
-    typedef tbb::enumerable_thread_specific<MaskT>                   PoolT;
-    typedef typename MaskT::LeafNodeType                             LeafT;
+    using MaskT = typename TreeT::template ValueConverter<ValueMask>::Type;
+    using PoolT = tbb::enumerable_thread_specific<MaskT>;
+    using LeafT = typename MaskT::LeafNodeType;
 
     // Very light-weight member data
     const int mIter;// number of iterations
@@ -1018,7 +1020,7 @@
 
         delete [] mLeafs;// no more need for the array of leaf node pointers
 
-        typedef typename PoolT::iterator IterT;
+        using IterT = typename PoolT::iterator;
         for (IterT it=pool.begin(); it!=pool.end(); ++it) mask.merge(*it);// fast stealing
 
         if (mode == PRESERVE_TILES) tools::prune(mask);//multithreaded
@@ -1039,7 +1041,7 @@
 
     // Simple wrapper of a raw double-pointer to mimic a std container
     struct MyArray {
-        typedef LeafT* value_type;//required by Tree::stealNodes
+        using value_type = LeafT*;//required by Tree::stealNodes
         value_type* ptr;
         MyArray(value_type* array) : ptr(array) {}
         void push_back(value_type leaf) { *ptr++ = leaf; }//required by Tree::stealNodes
@@ -1099,6 +1101,6 @@
 
 #endif // OPENVDB_TOOLS_MORPHOLOGY_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tools/MultiResGrid.h openvdb-6.1.0/openvdb/tools/MultiResGrid.h
--- openvdb-6.0.0/openvdb/tools/MultiResGrid.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/MultiResGrid.h	2019-05-07 22:58:35.000000000 +0200
@@ -575,7 +575,9 @@
     if ( level0 == level1 ) return v0;
     assert( level1 - level0 == 1 );
     const ValueType v1 = this->template sampleValue<Order>( ijk, 0, level1 );
+    OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
     const ValueType a = ValueType(level1 - level);
+    OPENVDB_NO_TYPE_CONVERSION_WARNING_END
     return a * v0 + (ValueType(1) - a) * v1;
 }
 
@@ -590,7 +592,9 @@
     if ( level0 == level1 ) return v0;
     assert( level1 - level0 == 1 );
     const ValueType v1 = this->template sampleValue<Order>( xyz, 0, level1 );
+    OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
     const ValueType a = ValueType(level1 - level);
+    OPENVDB_NO_TYPE_CONVERSION_WARNING_END
     return a * v0 + (ValueType(1) - a) * v1;
 }
 
@@ -802,9 +806,15 @@
         for (typename Range1::Iterator leafIter = range.begin(); leafIter; ++leafIter) {
             for (VoxelIter voxelIter = leafIter->cbeginValueOn(); voxelIter; ++voxelIter) {
                 Coord ijk = voxelIter.getCoord();
-                ijk[0] = int(math::Round(ijk[0] * scale));
-                ijk[1] = int(math::Round(ijk[1] * scale));
-                ijk[2] = int(math::Round(ijk[2] * scale));
+                OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+                const auto value0 = ijk[0] * scale;
+                const auto value1 = ijk[1] * scale;
+                const auto value2 = ijk[2] * scale;
+                OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+                ijk[0] = int(math::Round(value0));
+                ijk[1] = int(math::Round(value1));
+                ijk[2] = int(math::Round(value2));
+
                 acc.setValueOn( ijk );
             }//loop over active voxels in the fine tree
         }// loop over leaf nodes in the fine tree
@@ -839,7 +849,11 @@
                 const Vec3R xyz =  Vec3R( voxelIter.getCoord().data() );// mid level coord
                 const ValueType v0 = tools::Sampler<Order>::sample( acc0, xyz * scale0 );
                 const ValueType v1 = tools::Sampler<Order>::sample( acc1, xyz * scale1 );
-                voxelIter.setValue( ValueType(a*v0 + b*v1) );
+                OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
+                const auto value0 = a*v0;
+                const auto value1 = b*v1;
+                OPENVDB_NO_TYPE_CONVERSION_WARNING_END
+                voxelIter.setValue( ValueType(value0 + value1) );
             }
         }
     }
diff -aur openvdb-6.0.0/openvdb/tools/ParticleAtlas.h openvdb-6.1.0/openvdb/tools/ParticleAtlas.h
--- openvdb-6.0.0/openvdb/tools/ParticleAtlas.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/ParticleAtlas.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -903,7 +903,7 @@
 inline void
 ParticleAtlas<PointIndexGridType>::Iterator::updateFromLevel(size_t level)
 {
-    using TreeType = typename PointIndexGridType::TreeType;
+    using TreeT = typename PointIndexGridType::TreeType;
     using LeafNodeType = typename TreeType::LeafNodeType;
 
     this->clear();
@@ -911,8 +911,7 @@
     if (mAccessorListSize > 0) {
         const size_t levelIdx = std::min(mAccessorListSize - 1, level);
 
-        const TreeType& tree = mAtlas->pointIndexGrid(levelIdx).tree();
-
+        const TreeT& tree = mAtlas->pointIndexGrid(levelIdx).tree();
 
         std::vector<const LeafNodeType*> nodes;
         tree.getNodes(nodes);
@@ -1060,6 +1059,6 @@
 
 #endif // OPENVDB_TOOLS_PARTICLE_ATLAS_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tools/ParticlesToLevelSet.h openvdb-6.1.0/openvdb/tools/ParticlesToLevelSet.h
--- openvdb-6.0.0/openvdb/tools/ParticlesToLevelSet.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/ParticlesToLevelSet.h	2019-05-07 22:58:35.000000000 +0200
@@ -789,8 +789,15 @@
                 const Real x2y2 = x2 + math::Pow2(c.y() - P[1]);
                 for (c.z() = lo.z(); c.z() <= hi.z(); ++c.z()) {
                     const Real x2y2z2 = x2y2 + math::Pow2(c.z()-P[2]); // squared dist from c to P
+#if defined __INTEL_COMPILER
+    _Pragma("warning (push)")
+    _Pragma("warning (disable:186)") // "pointless comparison of unsigned integer with zero"
+#endif
                     if (x2y2z2 >= max2 || (!acc.probeValue(c, v) && (v < ValueT(0))))
                         continue;//outside narrow band of the particle or inside existing level set
+#if defined __INTEL_COMPILER
+    _Pragma("warning (pop)")
+#endif
                     if (x2y2z2 <= min2) {//inside narrow band of the particle.
                         acc.setValueOff(c, inside);
                         continue;
@@ -919,7 +926,6 @@
     bool operator< (const BlindData& rhs)     const { return mVisible <  rhs.mVisible; }
     bool operator> (const BlindData& rhs)     const { return mVisible >  rhs.mVisible; }
     BlindData operator+(const BlindData& rhs) const { return BlindData(mVisible + rhs.mVisible); }
-    BlindData operator+(const VisibleT&  rhs) const { return BlindData(mVisible + rhs); }
     BlindData operator-(const BlindData& rhs) const { return BlindData(mVisible - rhs.mVisible); }
     BlindData operator-() const { return BlindData(-mVisible, mBlind); }
 
@@ -945,6 +951,15 @@
     return BlindData<VisibleT, BlindT>(math::Abs(x.visible()), x.blind());
 }
 
+/// @private
+// Required to support the (zeroVal<BlindData>() + val) idiom.
+template<typename VisibleT, typename BlindT, typename T>
+inline BlindData<VisibleT, BlindT>
+operator+(const BlindData<VisibleT, BlindT>& x, const T& rhs)
+{
+    return BlindData<VisibleT, BlindT>(x.visible() + static_cast<VisibleT>(rhs), x.blind());
+}
+
 } // namespace p2ls_internal
 
 
diff -aur openvdb-6.0.0/openvdb/tools/PointScatter.h openvdb-6.1.0/openvdb/tools/PointScatter.h
--- openvdb-6.0.0/openvdb/tools/PointScatter.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/PointScatter.h	2019-05-07 22:58:35.000000000 +0200
@@ -152,7 +152,7 @@
             mTargetPointCount = Index64(mPointsPerVolume * voxelVolume * double(mVoxelCount));
         } else if (mTargetPointCount > 0) {
             BaseT::start("Uniform scattering with fixed point count");
-            mPointsPerVolume = mTargetPointCount / float(voxelVolume * mVoxelCount);
+            mPointsPerVolume = float(mTargetPointCount) / float(voxelVolume * double(mVoxelCount));
         } else {
             return false;
         }
@@ -242,7 +242,7 @@
         const Vec3R offset(0.5, 0.5, 0.5);
 
         const int ppv = math::Floor(mPointsPerVoxel);
-        const double delta = mPointsPerVoxel - ppv;
+        const double delta = mPointsPerVoxel - float(ppv);
         const bool fractional = !math::isApproxZero(delta, 1.0e-6);
 
         for (ValueIter iter = grid.cbeginValueOn(); iter; ++iter) {
@@ -255,7 +255,7 @@
                 iter.getBoundingBox(bbox);
                 const Coord size(bbox.extents());
                 const Vec3R dmin = bbox.min() - offset;
-                const double d = mPointsPerVoxel * iter.getVoxelCount();
+                const double d = mPointsPerVoxel * float(iter.getVoxelCount());
                 const int m = math::Floor(d);
                 for (int n = 0; n != m; ++n)  BaseT::addPoint(grid, dmin, size);
                 if (BaseT::getRand01() < d - m) BaseT::addPoint(grid, dmin, size);
@@ -327,7 +327,7 @@
         const Vec3R offset(0.5, 0.5, 0.5);
         for (typename GridT::ValueOnCIter iter = grid.cbeginValueOn(); iter; ++iter) {
             if (BaseT::interrupt()) return false;
-            const double d = (*iter) * pointsPerVoxel * iter.getVoxelCount();
+            const double d = double(*iter) * pointsPerVoxel * double(iter.getVoxelCount());
             const int n = int(d);
             if (iter.isVoxelValue()) { // a majority is expected to be voxels
                 const Vec3R dmin =iter.getCoord() - offset;
diff -aur openvdb-6.0.0/openvdb/tools/PointsToMask.h openvdb-6.1.0/openvdb/tools/PointsToMask.h
--- openvdb-6.0.0/openvdb/tools/PointsToMask.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/PointsToMask.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -245,9 +245,10 @@
         : mOwnsGrid(false)
         , mGrid(grid)
     {
-        if ( grainSize == 0 ) {
-            using IterT = typename PoolType::const_iterator;
-            for (IterT i=pool.begin(); i!=pool.end(); ++i) mGrid->topologyUnion( *i );
+        if (grainSize == 0) {
+            for (typename PoolType::const_iterator i = pool.begin(); i != pool.end(); ++i) {
+                mGrid->topologyUnion(*i);
+            }
         } else {
             VecT grids( pool.size() );
             typename PoolType::iterator i = pool.begin();
@@ -281,6 +282,6 @@
 
 #endif // OPENVDB_TOOLS_POINTSTOMASK_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tools/RayTracer.h openvdb-6.1.0/openvdb/tools/RayTracer.h
--- openvdb-6.0.0/openvdb/tools/RayTracer.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/RayTracer.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -280,7 +280,7 @@
         RGBA  operator* (ValueT scale)  const { return RGBA(r*scale, g*scale, b*scale);}
         RGBA  operator+ (const RGBA& rhs) const { return RGBA(r+rhs.r, g+rhs.g, b+rhs.b);}
         RGBA  operator* (const RGBA& rhs) const { return RGBA(r*rhs.r, g*rhs.g, b*rhs.b);}
-        RGBA& operator+=(const RGBA& rhs) { r+=rhs.r; g+=rhs.g; b+=rhs.b, a+=rhs.a; return *this;}
+        RGBA& operator+=(const RGBA& rhs) { r+=rhs.r; g+=rhs.g; b+=rhs.b; a+=rhs.a; return *this;}
 
         void over(const RGBA& rhs)
         {
@@ -947,7 +947,7 @@
 {
     const BaseShader& shader = *mShader;
     Vec3Type xyz, nml;
-    const float frac = 1.0f / (1.0f + mSubPixels);
+    const float frac = 1.0f / (1.0f + float(mSubPixels));
     for (size_t j=range.begin(), n=0, je = range.end(); j<je; ++j) {
         for (size_t i=0, ie = mCamera->width(); i<ie; ++i) {
             Film::RGBA& bg = mCamera->pixel(i,j);
@@ -1120,6 +1120,6 @@
 
 #endif // OPENVDB_TOOLS_RAYTRACER_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tools/Statistics.h openvdb-6.1.0/openvdb/tools/Statistics.h
--- openvdb-6.0.0/openvdb/tools/Statistics.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/Statistics.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -170,13 +170,13 @@
 /// FloatGrid grid = ...;
 ///
 /// // Assume that we know that the grid has a uniform scale map.
-/// typedef math::UniformScaleMap MapType;
+/// using MapType = math::UniformScaleMap;
 /// // Specify a world-space gradient operator that uses first-order differencing.
-/// typedef math::Gradient<MapType, math::FD_1ST> GradientOp;
+/// using GradientOp = math::Gradient<MapType, math::FD_1ST>;
 /// // Wrap the operator with an adapter that computes the magnitude of the gradient.
-/// typedef math::OpMagnitude<GradientOp, MapType> MagnitudeOp;
+/// using MagnitudeOp = math::OpMagnitude<GradientOp, MapType>;
 /// // Wrap the operator with an adapter that associates a map with it.
-/// typedef math::MapAdapter<MapType, GradientOp, double> CompoundOp;
+/// using CompoundOp = math::MapAdapter<MapType, GradientOp, double>;
 ///
 /// if (MapType::Ptr map = grid.constTransform().constMap<MapType>()) {
 ///     math::Stats stats = tools::opStatistics(grid.cbeginValueOn(), CompoundOp(*map));
@@ -189,11 +189,11 @@
 /// Vec3SGrid grid = ...;
 ///
 /// // Assume that we know that the grid has a uniform scale map.
-/// typedef math::UniformScaleMap MapType;
+/// using MapType = math::UniformScaleMap;
 /// // Specify a world-space divergence operator that uses first-order differencing.
-/// typedef math::Divergence<MapType, math::FD_1ST> DivergenceOp;
+/// using DivergenceOp = math::Divergence<MapType, math::FD_1ST>;
 /// // Wrap the operator with an adapter that associates a map with it.
-/// typedef math::MapAdapter<MapType, DivergenceOp, double> CompoundOp;
+/// using CompoundOp = math::MapAdapter<MapType, DivergenceOp, double>;
 ///
 /// if (MapType::Ptr map = grid.constTransform().constMap<MapType>()) {
 ///     math::Stats stats = tools::opStatistics(grid.cbeginValueOn(), CompoundOp(*map));
@@ -206,7 +206,7 @@
 /// Vec3SGrid grid = ...;
 ///
 /// // Specify an index-space divergence operator that uses first-order differencing.
-/// typedef math::ISDivergence<math::FD_1ST> DivergenceOp;
+/// using DivergenceOp = math::ISDivergence<math::FD_1ST>;
 ///
 /// math::Stats stats = tools::opStatistics(grid.cbeginValueOn(), DivergenceOp());
 /// @endcode
@@ -229,12 +229,12 @@
 /// whereas node-level iterators use the name ValueType.
 template<typename IterT, typename AuxT = void>
 struct IterTraits {
-    typedef typename IterT::ValueType ValueType;
+    using ValueType = typename IterT::ValueType;
 };
 
 template<typename TreeT, typename ValueIterT>
 struct IterTraits<tree::TreeValueIteratorBase<TreeT, ValueIterT> > {
-    typedef typename tree::TreeValueIteratorBase<TreeT, ValueIterT>::ValueT ValueType;
+    using ValueType = typename tree::TreeValueIteratorBase<TreeT, ValueIterT>::ValueT;
 };
 
 
@@ -259,8 +259,8 @@
 template<typename IterT, typename StatsT>
 struct GetVal
 {
-    typedef typename IterTraits<IterT>::ValueType ValueT;
-    typedef GetValImpl<ValueT, VecTraits<ValueT>::IsVec> ImplT;
+    using ValueT = typename IterTraits<IterT>::ValueType;
+    using ImplT = GetValImpl<ValueT, VecTraits<ValueT>::IsVec>;
 
     inline void operator()(const IterT& iter, StatsT& stats) const {
         if (iter.isVoxelValue()) stats.add(ImplT::get(*iter));
@@ -312,9 +312,9 @@
 template<typename IterT, typename OpT, typename StatsT>
 struct MathOp
 {
-    typedef typename IterT::TreeT                     TreeT;
-    typedef typename TreeT::ValueType                 ValueT;
-    typedef typename tree::ValueAccessor<const TreeT> ConstAccessor;
+    using TreeT = typename IterT::TreeT;
+    using ValueT = typename TreeT::ValueType;
+    using ConstAccessor = typename tree::ValueAccessor<const TreeT>;
 
     // Each thread gets its own accessor and its own copy of the operator.
     ConstAccessor mAcc;
@@ -323,7 +323,7 @@
 
     template<typename TreeT>
     static inline TreeT* THROW_IF_NULL(TreeT* ptr) {
-        if (ptr == NULL) OPENVDB_THROW(ValueError, "iterator references a null tree");
+        if (ptr == nullptr) OPENVDB_THROW(ValueError, "iterator references a null tree");
         return ptr;
     }
 
@@ -367,7 +367,7 @@
 inline math::Histogram
 histogram(const IterT& iter, double vmin, double vmax, size_t numBins, bool threaded)
 {
-    typedef stats_internal::GetVal<IterT, math::Histogram> ValueOp;
+    using ValueOp = stats_internal::GetVal<IterT, math::Histogram>;
     ValueOp valOp;
     stats_internal::HistOp<IterT, ValueOp> op(valOp, vmin, vmax, numBins);
     tools::accumulate(iter, op, threaded);
@@ -433,6 +433,6 @@
 
 #endif // OPENVDB_TOOLS_STATISTICS_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tools/TopologyToLevelSet.h openvdb-6.1.0/openvdb/tools/TopologyToLevelSet.h
--- openvdb-6.0.0/openvdb/tools/TopologyToLevelSet.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/TopologyToLevelSet.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -47,8 +47,9 @@
 #include <openvdb/Types.h>
 #include <openvdb/math/FiniteDifference.h> // for math::BiasedGradientScheme
 #include <openvdb/util/NullInterrupter.h>
-
 #include <tbb/task_group.h>
+#include <algorithm> // for std::min(), std::max()
+#include <vector>
 
 
 namespace openvdb {
@@ -91,7 +92,7 @@
 template<typename GridT, typename InterrupterT>
 inline typename GridT::template ValueConverter<float>::Type::Ptr
 topologyToLevelSet(const GridT& grid, int halfWidth = 3, int closingSteps = 1, int dilation = 0,
-    int smoothingSteps = 0, InterrupterT* interrupt = NULL);
+    int smoothingSteps = 0, InterrupterT* interrupt = nullptr);
 
 
 ////////////////////////////////////////
@@ -125,17 +126,18 @@
 template<typename TreeType>
 struct OffsetAndMinComp
 {
-    typedef typename TreeType::LeafNodeType     LeafNodeType;
-    typedef typename TreeType::ValueType        ValueType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
+    using ValueType = typename TreeType::ValueType;
 
-    OffsetAndMinComp(std::vector<LeafNodeType*>& lhsNodes, const TreeType& rhsTree, ValueType offset)
-        : mLhsNodes(lhsNodes.empty() ? NULL : &lhsNodes[0]), mRhsTree(&rhsTree), mOffset(offset)
+    OffsetAndMinComp(std::vector<LeafNodeType*>& lhsNodes,
+        const TreeType& rhsTree, ValueType offset)
+        : mLhsNodes(lhsNodes.empty() ? nullptr : &lhsNodes[0]), mRhsTree(&rhsTree), mOffset(offset)
     {
     }
 
     void operator()(const tbb::blocked_range<size_t>& range) const
     {
-        typedef typename LeafNodeType::ValueOnIter Iterator;
+        using Iterator = typename LeafNodeType::ValueOnIter;
 
         tree::ValueAccessor<const TreeType> rhsAcc(*mRhsTree);
         const ValueType offset = mOffset;
@@ -162,7 +164,7 @@
 
 template<typename GridType, typename InterrupterType>
 inline void
-normalizeLevelSet(GridType& grid, const int halfWidthInVoxels, InterrupterType* interrupt = NULL)
+normalizeLevelSet(GridType& grid, const int halfWidthInVoxels, InterrupterType* interrupt = nullptr)
 {
     LevelSetFilter<GridType, GridType, InterrupterType> filter(grid, interrupt);
     filter.setSpatialScheme(math::FIRST_BIAS);
@@ -174,11 +176,12 @@
 
 template<typename GridType, typename InterrupterType>
 inline void
-smoothLevelSet(GridType& grid, int iterations, int halfBandWidthInVoxels, InterrupterType* interrupt = NULL)
+smoothLevelSet(GridType& grid, int iterations, int halfBandWidthInVoxels,
+    InterrupterType* interrupt = nullptr)
 {
-    typedef typename GridType::ValueType        ValueType;
-    typedef typename GridType::TreeType         TreeType;
-    typedef typename TreeType::LeafNodeType     LeafNodeType;
+    using ValueType = typename GridType::ValueType;
+    using TreeType = typename GridType::TreeType;
+    using LeafNodeType = typename TreeType::LeafNodeType;
 
     GridType filterGrid(grid);
 
@@ -212,9 +215,9 @@
 topologyToLevelSet(const GridT& grid, int halfWidth, int closingSteps, int dilation,
     int smoothingSteps, InterrupterT* interrupt)
 {
-    typedef typename GridT::TreeType::template ValueConverter<ValueMask>::Type MaskTreeT;
-    typedef typename GridT::TreeType::template ValueConverter<float>::Type     FloatTreeT;
-    typedef Grid<FloatTreeT>                                                   FloatGridT;
+    using MaskTreeT = typename GridT::TreeType::template ValueConverter<ValueMask>::Type;
+    using FloatTreeT = typename GridT::TreeType::template ValueConverter<float>::Type;
+    using FloatGridT = Grid<FloatTreeT>;
 
     // Check inputs
 
@@ -222,7 +225,7 @@
     closingSteps = std::max(closingSteps, 0);
     dilation = std::max(dilation, 0);
 
-    if ( !grid.hasUniformVoxels() ) {
+    if (!grid.hasUniformVoxels()) {
         OPENVDB_THROW(ValueError, "Non-uniform voxels are not supported!");
     }
 
@@ -281,6 +284,6 @@
 #endif // OPENVDB_TOOLS_TOPOLOGY_TO_LEVELSET_HAS_BEEN_INCLUDED
 
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tools/ValueTransformer.h openvdb-6.1.0/openvdb/tools/ValueTransformer.h
--- openvdb-6.0.0/openvdb/tools/ValueTransformer.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/ValueTransformer.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -280,6 +280,15 @@
     inline void operator()(ValueType& v) const { v += val; }
 };
 
+
+template<>
+struct SumOp<bool> {
+    using ValueType = bool;
+    const ValueType val;
+    SumOp(const ValueType& v): val(v) {}
+    inline void operator()(ValueType& v) const { v = v || val; }
+};
+
 template<typename ValueType>
 struct MultOp {
     const ValueType val;
@@ -331,7 +340,7 @@
 class SharedOpApplier
 {
 public:
-    typedef typename tree::IteratorRange<IterT> IterRange;
+    using IterRange = typename tree::IteratorRange<IterT>;
 
     SharedOpApplier(const IterT& iter, OpT& op): mIter(iter), mOp(op) {}
 
@@ -357,7 +366,7 @@
 class CopyableOpApplier
 {
 public:
-    typedef typename tree::IteratorRange<IterT> IterRange;
+    using IterRange = typename tree::IteratorRange<IterT>;
 
     CopyableOpApplier(const IterT& iter, const OpT& op): mIter(iter), mOp(op), mOrigOp(&op) {}
 
@@ -395,7 +404,7 @@
         typename valxform::SharedOpApplier<IterT, XformOp> proc(iter, op);
         proc.process(threaded);
     } else {
-        typedef typename valxform::CopyableOpApplier<IterT, XformOp> Processor;
+        using Processor = typename valxform::CopyableOpApplier<IterT, XformOp>;
         Processor proc(iter, op);
         proc.process(threaded);
     }
@@ -420,9 +429,9 @@
 class SharedOpTransformer
 {
 public:
-    typedef typename InIterT::TreeT InTreeT;
-    typedef typename tree::IteratorRange<InIterT> IterRange;
-    typedef typename OutTreeT::ValueType OutValueT;
+    using InTreeT = typename InIterT::TreeT;
+    using IterRange = typename tree::IteratorRange<InIterT>;
+    using OutValueT = typename OutTreeT::ValueType;
 
     SharedOpTransformer(const InIterT& inIter, OutTreeT& outTree, OpT& op, MergePolicy merge):
         mIsRoot(true),
@@ -454,7 +463,7 @@
         // (the top-level output tree was supplied by the caller).
         if (!mIsRoot) {
             delete mOutputTree;
-            mOutputTree = NULL;
+            mOutputTree = nullptr;
         }
     }
 
@@ -504,9 +513,9 @@
 class CopyableOpTransformer
 {
 public:
-    typedef typename InIterT::TreeT InTreeT;
-    typedef typename tree::IteratorRange<InIterT> IterRange;
-    typedef typename OutTreeT::ValueType OutValueT;
+    using InTreeT = typename InIterT::TreeT;
+    using IterRange = typename tree::IteratorRange<InIterT>;
+    using OutValueT = typename OutTreeT::ValueType;
 
     CopyableOpTransformer(const InIterT& inIter, OutTreeT& outTree,
         const OpT& op, MergePolicy merge):
@@ -542,7 +551,7 @@
         // (the top-level output tree was supplied by the caller).
         if (!mIsRoot) {
             delete mOutputTree;
-            mOutputTree = NULL;
+            mOutputTree = nullptr;
         }
     }
 
@@ -599,14 +608,14 @@
 transformValues(const InIterT& inIter, OutGridT& outGrid, XformOp& op,
     bool threaded, bool shared, MergePolicy merge)
 {
-    typedef TreeAdapter<OutGridT> Adapter;
-    typedef typename Adapter::TreeType OutTreeT;
+    using Adapter = TreeAdapter<OutGridT>;
+    using OutTreeT = typename Adapter::TreeType;
     if (shared) {
-        typedef typename valxform::SharedOpTransformer<InIterT, OutTreeT, XformOp> Processor;
+        using Processor = typename valxform::SharedOpTransformer<InIterT, OutTreeT, XformOp>;
         Processor proc(inIter, Adapter::tree(outGrid), op, merge);
         proc.process(threaded);
     } else {
-        typedef typename valxform::CopyableOpTransformer<InIterT, OutTreeT, XformOp> Processor;
+        using Processor = typename valxform::CopyableOpTransformer<InIterT, OutTreeT, XformOp>;
         Processor proc(inIter, Adapter::tree(outGrid), op, merge);
         proc.process(threaded);
     }
@@ -618,10 +627,10 @@
 transformValues(const InIterT& inIter, OutGridT& outGrid, const XformOp& op,
     bool threaded, bool /*share*/, MergePolicy merge)
 {
-    typedef TreeAdapter<OutGridT> Adapter;
-    typedef typename Adapter::TreeType OutTreeT;
+    using Adapter = TreeAdapter<OutGridT>;
+    using OutTreeT = typename Adapter::TreeType;
     // Const ops are shared across threads, not copied.
-    typedef typename valxform::SharedOpTransformer<InIterT, OutTreeT, const XformOp> Processor;
+    using Processor = typename valxform::SharedOpTransformer<InIterT, OutTreeT, const XformOp>;
     Processor proc(inIter, Adapter::tree(outGrid), op, merge);
     proc.process(threaded);
 }
@@ -637,7 +646,7 @@
 class OpAccumulator
 {
 public:
-    typedef typename tree::IteratorRange<IterT> IterRange;
+    using IterRange = typename tree::IteratorRange<IterT>;
 
     // The root task makes a const copy of the original functor (mOrigOp)
     // and keeps a pointer to the original functor (mOp), which it then modifies.
@@ -702,6 +711,6 @@
 
 #endif // OPENVDB_TOOLS_VALUETRANSFORMER_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tools/VolumeAdvect.h openvdb-6.1.0/openvdb/tools/VolumeAdvect.h
--- openvdb-6.0.0/openvdb/tools/VolumeAdvect.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tools/VolumeAdvect.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -396,7 +396,7 @@
     using VoxelIterT = typename TreeT::LeafNodeType::ValueOnIter;
 
     Advect(const VolumeGridT& inGrid, const VolumeAdvection& parent)
-        : mTask(0)
+        : mTask(nullptr)
         , mInGrid(&inGrid)
         , mVelocityInt(parent.mVelGrid)
         , mParent(&parent)
@@ -567,6 +567,6 @@
 
 #endif // OPENVDB_TOOLS_VOLUME_ADVECT_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tree/LeafBuffer.h openvdb-6.1.0/openvdb/tree/LeafBuffer.h
--- openvdb-6.0.0/openvdb/tree/LeafBuffer.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tree/LeafBuffer.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -133,13 +133,13 @@
     bool empty() const { return (mData == nullptr); }
 #else
     /// Default constructor
-    inline LeafBuffer(): mData(new ValueType[SIZE]), mOutOfCore(0) {}
+    inline LeafBuffer(): mData(new ValueType[SIZE]) { mOutOfCore = 0; }
     /// Construct a buffer populated with the specified value.
     explicit inline LeafBuffer(const ValueType&);
     /// Copy constructor
     inline LeafBuffer(const LeafBuffer&);
     /// Construct a buffer but don't allocate memory for the full array of values.
-    LeafBuffer(PartialCreate, const ValueType&): mData(nullptr), mOutOfCore(0) {}
+    LeafBuffer(PartialCreate, const ValueType&): mData(nullptr) { mOutOfCore = 0; }
     /// Destructor
     inline ~LeafBuffer();
 
@@ -251,8 +251,8 @@
 inline
 LeafBuffer<T, Log2Dim>::LeafBuffer(const ValueType& val)
     : mData(new ValueType[SIZE])
-    , mOutOfCore(0)
 {
+    mOutOfCore = 0;
     this->fill(val);
 }
 
@@ -584,6 +584,6 @@
 
 #endif // OPENVDB_TREE_LEAFBUFFER_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tree/LeafManager.h openvdb-6.1.0/openvdb/tree/LeafManager.h
--- openvdb-6.0.0/openvdb/tree/LeafManager.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tree/LeafManager.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -43,7 +43,6 @@
 #define OPENVDB_TREE_LEAFMANAGER_HAS_BEEN_INCLUDED
 
 #include <openvdb/Types.h>
-#include "TreeIterator.h" // for CopyConstness
 #include <tbb/blocked_range.h>
 #include <tbb/parallel_for.h>
 #include <tbb/parallel_reduce.h>
@@ -222,7 +221,7 @@
         , mAuxBuffersPerLeaf(auxBuffersPerLeaf)
         , mLeafs(nullptr)
         , mAuxBuffers(nullptr)
-        , mTask(0)
+        , mTask(nullptr)
         , mIsMaster(true)
     {
         this->rebuild(serial);
@@ -239,7 +238,7 @@
         , mAuxBuffersPerLeaf(auxBuffersPerLeaf)
         , mLeafs(new LeafType*[mLeafCount])
         , mAuxBuffers(nullptr)
-        , mTask(0)
+        , mTask(nullptr)
         , mIsMaster(true)
     {
         size_t n = mLeafCount;
@@ -849,6 +848,6 @@
 
 #endif // OPENVDB_TREE_LEAFMANAGER_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/tree/TreeIterator.h openvdb-6.1.0/openvdb/tree/TreeIterator.h
--- openvdb-6.0.0/openvdb/tree/TreeIterator.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/tree/TreeIterator.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -58,23 +58,6 @@
 namespace OPENVDB_VERSION_NAME {
 namespace tree {
 
-/// CopyConstness<T1, T2>::Type is either const T2 or T2 with no const qualifier,
-/// depending on whether T1 is const.  For example,
-/// - CopyConstness<int, int>::Type is int
-/// - CopyConstness<int, const int>::Type is int
-/// - CopyConstness<const int, int>::Type is const int
-/// - CopyConstness<const int, const int>::Type is const int
-template<typename FromType, typename ToType> struct CopyConstness {
-    using Type = typename std::remove_const<ToType>::type;
-};
-template<typename FromType, typename ToType> struct CopyConstness<const FromType, ToType> {
-    using Type = const ToType;
-};
-
-
-////////////////////////////////////////
-
-
 namespace iter {
 
 template<typename HeadT, int HeadLevel>
@@ -1412,6 +1395,6 @@
 
 #endif // OPENVDB_TREE_TREEITERATOR_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/Types.h openvdb-6.1.0/openvdb/Types.h
--- openvdb-6.0.0/openvdb/Types.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/Types.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -212,27 +212,93 @@
 ////////////////////////////////////////
 
 
-template<typename T> struct VecTraits {
+/// @brief Helper metafunction used to determine if the first template
+/// parameter is a specialization of the class template given in the second
+/// template parameter
+template <typename T, template <typename...> class Template>
+struct IsSpecializationOf : std::false_type {};
+
+template <typename... Args, template <typename...> class Template>
+struct IsSpecializationOf<Template<Args...>, Template> : std::true_type {};
+
+
+////////////////////////////////////////
+
+
+template<typename T, bool = IsSpecializationOf<T, math::Vec2>::value ||
+                            IsSpecializationOf<T, math::Vec3>::value ||
+                            IsSpecializationOf<T, math::Vec4>::value>
+struct VecTraits
+{
+    static const bool IsVec = true;
+    static const int Size = T::size;
+    using ElementType = typename T::ValueType;
+};
+
+template<typename T>
+struct VecTraits<T, false>
+{
     static const bool IsVec = false;
     static const int Size = 1;
     using ElementType = T;
 };
 
-template<typename T> struct VecTraits<math::Vec2<T> > {
-    static const bool IsVec = true;
-    static const int Size = 2;
+template<typename T, bool = IsSpecializationOf<T, math::Quat>::value>
+struct QuatTraits
+{
+    static const bool IsQuat = true;
+    static const int Size = T::size;
+    using ElementType = typename T::ValueType;
+};
+
+template<typename T>
+struct QuatTraits<T, false>
+{
+    static const bool IsQuat = false;
+    static const int Size = 1;
     using ElementType = T;
 };
 
-template<typename T> struct VecTraits<math::Vec3<T> > {
-    static const bool IsVec = true;
-    static const int Size = 3;
+template<typename T, bool = IsSpecializationOf<T, math::Mat3>::value ||
+                            IsSpecializationOf<T, math::Mat4>::value>
+struct MatTraits
+{
+    static const bool IsMat = true;
+    static const int Size = T::size;
+    using ElementType = typename T::ValueType;
+};
+
+template<typename T>
+struct MatTraits<T, false>
+{
+    static const bool IsMat = false;
+    static const int Size = 1;
     using ElementType = T;
 };
 
-template<typename T> struct VecTraits<math::Vec4<T> > {
-    static const bool IsVec = true;
-    static const int Size = 4;
+template<typename T, bool = VecTraits<T>::IsVec ||
+                            QuatTraits<T>::IsQuat ||
+                            MatTraits<T>::IsMat>
+struct ValueTraits
+{
+    static const bool IsVec = VecTraits<T>::IsVec;
+    static const bool IsQuat = QuatTraits<T>::IsQuat;
+    static const bool IsMat = MatTraits<T>::IsMat;
+    static const bool IsScalar = false;
+    static const int Size = T::size;
+    static const int Elements = IsMat ? Size*Size : Size;
+    using ElementType = typename T::ValueType;
+};
+
+template<typename T>
+struct ValueTraits<T, false>
+{
+    static const bool IsVec = false;
+    static const bool IsQuat = false;
+    static const bool IsMat = false;
+    static const bool IsScalar = true;
+    static const int Size = 1;
+    static const int Elements = 1;
     using ElementType = T;
 };
 
@@ -271,6 +337,167 @@
 ////////////////////////////////////////
 
 
+/// @brief CopyConstness<T1, T2>::Type is either <tt>const T2</tt>
+/// or @c T2 with no @c const qualifier, depending on whether @c T1 is @c const.
+/// @details For example,
+/// - CopyConstness<int, int>::Type is @c int
+/// - CopyConstness<int, const int>::Type is @c int
+/// - CopyConstness<const int, int>::Type is <tt>const int</tt>
+/// - CopyConstness<const int, const int>::Type is <tt>const int</tt>
+template<typename FromType, typename ToType> struct CopyConstness {
+    using Type = typename std::remove_const<ToType>::type;
+};
+
+/// @cond OPENVDB_TYPES_INTERNAL
+template<typename FromType, typename ToType> struct CopyConstness<const FromType, ToType> {
+    using Type = const ToType;
+};
+/// @endcond
+
+
+////////////////////////////////////////
+
+
+/// @cond OPENVDB_TYPES_INTERNAL
+
+template<typename... Ts> struct TypeList; // forward declaration
+
+namespace internal {
+
+// Implementation details of TypeList
+
+template<typename ListT, typename... Ts> struct TSAppendImpl;
+
+// Append zero or more types.
+template<typename... Ts, typename... OtherTs>
+struct TSAppendImpl<TypeList<Ts...>, OtherTs...> {
+    using type = TypeList<Ts..., OtherTs...>;
+};
+
+// Append another TypeList's members.
+template<typename... Ts, typename... OtherTs>
+struct TSAppendImpl<TypeList<Ts...>, TypeList<OtherTs...>> {
+    using type = TypeList<Ts..., OtherTs...>;
+};
+
+
+// Remove all occurrences of type T.
+template<typename ListT, typename T> struct TSEraseImpl;
+
+// TypeList<>::Erase<int> = TypeList<>
+template<typename T>
+struct TSEraseImpl<TypeList<>, T> { using type = TypeList<>; };
+
+// TypeList<int, char, ...>::Erase<int> = TypeList<char, ...>::Erase<int>
+template<typename... Ts, typename T>
+struct TSEraseImpl<TypeList<T, Ts...>, T> {
+    using type = typename TSEraseImpl<TypeList<Ts...>, T>::type;
+};
+
+// TypeList<float, int, char...>::Erase<int> =
+//     TypeList<float>::Append<TypeList<int, char...>::Erase<int>>
+template<typename T2, typename... Ts, typename T>
+struct TSEraseImpl<TypeList<T2, Ts...>, T> {
+    using type = typename TSAppendImpl<TypeList<T2>,
+        typename TSEraseImpl<TypeList<Ts...>, T>::type>::type;
+};
+
+
+template<typename ListT, typename... Ts> struct TSRemoveImpl;
+
+template<typename ListT>
+struct TSRemoveImpl<ListT> { using type = ListT; };
+
+// Remove one or more types.
+template<typename ListT, typename T, typename... Ts>
+struct TSRemoveImpl<ListT, T, Ts...> {
+    using type = typename TSRemoveImpl<typename TSEraseImpl<ListT, T>::type, Ts...>::type;
+};
+
+// Remove the members of another TypeList.
+template<typename ListT, typename... Ts>
+struct TSRemoveImpl<ListT, TypeList<Ts...>> {
+    using type = typename TSRemoveImpl<ListT, Ts...>::type;
+};
+
+
+template<typename OpT> inline void TSForEachImpl(OpT) {}
+template<typename OpT, typename T, typename... Ts>
+inline void TSForEachImpl(OpT op) { op(T()); TSForEachImpl<OpT, Ts...>(op); }
+
+} // namespace internal
+
+/// @endcond
+
+
+/// @brief A list of types (not necessarily unique)
+/// @details Example:
+/// @code
+/// using MyTypes = openvdb::TypeList<int, float, int, double, float>;
+/// @endcode
+template<typename... Ts>
+struct TypeList
+{
+    /// The type of this list
+    using Self = TypeList;
+
+    /// @brief Append types, or the members of another TypeList, to this list.
+    /// @details Example:
+    /// @code
+    /// {
+    ///     using IntTypes = openvdb::TypeList<Int16, Int32, Int64>;
+    ///     using RealTypes = openvdb::TypeList<float, double>;
+    ///     using NumericTypes = IntTypes::Append<RealTypes>;
+    /// }
+    /// {
+    ///     using IntTypes = openvdb::TypeList<Int16>::Append<Int32, Int64>;
+    ///     using NumericTypes = IntTypes::Append<float>::Append<double>;
+    /// }
+    /// @endcode
+    template<typename... TypesToAppend>
+    using Append = typename internal::TSAppendImpl<Self, TypesToAppend...>::type;
+
+    /// @brief Remove all occurrences of one or more types, or the members of
+    /// another TypeList, from this list.
+    /// @details Example:
+    /// @code
+    /// {
+    ///     using NumericTypes = openvdb::TypeList<float, double, Int16, Int32, Int64>;
+    ///     using LongTypes = openvdb::TypeList<Int64, double>;
+    ///     using ShortTypes = NumericTypes::Remove<LongTypes>; // float, Int16, Int32
+    /// }
+    /// @endcode
+    template<typename... TypesToRemove>
+    using Remove = typename internal::TSRemoveImpl<Self, TypesToRemove...>::type;
+
+    /// @brief Invoke a templated, unary functor on a value of each type in this list.
+    /// @details Example:
+    /// @code
+    /// #include <typeinfo>
+    ///
+    /// template<typename ListT>
+    /// void printTypeList()
+    /// {
+    ///     std::string sep;
+    ///     auto op = [&](auto x) {  // C++14
+    ///         std::cout << sep << typeid(decltype(x)).name(); sep = ", "; };
+    ///     ListT::foreach(op);
+    /// }
+    ///
+    /// using MyTypes = openvdb::TypeList<int, float, double>;
+    /// printTypeList<MyTypes>(); // "i, f, d" (exact output is compiler-dependent)
+    /// @endcode
+    ///
+    /// @note The functor object is passed by value.  Wrap it with @c std::ref
+    /// to use the same object for each type.
+    template<typename OpT>
+    static void foreach(OpT op) { internal::TSForEachImpl<OpT, Ts...>(op); }
+};
+
+
+////////////////////////////////////////
+
+
 // Add new items to the *end* of this list, and update NUM_GRID_CLASSES.
 enum GridClass {
     GRID_UNKNOWN = 0,
@@ -341,6 +568,7 @@
 template<> inline const char* typeNameAsString<half>()              { return "half"; }
 template<> inline const char* typeNameAsString<float>()             { return "float"; }
 template<> inline const char* typeNameAsString<double>()            { return "double"; }
+template<> inline const char* typeNameAsString<int8_t>()            { return "int8"; }
 template<> inline const char* typeNameAsString<uint8_t>()           { return "uint8"; }
 template<> inline const char* typeNameAsString<int16_t>()           { return "int16"; }
 template<> inline const char* typeNameAsString<uint16_t>()          { return "uint16"; }
@@ -355,6 +583,9 @@
 template<> inline const char* typeNameAsString<Vec3i>()             { return "vec3i"; }
 template<> inline const char* typeNameAsString<Vec3f>()             { return "vec3s"; }
 template<> inline const char* typeNameAsString<Vec3d>()             { return "vec3d"; }
+template<> inline const char* typeNameAsString<Vec4i>()             { return "vec4i"; }
+template<> inline const char* typeNameAsString<Vec4f>()             { return "vec4s"; }
+template<> inline const char* typeNameAsString<Vec4d>()             { return "vec4d"; }
 template<> inline const char* typeNameAsString<std::string>()       { return "string"; }
 template<> inline const char* typeNameAsString<Mat3s>()             { return "mat3s"; }
 template<> inline const char* typeNameAsString<Mat3d>()             { return "mat3d"; }
@@ -506,7 +737,8 @@
 /// <dt><b>CP_COPY</b>
 /// <dd>Create a deep copy of the member.
 /// </dl>
-enum CopyPolicy { CP_NEW, CP_SHARE, CP_COPY };
+/// @deprecated ABI versions older than 4 are deprecated.
+enum OPENVDB_DEPRECATED CopyPolicy { CP_NEW, CP_SHARE, CP_COPY };
 #endif
 
 
@@ -575,6 +807,6 @@
 
 #endif // OPENVDB_TYPES_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
Seulement dans openvdb-6.1.0/openvdb/unittest: CMakeLists.txt
diff -aur openvdb-6.0.0/openvdb/unittest/main.cc openvdb-6.1.0/openvdb/unittest/main.cc
--- openvdb-6.0.0/openvdb/unittest/main.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/main.cc	2019-05-07 22:58:35.000000000 +0200
@@ -118,14 +118,12 @@
     {
         if (!mFailed) {
             // Print elapsed time only for successful tests.
-            const auto msec = int(std::round(mTimer.delta()));
-            std::cout << " : OK (";
-            if (msec > 0) {
-                std::cout << msec;
+            const double msec = mTimer.milliseconds();
+            if (msec > 1.0) {
+              openvdb::util::printTime(std::cout, msec, " : OK (", ")", 4, 1, 0);
             } else {
-                std::cout << "<1";
+              std::cout << " : OK (<1ms)";
             }
-            std::cout << "ms)";
         }
         std::cout << std::endl;
     }
diff -aur openvdb-6.0.0/openvdb/unittest/TestAttributeArray.cc openvdb-6.1.0/openvdb/unittest/TestAttributeArray.cc
--- openvdb-6.0.0/openvdb/unittest/TestAttributeArray.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestAttributeArray.cc	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -49,6 +49,7 @@
 #include <tbb/tick_count.h>
 #include <tbb/atomic.h>
 
+#include <cstdio> // for std::remove()
 #include <fstream>
 #include <sstream>
 #include <iostream>
@@ -64,52 +65,16 @@
 #include <sys/stat.h> // for stat()
 #endif
 
-/// @brief io::MappedFile has a private constructor, so this unit tests uses a matching proxy
-class ProxyMappedFile
+
+/// @brief io::MappedFile has a private constructor, so declare a class that acts as the friend
+class TestMappedFile
 {
 public:
-    explicit ProxyMappedFile(const std::string& filename)
-        : mImpl(new Impl(filename)) { }
-
-private:
-    class Impl
+    static openvdb::io::MappedFile::Ptr create(const std::string& filename)
     {
-    public:
-        Impl(const std::string& filename)
-            : mMap(filename.c_str(), boost::interprocess::read_only)
-            , mRegion(mMap, boost::interprocess::read_only)
-        {
-            mLastWriteTime = 0;
-            const char* regionFilename = mMap.get_name();
-#ifdef _MSC_VER
-            using namespace boost::interprocess::detail;
-            using namespace boost::interprocess::ipcdetail;
-            using openvdb::Index64;
-
-            if (void* fh = open_existing_file(regionFilename, boost::interprocess::read_only)) {
-                FILETIME mtime;
-                if (GetFileTime(fh, nullptr, nullptr, &mtime)) {
-                    mLastWriteTime = (Index64(mtime.dwHighDateTime) << 32) | mtime.dwLowDateTime;
-                }
-                close_file(fh);
-            }
-#else
-            struct stat info;
-            if (0 == ::stat(regionFilename, &info)) {
-                mLastWriteTime = openvdb::Index64(info.st_mtime);
-            }
-#endif
-        }
-
-        using Notifier = std::function<void(std::string /*filename*/)>;
-        boost::interprocess::file_mapping mMap;
-        boost::interprocess::mapped_region mRegion;
-        bool mAutoDelete = false;
-        Notifier mNotifier;
-        mutable tbb::atomic<openvdb::Index64> mLastWriteTime;
-    }; // class Impl
-    std::unique_ptr<Impl> mImpl;
-}; // class ProxyMappedFile
+        return openvdb::SharedPtr<openvdb::io::MappedFile>(new openvdb::io::MappedFile(filename));
+    }
+};
 
 
 /// @brief Functionality similar to openvdb::util::CpuTimer except with prefix padding and no decimals.
@@ -161,6 +126,14 @@
 };// ProfileTimer
 
 
+struct ScopedFile
+{
+    explicit ScopedFile(const std::string& s): pathname(s) {}
+    ~ScopedFile() { if (!pathname.empty()) std::remove(pathname.c_str()); }
+    const std::string pathname;
+};
+
+
 using namespace openvdb;
 using namespace openvdb::points;
 
@@ -423,6 +396,19 @@
             CPPUNIT_ASSERT(!attr.valueTypeIsMatrix());
         }
         {
+            TypedAttributeArray<int8_t> typedAttr(size);
+            AttributeArray& attr(typedAttr);
+            CPPUNIT_ASSERT_EQUAL(Name("int8"), attr.valueType());
+            CPPUNIT_ASSERT_EQUAL(Name("null"), attr.codecType());
+            CPPUNIT_ASSERT_EQUAL(Index(1), attr.valueTypeSize());
+            CPPUNIT_ASSERT_EQUAL(Index(1), attr.storageTypeSize());
+            CPPUNIT_ASSERT(!attr.valueTypeIsFloatingPoint());
+            CPPUNIT_ASSERT(!attr.valueTypeIsClass());
+            CPPUNIT_ASSERT(!attr.valueTypeIsVector());
+            CPPUNIT_ASSERT(!attr.valueTypeIsQuaternion());
+            CPPUNIT_ASSERT(!attr.valueTypeIsMatrix());
+        }
+        {
             TypedAttributeArray<int16_t> typedAttr(size);
             AttributeArray& attr(typedAttr);
             CPPUNIT_ASSERT_EQUAL(Name("int16"), attr.valueType());
@@ -736,11 +722,6 @@
             CPPUNIT_ASSERT_EQUAL(attr.isUniform(), attrB.isUniform());
             CPPUNIT_ASSERT_EQUAL(attr.isTransient(), attrB.isTransient());
             CPPUNIT_ASSERT_EQUAL(attr.isHidden(), attrB.isHidden());
-// disable deprecated warnings for in-memory compression
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-            CPPUNIT_ASSERT_EQUAL(attr.isCompressed(), attrB.isCompressed());
-#pragma GCC diagnostic pop
 
             for (unsigned i = 0; i < unsigned(count); ++i) {
                 CPPUNIT_ASSERT_EQUAL(attr.get(i), attrB.get(i));
@@ -749,74 +730,20 @@
             }
         }
 
+        { // Equality using an unregistered attribute type
+            TypedAttributeArray<half> attr1(50);
+            TypedAttributeArray<half> attr2(50);
+
+            CPPUNIT_ASSERT(attr1 == attr2);
+        }
+
         // attribute array must not be uniform for compression
 
         attr.set(1, 7);
         attr.set(2, 8);
         attr.set(6, 100);
-
-        // note that in-memory compression has been deprecated, verify all
-        // isCompressed() calls return false
-
-// disable deprecated warnings for in-memory compression
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-
-        CPPUNIT_ASSERT(!attr.isCompressed());
-
-        { // test compressed copy construction
-            attr.compress();
-
-            CPPUNIT_ASSERT(!attr.isCompressed());
-
-            AttributeArray::Ptr attrCopy = attr.copy();
-            AttributeArrayI& attrB(AttributeArrayI::cast(*attrCopy));
-
-            CPPUNIT_ASSERT(matchingNamePairs(attr.type(), attrB.type()));
-            CPPUNIT_ASSERT_EQUAL(attr.size(), attrB.size());
-            CPPUNIT_ASSERT_EQUAL(attr.memUsage(), attrB.memUsage());
-            CPPUNIT_ASSERT_EQUAL(attr.isUniform(), attrB.isUniform());
-            CPPUNIT_ASSERT_EQUAL(attr.isTransient(), attrB.isTransient());
-            CPPUNIT_ASSERT_EQUAL(attr.isHidden(), attrB.isHidden());
-            CPPUNIT_ASSERT_EQUAL(attr.isCompressed(), attrB.isCompressed());
-
-            for (unsigned i = 0; i < unsigned(count); ++i) {
-                CPPUNIT_ASSERT_EQUAL(attr.get(i), attrB.get(i));
-                CPPUNIT_ASSERT_EQUAL(attr.get(i), attrB.getUnsafe(i));
-                CPPUNIT_ASSERT_EQUAL(attr.getUnsafe(i), attrB.getUnsafe(i));
-            }
-        }
-
-        { // test compressed copy construction (uncompress on copy)
-            attr.compress();
-
-            CPPUNIT_ASSERT(!attr.isCompressed());
-
-            AttributeArray::Ptr attrCopy = attr.copyUncompressed();
-            AttributeArrayI& attrB(AttributeArrayI::cast(*attrCopy));
-
-            CPPUNIT_ASSERT(!attrB.isCompressed());
-
-            attr.decompress();
-
-            CPPUNIT_ASSERT(matchingNamePairs(attr.type(), attrB.type()));
-            CPPUNIT_ASSERT_EQUAL(attr.size(), attrB.size());
-            CPPUNIT_ASSERT_EQUAL(attr.memUsage(), attrB.memUsage());
-            CPPUNIT_ASSERT_EQUAL(attr.isUniform(), attrB.isUniform());
-            CPPUNIT_ASSERT_EQUAL(attr.isTransient(), attrB.isTransient());
-            CPPUNIT_ASSERT_EQUAL(attr.isHidden(), attrB.isHidden());
-            CPPUNIT_ASSERT_EQUAL(attr.isCompressed(), attrB.isCompressed());
-
-            for (unsigned i = 0; i < unsigned(count); ++i) {
-                CPPUNIT_ASSERT_EQUAL(attr.get(i), attrB.get(i));
-                CPPUNIT_ASSERT_EQUAL(attr.get(i), attrB.getUnsafe(i));
-                CPPUNIT_ASSERT_EQUAL(attr.getUnsafe(i), attrB.getUnsafe(i));
-            }
-        }
     }
 
-#pragma GCC diagnostic pop
-
     { // Fixed codec (position range)
         AttributeArray::Ptr attr1(new AttributeArrayC(50));
 
@@ -925,21 +852,7 @@
         std::istringstream istr(ostr.str(), std::ios_base::binary);
         attrB.read(istr);
 
-        CPPUNIT_ASSERT(matchingNamePairs(attrA.type(), attrB.type()));
-        CPPUNIT_ASSERT_EQUAL(attrA.size(), attrB.size());
-        CPPUNIT_ASSERT_EQUAL(attrA.isUniform(), attrB.isUniform());
-        CPPUNIT_ASSERT_EQUAL(attrA.isTransient(), attrB.isTransient());
-        CPPUNIT_ASSERT_EQUAL(attrA.isHidden(), attrB.isHidden());
-// disable deprecated warnings for in-memory compression
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-        CPPUNIT_ASSERT_EQUAL(attrA.isCompressed(), attrB.isCompressed());
-#pragma GCC diagnostic pop
-        CPPUNIT_ASSERT_EQUAL(attrA.memUsage(), attrB.memUsage());
-
-        for (unsigned i = 0; i < unsigned(count); ++i) {
-            CPPUNIT_ASSERT_EQUAL(attrA.get(i), attrB.get(i));
-        }
+        CPPUNIT_ASSERT(attrA == attrB);
 
         AttributeArrayI attrC(count, 3);
         attrC.setTransient(true);
@@ -947,12 +860,12 @@
         std::ostringstream ostrC(std::ios_base::binary);
         attrC.write(ostrC);
 
-        CPPUNIT_ASSERT_EQUAL(size_t(0), ostrC.str().size());
+        CPPUNIT_ASSERT(ostrC.str().empty());
 
         std::ostringstream ostrD(std::ios_base::binary);
         attrC.write(ostrD, /*transient=*/true);
 
-        CPPUNIT_ASSERT(ostrD.str().size() != size_t(0));
+        CPPUNIT_ASSERT(!ostrD.str().empty());
     }
 
     // Registry
@@ -1025,22 +938,18 @@
         targetTypedAttr.set(pair.second, sourceTypedAttr.get(pair.first));
     }
 
-    { // verify behaviour with slow virtual function
+#if OPENVDB_ABI_VERSION_NUMBER < 6
+    { // verify behaviour with slow virtual function (ABI<6)
         AttributeArrayD typedAttr(size);
         AttributeArray& attr(typedAttr);
 
-// disable deprecated warnings for virtual set() method (from ABI=6 onwards)
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
         for (const auto& pair : indexPairs) {
             attr.set(pair.second, sourceAttr, pair.first);
         }
-#pragma GCC diagnostic pop
 
         CPPUNIT_ASSERT(targetAttr == attr);
     }
-
-#if OPENVDB_ABI_VERSION_NUMBER >= 6
+#else
     using AttributeArrayF = TypedAttributeArray<float>;
 
     { // use std::vector<std::pair<Index, Index>>::begin() as iterator to AttributeArray::copy()
@@ -1071,7 +980,8 @@
         TypedAttributeArray<half> targetTypedAttr1(size);
         AttributeArray& targetAttr1(targetTypedAttr1);
         for (Index i = 0; i < size; i++) {
-            targetTypedAttr1.set(i, sourceTypedAttr.get(i));
+            targetTypedAttr1.set(i,
+                io::RealToHalf<double>::convert(sourceTypedAttr.get(i)));
         }
 
         // truncated float array
@@ -1358,56 +1268,22 @@
         CPPUNIT_ASSERT_EQUAL(Vec3f(10), handle.get(5));
     }
 
-// disable deprecated warnings for in-memory compression
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-
     {
         AttributeArray* array = attrSet.get(1);
 
-        array->compress();
-
         AttributeWriteHandle<float> handle(*array);
 
         handle.set(6, float(11));
 
         CPPUNIT_ASSERT_EQUAL(float(11), handle.get(6));
 
-        CPPUNIT_ASSERT(!array->isCompressed());
-
-        array->compress();
-
-        CPPUNIT_ASSERT(!array->isCompressed());
-
         {
             AttributeHandle<float> handleRO(*array);
 
-            CPPUNIT_ASSERT(!array->isCompressed());
-
-            CPPUNIT_ASSERT_EQUAL(float(11), handleRO.get(6));
-
-            CPPUNIT_ASSERT(!array->isCompressed());
-        }
-
-        CPPUNIT_ASSERT(!array->isCompressed());
-
-        {
-            AttributeHandle<float> handleRO(*array, /*preserveCompression=*/false);
-
-            // AttributeHandle uncompresses data on construction
-
-            CPPUNIT_ASSERT(!array->isCompressed());
-
             CPPUNIT_ASSERT_EQUAL(float(11), handleRO.get(6));
-
-            CPPUNIT_ASSERT(!array->isCompressed());
         }
-
-        CPPUNIT_ASSERT(!array->isCompressed());
     }
 
-#pragma GCC diagnostic pop
-
     // check values have been correctly set without using handles
 
     {
@@ -1534,6 +1410,25 @@
         CPPUNIT_ASSERT_EQUAL(Index(1), handle.stride());
         CPPUNIT_ASSERT_EQUAL(array->dataSize(), handle.size());
     }
+
+    { // IO
+        const Index count = 50, total = 100;
+        AttributeArrayI attrA(count, total, /*constantStride=*/false);
+
+        for (unsigned i = 0; i < unsigned(total); ++i) {
+            attrA.set(i, int(i));
+        }
+
+        std::ostringstream ostr(std::ios_base::binary);
+        io::setDataCompression(ostr, io::COMPRESS_BLOSC);
+        attrA.write(ostr);
+
+        AttributeArrayI attrB;
+        std::istringstream istr(ostr.str(), std::ios_base::binary);
+        attrB.read(istr);
+
+        CPPUNIT_ASSERT(attrA == attrB);
+    }
 }
 
 void
@@ -1545,6 +1440,8 @@
     AttributeArrayI::registerType();
     AttributeArrayF::registerType();
 
+    SharedPtr<io::MappedFile> mappedFile;
+
     io::StreamMetadata::Ptr streamMetadata(new io::StreamMetadata);
 
     std::string tempDir;
@@ -1602,10 +1499,7 @@
             fileout.close();
         }
 
-        // abuse File being a friend of MappedFile to get around the private constructor
-
-        ProxyMappedFile* proxy = new ProxyMappedFile(filename);
-        SharedPtr<io::MappedFile> mappedFile(reinterpret_cast<io::MappedFile*>(proxy));
+        mappedFile = TestMappedFile::create(filename);
 
         // read in using delayed load and check manual loading of data
         {
@@ -1628,11 +1522,6 @@
             CPPUNIT_ASSERT_EQUAL(attrA.isUniform(), attrB.isUniform());
             CPPUNIT_ASSERT_EQUAL(attrA.isTransient(), attrB.isTransient());
             CPPUNIT_ASSERT_EQUAL(attrA.isHidden(), attrB.isHidden());
-// disable deprecated warnings for in-memory compression
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-            CPPUNIT_ASSERT_EQUAL(attrA.isCompressed(), attrB.isCompressed());
-#pragma GCC diagnostic pop
 
             AttributeArrayI attrBcopy(attrB);
             AttributeArrayI attrBequal = attrB;
@@ -1683,11 +1572,6 @@
             CPPUNIT_ASSERT_EQUAL(attrA2.isUniform(), attrB2.isUniform());
             CPPUNIT_ASSERT_EQUAL(attrA2.isTransient(), attrB2.isTransient());
             CPPUNIT_ASSERT_EQUAL(attrA2.isHidden(), attrB2.isHidden());
-// disable deprecated warnings for in-memory compression
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-            CPPUNIT_ASSERT_EQUAL(attrA2.isCompressed(), attrB2.isCompressed());
-#pragma GCC diagnostic pop
 
             AttributeArrayF attrB2copy(attrB2);
             AttributeArrayF attrB2equal = attrB2;
@@ -1842,17 +1726,6 @@
             attrB.readPagedBuffers(inputStream);
 
             CPPUNIT_ASSERT(attrB.isOutOfCore());
-
-// disable deprecated warnings for in-memory compression
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-            CPPUNIT_ASSERT(!attrB.isCompressed());
-
-            attrB.compress();
-
-            CPPUNIT_ASSERT(attrB.isOutOfCore());
-            CPPUNIT_ASSERT(!attrB.isCompressed());
-#pragma GCC diagnostic pop
         }
 
         // read in using delayed load and check copy and assignment constructors
@@ -2026,10 +1899,7 @@
             fileout.close();
         }
 
-        // abuse File being a friend of MappedFile to get around the private constructor
-
-        proxy = new ProxyMappedFile(filename);
-        mappedFile.reset(reinterpret_cast<io::MappedFile*>(proxy));
+        mappedFile = TestMappedFile::create(filename);
 
         // read in using delayed load and check fill()
         {
@@ -2086,10 +1956,7 @@
             fileout.close();
         }
 
-        // abuse File being a friend of MappedFile to get around the private constructor
-
-        proxy = new ProxyMappedFile(filename);
-        mappedFile.reset(reinterpret_cast<io::MappedFile*>(proxy));
+        mappedFile = TestMappedFile::create(filename);
 
         // read in using delayed load and check fill()
         {
@@ -2120,11 +1987,6 @@
             io::setStreamMetadataPtr(fileout, streamMetadata);
             io::setDataCompression(fileout, io::COMPRESS_BLOSC);
 
-// disable deprecated warnings for in-memory compression
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-            attrA.compress();
-#pragma GCC diagnostic pop
             attrA.writeMetadata(fileout, false, /*paged=*/true);
 
             compression::PagedOutputStream outputStreamSize(fileout);
@@ -2139,10 +2001,7 @@
             fileout.close();
         }
 
-        // abuse File being a friend of MappedFile to get around the private constructor
-
-        proxy = new ProxyMappedFile(filename);
-        mappedFile.reset(reinterpret_cast<io::MappedFile*>(proxy));
+        mappedFile = TestMappedFile::create(filename);
 
         // read in using delayed load and check manual loading of data
         {
@@ -2159,18 +2018,10 @@
             inputStream.setSizeOnly(false);
             attrB.readPagedBuffers(inputStream);
 
-// disable deprecated warnings for in-memory compression
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-            CPPUNIT_ASSERT(!attrB.isCompressed());
-
             CPPUNIT_ASSERT(attrB.isOutOfCore());
             attrB.loadData();
             CPPUNIT_ASSERT(!attrB.isOutOfCore());
 
-            CPPUNIT_ASSERT(!attrB.isCompressed());
-#pragma GCC diagnostic pop
-
             CPPUNIT_ASSERT_EQUAL(attrA.memUsage(), attrB.memUsage());
 
             for (unsigned i = 0; i < unsigned(count); ++i) {
@@ -2207,6 +2058,7 @@
 
             { // attempting to write a partially-read AttributeArray throws
                 std::string filename = tempDir + "/openvdb_partial1";
+                ScopedFile f(filename);
                 std::ofstream fileout(filename.c_str(), std::ios_base::binary);
                 io::setStreamMetadataPtr(fileout, streamMetadata);
                 io::setDataCompression(fileout, io::COMPRESS_BLOSC);
@@ -2263,36 +2115,6 @@
         }
 
 #ifdef OPENVDB_USE_BLOSC
-        // read in using delayed load and check no implicit load through compress()
-        {
-            AttributeArrayI attrB;
-
-            std::ifstream filein(filename.c_str(), std::ios_base::in | std::ios_base::binary);
-            io::setStreamMetadataPtr(filein, streamMetadata);
-            io::setMappedFilePtr(filein, mappedFile);
-
-            attrB.readMetadata(filein);
-            compression::PagedInputStream inputStream(filein);
-            inputStream.setSizeOnly(true);
-            attrB.readPagedBuffers(inputStream);
-            inputStream.setSizeOnly(false);
-            attrB.readPagedBuffers(inputStream);
-
-// disable deprecated warnings for in-memory compression
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-
-            CPPUNIT_ASSERT(attrB.isOutOfCore());
-            CPPUNIT_ASSERT(!attrB.isCompressed());
-
-            attrB.compress();
-
-            CPPUNIT_ASSERT(attrB.isOutOfCore());
-            CPPUNIT_ASSERT(!attrB.isCompressed());
-
-#pragma GCC diagnostic pop
-        }
-
         // read in using delayed load and check copy and assignment constructors
         {
             AttributeArrayI attrB;
@@ -2349,23 +2171,13 @@
 
             CPPUNIT_ASSERT(attrB.isOutOfCore());
 
-// disable deprecated warnings for in-memory compression
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-            CPPUNIT_ASSERT(!attrB.isCompressed());
-
             AttributeHandle<int> handle(attrB);
 
             CPPUNIT_ASSERT(!attrB.isOutOfCore());
-            CPPUNIT_ASSERT(!attrB.isCompressed());
 
             for (unsigned i = 0; i < unsigned(count); ++i) {
                 CPPUNIT_ASSERT_EQUAL(attrA.get(i), handle.get(i));
             }
-
-            AttributeHandle<int> handle2(attrB, /*preserveCompression=*/false);
-            CPPUNIT_ASSERT(!attrB.isCompressed());
-#pragma GCC diagnostic pop
         }
 #endif
 
@@ -2395,10 +2207,7 @@
             fileout.close();
         }
 
-        // abuse File being a friend of MappedFile to get around the private constructor
-
-        proxy = new ProxyMappedFile(filename);
-        mappedFile.reset(reinterpret_cast<io::MappedFile*>(proxy));
+        mappedFile = TestMappedFile::create(filename);
 
         // read in using delayed load and check metadata fail due to serialization flags
         {
@@ -2529,13 +2338,14 @@
 void sum(const Name& prefix, const AttrT& attr)
 {
     ProfileTimer timer(prefix + ": sum");
-    typename AttrT::ValueType sum = 0;
+    using ValueType = typename AttrT::ValueType;
+    ValueType sum = 0;
     const Index size = attr.size();
     for (Index i = 0; i < size; i++) {
         sum += attr.getUnsafe(i);
     }
     // prevent compiler optimisations removing computation
-    CPPUNIT_ASSERT(sum);
+    CPPUNIT_ASSERT(sum!=ValueType());
 }
 
 template <typename CodecT, typename AttrT>
@@ -2549,7 +2359,7 @@
         sum += handle.get(i);
     }
     // prevent compiler optimisations removing computation
-    CPPUNIT_ASSERT(sum);
+    CPPUNIT_ASSERT(sum!=ValueType());
 }
 
 } // namespace profile
@@ -2595,7 +2405,7 @@
                 sum += float(values[i]);
             }
             // to prevent optimisation clean up
-            CPPUNIT_ASSERT(sum);
+            CPPUNIT_ASSERT(sum!=0.0f);
         }
     }
 
@@ -2669,6 +2479,6 @@
     }
 }
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/unittest/TestAttributeArrayString.cc openvdb-6.1.0/openvdb/unittest/TestAttributeArrayString.cc
--- openvdb-6.0.0/openvdb/unittest/TestAttributeArrayString.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestAttributeArrayString.cc	2019-05-07 22:58:35.000000000 +0200
@@ -30,6 +30,7 @@
 
 #include <cppunit/extensions/HelperMacros.h>
 #include <openvdb/points/AttributeArrayString.h>
+#include <openvdb/util/CpuTimer.h>
 
 #include <openvdb/openvdb.h>
 
@@ -49,6 +50,7 @@
     CPPUNIT_TEST(testStringAttribute);
     CPPUNIT_TEST(testStringAttributeHandle);
     CPPUNIT_TEST(testStringAttributeWriteHandle);
+    CPPUNIT_TEST(testProfile);
 
     CPPUNIT_TEST_SUITE_END();
 
@@ -56,6 +58,7 @@
     void testStringAttribute();
     void testStringAttributeHandle();
     void testStringAttributeWriteHandle();
+    void testProfile();
 
 }; // class TestAttributeArrayString
 
@@ -273,6 +276,8 @@
 
     CPPUNIT_ASSERT_EQUAL(handle.size(), Index(4));
     CPPUNIT_ASSERT_EQUAL(handle.size(), attr.size());
+    CPPUNIT_ASSERT_EQUAL(Index(1), handle.stride());
+    CPPUNIT_ASSERT(handle.hasConstantStride());
 
     { // index 0 should always be an empty string
         Name value = handle.get(0);
@@ -344,6 +349,28 @@
         TypedAttributeArray<float> invalidAttr(50);
         CPPUNIT_ASSERT_THROW(StringAttributeHandle(invalidAttr, metadata), TypeError);
     }
+
+    // Test stride and hasConstantStride methods for string handles
+
+    {
+        StringAttributeArray attr(3, 2, true);
+        StringAttributeHandle handle(attr, metadata);
+
+        CPPUNIT_ASSERT_EQUAL(Index(3), handle.size());
+        CPPUNIT_ASSERT_EQUAL(handle.size(), attr.size());
+        CPPUNIT_ASSERT_EQUAL(Index(2), handle.stride());
+        CPPUNIT_ASSERT(handle.hasConstantStride());
+    }
+
+    {
+        StringAttributeArray attr(4, 10, false);
+        StringAttributeHandle handle(attr, metadata);
+
+        CPPUNIT_ASSERT_EQUAL(Index(10), handle.size());
+        CPPUNIT_ASSERT_EQUAL(Index(4), attr.size());
+        CPPUNIT_ASSERT_EQUAL(Index(1), handle.stride());
+        CPPUNIT_ASSERT(!handle.hasConstantStride());
+    }
 }
 
 
@@ -372,9 +399,27 @@
         CPPUNIT_ASSERT_THROW(handle.set(1, "testB"), LookupError);
     }
 
+    { // empty string always has index 0
+        CPPUNIT_ASSERT(handle.contains(""));
+    }
+
+    { // cache won't contain metadata until it has been reset
+        CPPUNIT_ASSERT(!handle.contains("testA"));
+        CPPUNIT_ASSERT(!handle.contains("testB"));
+        CPPUNIT_ASSERT(!handle.contains("testC"));
+    }
+
     handle.resetCache();
 
+    { // empty string always has index 0 regardless of cache reset
+        CPPUNIT_ASSERT(handle.contains(""));
+    }
+
     { // cache now reset
+        CPPUNIT_ASSERT(handle.contains("testA"));
+        CPPUNIT_ASSERT(handle.contains("testB"));
+        CPPUNIT_ASSERT(handle.contains("testC"));
+
         CPPUNIT_ASSERT_NO_THROW(handle.set(1, "testB"));
 
         CPPUNIT_ASSERT_EQUAL(handle.get(0), Name(""));
@@ -443,6 +488,72 @@
     }
 }
 
+
+void
+TestAttributeArrayString::testProfile()
+{
+
+#ifdef PROFILE
+    struct Timer : public openvdb::util::CpuTimer {};
+    const size_t elements = 1000000;
+#else
+    struct Timer {
+        void start(const std::string&) {}
+        void stop() {}
+    };
+    const size_t elements = 10000;
+#endif
+
+    MetaMap metadata;
+    StringMetaInserter inserter(metadata);
+
+    Timer timer;
+    timer.start("StringMetaInserter initialise");
+
+    for (size_t i = 0; i < elements; ++i) {
+        inserter.insert("test_string_" + std::to_string(i));
+    }
+
+    timer.stop();
+
+    for (size_t i = 0; i < elements/2; ++i) {
+        metadata.removeMeta("test_string_" + std::to_string(i*2));
+    }
+
+    timer.start("StringMetaInserter resetCache()");
+
+    inserter.resetCache();
+
+    timer.stop();
+    timer.start("StringMetaInserter insert duplicates");
+
+    for (size_t i = 0; i < elements; ++i) {
+        inserter.insert("test_string_" + std::to_string(i));
+    }
+
+    timer.stop();
+
+    openvdb::points::StringAttributeArray attr(elements);
+    for (size_t i = 0; i < elements; ++i) {
+        attr.set(Index(i), Index(i));
+    }
+
+    timer.start("StringAttributeWriteHandle construction");
+
+    openvdb::points::StringAttributeWriteHandle handle(attr, metadata);
+
+    timer.stop();
+    timer.start("StringAttributeWriteHandle contains()");
+
+    // half the calls will miss caches
+    volatile bool result = false;
+    for (size_t i = 0; i < elements/2; ++i) {
+        result |= handle.contains("test_string_" + std::to_string(i*4));
+    }
+
+    timer.stop();
+}
+
 // Copyright (c) 2012-2018 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/unittest/TestAttributeSet.cc openvdb-6.1.0/openvdb/unittest/TestAttributeSet.cc
--- openvdb-6.0.0/openvdb/unittest/TestAttributeSet.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestAttributeSet.cc	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -82,11 +82,6 @@
 
         if (a->size() != b->size()) return false;
         if (a->isUniform() != b->isUniform()) return false;
-// disable deprecated warnings for in-memory compression
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-        if (a->isCompressed() != b->isCompressed()) return false;
-#pragma GCC diagnostic pop
         if (a->isHidden() != b->isHidden()) return false;
         if (a->type() != b->type()) return false;
     }
@@ -522,6 +517,7 @@
 {
     // Define and register some common attribute types
     using AttributeS        = TypedAttributeArray<float>;
+    using AttributeB        = TypedAttributeArray<bool>;
     using AttributeI        = TypedAttributeArray<int32_t>;
     using AttributeL        = TypedAttributeArray<int64_t>;
     using AttributeVec3s    = TypedAttributeArray<Vec3s>;
@@ -575,6 +571,68 @@
             /*stride=*/51, /*constantStride=*/false));
     }
 
+    { // copy construction with varying attribute types and strides
+        Descriptor::Ptr descr = Descriptor::create(AttributeVec3s::attributeType());
+        AttributeSet attrSet(descr, /*arrayLength=*/50);
+
+        attrSet.appendAttribute("float1", AttributeS::attributeType(), /*stride=*/1);
+        attrSet.appendAttribute("int1", AttributeI::attributeType(), /*stride=*/1);
+        attrSet.appendAttribute("float3", AttributeS::attributeType(), /*stride=*/3);
+        attrSet.appendAttribute("vector", AttributeVec3s::attributeType(), /*stride=*/1);
+        attrSet.appendAttribute("vector3", AttributeVec3s::attributeType(), /*stride=*/3);
+        attrSet.appendAttribute("bool100", AttributeB::attributeType(), /*stride=*/100);
+        attrSet.appendAttribute("boolDynamic", AttributeB::attributeType(), /*size=*/100, false);
+        attrSet.appendAttribute("intDynamic", AttributeI::attributeType(), /*size=*/300, false);
+
+        CPPUNIT_ASSERT_EQUAL(std::string("float"), attrSet.getConst("float1")->type().first);
+        CPPUNIT_ASSERT_EQUAL(std::string("int32"), attrSet.getConst("int1")->type().first);
+        CPPUNIT_ASSERT_EQUAL(std::string("float"), attrSet.getConst("float3")->type().first);
+        CPPUNIT_ASSERT_EQUAL(std::string("vec3s"), attrSet.getConst("vector")->type().first);
+        CPPUNIT_ASSERT_EQUAL(std::string("vec3s"), attrSet.getConst("vector3")->type().first);
+        CPPUNIT_ASSERT_EQUAL(std::string("bool"), attrSet.getConst("bool100")->type().first);
+        CPPUNIT_ASSERT_EQUAL(std::string("bool"), attrSet.getConst("boolDynamic")->type().first);
+        CPPUNIT_ASSERT_EQUAL(std::string("int32"), attrSet.getConst("intDynamic")->type().first);
+
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(1), attrSet.getConst("float1")->stride());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(1), attrSet.getConst("int1")->stride());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(3), attrSet.getConst("float3")->stride());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(1), attrSet.getConst("vector")->stride());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(3), attrSet.getConst("vector3")->stride());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(100), attrSet.getConst("bool100")->stride());
+
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(50), attrSet.getConst("float1")->size());
+
+        // error as the new length is greater than the data size of the
+        // 'boolDynamic' attribute
+        CPPUNIT_ASSERT_THROW(AttributeSet(attrSet, /*arrayLength=*/200), openvdb::ValueError);
+
+        AttributeSet attrSet2(attrSet, /*arrayLength=*/100);
+
+        CPPUNIT_ASSERT_EQUAL(std::string("float"), attrSet2.getConst("float1")->type().first);
+        CPPUNIT_ASSERT_EQUAL(std::string("int32"), attrSet2.getConst("int1")->type().first);
+        CPPUNIT_ASSERT_EQUAL(std::string("float"), attrSet2.getConst("float3")->type().first);
+        CPPUNIT_ASSERT_EQUAL(std::string("vec3s"), attrSet2.getConst("vector")->type().first);
+        CPPUNIT_ASSERT_EQUAL(std::string("vec3s"), attrSet2.getConst("vector3")->type().first);
+        CPPUNIT_ASSERT_EQUAL(std::string("bool"), attrSet2.getConst("bool100")->type().first);
+        CPPUNIT_ASSERT_EQUAL(std::string("bool"), attrSet2.getConst("boolDynamic")->type().first);
+        CPPUNIT_ASSERT_EQUAL(std::string("int32"), attrSet2.getConst("intDynamic")->type().first);
+
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(1), attrSet2.getConst("float1")->stride());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(1), attrSet2.getConst("int1")->stride());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(3), attrSet2.getConst("float3")->stride());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(1), attrSet2.getConst("vector")->stride());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(3), attrSet2.getConst("vector3")->stride());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(100), attrSet2.getConst("bool100")->stride());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(0), attrSet2.getConst("boolDynamic")->stride());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(0), attrSet2.getConst("intDynamic")->stride());
+
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(100), attrSet2.getConst("float1")->size());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(100), attrSet2.getConst("boolDynamic")->size());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(100), attrSet2.getConst("intDynamic")->size());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(100), attrSet2.getConst("boolDynamic")->dataSize());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(300), attrSet2.getConst("intDynamic")->dataSize());
+    }
+
     Descriptor::Ptr descr = Descriptor::create(AttributeVec3s::attributeType());
     AttributeSet attrSetA(descr, /*arrayLength=*/50);
 
@@ -1076,6 +1134,6 @@
     }
 }
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/unittest/TestCoord.cc openvdb-6.1.0/openvdb/unittest/TestCoord.cc
--- openvdb-6.0.0/openvdb/unittest/TestCoord.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestCoord.cc	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -28,6 +28,7 @@
 //
 ///////////////////////////////////////////////////////////////////////////
 
+#include <unordered_map>
 #include <cppunit/extensions/HelperMacros.h>
 #include <openvdb/Types.h>
 #include <sstream>
@@ -42,12 +43,14 @@
     CPPUNIT_TEST(testConversion);
     CPPUNIT_TEST(testIO);
     CPPUNIT_TEST(testCoordBBox);
+    CPPUNIT_TEST(testCoordHash);
     CPPUNIT_TEST_SUITE_END();
 
     void testCoord();
     void testConversion();
     void testIO();
     void testCoordBBox();
+    void testCoordHash();
 };
 
 CPPUNIT_TEST_SUITE_REGISTRATION(TestCoord);
@@ -85,7 +88,8 @@
     CPPUNIT_ASSERT(xyz2 < xyz);
     CPPUNIT_ASSERT(xyz2 <= xyz);
 
-    xyz2 -= xyz2;
+    Coord xyz3(xyz2);
+    xyz2 -= xyz3;
     CPPUNIT_ASSERT_EQUAL(Coord(), xyz2);
 
     xyz2.reset(0, 4, 4);
@@ -201,6 +205,24 @@
         const openvdb::CoordBBox b(min, max);
         CPPUNIT_ASSERT_EQUAL(openvdb::Vec3d(3.5, 6.0, 9.0), b.getCenter());
     }
+    {// moveMin
+        const openvdb::Coord min(1,2,3), max(6,10,15);
+        openvdb::CoordBBox b(min, max);
+        const openvdb::Coord dim = b.dim();
+        b.moveMin(openvdb::Coord(0));
+        CPPUNIT_ASSERT_EQUAL(dim, b.dim());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Coord(0), b.min());
+        CPPUNIT_ASSERT_EQUAL(max-min, b.max());
+    }
+    {// moveMax
+        const openvdb::Coord min(1,2,3), max(6,10,15);
+        openvdb::CoordBBox b(min, max);
+        const openvdb::Coord dim = b.dim();
+        b.moveMax(openvdb::Coord(0));
+        CPPUNIT_ASSERT_EQUAL(dim, b.dim());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Coord(0), b.max());
+        CPPUNIT_ASSERT_EQUAL(min-max, b.min());
+    }
     {// a volume that overflows Int32.
         using Int32 = openvdb::Int32;
         Int32 maxInt32 = std::numeric_limits<Int32>::max();
@@ -362,6 +384,39 @@
     }
 }
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+void
+TestCoord::testCoordHash()
+{
+    {//test Coord::hash function
+      openvdb::Coord a(-1, 34, 67), b(-2, 34, 67);
+      CPPUNIT_ASSERT(a.hash<>() != b.hash<>());
+      CPPUNIT_ASSERT(a.hash<10>() != b.hash<10>());
+      CPPUNIT_ASSERT(a.hash<5>() != b.hash<5>());
+    }
+
+    {//test std::hash function
+      std::hash<openvdb::Coord> h;
+      openvdb::Coord a(-1, 34, 67), b(-2, 34, 67);
+      CPPUNIT_ASSERT(h(a) != h(b));
+    }
+
+    {//test hash map (= unordered_map)
+      using KeyT = openvdb::Coord;
+      using ValueT = size_t;
+      using HashT = std::hash<openvdb::Coord>;
+
+      std::unordered_map<KeyT, ValueT, HashT> h;
+      const openvdb::Coord min(-10,-20,30), max(20,30,50);
+      const openvdb::CoordBBox bbox(min, max);
+      size_t n = 0;
+      for (const auto& ijk: bbox) h[ijk] = n++;
+      CPPUNIT_ASSERT_EQUAL(h.size(), n);
+      n = 0;
+      for (const auto& ijk: bbox) CPPUNIT_ASSERT_EQUAL(h[ijk], n++);
+      CPPUNIT_ASSERT(h.load_factor() <= 1.0f);// no hask key collisions!
+    }
+}
+
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/unittest/TestCpt.cc openvdb-6.1.0/openvdb/unittest/TestCpt.cc
--- openvdb-6.0.0/openvdb/unittest/TestCpt.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestCpt.cc	2019-05-07 22:58:35.000000000 +0200
@@ -496,7 +496,7 @@
     const openvdb::CoordBBox maskbbox(openvdb::Coord(35, 30, 30), openvdb::Coord(41, 41, 41));
     BoolGrid::Ptr maskGrid = BoolGrid::create(false);
     maskGrid->fill(maskbbox, true/*value*/, true/*activate*/);
-    
+
     // run the tool
     //typedef openvdb::tools::Cpt<FloatGrid> FloatCpt;//fails because MaskT defaults to MaskGrid
     typedef openvdb::tools::Cpt<FloatGrid, BoolGrid> FloatCpt;
diff -aur openvdb-6.0.0/openvdb/unittest/TestDense.cc openvdb-6.1.0/openvdb/unittest/TestDense.cc
--- openvdb-6.0.0/openvdb/unittest/TestDense.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestDense.cc	2019-05-07 22:58:35.000000000 +0200
@@ -126,7 +126,7 @@
 
     // Check Desne::origin()
     CPPUNIT_ASSERT(openvdb::Coord(-40,-5, 6) == dense.origin());
-    
+
     // Check coordToOffset and offsetToCoord
     size_t offset = 0;
     for (openvdb::Coord P(bbox.min()); P[0] <= bbox.max()[0]; ++P[0]) {
@@ -140,7 +140,7 @@
             }
         }
     }
-    
+
     // Check Dense::valueCount
     const int size = static_cast<int>(dense.valueCount());
     CPPUNIT_ASSERT_EQUAL(30*13*17, size);
@@ -202,12 +202,12 @@
 
     // Check Desne::origin()
     CPPUNIT_ASSERT(openvdb::Coord(-40,-5, 6) == dense.origin());
-        
+
     // Check coordToOffset and offsetToCoord
     size_t offset = 0;
     for (openvdb::Coord P(bbox.min()); P[2] <= bbox.max()[2]; ++P[2]) {
         for (P[1] = bbox.min()[1]; P[1] <= bbox.max()[1]; ++P[1]) {
-            for (P[0] = bbox.min()[0]; P[0] <= bbox.max()[0]; ++P[0]) {            
+            for (P[0] = bbox.min()[0]; P[0] <= bbox.max()[0]; ++P[0]) {
                 //std::cerr << "offset = " << offset << " P = " << P << std::endl;
                 CPPUNIT_ASSERT_EQUAL(offset, dense.coordToOffset(P));
                 CPPUNIT_ASSERT_EQUAL(P - dense.origin(), dense.offsetToLocalCoord(offset));
@@ -216,7 +216,7 @@
             }
         }
     }
-    
+
     // Check Dense::valueCount
     const int size = static_cast<int>(dense.valueCount());
     CPPUNIT_ASSERT_EQUAL(30*13*17, size);
diff -aur openvdb-6.0.0/openvdb/unittest/TestDiagnostics.cc openvdb-6.1.0/openvdb/unittest/TestDiagnostics.cc
--- openvdb-6.0.0/openvdb/unittest/TestDiagnostics.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestDiagnostics.cc	2019-05-07 22:58:35.000000000 +0200
@@ -192,22 +192,22 @@
 
     FloatGrid::Ptr gridSphere =
         tools::createLevelSetSphere<FloatGrid>(radius, center, voxelSize, width);
-        
+
     //gridSphere->print(std::cerr, 2);
-    
+
     {// Check min/max of active values
         math::Extrema ex = tools::extrema(gridSphere->cbeginValueOn());
         //std::cerr << "Min = " << ex.min() << " max = " << ex.max() << std::endl;
         CPPUNIT_ASSERT(ex.min() > -voxelSize*width);
         CPPUNIT_ASSERT(ex.max() <  voxelSize*width);
-        
+
     }
     {// Check min/max of all values
         math::Extrema ex = tools::extrema(gridSphere->cbeginValueAll());
         //std::cerr << "Min = " << ex.min() << " max = " << ex.max() << std::endl;
         CPPUNIT_ASSERT(ex.min() >= -voxelSize*width);
         CPPUNIT_ASSERT(ex.max() <=  voxelSize*width);
-        
+
     }
     {// check range of all values in a sphere w/o mask
         tools::CheckRange<FloatGrid, true, true, FloatGrid::ValueAllCIter> c(-gamma, gamma);
@@ -316,13 +316,13 @@
 
     FloatGrid::Ptr grid =
         tools::createLevelSetSphere<FloatGrid>(radius, center, voxelSize, width);
-    
+
     //tools::CheckLevelSet<FloatGrid> c(*grid);
     //std::string str = c.check();
     std::string str = tools::checkLevelSet(*grid);
     CPPUNIT_ASSERT(str.empty());
     //std::cerr << "\n" << str << std::endl;
-    
+
     grid->tree().setValue(Coord(0,0,0), voxelSize*(width+0.5f));
     //str = c.check();
     str = tools::checkLevelSet(*grid);
@@ -332,7 +332,7 @@
     //str = c.check(6);
     str = tools::checkLevelSet(*grid, 6);
     CPPUNIT_ASSERT(str.empty());
-    
+
 }// testCheckLevelSet
 
 void
@@ -346,7 +346,7 @@
     FloatGrid::Ptr grid =
         tools::createLevelSetSphere<FloatGrid>(radius, center, voxelSize, width);
     tools::sdfToFogVolume(*grid);
-    
+
     //tools::CheckFogVolume<FloatGrid> c(*grid);
     //std::string str = c.check();
     std::string str = tools::checkFogVolume(*grid);
@@ -362,7 +362,7 @@
     str = tools::checkFogVolume(*grid, 5);
     //str = c.check(5);
     CPPUNIT_ASSERT(str.empty());
-    
+
 }// testCheckFogVolume
 
 void
diff -aur openvdb-6.0.0/openvdb/unittest/TestGrid.cc openvdb-6.1.0/openvdb/unittest/TestGrid.cc
--- openvdb-6.0.0/openvdb/unittest/TestGrid.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestGrid.cc	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -54,6 +54,7 @@
     CPPUNIT_TEST(testCopyGrid);
     CPPUNIT_TEST(testValueConversion);
     CPPUNIT_TEST(testClipping);
+    CPPUNIT_TEST(testApply);
     CPPUNIT_TEST_SUITE_END();
 
     void testGridRegistry();
@@ -64,6 +65,7 @@
     void testCopyGrid();
     void testValueConversion();
     void testClipping();
+    void testApply();
 };
 
 CPPUNIT_TEST_SUITE_REGISTRATION(TestGrid);
@@ -459,6 +461,71 @@
     */
 }
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+
+////////////////////////////////////////
+
+
+namespace {
+
+struct GridOp
+{
+    bool isConst = false;
+    template<typename GridT> void operator()(const GridT&) { isConst = true; }
+    template<typename GridT> void operator()(GridT&) { isConst = false; }
+};
+
+} // anonymous namespace
+
+
+void
+TestGrid::testApply()
+{
+    using namespace openvdb;
+
+    const GridBase::Ptr
+        boolGrid = BoolGrid::create(),
+        floatGrid = FloatGrid::create(),
+        doubleGrid = DoubleGrid::create(),
+        intGrid = Int32Grid::create();
+
+    const GridBase::ConstPtr
+        boolCGrid = BoolGrid::create(),
+        floatCGrid = FloatGrid::create(),
+        doubleCGrid = DoubleGrid::create(),
+        intCGrid = Int32Grid::create();
+
+    {
+        using AllowedGridTypes = TypeList<>;
+
+        // Verify that the functor is not applied to any of the grids.
+        GridOp op;
+        CPPUNIT_ASSERT(!boolGrid->apply<AllowedGridTypes>(op));
+        CPPUNIT_ASSERT(!boolCGrid->apply<AllowedGridTypes>(op));
+        CPPUNIT_ASSERT(!floatGrid->apply<AllowedGridTypes>(op));
+        CPPUNIT_ASSERT(!floatCGrid->apply<AllowedGridTypes>(op));
+        CPPUNIT_ASSERT(!doubleGrid->apply<AllowedGridTypes>(op));
+        CPPUNIT_ASSERT(!doubleCGrid->apply<AllowedGridTypes>(op));
+        CPPUNIT_ASSERT(!intGrid->apply<AllowedGridTypes>(op));
+        CPPUNIT_ASSERT(!intCGrid->apply<AllowedGridTypes>(op));
+    }
+    {
+        using AllowedGridTypes = TypeList<FloatGrid, FloatGrid, DoubleGrid>;
+
+        // Verify that the functor is applied only to grids of the allowed types
+        // and that their constness is respected.
+        GridOp op;
+        CPPUNIT_ASSERT(!boolGrid->apply<AllowedGridTypes>(op));
+        CPPUNIT_ASSERT(!intGrid->apply<AllowedGridTypes>(op));
+        CPPUNIT_ASSERT(floatGrid->apply<AllowedGridTypes>(op));  CPPUNIT_ASSERT(!op.isConst);
+        CPPUNIT_ASSERT(doubleGrid->apply<AllowedGridTypes>(op)); CPPUNIT_ASSERT(!op.isConst);
+
+        CPPUNIT_ASSERT(!boolCGrid->apply<AllowedGridTypes>(op));
+        CPPUNIT_ASSERT(!intCGrid->apply<AllowedGridTypes>(op));
+        CPPUNIT_ASSERT(floatCGrid->apply<AllowedGridTypes>(op));  CPPUNIT_ASSERT(op.isConst);
+        CPPUNIT_ASSERT(doubleCGrid->apply<AllowedGridTypes>(op)); CPPUNIT_ASSERT(op.isConst);
+    }
+}
+
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/unittest/TestInit.cc openvdb-6.1.0/openvdb/unittest/TestInit.cc
--- openvdb-6.0.0/openvdb/unittest/TestInit.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestInit.cc	2019-05-07 22:58:35.000000000 +0200
@@ -73,7 +73,7 @@
     CPPUNIT_ASSERT(math::TranslationMap::isRegistered());
     CPPUNIT_ASSERT(math::ScaleTranslateMap::isRegistered());
     CPPUNIT_ASSERT(math::NonlinearFrustumMap::isRegistered());
-    
+
     // grid types
     CPPUNIT_ASSERT(BoolGrid::isRegistered());
     CPPUNIT_ASSERT(FloatGrid::isRegistered());
diff -aur openvdb-6.0.0/openvdb/unittest/TestLeafBool.cc openvdb-6.1.0/openvdb/unittest/TestLeafBool.cc
--- openvdb-6.0.0/openvdb/unittest/TestLeafBool.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestLeafBool.cc	2019-05-07 22:58:35.000000000 +0200
@@ -228,43 +228,43 @@
     {
         LeafType leaf(Coord(0, 0, 0), false); // false and inactive
         LeafType leaf2(Coord(0, 0, 0), true); // true and inactive
-        
+
         CPPUNIT_ASSERT(leaf != leaf2);
-        
+
         leaf.fill(CoordBBox(Coord(0), Coord(LeafType::DIM - 1)), true, /*active=*/false);
         CPPUNIT_ASSERT(leaf == leaf2); // true and inactive
-        
+
         leaf.setValuesOn(); // true and active
-        
+
         leaf2.fill(CoordBBox(Coord(0), Coord(LeafType::DIM - 1)), false); // false and active
         CPPUNIT_ASSERT(leaf != leaf2);
-        
+
         leaf.negate(); // false and active
         CPPUNIT_ASSERT(leaf == leaf2);
-        
+
         // Set some values.
         leaf.setValueOn(Coord(0, 0, 0), true);
         leaf.setValueOn(Coord(0, 1, 0), true);
         leaf.setValueOn(Coord(1, 1, 0), true);
         leaf.setValueOn(Coord(1, 1, 2), true);
-        
+
         leaf2.setValueOn(Coord(0, 0, 0), true);
         leaf2.setValueOn(Coord(0, 1, 0), true);
         leaf2.setValueOn(Coord(1, 1, 0), true);
         leaf2.setValueOn(Coord(1, 1, 2), true);
-        
+
         CPPUNIT_ASSERT(leaf == leaf2);
-        
+
         leaf2.setValueOn(Coord(0, 0, 1), true);
-        
+
         CPPUNIT_ASSERT(leaf != leaf2);
-        
+
         leaf2.setValueOff(Coord(0, 0, 1), false);
-        
+
         CPPUNIT_ASSERT(leaf != leaf2);
-        
+
         leaf2.setValueOn(Coord(0, 0, 1));
-        
+
         CPPUNIT_ASSERT(leaf == leaf2);
     }
     {// test LeafNode<bool>::operator==()
@@ -279,7 +279,7 @@
         CPPUNIT_ASSERT(leaf2 != leaf4);
         CPPUNIT_ASSERT(leaf3 != leaf4);
     }
-        
+
 }
 
 
@@ -542,7 +542,7 @@
     using namespace openvdb;
     LeafType leaf(openvdb::Coord(0, 0, 0), /*background=*/false);
     bool state = false;
-    
+
     CPPUNIT_ASSERT_EQUAL(Index(0), leaf.medianOn(state));
     CPPUNIT_ASSERT(state == false);
     CPPUNIT_ASSERT_EQUAL(leaf.numValues(), leaf.medianOff(state));
@@ -562,7 +562,7 @@
     CPPUNIT_ASSERT_EQUAL(leaf.numValues()-2, leaf.medianOff(state));
     CPPUNIT_ASSERT(state == false);
     CPPUNIT_ASSERT(!leaf.medianAll());
-    
+
     leaf.setValue(Coord(5,0,1), true);
     CPPUNIT_ASSERT_EQUAL(Index(3), leaf.medianOn(state));
     CPPUNIT_ASSERT(state == false);
diff -aur openvdb-6.0.0/openvdb/unittest/TestLeafMask.cc openvdb-6.1.0/openvdb/unittest/TestLeafMask.cc
--- openvdb-6.0.0/openvdb/unittest/TestLeafMask.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestLeafMask.cc	2019-05-07 22:58:35.000000000 +0200
@@ -235,43 +235,43 @@
     {
         LeafType leaf(Coord(0, 0, 0), false); // false and inactive
         LeafType leaf2(Coord(0, 0, 0), true); // true and inactive
-        
+
         CPPUNIT_ASSERT(leaf != leaf2);
-        
+
         leaf.fill(CoordBBox(Coord(0), Coord(LeafType::DIM - 1)), true, false);
         CPPUNIT_ASSERT(leaf == leaf2); // true and inactive
-        
+
         leaf.setValuesOn(); // true and active
-        
+
         leaf2.fill(CoordBBox(Coord(0), Coord(LeafType::DIM - 1)), false); // false and active
         CPPUNIT_ASSERT(leaf != leaf2);
-        
+
         leaf.negate(); // false and active
         CPPUNIT_ASSERT(leaf == leaf2);
-        
+
         // Set some values.
         leaf.setValueOn(Coord(0, 0, 0), true);
         leaf.setValueOn(Coord(0, 1, 0), true);
         leaf.setValueOn(Coord(1, 1, 0), true);
         leaf.setValueOn(Coord(1, 1, 2), true);
-        
+
         leaf2.setValueOn(Coord(0, 0, 0), true);
         leaf2.setValueOn(Coord(0, 1, 0), true);
         leaf2.setValueOn(Coord(1, 1, 0), true);
         leaf2.setValueOn(Coord(1, 1, 2), true);
-        
+
         CPPUNIT_ASSERT(leaf == leaf2);
-        
+
         leaf2.setValueOn(Coord(0, 0, 1), true);
-        
+
         CPPUNIT_ASSERT(leaf != leaf2);
-        
+
         leaf2.setValueOff(Coord(0, 0, 1), false);
-        
+
         CPPUNIT_ASSERT(leaf == leaf2);//values and states coinside
-        
+
         leaf2.setValueOn(Coord(0, 0, 1));
-        
+
         CPPUNIT_ASSERT(leaf != leaf2);//values and states coinside
     }
     {// test LeafNode<bool>::operator==()
@@ -286,7 +286,7 @@
         CPPUNIT_ASSERT(leaf2 == leaf4);
         CPPUNIT_ASSERT(leaf3 != leaf4);
     }
-        
+
 }
 
 
@@ -449,24 +449,24 @@
             args.setResult(args.aIsActive() ^ args.bIsActive());// state = value
         }
     };
-    
+
     LeafType leaf(openvdb::Coord(0, 0, 0));
     for (openvdb::Index n = 0; n < leaf.numValues(); n += 10) leaf.setValueOn(n);
     CPPUNIT_ASSERT(!leaf.isValueMaskOn());
     CPPUNIT_ASSERT(!leaf.isValueMaskOff());
     const LeafType::NodeMaskType savedMask = leaf.getValueMask();
     OPENVDB_LOG_DEBUG_RUNTIME(leaf.str());
-    
+
     LeafType leaf2(leaf);
     for (openvdb::Index n = 0; n < leaf.numValues(); n += 4) leaf2.setValueOn(n);
-    
+
     CPPUNIT_ASSERT(!leaf2.isValueMaskOn());
     CPPUNIT_ASSERT(!leaf2.isValueMaskOff());
     OPENVDB_LOG_DEBUG_RUNTIME(leaf2.str());
-    
+
     leaf.combine(leaf2, Local::op);
     OPENVDB_LOG_DEBUG_RUNTIME(leaf.str());
-    
+
     CPPUNIT_ASSERT(leaf.getValueMask() == (savedMask ^ leaf2.getValueMask()));
 }
 
@@ -545,7 +545,7 @@
     using namespace openvdb;
     LeafType leaf(openvdb::Coord(0, 0, 0), /*background=*/false);
     bool state = false;
-    
+
     CPPUNIT_ASSERT_EQUAL(Index(0), leaf.medianOn(state));
     CPPUNIT_ASSERT(state == true);
     CPPUNIT_ASSERT_EQUAL(leaf.numValues(), leaf.medianOff(state));
@@ -558,7 +558,7 @@
     CPPUNIT_ASSERT_EQUAL(leaf.numValues()-1, leaf.medianOff(state));
     CPPUNIT_ASSERT(state == false);
     CPPUNIT_ASSERT(!leaf.medianAll());
-    
+
 
     leaf.setValue(Coord(0,0,1), true);
     CPPUNIT_ASSERT_EQUAL(Index(2), leaf.medianOn(state));
@@ -566,15 +566,15 @@
     CPPUNIT_ASSERT_EQUAL(leaf.numValues()-2, leaf.medianOff(state));
     CPPUNIT_ASSERT(state == false);
     CPPUNIT_ASSERT(!leaf.medianAll());
-    
-    
+
+
     leaf.setValue(Coord(5,0,1), true);
     CPPUNIT_ASSERT_EQUAL(Index(3), leaf.medianOn(state));
     CPPUNIT_ASSERT(state == true);
     CPPUNIT_ASSERT_EQUAL(leaf.numValues()-3, leaf.medianOff(state));
     CPPUNIT_ASSERT(state == false);
     CPPUNIT_ASSERT(!leaf.medianAll());
-    
+
 
     leaf.fill(false, false);
     CPPUNIT_ASSERT_EQUAL(Index(0), leaf.medianOn(state));
@@ -582,7 +582,7 @@
     CPPUNIT_ASSERT_EQUAL(leaf.numValues(), leaf.medianOff(state));
     CPPUNIT_ASSERT(state == false);
     CPPUNIT_ASSERT(!leaf.medianAll());
-    
+
 
     for (Index i=0; i<leaf.numValues()/2; ++i) {
         leaf.setValueOn(i, true);
diff -aur openvdb-6.0.0/openvdb/unittest/TestLevelSetUtil.cc openvdb-6.1.0/openvdb/unittest/TestLevelSetUtil.cc
--- openvdb-6.0.0/openvdb/unittest/TestLevelSetUtil.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestLevelSetUtil.cc	2019-05-07 22:58:35.000000000 +0200
@@ -160,7 +160,7 @@
 
         std::vector<FloatGrid::Ptr> segments;
 
-        // This tool will not identify two separate segments when the narrow-bands overlap. 
+        // This tool will not identify two separate segments when the narrow-bands overlap.
         openvdb::tools::segmentActiveVoxels(*sdfGrid, segments);
         CPPUNIT_ASSERT(segments.size() == 1);
 
@@ -180,6 +180,46 @@
         CPPUNIT_ASSERT(segments[0]->tree().getValue(ijk) > 0.0f);
     }
 
+    { // Test empty SDF grid
+
+        FloatGrid::Ptr sdfGrid = openvdb::FloatGrid::create(/*background=*/10.2f);
+        sdfGrid->setGridClass(openvdb::GRID_LEVEL_SET);
+
+        std::vector<FloatGrid::Ptr> segments;
+        openvdb::tools::segmentSDF(*sdfGrid, segments);
+
+        CPPUNIT_ASSERT_EQUAL(size_t(1), segments.size());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index32(0), segments[0]->tree().leafCount());
+        CPPUNIT_ASSERT_EQUAL(10.2f, segments[0]->background());
+    }
+
+    { // Test SDF grid with inactive leaf nodes
+
+        BBoxs bbox(Vec3s(0.0, 0.0, 0.0), Vec3s(1.0, 1.0, 1.0));
+        Transform::Ptr transform = Transform::createLinearTransform(0.1);
+        FloatGrid::Ptr sdfGrid = openvdb::tools::createLevelSetBox<FloatGrid>(bbox, *transform,
+            /*halfwidth=*/5);
+
+        CPPUNIT_ASSERT(sdfGrid->tree().activeVoxelCount() > openvdb::Index64(0));
+
+        // make all active voxels inactive
+
+        for (auto leaf = sdfGrid->tree().beginLeaf(); leaf; ++leaf) {
+            for (auto iter = leaf->beginValueOn(); iter; ++iter) {
+                leaf->setValueOff(iter.getCoord());
+            }
+        }
+
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index64(0), sdfGrid->tree().activeVoxelCount());
+
+        std::vector<FloatGrid::Ptr> segments;
+        openvdb::tools::segmentSDF(*sdfGrid, segments);
+
+        CPPUNIT_ASSERT_EQUAL(size_t(1), segments.size());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index32(0), segments[0]->tree().leafCount());
+        CPPUNIT_ASSERT_EQUAL(sdfGrid->background(), segments[0]->background());
+    }
+
     { // Test fog volume with active tiles
 
         openvdb::FloatGrid::Ptr grid = openvdb::FloatGrid::create(0.0);
@@ -191,7 +231,39 @@
 
         std::vector<FloatGrid::Ptr> segments;
         openvdb::tools::segmentActiveVoxels(*grid, segments);
-        CPPUNIT_ASSERT(segments.size() == 2);
+        CPPUNIT_ASSERT_EQUAL(size_t(2), segments.size());
+    }
+
+    { // Test an empty fog volume
+
+        openvdb::FloatGrid::Ptr grid = openvdb::FloatGrid::create(/*background=*/3.1f);
+
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index32(0), grid->tree().leafCount());
+
+        std::vector<FloatGrid::Ptr> segments;
+        openvdb::tools::segmentActiveVoxels(*grid, segments);
+
+        // note that an empty volume should segment into an empty volume
+        CPPUNIT_ASSERT_EQUAL(size_t(1), segments.size());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index32(0), segments[0]->tree().leafCount());
+        CPPUNIT_ASSERT_EQUAL(3.1f, segments[0]->background());
+    }
+
+    { // Test fog volume with two inactive leaf nodes
+
+        openvdb::FloatGrid::Ptr grid = openvdb::FloatGrid::create(0.0);
+
+        grid->tree().touchLeaf(openvdb::Coord(0,0,0));
+        grid->tree().touchLeaf(openvdb::Coord(100,100,100));
+
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index32(2), grid->tree().leafCount());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index64(0), grid->tree().activeVoxelCount());
+
+        std::vector<FloatGrid::Ptr> segments;
+        openvdb::tools::segmentActiveVoxels(*grid, segments);
+
+        CPPUNIT_ASSERT_EQUAL(size_t(1), segments.size());
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index32(0), segments[0]->tree().leafCount());
     }
 }
 
diff -aur openvdb-6.0.0/openvdb/unittest/TestMetadata.cc openvdb-6.1.0/openvdb/unittest/TestMetadata.cc
--- openvdb-6.0.0/openvdb/unittest/TestMetadata.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestMetadata.cc	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -31,6 +31,7 @@
 #include <cppunit/extensions/HelperMacros.h>
 #include <openvdb/Exceptions.h>
 #include <openvdb/Metadata.h>
+#include <sstream>
 
 
 class TestMetadata: public CppUnit::TestCase
@@ -121,6 +122,12 @@
         meta.setValue(Vec3s(-1.0, 0.0, 1.0));
         CPPUNIT_ASSERT(meta.asBool());
     }
+    {
+        Vec4DMetadata meta(Vec4d(0.0));
+        CPPUNIT_ASSERT(!meta.asBool());
+        meta.setValue(Vec4d(1.0));
+        CPPUNIT_ASSERT(meta.asBool());
+    }
 }
 
 
@@ -182,6 +189,6 @@
     }
 }
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/unittest/TestMetadataIO.cc openvdb-6.1.0/openvdb/unittest/TestMetadataIO.cc
--- openvdb-6.0.0/openvdb/unittest/TestMetadataIO.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestMetadataIO.cc	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -71,194 +71,88 @@
 CPPUNIT_TEST_SUITE_REGISTRATION(TestMetadataIO<std::string>);
 CPPUNIT_TEST_SUITE_REGISTRATION(TestMetadataIO<openvdb::Vec3R>);
 CPPUNIT_TEST_SUITE_REGISTRATION(TestMetadataIO<openvdb::Vec2i>);
+CPPUNIT_TEST_SUITE_REGISTRATION(TestMetadataIO<openvdb::Vec4d>);
 
 
-template<typename T>
-void
-TestMetadataIO<T>::test()
-{
-    using namespace openvdb;
-
-    TypedMetadata<T> m(1);
-
-    std::ostringstream ostr(std::ios_base::binary);
+namespace {
 
-    m.write(ostr);
+template<typename T> struct Value { static T create(int i) { return T(i); } };
 
-    std::istringstream istr(ostr.str(), std::ios_base::binary);
+template<> struct Value<std::string> {
+    static std::string create(int i) { return "test" + std::to_string(i); }
+};
 
-    TypedMetadata<T> tm;
-    tm.read(istr);
+template<typename T> struct Value<openvdb::math::Vec2<T>> {
+    using ValueType = openvdb::math::Vec2<T>;
+    static ValueType create(int i) { return ValueType(i, i+1); }
+};
+template<typename T> struct Value<openvdb::math::Vec3<T>> {
+    using ValueType = openvdb::math::Vec3<T>;
+    static ValueType create(int i) { return ValueType(i, i+1, i+2); }
+};
+template<typename T> struct Value<openvdb::math::Vec4<T>> {
+    using ValueType = openvdb::math::Vec4<T>;
+    static ValueType create(int i) { return ValueType(i, i+1, i+2, i+3); }
+};
 
-    CPPUNIT_ASSERT_DOUBLES_EQUAL(T(1),tm.value(),0);
-    //CPPUNIT_ASSERT(tm.value() == T(1));
 }
 
 
 template<typename T>
 void
-TestMetadataIO<T>::testMultiple()
-{
-    using namespace openvdb;
-
-    TypedMetadata<T> m(1);
-    TypedMetadata<T> m2(2);
-
-    std::ostringstream ostr(std::ios_base::binary);
-
-    m.write(ostr);
-    m2.write(ostr);
-
-    std::istringstream istr(ostr.str(), std::ios_base::binary);
-
-    TypedMetadata<T> tm, tm2;
-    tm.read(istr);
-    tm2.read(istr);
-
-    CPPUNIT_ASSERT_DOUBLES_EQUAL(T(1),tm.value(),0);
-    //CPPUNIT_ASSERT(tm.value() == T(1));
-    CPPUNIT_ASSERT_DOUBLES_EQUAL(T(2),tm2.value(),0);
-    //CPPUNIT_ASSERT(tm2.value() == T(2));
-}
-
-
-template<>
-void
-TestMetadataIO<std::string>::test()
-{
-    using namespace openvdb;
-
-    TypedMetadata<std::string> m("test");
-
-    std::ostringstream ostr(std::ios_base::binary);
-
-    m.write(ostr);
-
-    std::istringstream istr(ostr.str(), std::ios_base::binary);
-
-    TypedMetadata<std::string> tm;
-    tm.read(istr);
-
-    CPPUNIT_ASSERT(tm.value() == "test");
-}
-
-
-template<>
-void
-TestMetadataIO<std::string>::testMultiple()
+TestMetadataIO<T>::test()
 {
     using namespace openvdb;
 
-    TypedMetadata<std::string> m("test");
-    TypedMetadata<std::string> m2("test2");
+    const T val = Value<T>::create(1);
+    TypedMetadata<T> m(val);
 
     std::ostringstream ostr(std::ios_base::binary);
 
     m.write(ostr);
-    m2.write(ostr);
 
     std::istringstream istr(ostr.str(), std::ios_base::binary);
 
-    TypedMetadata<std::string> tm, tm2;
+    TypedMetadata<T> tm;
     tm.read(istr);
-    tm2.read(istr);
-
-    CPPUNIT_ASSERT(tm.value() == "test");
-    CPPUNIT_ASSERT(tm2.value() == "test2");
-}
-
-
-template<>
-void
-TestMetadataIO<openvdb::Vec3R>::test()
-{
-    using namespace openvdb;
-
-    TypedMetadata<Vec3R> m(Vec3R(1, 2, 3));
-
-    std::ostringstream ostr(std::ios_base::binary);
-
-    m.write(ostr);
 
-    std::istringstream istr(ostr.str(), std::ios_base::binary);
+    OPENVDB_NO_FP_EQUALITY_WARNING_BEGIN
 
-    TypedMetadata<Vec3R> tm;
-    tm.read(istr);
+    CPPUNIT_ASSERT_EQUAL(val, tm.value());
 
-    CPPUNIT_ASSERT(tm.value() == Vec3R(1, 2, 3));
+    OPENVDB_NO_FP_EQUALITY_WARNING_END
 }
 
 
-template<>
+template<typename T>
 void
-TestMetadataIO<openvdb::Vec3R>::testMultiple()
+TestMetadataIO<T>::testMultiple()
 {
     using namespace openvdb;
 
-    TypedMetadata<Vec3R> m(Vec3R(1, 2, 3));
-    TypedMetadata<Vec3R> m2(Vec3R(4, 5, 6));
+    const T val1 = Value<T>::create(1), val2 = Value<T>::create(2);
+    TypedMetadata<T> m1(val1);
+    TypedMetadata<T> m2(val2);
 
     std::ostringstream ostr(std::ios_base::binary);
 
-    m.write(ostr);
+    m1.write(ostr);
     m2.write(ostr);
 
     std::istringstream istr(ostr.str(), std::ios_base::binary);
 
-    TypedMetadata<Vec3R> tm, tm2;
-    tm.read(istr);
+    TypedMetadata<T> tm1, tm2;
+    tm1.read(istr);
     tm2.read(istr);
 
-    CPPUNIT_ASSERT(tm.value() == Vec3R(1, 2, 3));
-    CPPUNIT_ASSERT(tm2.value() == Vec3R(4, 5, 6));
-}
-
-
-template<>
-void
-TestMetadataIO<openvdb::Vec2i>::test()
-{
-    using namespace openvdb;
-
-    TypedMetadata<Vec2i> m(Vec2i(1, 2));
-
-    std::ostringstream ostr(std::ios_base::binary);
-
-    m.write(ostr);
-
-    std::istringstream istr(ostr.str(), std::ios_base::binary);
-
-    TypedMetadata<Vec2i> tm;
-    tm.read(istr);
-
-    CPPUNIT_ASSERT(tm.value() == Vec2i(1, 2));
-}
-
-
-template<>
-void
-TestMetadataIO<openvdb::Vec2i>::testMultiple()
-{
-    using namespace openvdb;
-
-    TypedMetadata<Vec2i> m(Vec2i(1, 2));
-    TypedMetadata<Vec2i> m2(Vec2i(3, 4));
+    OPENVDB_NO_FP_EQUALITY_WARNING_BEGIN
 
-    std::ostringstream ostr(std::ios_base::binary);
-
-    m.write(ostr);
-    m2.write(ostr);
-
-    std::istringstream istr(ostr.str(), std::ios_base::binary);
-
-    TypedMetadata<Vec2i> tm, tm2;
-    tm.read(istr);
-    tm2.read(istr);
+    CPPUNIT_ASSERT_EQUAL(val1, tm1.value());
+    CPPUNIT_ASSERT_EQUAL(val2, tm2.value());
 
-    CPPUNIT_ASSERT(tm.value() == Vec2i(1, 2));
-    CPPUNIT_ASSERT(tm2.value() == Vec2i(3, 4));
+    OPENVDB_NO_FP_EQUALITY_WARNING_END
 }
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/unittest/TestParticlesToLevelSet.cc openvdb-6.1.0/openvdb/unittest/TestParticlesToLevelSet.cc
--- openvdb-6.0.0/openvdb/unittest/TestParticlesToLevelSet.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestParticlesToLevelSet.cc	2019-05-07 22:58:35.000000000 +0200
@@ -59,6 +59,7 @@
     }
 
     CPPUNIT_TEST_SUITE(TestParticlesToLevelSet);
+    CPPUNIT_TEST(testBlindData);
     CPPUNIT_TEST(testMyParticleList);
     CPPUNIT_TEST(testRasterizeSpheres);
     CPPUNIT_TEST(testRasterizeSpheresAndId);
@@ -67,6 +68,7 @@
     CPPUNIT_TEST(testMaskOutput);
     CPPUNIT_TEST_SUITE_END();
 
+    void testBlindData();
     void testMyParticleList();
     void testRasterizeSpheres();
     void testRasterizeSpheresAndId();
@@ -156,6 +158,44 @@
 
 
 void
+TestParticlesToLevelSet::testBlindData()
+{
+    using BlindTypeIF = openvdb::tools::p2ls_internal::BlindData<openvdb::Index, float>;
+
+    BlindTypeIF value(openvdb::Index(8), 5.2f);
+    CPPUNIT_ASSERT_EQUAL(openvdb::Index(8), value.visible());
+    ASSERT_DOUBLES_EXACTLY_EQUAL(5.2f, value.blind());
+
+    BlindTypeIF value2(openvdb::Index(13), 1.6f);
+
+    { // test equality
+        // only visible portion needs to be equal
+        BlindTypeIF blind(openvdb::Index(13), 6.7f);
+        CPPUNIT_ASSERT(value2 == blind);
+    }
+
+    { // test addition of two blind types
+        BlindTypeIF blind = value + value2;
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(8+13), blind.visible());
+        CPPUNIT_ASSERT_EQUAL(0.0f, blind.blind()); // blind values are both dropped
+    }
+
+    { // test addition of blind type with visible type
+        BlindTypeIF blind = value + 3;
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(8+3), blind.visible());
+        CPPUNIT_ASSERT_EQUAL(5.2f, blind.blind());
+    }
+
+    { // test addition of blind type with type that requires casting
+        // note that this will generate conversion warnings if not handled properly
+        BlindTypeIF blind = value + 3.7;
+        CPPUNIT_ASSERT_EQUAL(openvdb::Index(8+3), blind.visible());
+        CPPUNIT_ASSERT_EQUAL(5.2f, blind.blind());
+    }
+}
+
+
+void
 TestParticlesToLevelSet::testMyParticleList()
 {
     MyParticleList pa;
diff -aur openvdb-6.0.0/openvdb/unittest/TestPointAdvect.cc openvdb-6.1.0/openvdb/unittest/TestPointAdvect.cc
--- openvdb-6.0.0/openvdb/unittest/TestPointAdvect.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestPointAdvect.cc	2019-05-07 22:58:35.000000000 +0200
@@ -172,7 +172,7 @@
                 int theId = idHandle.get(*iter);
                 Vec3s position = transform.indexToWorld(
                     positionHandle.get(*iter) + iter.getCoord().asVec3d());
-                Vec3s expectedPosition(positions[theId] + velocityBackground * 10);
+                Vec3s expectedPosition(positions[theId] + velocityBackground * 10.0f);
                 CPPUNIT_ASSERT(math::isApproxEqual(position, expectedPosition, tolerance));
             }
         }
@@ -427,7 +427,7 @@
     for (auto leaf = velocity->tree().beginLeaf(); leaf; ++leaf) {
         for (auto iter = leaf->beginValueOn(); iter; ++iter) {
             Vec3s position = xform->indexToWorld(iter.getCoord().asVec3d());
-            Vec3s vel = (position.cross(Vec3s(0, 0, 1)) * 2 * M_PI) / 10;
+            Vec3s vel = (position.cross(Vec3s(0, 0, 1)) * 2.0f * M_PI) / 10.0f;
             iter.setValue(vel);
         }
     }
diff -aur openvdb-6.0.0/openvdb/unittest/TestPointAttribute.cc openvdb-6.1.0/openvdb/unittest/TestPointAttribute.cc
--- openvdb-6.0.0/openvdb/unittest/TestPointAttribute.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestPointAttribute.cc	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -457,23 +457,8 @@
 
     CPPUNIT_ASSERT(leafIter->attributeArray("compact").isUniform());
     CPPUNIT_ASSERT(leafIter2->attributeArray("compact").isUniform());
-
-// disable deprecated warnings for in-memory compression
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
-
-    bloscCompressAttribute(tree, "id");
-
-#ifdef OPENVDB_USE_BLOSC
-    CPPUNIT_ASSERT(!leafIter->attributeArray("id").isCompressed());
-    CPPUNIT_ASSERT(!leafIter->attributeArray("id2").isCompressed());
-    CPPUNIT_ASSERT(!leafIter2->attributeArray("id").isCompressed());
-    CPPUNIT_ASSERT(!leafIter2->attributeArray("id2").isCompressed());
-#endif
-
-#pragma GCC diagnostic pop
 }
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/unittest/TestPointConversion.cc openvdb-6.1.0/openvdb/unittest/TestPointConversion.cc
--- openvdb-6.0.0/openvdb/unittest/TestPointConversion.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestPointConversion.cc	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -51,14 +51,18 @@
 
     CPPUNIT_TEST_SUITE(TestPointConversion);
     CPPUNIT_TEST(testPointConversion);
+    CPPUNIT_TEST(testPointConversionNans);
     CPPUNIT_TEST(testStride);
     CPPUNIT_TEST(testComputeVoxelSize);
+    CPPUNIT_TEST(testPrecision);
 
     CPPUNIT_TEST_SUITE_END();
 
     void testPointConversion();
+    void testPointConversionNans();
     void testStride();
     void testComputeVoxelSize();
+    void testPrecision();
 
 }; // class TestPointConversion
 
@@ -472,6 +476,154 @@
 
 
 void
+TestPointConversion::testPointConversionNans()
+{
+    // generate points
+
+    const size_t count(25);
+
+    AttributeWrapper<Vec3f> position(1);
+    AttributeWrapper<int> xyz(1);
+    AttributeWrapper<int> id(1);
+    AttributeWrapper<float> uniform(1);
+    AttributeWrapper<openvdb::Name> string(1);
+    GroupWrapper group;
+
+    genPoints(count, /*scale=*/ 1.0, /*stride=*/false,
+        position, xyz, id, uniform, string, group);
+
+    // set point numbers 0, 10, 20 and 24 to a nan position
+
+    const std::vector<int> nanIndices = { 0, 10, 20, 24 };
+
+    AttributeWrapper<Vec3f>::Handle positionHandle(position);
+    const Vec3f nanPos(std::nan("0"));
+    CPPUNIT_ASSERT(nanPos.isNan());
+    for (const int& idx : nanIndices) {
+        positionHandle.set(idx, /*stride*/0, nanPos);
+    }
+
+    CPPUNIT_ASSERT_EQUAL(count, position.size());
+    CPPUNIT_ASSERT_EQUAL(count, id.size());
+    CPPUNIT_ASSERT_EQUAL(count, uniform.size());
+    CPPUNIT_ASSERT_EQUAL(count, string.size());
+    CPPUNIT_ASSERT_EQUAL(count, group.size());
+
+    // convert point positions into a Point Data Grid
+
+    openvdb::math::Transform::Ptr transform =
+        openvdb::math::Transform::createLinearTransform(/*voxelsize*/1.0f);
+
+    tools::PointIndexGrid::Ptr pointIndexGrid = tools::createPointIndexGrid<tools::PointIndexGrid>(position, *transform);
+    PointDataGrid::Ptr pointDataGrid = createPointDataGrid<NullCodec, PointDataGrid>(*pointIndexGrid, position, *transform);
+
+    tools::PointIndexTree& indexTree = pointIndexGrid->tree();
+    PointDataTree& tree = pointDataGrid->tree();
+
+    // set expected point count to the total minus the number of nan positions
+    const size_t expected = count - nanIndices.size();
+    CPPUNIT_ASSERT_EQUAL(expected, static_cast<size_t>(pointCount(tree)));
+
+    // add id and populate
+
+    appendAttribute<int>(tree, "id");
+    populateAttribute<PointDataTree, tools::PointIndexTree, AttributeWrapper<int>>(tree, indexTree, "id", id);
+
+    // add uniform and populate
+
+    appendAttribute<float>(tree, "uniform");
+    populateAttribute<PointDataTree, tools::PointIndexTree, AttributeWrapper<float>>(tree, indexTree, "uniform", uniform);
+
+    // add string and populate
+
+    appendAttribute<Name>(tree, "string");
+    populateAttribute<PointDataTree, tools::PointIndexTree, AttributeWrapper<openvdb::Name>>(
+        tree, indexTree, "string", string);
+
+    // add group and set membership
+
+    appendGroup(tree, "test");
+    setGroup(tree, indexTree, group.buffer(), "test");
+
+    // create accessor and iterator for Point Data Tree
+
+    const auto leafCIter = tree.cbeginLeaf();
+
+    CPPUNIT_ASSERT_EQUAL(5, int(leafCIter->attributeSet().size()));
+
+    CPPUNIT_ASSERT(leafCIter->attributeSet().find("id") != AttributeSet::INVALID_POS);
+    CPPUNIT_ASSERT(leafCIter->attributeSet().find("uniform") != AttributeSet::INVALID_POS);
+    CPPUNIT_ASSERT(leafCIter->attributeSet().find("P") != AttributeSet::INVALID_POS);
+    CPPUNIT_ASSERT(leafCIter->attributeSet().find("string") != AttributeSet::INVALID_POS);
+
+    const auto idIndex = static_cast<Index>(leafCIter->attributeSet().find("id"));
+    const auto uniformIndex = static_cast<Index>(leafCIter->attributeSet().find("uniform"));
+    const auto stringIndex = static_cast<Index>(leafCIter->attributeSet().find("string"));
+    const AttributeSet::Descriptor::GroupIndex groupIndex =
+        leafCIter->attributeSet().groupIndex("test");
+
+    // convert back into linear point attribute data
+
+    AttributeWrapper<Vec3f> outputPosition(1);
+    AttributeWrapper<int> outputId(1);
+    AttributeWrapper<float> outputUniform(1);
+    AttributeWrapper<openvdb::Name> outputString(1);
+    GroupWrapper outputGroup;
+
+    outputPosition.resize(position.size());
+    outputId.resize(id.size());
+    outputUniform.resize(uniform.size());
+    outputString.resize(string.size());
+    outputGroup.resize(group.size());
+
+    std::vector<Index64> offsets;
+    pointOffsets(offsets, tree);
+
+    convertPointDataGridPosition(outputPosition, *pointDataGrid, offsets, 0);
+    convertPointDataGridAttribute(outputId, tree, offsets, 0, idIndex, 1);
+    convertPointDataGridAttribute(outputUniform, tree, offsets, 0, uniformIndex, 1);
+    convertPointDataGridAttribute(outputString, tree, offsets, 0, stringIndex, 1);
+    convertPointDataGridGroup(outputGroup, tree, offsets, 0, groupIndex);
+
+    // pack and sort the new buffers based on id
+
+    std::vector<PointData> pointData(expected);
+
+    for (unsigned int i = 0; i < expected; i++) {
+        pointData[i].id = outputId.buffer()[i];
+        pointData[i].position = outputPosition.buffer()[i];
+        pointData[i].uniform = outputUniform.buffer()[i];
+        pointData[i].string = outputString.buffer()[i];
+        pointData[i].group = outputGroup.buffer()[i];
+    }
+
+    std::sort(pointData.begin(), pointData.end());
+
+    // compare old and new buffers, taking into account the nan position
+    // which should not have been converted
+
+    for (unsigned int i = 0; i < expected; ++i)
+    {
+        size_t iOffset = i;
+        for (const int& idx : nanIndices) {
+            if (int(iOffset) >= idx) iOffset += 1;
+        }
+
+        CPPUNIT_ASSERT_EQUAL(id.buffer()[iOffset], pointData[i].id);
+        CPPUNIT_ASSERT_EQUAL(group.buffer()[iOffset], pointData[i].group);
+        CPPUNIT_ASSERT_EQUAL(uniform.buffer()[iOffset], pointData[i].uniform);
+        CPPUNIT_ASSERT_EQUAL(string.buffer()[iOffset], pointData[i].string);
+        CPPUNIT_ASSERT_DOUBLES_EQUAL(position.buffer()[iOffset].x(), pointData[i].position.x(), /*tolerance=*/1e-6);
+        CPPUNIT_ASSERT_DOUBLES_EQUAL(position.buffer()[iOffset].y(), pointData[i].position.y(), /*tolerance=*/1e-6);
+        CPPUNIT_ASSERT_DOUBLES_EQUAL(position.buffer()[iOffset].z(), pointData[i].position.z(), /*tolerance=*/1e-6);
+    }
+}
+
+
+////////////////////////////////////////
+
+
+void
 TestPointConversion::testStride()
 {
     // generate points
@@ -976,6 +1128,184 @@
     }
 }
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+void
+TestPointConversion::testPrecision()
+{
+    const double tolerance = math::Tolerance<float>::value();
+
+    { // test values far from origin
+        const double voxelSize = 0.5;
+        const float halfVoxelSize = 0.25f;
+        auto transform = math::Transform::createLinearTransform(voxelSize);
+
+        float onBorder = 1000.0f + halfVoxelSize; // can be represented exactly in floating-point
+        float beforeBorder = std::nextafterf(onBorder, /*to=*/0.0f);
+        float afterBorder = std::nextafterf(onBorder, /*to=*/2000.0f);
+
+        const Vec3f positionBefore(beforeBorder, afterBorder, onBorder);
+
+        std::vector<Vec3f> points{positionBefore};
+        PointAttributeVector<Vec3f> wrapper(points);
+        auto pointIndexGrid = tools::createPointIndexGrid<tools::PointIndexGrid>(
+            wrapper, *transform);
+
+        Vec3f positionAfterNull;
+        Vec3f positionAfterFixed16;
+
+        { // null codec
+            auto points = createPointDataGrid<NullCodec, PointDataGrid>(
+                *pointIndexGrid, wrapper, *transform);
+
+            auto leafIter = points->tree().cbeginLeaf();
+            auto indexIter = leafIter->beginIndexOn();
+            auto handle = AttributeHandle<Vec3f>(leafIter->constAttributeArray("P"));
+
+            const auto& ijk = indexIter.getCoord();
+
+            CPPUNIT_ASSERT_EQUAL(ijk.x(), 2000);
+            CPPUNIT_ASSERT_EQUAL(ijk.y(), 2001);
+            CPPUNIT_ASSERT_EQUAL(ijk.z(), 2001); // on border value is stored in the higher voxel
+
+            const Vec3f positionVoxelSpace = handle.get(*indexIter);
+
+            // voxel-space range: -0.5f >= value > 0.5f
+
+            CPPUNIT_ASSERT(positionVoxelSpace.x() > 0.49f && positionVoxelSpace.x() < 0.5f);
+            CPPUNIT_ASSERT(positionVoxelSpace.y() > -0.5f && positionVoxelSpace.y() < -0.49f);
+            CPPUNIT_ASSERT(positionVoxelSpace.z() == -0.5f); // on border value is stored at -0.5f
+
+            positionAfterNull = Vec3f(transform->indexToWorld(positionVoxelSpace + ijk.asVec3d()));
+
+            CPPUNIT_ASSERT_DOUBLES_EQUAL(positionAfterNull.x(), positionBefore.x(), tolerance);
+            CPPUNIT_ASSERT_DOUBLES_EQUAL(positionAfterNull.y(), positionBefore.y(), tolerance);
+            CPPUNIT_ASSERT_DOUBLES_EQUAL(positionAfterNull.z(), positionBefore.z(), tolerance);
+        }
+
+        { // fixed 16-bit codec
+            auto points = createPointDataGrid<FixedPointCodec<false>, PointDataGrid>(
+                *pointIndexGrid, wrapper, *transform);
+
+            auto leafIter = points->tree().cbeginLeaf();
+            auto indexIter = leafIter->beginIndexOn();
+            auto handle = AttributeHandle<Vec3f>(leafIter->constAttributeArray("P"));
+
+            const auto& ijk = indexIter.getCoord();
+
+            CPPUNIT_ASSERT_EQUAL(ijk.x(), 2000);
+            CPPUNIT_ASSERT_EQUAL(ijk.y(), 2001);
+            CPPUNIT_ASSERT_EQUAL(ijk.z(), 2001); // on border value is stored in the higher voxel
+
+            const Vec3f positionVoxelSpace = handle.get(*indexIter);
+
+            // voxel-space range: -0.5f >= value > 0.5f
+
+            CPPUNIT_ASSERT(positionVoxelSpace.x() > 0.49f && positionVoxelSpace.x() < 0.5f);
+            CPPUNIT_ASSERT(positionVoxelSpace.y() > -0.5f && positionVoxelSpace.y() < -0.49f);
+            CPPUNIT_ASSERT(positionVoxelSpace.z() == -0.5f); // on border value is stored at -0.5f
+
+            positionAfterFixed16 = Vec3f(transform->indexToWorld(
+                positionVoxelSpace + ijk.asVec3d()));
+
+            CPPUNIT_ASSERT_DOUBLES_EQUAL(positionAfterFixed16.x(), positionBefore.x(), tolerance);
+            CPPUNIT_ASSERT_DOUBLES_EQUAL(positionAfterFixed16.y(), positionBefore.y(), tolerance);
+            CPPUNIT_ASSERT_DOUBLES_EQUAL(positionAfterFixed16.z(), positionBefore.z(), tolerance);
+        }
+
+        // at this precision null codec == fixed-point 16-bit codec
+
+        CPPUNIT_ASSERT_EQUAL(positionAfterNull.x(), positionAfterFixed16.x());
+        CPPUNIT_ASSERT_EQUAL(positionAfterNull.y(), positionAfterFixed16.y());
+        CPPUNIT_ASSERT_EQUAL(positionAfterNull.z(), positionAfterFixed16.z());
+    }
+
+    { // test values near to origin
+        const double voxelSize = 0.5;
+        const float halfVoxelSize = 0.25f;
+        auto transform = math::Transform::createLinearTransform(voxelSize);
+
+        float onBorder = 0.0f+halfVoxelSize;
+        float beforeBorder = std::nextafterf(onBorder, /*to=*/0.0f);
+        float afterBorder = std::nextafterf(onBorder, /*to=*/2000.0f);
+
+        const Vec3f positionBefore(beforeBorder, afterBorder, onBorder);
+
+        std::vector<Vec3f> points{positionBefore};
+        PointAttributeVector<Vec3f> wrapper(points);
+        auto pointIndexGrid = tools::createPointIndexGrid<tools::PointIndexGrid>(
+            wrapper, *transform);
+
+        Vec3f positionAfterNull;
+        Vec3f positionAfterFixed16;
+
+        { // null codec
+            auto points = createPointDataGrid<NullCodec, PointDataGrid>(
+                *pointIndexGrid, wrapper, *transform);
+
+            auto leafIter = points->tree().cbeginLeaf();
+            auto indexIter = leafIter->beginIndexOn();
+            auto handle = AttributeHandle<Vec3f>(leafIter->constAttributeArray("P"));
+
+            const auto& ijk = indexIter.getCoord();
+
+            CPPUNIT_ASSERT_EQUAL(ijk.x(), 0);
+            CPPUNIT_ASSERT_EQUAL(ijk.y(), 1);
+            CPPUNIT_ASSERT_EQUAL(ijk.z(), 1); // on border value is stored in the higher voxel
+
+            const Vec3f positionVoxelSpace = handle.get(*indexIter);
+
+            // voxel-space range: -0.5f >= value > 0.5f
+
+            CPPUNIT_ASSERT(positionVoxelSpace.x() > 0.49f && positionVoxelSpace.x() < 0.5f);
+            CPPUNIT_ASSERT(positionVoxelSpace.y() > -0.5f && positionVoxelSpace.y() < -0.49f);
+            CPPUNIT_ASSERT(positionVoxelSpace.z() == -0.5f); // on border value is stored at -0.5f
+
+            positionAfterNull = Vec3f(transform->indexToWorld(positionVoxelSpace + ijk.asVec3d()));
+
+            CPPUNIT_ASSERT_DOUBLES_EQUAL(positionAfterNull.x(), positionBefore.x(), tolerance);
+            CPPUNIT_ASSERT_DOUBLES_EQUAL(positionAfterNull.y(), positionBefore.y(), tolerance);
+            CPPUNIT_ASSERT_DOUBLES_EQUAL(positionAfterNull.z(), positionBefore.z(), tolerance);
+        }
+
+        { // fixed 16-bit codec - at this precision, this codec results in lossy compression
+            auto points = createPointDataGrid<FixedPointCodec<false>, PointDataGrid>(
+                *pointIndexGrid, wrapper, *transform);
+
+            auto leafIter = points->tree().cbeginLeaf();
+            auto indexIter = leafIter->beginIndexOn();
+            auto handle = AttributeHandle<Vec3f>(leafIter->constAttributeArray("P"));
+
+            const auto& ijk = indexIter.getCoord();
+
+            CPPUNIT_ASSERT_EQUAL(ijk.x(), 0);
+            CPPUNIT_ASSERT_EQUAL(ijk.y(), 1);
+            CPPUNIT_ASSERT_EQUAL(ijk.z(), 1); // on border value is stored in the higher voxel
+
+            const Vec3f positionVoxelSpace = handle.get(*indexIter);
+
+            // voxel-space range: -0.5f >= value > 0.5f
+
+            CPPUNIT_ASSERT(positionVoxelSpace.x() == 0.5f); // before border is clamped to 0.5f
+            CPPUNIT_ASSERT(positionVoxelSpace.y() == -0.5f); // after border is clamped to -0.5f
+            CPPUNIT_ASSERT(positionVoxelSpace.z() == -0.5f); // on border is stored at -0.5f
+
+            positionAfterFixed16 = Vec3f(transform->indexToWorld(
+                positionVoxelSpace + ijk.asVec3d()));
+
+            // reduce tolerance to handle lack of precision
+
+            CPPUNIT_ASSERT_DOUBLES_EQUAL(positionAfterFixed16.x(), positionBefore.x(), 1e-6);
+            CPPUNIT_ASSERT_DOUBLES_EQUAL(positionAfterFixed16.y(), positionBefore.y(), 1e-6);
+            CPPUNIT_ASSERT_DOUBLES_EQUAL(positionAfterFixed16.z(), positionBefore.z(), tolerance);
+        }
+
+        // only z matches precisely due to lossy compression
+
+        CPPUNIT_ASSERT(positionAfterNull.x() != positionAfterFixed16.x());
+        CPPUNIT_ASSERT(positionAfterNull.y() != positionAfterFixed16.y());
+        CPPUNIT_ASSERT_EQUAL(positionAfterNull.z(), positionAfterFixed16.z());
+    }
+}
+
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/unittest/TestPointGroup.cc openvdb-6.1.0/openvdb/unittest/TestPointGroup.cc
--- openvdb-6.0.0/openvdb/unittest/TestPointGroup.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestPointGroup.cc	2019-05-07 22:58:35.000000000 +0200
@@ -475,13 +475,42 @@
     GroupFilter filter("test", tree.cbeginLeaf()->attributeSet());
     CPPUNIT_ASSERT_EQUAL(pointCount(tree, filter), Index64(0));
 
-    std::vector<short> membership{1, 0, 1, 1, 0, 1};
-
     // copy tree for descriptor sharing test
 
     PointDataTree tree2(tree);
 
-    setGroup(tree, pointIndexGrid->tree(), membership, "test");
+    std::vector<short> membership{1, 0, 1, 1, 0, 1};
+
+    // test add to group
+
+    setGroup(tree, "test", true);
+    CPPUNIT_ASSERT_EQUAL(pointCount(tree, filter), Index64(6));
+
+    // test nothing is done if the index tree contains no valid indices
+
+    tools::PointIndexGrid::Ptr tmpIndexGrid = tools::PointIndexGrid::create();
+    setGroup(tree, tmpIndexGrid->tree(), {0,0,0,0,0,0}, "test", /*remove*/true);
+    CPPUNIT_ASSERT_EQUAL(Index64(6), pointCount(tree, filter));
+
+    // test throw on out of range index
+
+    auto indexLeaf = tmpIndexGrid->tree().touchLeaf(tree.cbeginLeaf()->origin());
+    indexLeaf->indices().emplace_back(membership.size());
+    CPPUNIT_ASSERT_THROW(setGroup(tree, tmpIndexGrid->tree(), membership, "test"), IndexError);
+    CPPUNIT_ASSERT_EQUAL(Index64(6), pointCount(tree, filter));
+
+    // test remove flag
+
+    setGroup(tree, pointIndexGrid->tree(), membership, "test", /*remove*/false);
+    CPPUNIT_ASSERT_EQUAL(Index64(6), pointCount(tree, filter));
+
+    setGroup(tree, pointIndexGrid->tree(), membership, "test", /*remove*/true);
+    CPPUNIT_ASSERT_EQUAL(Index64(4), pointCount(tree, filter));
+
+    setGroup(tree, pointIndexGrid->tree(), {0,1,0,0,1,0}, "test", /*remove*/false);
+    CPPUNIT_ASSERT_EQUAL(Index64(6), pointCount(tree, filter));
+
+    setGroup(tree, pointIndexGrid->tree(), membership, "test", /*remove*/true);
 
     // check that descriptor remains shared
 
diff -aur openvdb-6.0.0/openvdb/unittest/TestPointMask.cc openvdb-6.1.0/openvdb/unittest/TestPointMask.cc
--- openvdb-6.0.0/openvdb/unittest/TestPointMask.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestPointMask.cc	2019-05-07 22:58:35.000000000 +0200
@@ -129,7 +129,7 @@
     }
 
     { // use a much larger voxel size that splits the points into two regions
-        const float newVoxelSize(2);
+        const float newVoxelSize(4);
         openvdb::math::Transform::Ptr newTransform(
             openvdb::math::Transform::createLinearTransform(newVoxelSize));
 
diff -aur openvdb-6.0.0/openvdb/unittest/TestPointMove.cc openvdb-6.1.0/openvdb/unittest/TestPointMove.cc
--- openvdb-6.0.0/openvdb/unittest/TestPointMove.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestPointMove.cc	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -265,7 +265,6 @@
     CachedDeformer<double> cachedDeformer(cache);
 
     // check initialization is as expected
-    CPPUNIT_ASSERT(cachedDeformer.mLocalLeafVec.empty());
     CPPUNIT_ASSERT(cachedDeformer.mLeafVec == nullptr);
     CPPUNIT_ASSERT(cachedDeformer.mLeafMap == nullptr);
 
@@ -281,7 +280,6 @@
 
     // reset should no longer throw and leaf vec pointer should now be non-null
     CPPUNIT_ASSERT_NO_THROW(cachedDeformer.reset(nullObject, size_t(0)));
-    CPPUNIT_ASSERT(cachedDeformer.mLocalLeafVec.empty());
     CPPUNIT_ASSERT(cachedDeformer.mLeafMap == nullptr);
     CPPUNIT_ASSERT(cachedDeformer.mLeafVec != nullptr);
     CPPUNIT_ASSERT(cachedDeformer.mLeafVec->empty());
@@ -309,64 +307,12 @@
     // now reset the cached deformer and verify the value is updated
     // (map has precedence over vector)
     cachedDeformer.reset(nullObject, size_t(0));
-    CPPUNIT_ASSERT(cachedDeformer.mLocalLeafVec.empty());
     CPPUNIT_ASSERT(cachedDeformer.mLeafMap != nullptr);
     CPPUNIT_ASSERT(cachedDeformer.mLeafVec == nullptr);
     newPosition.setZero();
     cachedDeformer.apply(newPosition, indexIter);
     CPPUNIT_ASSERT(math::isApproxEqual(newDeformedPosition, newPosition));
 
-    // test map -> vector expansion
-    leaf.mapData.clear();
-    for (int i = 0; i < 16; i++) {
-        leaf.mapData.insert({i, Vec3d(0, i, 0)});
-    }
-
-    cachedDeformer.reset(nullObject, size_t(0));
-
-    // 16 values (or less) so local vector is not populated
-    CPPUNIT_ASSERT(cachedDeformer.mLocalLeafVec.empty());
-    CPPUNIT_ASSERT(cachedDeformer.mLeafMap != nullptr);
-    CPPUNIT_ASSERT(cachedDeformer.mLeafVec == nullptr);
-
-    // check value access
-    for (int i = 0; i < 16; i++) {
-        DummyIter indexIterI(i);
-        cachedDeformer.apply(newPosition, indexIterI);
-        CPPUNIT_ASSERT(math::isApproxEqual(Vec3d(0, i, 0), newPosition));
-    }
-
-    leaf.mapData.insert({16, Vec3d(0, 16, 0)});
-
-    // ValueError thrown because totalSize has not been set correctly
-    CPPUNIT_ASSERT_THROW(cachedDeformer.reset(nullObject, size_t(0)), openvdb::ValueError);
-
-    // use very large total size to prevent local expansion
-    leaf.totalSize = 17 * 256 + 1;
-
-    CPPUNIT_ASSERT_NO_THROW(cachedDeformer.reset(nullObject, size_t(0)));
-
-    CPPUNIT_ASSERT(cachedDeformer.mLocalLeafVec.empty());
-    CPPUNIT_ASSERT(cachedDeformer.mLeafMap != nullptr);
-    CPPUNIT_ASSERT(cachedDeformer.mLeafVec == nullptr);
-
-    // use total size that represents a sequential dataset
-    leaf.totalSize = Index(leaf.mapData.size());
-
-    CPPUNIT_ASSERT_NO_THROW(cachedDeformer.reset(nullObject, size_t(0)));
-
-    // greater than 16 values so local vector is populated
-    CPPUNIT_ASSERT_EQUAL(leaf.mapData.size(), cachedDeformer.mLocalLeafVec.size());
-    CPPUNIT_ASSERT(cachedDeformer.mLeafMap == nullptr);
-    CPPUNIT_ASSERT(cachedDeformer.mLeafVec != nullptr);
-
-    // check value access
-    for (int i = 0; i < 17; i++) {
-        DummyIter indexIterI(i);
-        cachedDeformer.apply(newPosition, indexIterI);
-        CPPUNIT_ASSERT(math::isApproxEqual(Vec3d(0, i, 0), newPosition));
-    }
-
     // four points, some same leaf, some different
     const float voxelSize = 1.0f;
     std::vector<Vec3s> positions =  {
@@ -856,8 +802,9 @@
         const int leafCount = points->tree().leafCount();
         const int pointCount = int(positions.size());
 
-        tbb::atomic<int> resetCalls = 0;
-        tbb::atomic<int> applyCalls = 0;
+        tbb::atomic<int> resetCalls, applyCalls;
+        resetCalls = 0;
+        applyCalls = 0;
 
         // this deformer applies an offset and tracks the number of calls
 
@@ -1128,6 +1075,77 @@
         CPPUNIT_ASSERT_EQUAL(short(0), nonZeroGroups2[2]);
         CPPUNIT_ASSERT_EQUAL(short(1), nonZeroGroups2[3]);
     }
+
+    { // larger data set with a cached deformer and group filtering
+        std::vector<openvdb::Vec3R> newPositions;
+        const int count = 10000;
+        unittest_util::genPoints(count, newPositions);
+
+        // manually construct point data grid instead of using positionsToGrid()
+
+        const PointAttributeVector<openvdb::Vec3R> pointList(newPositions);
+
+        openvdb::math::Transform::Ptr transform(
+            openvdb::math::Transform::createLinearTransform(/*voxelSize=*/0.1));
+
+        tools::PointIndexGrid::Ptr pointIndexGrid =
+            tools::createPointIndexGrid<tools::PointIndexGrid>(pointList, *transform);
+
+        PointDataGrid::Ptr points =
+                createPointDataGrid<NullCodec, PointDataGrid>(*pointIndexGrid,
+                                                              pointList, *transform);
+
+        appendGroup(points->tree(), "odd");
+
+        std::vector<short> oddGroups(newPositions.size(), 0);
+        for (size_t i = 1; i < newPositions.size(); i += 2) {
+            oddGroups[i] = 1;
+        }
+
+        setGroup(points->tree(), pointIndexGrid->tree(), oddGroups, "odd");
+
+        std::vector<std::string> includeGroups{"odd"};
+        std::vector<std::string> excludeGroups;
+
+        auto leaf = points->tree().cbeginLeaf();
+        MultiGroupFilter advectFilter(includeGroups, excludeGroups, leaf->attributeSet());
+        OffsetDeformer offsetDeformer(Vec3d(0, 1, 0));
+
+        CachedDeformer<double>::Cache cache;
+        CachedDeformer<double> cachedDeformer(cache);
+
+        cachedDeformer.evaluate(*points, offsetDeformer, advectFilter);
+
+        double ySumBefore = 0.0;
+        double ySumAfter = 0.0;
+
+        for (auto leaf = points->tree().cbeginLeaf(); leaf; ++leaf) {
+            AttributeHandle<Vec3f> handle(leaf->constAttributeArray("P"));
+            for (auto iter = leaf->beginIndexOn(); iter; ++iter) {
+                Vec3d position = handle.get(*iter) + iter.getCoord().asVec3s();
+                position = transform->indexToWorld(position);
+                ySumBefore += position.y();
+            }
+        }
+
+        movePoints(*points, cachedDeformer);
+
+        for (auto leaf = points->tree().cbeginLeaf(); leaf; ++leaf) {
+            AttributeHandle<Vec3f> handle(leaf->constAttributeArray("P"));
+            for (auto iter = leaf->beginIndexOn(); iter; ++iter) {
+                Vec3d position = handle.get(*iter) + iter.getCoord().asVec3s();
+                position = transform->indexToWorld(position);
+                ySumAfter += position.y();
+            }
+        }
+
+        // total increase in Y should be approximately count / 2
+        // (only odd points are being moved 1.0 in Y)
+        double increaseInY = ySumAfter - ySumBefore;
+
+        CPPUNIT_ASSERT_DOUBLES_EQUAL(increaseInY, static_cast<double>(count) / 2.0,
+            /*tolerance=*/double(0.01));
+    }
 }
 
 
@@ -1184,6 +1202,6 @@
     ASSERT_APPROX_EQUAL(positions1, positions3, __LINE__);
 }
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/unittest/TestTree.cc openvdb-6.1.0/openvdb/unittest/TestTree.cc
--- openvdb-6.0.0/openvdb/unittest/TestTree.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestTree.cc	2019-05-07 22:58:35.000000000 +0200
@@ -247,7 +247,7 @@
         std::ostringstream ostr;
         ostr << "half float buffers not significantly smaller than full float ("
             << halfBytes << " vs. " << fullBytes << " bytes)";
-        CPPUNIT_ASSERT_MESSAGE(ostr.str(), halfBytes < size_t(0.75 * fullBytes));
+        CPPUNIT_ASSERT_MESSAGE(ostr.str(), halfBytes < size_t(0.75 * double(fullBytes)));
     } else {
         // For non-real data types, "half float" and "full float" file sizes should be the same.
         CPPUNIT_ASSERT_MESSAGE("full float and half float file sizes differ for data of type "
diff -aur openvdb-6.0.0/openvdb/unittest/TestTreeCombine.cc openvdb-6.1.0/openvdb/unittest/TestTreeCombine.cc
--- openvdb-6.0.0/openvdb/unittest/TestTreeCombine.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestTreeCombine.cc	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -119,7 +119,7 @@
 struct OrderDependentCombineOp {
     OrderDependentCombineOp() {}
     void operator()(const ValueT& a, const ValueT& b, ValueT& result) const {
-        result = a + 100 * b; // result is order-dependent on A and B
+        result = a + ValueT(100) * b; // result is order-dependent on A and B
     }
 };
 
@@ -141,7 +141,7 @@
     struct ArgsOp {
         static void order(openvdb::CombineArgs<ValueT>& args) {
             // The result is order-dependent on A and B.
-            args.setResult(args.a() + 100 * args.b());
+            args.setResult(args.a() + ValueT(100) * args.b());
             args.setResultIsActive(args.aIsActive() || args.bIsActive());
         }
     };
@@ -154,14 +154,14 @@
 template<typename TreeT> void compMul(TreeT& a, TreeT& b) { openvdb::tools::compMul(a, b); }\
 template<typename TreeT> void compDiv(TreeT& a, TreeT& b) { openvdb::tools::compDiv(a, b); }\
 
-inline float orderf(float a, float b) { return a + 100 * b; }
+inline float orderf(float a, float b) { return a + 100.0f * b; }
 inline float maxf(float a, float b) { return std::max(a, b); }
 inline float minf(float a, float b) { return std::min(a, b); }
 inline float sumf(float a, float b) { return a + b; }
 inline float mulf(float a, float b) { return a * b; }
 inline float divf(float a, float b) { return a / b; }
 
-inline openvdb::Vec3f orderv(const openvdb::Vec3f& a, const openvdb::Vec3f& b) { return a+100*b; }
+inline openvdb::Vec3f orderv(const openvdb::Vec3f& a, const openvdb::Vec3f& b) { return a+100.0f*b; }
 inline openvdb::Vec3f maxv(const openvdb::Vec3f& a, const openvdb::Vec3f& b) {
     const float aMag = a.lengthSqr(), bMag = b.lengthSqr();
     return (aMag > bMag ? a : (bMag > aMag ? b : std::max(a, b)));
@@ -787,7 +787,7 @@
     CPPUNIT_ASSERT(largeTree2.get() != nullptr);
 
 #if TEST_CSG_VERBOSE
-    std::cerr << "file read: " << timer.delta() << " sec\n";
+    std::cerr << "file read: " << timer.milliseconds() << " msec\n";
 #endif
 
 #if TEST_CSG_VERBOSE
@@ -836,7 +836,7 @@
     TreePtr aTree(new TreeT(aInputTree));
     TreeT bTree(bInputTree);
 #if TEST_CSG_VERBOSE
-    std::cerr << "deep copy: " << timer.delta() << " ms\n";
+    std::cerr << "deep copy: " << timer.milliseconds() << " msec\n";
 #endif
 
 #if (TEST_CSG_VERBOSE > 1)
@@ -855,7 +855,7 @@
 #endif
     visitor(*aTree, bTree);
 #if TEST_CSG_VERBOSE
-    std::cerr << "combine: " << timer.delta() << " ms\n";
+    std::cerr << "combine: " << timer.milliseconds() << " msec\n";
 #endif
 #if (TEST_CSG_VERBOSE > 1)
     std::cerr << "\nActual:\n";
@@ -1070,6 +1070,6 @@
 ////////////////////////////////////////
 
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/unittest/TestTreeGetSetValues.cc openvdb-6.1.0/openvdb/unittest/TestTreeGetSetValues.cc
--- openvdb-6.0.0/openvdb/unittest/TestTreeGetSetValues.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestTreeGetSetValues.cc	2019-05-07 22:58:35.000000000 +0200
@@ -367,7 +367,7 @@
     CPPUNIT_ASSERT_EQUAL(openvdb::Index32(0), tree.leafCount());
     CPPUNIT_ASSERT_EQUAL(openvdb::Index32(1), tree.nonLeafCount()); // root node
     CPPUNIT_ASSERT(tree.empty());
-    
+
     // Partially fill a region with inactive background values.
     tree.fill(CoordBBox(Coord(27), Coord(254)), background, /*active=*/false);
     // Confirm that after pruning, the tree is empty.
Seulement dans openvdb-6.1.0/openvdb/unittest: TestTypes.cc
diff -aur openvdb-6.0.0/openvdb/unittest/TestUtil.cc openvdb-6.1.0/openvdb/unittest/TestUtil.cc
--- openvdb-6.0.0/openvdb/unittest/TestUtil.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/TestUtil.cc	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -39,6 +39,7 @@
 #include <openvdb/Exceptions.h>
 #include <openvdb/util/CpuTimer.h>
 #include <openvdb/util/PagedArray.h>
+#include <openvdb/util/Formats.h>
 
 #include <iostream>
 
@@ -55,11 +56,13 @@
 {
 public:
     CPPUNIT_TEST_SUITE(TestUtil);
+    CPPUNIT_TEST(testFormats);
     CPPUNIT_TEST(testCpuTimer);
     CPPUNIT_TEST(testPagedArray);
     CPPUNIT_TEST_SUITE_END();
 
     void testCpuTimer();
+    void testFormats();
     void testPagedArray();
 
     using RangeT = tbb::blocked_range<size_t>;
@@ -114,20 +117,70 @@
 
 CPPUNIT_TEST_SUITE_REGISTRATION(TestUtil);
 
+void
+TestUtil::testFormats()
+{
+  {// TODO: add  unit tests for printBytes
+  }
+  {// TODO: add a unit tests for printNumber
+  }
+  {// test long format printTime
+      const int width = 4, precision = 1, verbose = 1;
+      const int days = 1;
+      const int hours = 3;
+      const int minutes = 59;
+      const int seconds = 12;
+      const double milliseconds = 347.6;
+      const double mseconds = milliseconds + (seconds + (minutes + (hours + days*24)*60)*60)*1000.0;
+      std::ostringstream ostr1, ostr2;
+      CPPUNIT_ASSERT_EQUAL(4, openvdb::util::printTime(ostr2, mseconds, "Completed in ", "", width, precision, verbose ));
+      ostr1 << std::setprecision(precision) << std::setiosflags(std::ios::fixed);
+      ostr1 << "Completed in " << days << " day, " << hours << " hours, " << minutes << " minutes, "
+            << seconds << " seconds and " << std::setw(width) << milliseconds << " milliseconds (" << mseconds << "ms)";
+      //std::cerr << ostr2.str() << std::endl;
+      CPPUNIT_ASSERT_EQUAL(ostr1.str(), ostr2.str());
+    }
+    {// test compact format printTime
+      const int width = 4, precision = 1, verbose = 0;
+      const int days = 1;
+      const int hours = 3;
+      const int minutes = 59;
+      const int seconds = 12;
+      const double milliseconds = 347.6;
+      const double mseconds = milliseconds + (seconds + (minutes + (hours + days*24)*60)*60)*1000.0;
+      std::ostringstream ostr1, ostr2;
+      CPPUNIT_ASSERT_EQUAL(4, openvdb::util::printTime(ostr2, mseconds, "Completed in ", "", width, precision, verbose ));
+      ostr1 << std::setprecision(precision) << std::setiosflags(std::ios::fixed);
+      ostr1 << "Completed in " << days << "d " << hours << "h " << minutes << "m "
+            << std::setw(width) << (seconds + milliseconds/1000.0) << "s";
+      //std::cerr << ostr2.str() << std::endl;
+      CPPUNIT_ASSERT_EQUAL(ostr1.str(), ostr2.str());
+    }
+}
 
 void
 TestUtil::testCpuTimer()
 {
-    const int expected = 259, tolerance = 20;//milliseconds
+    const int expected = 159, tolerance = 20;//milliseconds
     const tbb::tick_count::interval_t sec(expected/1000.0);
-
-    openvdb::util::CpuTimer timer;
-    tbb::this_tbb_thread::sleep(sec);
-    const int actual1 = static_cast<int>(timer.delta());
-    CPPUNIT_ASSERT_DOUBLES_EQUAL(expected, actual1, tolerance);
-    tbb::this_tbb_thread::sleep(sec);
-    const int actual2 = static_cast<int>(timer.delta());
-    CPPUNIT_ASSERT_DOUBLES_EQUAL(2*expected, actual2, tolerance);
+    {
+      openvdb::util::CpuTimer timer;
+      tbb::this_tbb_thread::sleep(sec);
+      const int actual1 = static_cast<int>(timer.milliseconds());
+      CPPUNIT_ASSERT_DOUBLES_EQUAL(expected, actual1, tolerance);
+      tbb::this_tbb_thread::sleep(sec);
+      const int actual2 = static_cast<int>(timer.milliseconds());
+      CPPUNIT_ASSERT_DOUBLES_EQUAL(2*expected, actual2, tolerance);
+    }
+    {
+      openvdb::util::CpuTimer timer;
+      tbb::this_tbb_thread::sleep(sec);
+      auto t1 = timer.restart();
+      tbb::this_tbb_thread::sleep(sec);
+      tbb::this_tbb_thread::sleep(sec);
+      auto t2 = timer.restart();
+      CPPUNIT_ASSERT_DOUBLES_EQUAL(2*t1, t2, tolerance);
+    }
 }
 
 
@@ -595,6 +648,6 @@
     }
 }
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/unittest/util.h openvdb-6.1.0/openvdb/unittest/util.h
--- openvdb-6.0.0/openvdb/unittest/util.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/unittest/util.h	2019-05-07 22:58:35.000000000 +0200
@@ -68,7 +68,9 @@
             for (xyz[2]=0; xyz[2]<dim[2]; ++xyz[2]) {
                 const openvdb::Vec3R p =  grid.transform().indexToWorld(xyz);
                 const float dist = float((p-center).length() - radius);
+                OPENVDB_NO_TYPE_CONVERSION_WARNING_BEGIN
                 ValueT val = ValueT(zero + dist);
+                OPENVDB_NO_TYPE_CONVERSION_WARNING_END
                 switch (mode) {
                 case SPHERE_DENSE:
                     acc.setValue(xyz, val);
@@ -129,30 +131,30 @@
     const int n = int(std::sqrt(double(numPoints)));
     const double xScale = (2.0 * M_PI) / double(n);
     const double yScale = M_PI / double(n);
-    
+
     double x, y, theta, phi;
     openvdb::Vec3R pos;
-    
+
     points.reserve(n*n);
-    
+
     // loop over a [0 to n) x [0 to n) grid.
     for (int a = 0; a < n; ++a) {
         for (int b = 0; b < n; ++b) {
-            
+
             // jitter, move to random pos. inside the current cell
             x = double(a) + randNumber();
             y = double(b) + randNumber();
-            
+
             // remap to a lat/long map
             theta = y * yScale; // [0 to PI]
             phi   = x * xScale; // [0 to 2PI]
-            
+
             // convert to cartesian coordinates on a unit sphere.
             // spherical coordinate triplet (r=1, theta, phi)
             pos[0] = std::sin(theta)*std::cos(phi);
             pos[1] = std::sin(theta)*std::sin(phi);
             pos[2] = std::cos(theta);
-            
+
             points.push_back(pos);
         }
     }
diff -aur openvdb-6.0.0/openvdb/util/CpuTimer.h openvdb-6.1.0/openvdb/util/CpuTimer.h
--- openvdb-6.0.0/openvdb/util/CpuTimer.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/util/CpuTimer.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -36,7 +36,8 @@
 #include <tbb/tick_count.h>
 #include <iostream>// for std::cerr
 #include <sstream>// for ostringstream
-#include <iomanip>//for setprecision
+#include <iomanip>// for setprecision
+#include "Formats.h"// for printTime
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -46,7 +47,7 @@
 /// @brief Simple timer for basic profiling.
 ///
 /// @code
-///    CpuTimer timer;
+///    util::CpuTimer timer;
 ///    // code here will not be timed!
 ///    timer.start("algorithm");
 ///    // code to be timed goes here
@@ -56,65 +57,139 @@
 /// or to time multiple blocks of code
 ///
 /// @code
-///    CpuTimer timer("algorithm 1");
+///    util::CpuTimer timer("algorithm 1");
 ///    // code to be timed goes here
 ///    timer.restart("algorithm 2");
 ///    // code to be timed goes here
 ///    timer.stop();
 /// @endcode
+///
+/// or to measure speedup between multiple runs
+///
+/// @code
+///    util::CpuTimer timer("algorithm 1");
+///    // code for the first run goes here
+///    const double t1 = timer.restart("algorithm 2");
+///    // code for the second run goes here
+///    const double t2 = timer.stop();
+///    std::cerr << "Algorithm 1 is " << (t2/t1)
+///              << " timers faster than algorithm 2\n";
+/// @endcode
+///
+/// or to measure multiple blocks of code with deferred output
+///
+/// @code
+///    util::CpuTimer timer();
+///    // code here will not be timed!
+///    timer.start();
+///    // code for the first run goes here
+///    const double t1 = timer.restart();//time in milliseconds
+///    // code for the second run goes here
+///    const double t2 = timer.restart();//time in milliseconds
+///    // code here will not be timed!
+///    util::printTime(std::cout, t1, "Algorithm 1 completed in ");
+///    util::printTime(std::cout, t2, "Algorithm 2 completed in ");
+/// @endcode
 class CpuTimer
 {
 public:
 
     /// @brief Initiate timer
-    CpuTimer() : mT0(tbb::tick_count::now()) {}
+    CpuTimer(std::ostream& os = std::cerr) : mOutStream(os), mT0(tbb::tick_count::now()) {}
 
-    /// @brief Prints message and re-start timer.
+    /// @brief Prints message and start timer.
     ///
     /// @note Should normally be followed by a call to stop()
-    CpuTimer(const std::string& msg) { this->start(msg); }
+    CpuTimer(const std::string& msg, std::ostream& os = std::cerr) : mOutStream(os), mT0() { this->start(msg); }
 
     /// @brief Start timer.
     ///
-    /// @note Should normally be followed by a call to time()
+    /// @note Should normally be followed by a call to milliseconds() or stop(std::string)
     inline void start() { mT0 = tbb::tick_count::now(); }
 
-    /// @brief Print message and re-start timer.
+    /// @brief Print message and start timer.
     ///
     /// @note Should normally be followed by a call to stop()
     inline void start(const std::string& msg)
     {
-        std::cerr << msg << " ... ";
+        mOutStream << msg << " ...";
         this->start();
     }
 
-    /// @brief Stop previous timer, print message and re-start timer.
+    /// @brief Return Time difference in milliseconds since construction or start was called.
     ///
-    /// @note Should normally be followed by a call to stop()
-    inline void restart(const std::string& msg)
+    /// @note Combine this method with start() to get timing without any outputs.
+    inline double milliseconds() const
     {
-        this->stop();
-        this->start(msg);
+        tbb::tick_count::interval_t dt = tbb::tick_count::now() - mT0;
+        return 1000.0*dt.seconds();
     }
 
-    /// Return Time diference in milliseconds since construction or start was called.
-    inline double delta() const
+    /// @brief Return Time difference in seconds since construction or start was called.
+    ///
+    /// @note Combine this method with start() to get timing without any outputs.
+    inline double seconds() const
     {
         tbb::tick_count::interval_t dt = tbb::tick_count::now() - mT0;
-        return 1000.0*dt.seconds();
+        return dt.seconds();
     }
 
-    /// @brief Print time in milliseconds since construction or start was called.
-    inline void stop() const
+    /// @brief This method is identical to milliseconds() - deprecated
+    OPENVDB_DEPRECATED inline double delta() const { return this->milliseconds(); }
+
+    inline std::string time() const
     {
-        const double t = this->delta();
-        std::ostringstream ostr;
-        ostr << "completed in " << std::setprecision(3) << t << " ms\n";
-        std::cerr << ostr.str();
+        const double msec = this->milliseconds();
+        std::ostringstream os;
+        printTime(os, msec, "", "", 4, 1, 1);
+        return os.str();
     }
 
-private:
+    /// @brief Returns and prints time in milliseconds since construction or start was called.
+    ///
+    /// @note Combine this method with start(std::string) to print at start and stop of task being timed.
+    inline double stop() const
+    {
+        const double msec = this->milliseconds();
+        printTime(mOutStream, msec, " completed in ", "\n", 4, 3, 1);
+        return msec;
+    }
+
+    /// @brief Returns and prints time in milliseconds since construction or start was called.
+    ///
+    /// @note Combine this method with start() to delay output of task being timed.
+    inline double stop(const std::string& msg) const
+    {
+        const double msec = this->milliseconds();
+        mOutStream << msg << " ...";
+        printTime(mOutStream, msec, " completed in ", "\n", 4, 3, 1);
+        return msec;
+    }
 
+    /// @brief Re-start timer.
+    /// @return time in milliseconds since previous start or restart.
+    ///
+    /// @note Should normally be followed by a call to stop() or restart()
+    inline double restart()
+    {
+        const double msec = this->milliseconds();
+        this->start();
+        return msec;
+    }
+
+    /// @brief Stop previous timer, print message and re-start timer.
+    /// @return time in milliseconds since previous start or restart.
+    ///
+    /// @note Should normally be followed by a call to stop() or restart()
+    inline double restart(const std::string& msg)
+    {
+        const double delta = this->stop();
+        this->start(msg);
+        return delta;
+    }
+
+private:
+    std::ostream&   mOutStream;
     tbb::tick_count mT0;
 };// CpuTimer
 
@@ -125,6 +200,6 @@
 
 #endif // OPENVDB_UTIL_CPUTIMER_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/util/Formats.cc openvdb-6.1.0/openvdb/util/Formats.cc
--- openvdb-6.0.0/openvdb/util/Formats.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/util/Formats.cc	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -29,7 +29,6 @@
 ///////////////////////////////////////////////////////////////////////////
 
 #include "Formats.h"
-
 #include <openvdb/Platform.h>
 #include <iostream>
 #include <iomanip>
@@ -112,10 +111,69 @@
     return group;
 }
 
+int
+printTime(std::ostream& os, double milliseconds,
+  const std::string& head, const std::string& tail,
+  int width, int precision, int verbose)
+  {
+    int group = 0;
+
+    // Write to a string stream so that I/O manipulators like
+    // std::setprecision() don't alter the output stream.
+    std::ostringstream ostr;
+    ostr << head;
+    ostr << std::setprecision(precision) << std::setiosflags(std::ios::fixed);
+
+    if (milliseconds >= 1000.0) {// one second or longer
+      const uint32_t seconds = static_cast<uint32_t>(milliseconds / 1000.0) % 60 ;
+      const uint32_t minutes = static_cast<uint32_t>(milliseconds / (1000.0*60)) % 60;
+      const uint32_t hours   = static_cast<uint32_t>(milliseconds / (1000.0*60*60)) % 24;
+      const uint32_t days    = static_cast<uint32_t>(milliseconds / (1000.0*60*60*24));
+      if (days>0) {
+        ostr << days << (verbose==0 ? "d " : days>1 ? " days, " : " day, ");
+        group = 4;
+      }
+      if (hours>0) {
+        ostr << hours << (verbose==0 ? "h " : hours>1 ? " hours, " : " hour, ");
+        if (!group) group = 3;
+      }
+      if (minutes>0) {
+        ostr << minutes << (verbose==0 ? "m " : minutes>1 ? " minutes, " : " minute, ");
+        if (!group) group = 2;
+      }
+      if (seconds>0) {
+        if (verbose) {
+          ostr << seconds << (seconds>1 ? " seconds and " : " second and ");
+          const double msec = milliseconds - (seconds + (minutes + (hours + days * 24) * 60) * 60) * 1000.0;
+          ostr << std::setw(width) << msec << " milliseconds (" << milliseconds << "ms)";
+        } else {
+          const double sec = milliseconds/1000.0 - (minutes + (hours + days * 24) * 60) * 60;
+          ostr << std::setw(width) << sec << "s";
+        }
+      } else {// zero seconds
+        const double msec = milliseconds - (minutes + (hours + days * 24) * 60) * 60 * 1000.0;
+        if (verbose) {
+          ostr << std::setw(width) << msec << " milliseconds (" << milliseconds << "ms)";
+        } else {
+          ostr << std::setw(width) << msec << "ms";
+        }
+      }
+      if (!group) group = 1;
+    } else {// less than a second
+      ostr << std::setw(width) << milliseconds << (verbose ? " milliseconds" : "ms");
+    }
+
+    ostr << tail;
+
+    os << ostr.str();
+
+    return group;
+  }
+
 } // namespace util
 } // namespace OPENVDB_VERSION_NAME
 } // namespace openvdb
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/util/Formats.h openvdb-6.1.0/openvdb/util/Formats.h
--- openvdb-6.0.0/openvdb/util/Formats.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/util/Formats.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -80,6 +80,21 @@
     const std::string& tail = "\n",
     bool exact = true, int width = 8, int precision = 3);
 
+/// Output a time in milliseconds with the correct suffix (days, hours, minutes, seconds and milliseconds)
+/// @param os             the output stream
+/// @param milliseconds   the time to be output
+/// @param head           a string to be output before the time
+/// @param tail           a string to be output after the time
+/// @param width          a fixed width for the numeric text
+/// @param precision      the number of digits after the decimal point
+/// @param verbose        verbose level, 0 is compact format and 1 is long format
+/// @return 0, 1, 2, 3, or 4 denoting the order of magnitude of the time.
+OPENVDB_API int
+printTime(std::ostream& os, double milliseconds,
+    const std::string& head = "",
+    const std::string& tail = "\n",
+    int width = 4, int precision = 1, int verbose = 0);
+
 
 ////////////////////////////////////////
 
@@ -135,6 +150,6 @@
 
 #endif // OPENVDB_UTIL_FORMATS_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/util/NodeMasks.h openvdb-6.1.0/openvdb/util/NodeMasks.h
--- openvdb-6.0.0/openvdb/util/NodeMasks.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/util/NodeMasks.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -729,12 +729,12 @@
     /// Set the <i>n</i>th  bit on
     void setOn(Index32 n) {
         assert( n  < 8 );
-        mByte = mByte | static_cast<Byte>(0x01U << (n & 7));
+        mByte = static_cast<Byte>(mByte | 0x01U << (n & 7));
     }
     /// Set the <i>n</i>th bit off
     void setOff(Index32 n) {
         assert( n  < 8 );
-        mByte = mByte & static_cast<Byte>(~(0x01U << (n & 7)));
+        mByte = static_cast<Byte>(mByte & ~(0x01U << (n & 7)));
     }
     /// Set the <i>n</i>th bit to the specified state
     void set(Index32 n, bool On) { On ? this->setOn(n) : this->setOff(n); }
@@ -747,7 +747,7 @@
     /// Toggle the state of the <i>n</i>th bit
     void toggle(Index32 n) {
         assert( n  < 8 );
-        mByte = mByte ^ static_cast<Byte>(0x01U << (n & 7));
+        mByte = static_cast<Byte>(mByte ^ 0x01U << (n & 7));
     }
     /// Toggle the state of all bits in the mask
     void toggle() { mByte = static_cast<Byte>(~mByte); }
@@ -1435,6 +1435,6 @@
 
 #endif // OPENVDB_UTIL_NODEMASKS_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/util/NullInterrupter.h openvdb-6.1.0/openvdb/util/NullInterrupter.h
--- openvdb-6.0.0/openvdb/util/NullInterrupter.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/util/NullInterrupter.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -55,7 +55,7 @@
     NullInterrupter () {}
     /// Signal the start of an interruptible operation.
     /// @param name  an optional descriptive name for the operation
-    void start(const char* name = NULL) { (void)name; }
+    void start(const char* name = nullptr) { (void)name; }
     /// Signal the end of an interruptible operation.
     void end() {}
     /// Check if an interruptible operation should be aborted.
@@ -85,6 +85,6 @@
 
 #endif // OPENVDB_UTIL_NULL_INTERRUPTER_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/util/PagedArray.h openvdb-6.1.0/openvdb/util/PagedArray.h
--- openvdb-6.0.0/openvdb/util/PagedArray.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/util/PagedArray.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -202,7 +202,7 @@
     using ValueType = ValueT;
 
     /// @brief Default constructor
-    PagedArray() = default;
+    PagedArray() { mSize = 0; }
 
     /// @brief Destructor removed all allocated pages
     ~PagedArray() { this->clear(); }
@@ -510,7 +510,7 @@
         }
     }
     PageTableT mPageTable;//holds points to allocated pages
-    tbb::atomic<size_t> mSize{0};// current number of elements in array
+    tbb::atomic<size_t> mSize;// current number of elements in array
     size_t mCapacity = 0;//capacity of array given the current page count
     tbb::spin_mutex mGrowthMutex;//Mutex-lock required to grow pages
 }; // Public class PagedArray
@@ -781,6 +781,6 @@
 
 #endif // OPENVDB_UTIL_PAGED_ARRAY_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/version.h openvdb-6.1.0/openvdb/version.h
--- openvdb-6.0.0/openvdb/version.h	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/version.h	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -71,29 +71,10 @@
 
 #include "Platform.h"
 
-/// @name Utilities
-/// @{
-/// @cond OPENVDB_VERSION_INTERNAL
-#define OPENVDB_PREPROC_STRINGIFY_(x) #x
-/// @endcond
-/// @brief Return @a x as a string literal.  If @a x is a macro,
-/// return its value as a string literal.
-/// @hideinitializer
-#define OPENVDB_PREPROC_STRINGIFY(x) OPENVDB_PREPROC_STRINGIFY_(x)
-
-/// @cond OPENVDB_VERSION_INTERNAL
-#define OPENVDB_PREPROC_CONCAT_(x, y) x ## y
-/// @endcond
-/// @brief Form a new token by concatenating two existing tokens.
-/// If either token is a macro, concatenate its value.
-/// @hideinitializer
-#define OPENVDB_PREPROC_CONCAT(x, y) OPENVDB_PREPROC_CONCAT_(x, y)
-/// @}
-
 
 // Library major, minor and patch version numbers
 #define OPENVDB_LIBRARY_MAJOR_VERSION_NUMBER 6
-#define OPENVDB_LIBRARY_MINOR_VERSION_NUMBER 0
+#define OPENVDB_LIBRARY_MINOR_VERSION_NUMBER 1
 #define OPENVDB_LIBRARY_PATCH_VERSION_NUMBER 0
 
 // If OPENVDB_ABI_VERSION_NUMBER is already defined (e.g., via -DOPENVDB_ABI_VERSION_NUMBER=N)
@@ -114,6 +95,14 @@
     #endif
 #endif
 
+// If using an OPENVDB_ABI_VERSION_NUMBER that has been deprecated, issue an error
+// directive.  This can be optionally suppressed by defining OPENVDB_USE_DEPRECATED_ABI.
+#ifndef OPENVDB_USE_DEPRECATED_ABI
+    #if OPENVDB_ABI_VERSION_NUMBER <= 3
+        #error ABI <= 3 is deprecated, define OPENVDB_USE_DEPRECATED_ABI to suppress this error
+    #endif
+#endif
+
 #if OPENVDB_ABI_VERSION_NUMBER == OPENVDB_LIBRARY_MAJOR_VERSION_NUMBER
     /// @brief The version namespace name for this library version
     /// @hideinitializer
@@ -174,7 +163,7 @@
 
 /// By default, the @b OPENVDB_REQUIRE_VERSION_NAME macro is undefined, and
 /// symbols from the version namespace are promoted to the top-level namespace
-/// so that, for example, @b openvdb::v6_0::io::File can be referred to
+/// so that, for example, @b openvdb::v5_0::io::File can be referred to
 /// simply as @b openvdb::io::File.
 ///
 /// When @b OPENVDB_REQUIRE_VERSION_NAME is defined, symbols must be
@@ -252,6 +241,6 @@
 
 #endif // OPENVDB_VERSION_HAS_BEEN_INCLUDED
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/openvdb/viewer/RenderModules.cc openvdb-6.1.0/openvdb/viewer/RenderModules.cc
--- openvdb-6.0.0/openvdb/viewer/RenderModules.cc	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/openvdb/viewer/RenderModules.cc	2019-05-07 22:58:35.000000000 +0200
@@ -1,6 +1,6 @@
 ///////////////////////////////////////////////////////////////////////////
 //
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 //
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
@@ -288,22 +288,22 @@
 
     glBindBuffer(GL_ARRAY_BUFFER, mVertexBuffer);
     glEnableClientState(GL_VERTEX_ARRAY);
-    glVertexPointer(3, GL_FLOAT, 0, 0);
+    glVertexPointer(3, GL_FLOAT, 0, nullptr);
 
     if (usesColorBuffer) {
         glBindBuffer(GL_ARRAY_BUFFER, mColorBuffer);
         glEnableClientState(GL_COLOR_ARRAY);
-        glColorPointer(3, GL_FLOAT, 0, 0);
+        glColorPointer(3, GL_FLOAT, 0, nullptr);
     }
 
     if (usesNormalBuffer) {
         glEnableClientState(GL_NORMAL_ARRAY);
         glBindBuffer(GL_ARRAY_BUFFER, mNormalBuffer);
-        glNormalPointer(GL_FLOAT, 0, 0);
+        glNormalPointer(GL_FLOAT, 0, nullptr);
     }
 
     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mIndexBuffer);
-    glDrawElements(mPrimType, mPrimNum, GL_UNSIGNED_INT, 0);
+    glDrawElements(mPrimType, mPrimNum, GL_UNSIGNED_INT, nullptr);
 
     // disable client-side capabilities
     if (usesColorBuffer) glDisableClientState(GL_COLOR_ARRAY);
@@ -902,7 +902,7 @@
                 insertPoint(pos, index);
                 ++index;
 
-                Index64 r = Index64(std::floor(double(mVoxelsPerLeaf) / activeVoxels));
+                Index64 r = Index64(std::floor(double(mVoxelsPerLeaf) / double(activeVoxels)));
                 for (Index64 i = 1, I = mVoxelsPerLeaf - 2; i < I; ++i) {
                     pos = mTransform.indexToWorld(coords[static_cast<size_t>(i * r)]);
                     insertPoint(pos, index);
@@ -1086,10 +1086,10 @@
     {
         mOffset[0] = static_cast<float>(std::min(mZeroValue, mMinValue));
         mScale[0] = static_cast<float>(
-            1.0 / (std::abs(std::max(mZeroValue, mMaxValue) - mOffset[0])));
+            1.0 / (std::abs(float(std::max(mZeroValue, mMaxValue)) - mOffset[0])));
         mOffset[1] = static_cast<float>(std::min(mZeroValue, mMinValue));
         mScale[1] = static_cast<float>(
-            1.0 / (std::abs(std::max(mZeroValue, mMaxValue) - mOffset[1])));
+            1.0 / (std::abs(float(std::max(mZeroValue, mMaxValue)) - mOffset[1])));
     }
 
     std::vector<GLfloat>& mPoints;
@@ -1691,6 +1691,6 @@
 
 } // namespace openvdb_viewer
 
-// Copyright (c) 2012-2018 DreamWorks Animation LLC
+// Copyright (c) 2012-2019 DreamWorks Animation LLC
 // All rights reserved. This software is distributed under the
 // Mozilla Public License 2.0 ( http://www.mozilla.org/MPL/2.0/ )
diff -aur openvdb-6.0.0/README.md openvdb-6.1.0/README.md
--- openvdb-6.0.0/README.md	2018-12-18 13:27:52.000000000 +0100
+++ openvdb-6.1.0/README.md	2019-05-07 22:58:35.000000000 +0200
@@ -1,5 +1,8 @@
 ![OpenVDB](http://www.openvdb.org/images/openvdb_logo.png)
 
+[![CircleCI](https://circleci.com/gh/AcademySoftwareFoundation/openvdb.svg?style=svg)](https://circleci.com/gh/AcademySoftwareFoundation/openvdb)
+[![CII Best Practices](https://bestpractices.coreinfrastructure.org/projects/2774/badge)](https://bestpractices.coreinfrastructure.org/projects/2774)
+
 [Website](http://www.openvdb.org) |
 [Discussion Forum](http://www.openvdb.org/forum) |
 [Documentation](http://www.openvdb.org/documentation/)
@@ -21,3 +24,83 @@
 
 Developers who wish to contribute code to be considered for inclusion in the OpenVDB distribution must first complete the [Contributor License Agreement](http://www.openvdb.org/download/OpenVDBContributorLicenseAgreement.pdf) and submit it to [openvdb@gmail.com](mailto:openvdb@gmail.com).  We prefer code submissions in the form of pull requests to this repository.  All code should adhere to the OpenVDB [coding standards](http://www.openvdb.org/documentation/doxygen/codingStyle.html), and _every commit must be signed off_.  That is, every commit log message must include a `Signed-off-by` line (generated, for example, with `git commit --signoff`), indicating that the committer wrote the code and has the right to release it under the [MPL 2.0](https://www.mozilla.org/MPL/2.0/) license. See http://developercertificate.org/ for more information on this requirement.
 
+
+### Developer Quick Start
+
+#### Linux
+##### Installing Dependencies (Boost, TBB, OpenEXR, Blosc)
+
+```
+apt-get install -y libboost-iostreams-dev
+apt-get install -y libboost-system-dev
+apt-get install -y libtbb-dev
+apt-get install -y libilmbase-dev
+apt-get install -y libopenexr-dev
+```
+```
+git clone git@github.com:Blosc/c-blosc.git
+cd c-blosc
+git checkout tags/v1.5.0 -b v1.5.0
+mkdir build
+cd build
+cmake ..
+make -j4
+make install
+cd ../..
+```
+
+##### Building OpenVDB
+```
+git clone git@github.com:AcademySoftwareFoundation/openvdb.git
+cd openvdb
+mkdir build
+cd build
+cmake ..
+make -j4
+make install
+```
+#### Mac OSX
+##### Installing Dependencies (Boost, TBB, OpenEXR, Blosc)
+```
+brew install boost
+brew install tbb
+brew install ilmbase
+brew install openexr
+```
+```
+git clone git@github.com:Blosc/c-blosc.git
+cd c-blosc
+git checkout tags/v1.5.0 -b v1.5.0
+mkdir build
+cd build
+cmake ..
+make -j4
+make install
+cd ../..
+```
+##### Building OpenVDB
+```
+git clone git@github.com:AcademySoftwareFoundation/openvdb.git
+cd openvdb
+mkdir build
+cd build
+cmake ..
+make -j4
+make install
+```
+#### Windows
+##### Installing Dependencies (Boost, TBB, OpenEXR, Blosc)
+```
+vcpkg install boost zlib blosc openexr tbb
+vcpkg integrate install
+```
+##### Building OpenVDB
+```
+git clone git@github.com:AcademySoftwareFoundation/openvdb.git
+cd openvdb
+mkdir build
+cd build
+cmake -DCMAKE_TOOLCHAIN_FILE=<PATH_TO_VCPKG>\scripts\buildsystems\vcpkg.cmake ..
+make -j4
+make install
+```
Seulement dans openvdb-6.0.0: travis
Seulement dans openvdb-6.0.0: .travis.yml
Seulement dans openvdb-6.1.0/tsc/meetings: 2018-12-13.md
Seulement dans openvdb-6.1.0/tsc/meetings: 2019-01-17.md
Seulement dans openvdb-6.1.0/tsc/meetings: 2019-01-24.md
Seulement dans openvdb-6.1.0/tsc/meetings: 2019-01-31.md
Seulement dans openvdb-6.1.0/tsc/meetings: 2019-02-14.md
Seulement dans openvdb-6.1.0/tsc/meetings: 2019-02-28.md
Seulement dans openvdb-6.1.0/tsc/meetings: 2019-03-07.md
Seulement dans openvdb-6.1.0/tsc/meetings: 2019-03-21.md
Seulement dans openvdb-6.1.0/tsc/meetings: 2019-03-28.md
Seulement dans openvdb-6.1.0/tsc/meetings: 2019-04-18.md
Seulement dans openvdb-6.1.0/tsc/meetings: 2019-04-25.md
Seulement dans openvdb-6.1.0/tsc/meetings: 2019-05-02.md
Seulement dans openvdb-6.1.0/tsc/process: deprecation.md
Seulement dans openvdb-6.1.0/tsc/process: release.md
